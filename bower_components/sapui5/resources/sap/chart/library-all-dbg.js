// This file has been generated by the SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.chart.library-all');
if ( !jQuery.sap.isDeclared('sap.chart.AutoScaleMode') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

// Provides enumeration for sap.chart.AutoScaleMode
jQuery.sap.declare('sap.chart.AutoScaleMode'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/AutoScaleMode",function() {
    "use strict";


    /**
     * @class
     * Enumeration for how the analytical chart adapts the value axis to the data.
     *
     * @static
     * @public
     * @alias sap.chart.AutoScaleMode
     */
    var AutoScaleMode = {
        /**
         * Minimum and maximum value is calculated from the entire data set in the backend, no matter data can be loaded or not, visible or not.
         * @public
         */
        DataSet: "DataSet",
        /**
         * Minimum and maximum value is calculated from the data that are currently visible. Scrolling will change the scale.
         * @public
         */
        VisibleData: "VisibleData"
    };

    return AutoScaleMode;

}, /* bExport= */ true);

}; // end of sap/chart/AutoScaleMode.js
if ( !jQuery.sap.isDeclared('sap.chart.ChartLog') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.chart.ChartLog'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/ChartLog",[], function() {
	"use strict";

	function ChartLog(sType, sName, sMessage) {
		this._type = sType;
		this._name = sName;
		this._message = sMessage;
	}

	ChartLog.prototype.display = function() {
		if (this._type === "error") {
			jQuery.sap.log.error("[Analytical Chart] " + this._name, this._message);
		}
	};

	return ChartLog;
});
}; // end of sap/chart/ChartLog.js
if ( !jQuery.sap.isDeclared('sap.chart.ChartType') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

// Provides enumeration sap.chart.ChartType
jQuery.sap.declare('sap.chart.ChartType'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/ChartType",function() {
    "use strict";


    /**
    * Enumeration for supported chart types in analytical chart
    *
    * @namespace
    * @public
    * @alias sap.chart.ChartType
    */
    var ChartType = {
        /**
         * Bar Chart
         * @public
         */
        Bar: "bar",
        /**
         * Column Chart
         * @public
         */
        Column: "column",
        /**
         * Line Chart
         * @public
         */
        Line: "line",
        /**
         * Combined Column Line Chart
         * @public
         */
        Combination: "combination",
        /**
         * Pie Chart
         * @public
         */
        Pie: "pie",
        /**
         * Donut Chart
         * @public
         */
        Donut: "donut",
        /**
         * Scatter Plot
         * @public
         */
        Scatter: "scatter",
        /**
         * Bubble Chart
         * @public
         */
        Bubble: "bubble",
        /**
         * Heat Map
         * @public
         */
        Heatmap: "heatmap",
        /**
         * Bubble Chart
         * @public
         */
        Bullet: "bullet",
        /**
         * Vertical Bullet Chart
         * @public
         */
        VerticalBullet: "vertical_bullet",
        /**
         * Stacked Bar Chart
         * @public
         */
        StackedBar: "stacked_bar",
        /**
         * Stacked Column Chart
         * @public
         */
        StackedColumn: "stacked_column",
        /**
         * Combined Stacked Line Chart
         * @public
         */
        StackedCombination: "stacked_combination",
        /**
         * Horizontal Combined Stacked Line Chart
         * @public
         */
        HorizontalStackedCombination: "horizontal_stacked_combination",
        /**
         * Bar Chart with 2 X-Axes
         * @public
         */
        DualBar: "dual_bar",
        /**
         * Column Chart with 2 Y-Axes
         * @public
         */
        DualColumn: "dual_column",
        /**
         * Line Chart with 2 Y-Axes
         * @public
         */
        DualLine: "dual_line",
        /**
         * Stacked Bar Chart with 2 X-Axes
         * @public
         */
        DualStackedBar: "dual_stacked_bar",
        /**
         * Stacked Column Chart with 2 Y-Axes
         * @public
         */
        DualStackedColumn: "dual_stacked_column",
         /**
         * Combined Column Line Chart with 2 Y-Axes
         * @public
         */
        DualCombination: "dual_combination",
         /**
         * Horizontal Combined Bar Line Chart with 2 X-Axes
         * @public
         */
        DualHorizontalCombination: "dual_horizontal_combination",
        /**
         * Combined Stacked Line Chart with 2 Y-Axes
         * @public
         */
        DualStackedCombination: "dual_stacked_combination",
        /**
         * Horizontal Combined Stacked Line Chart with 2 X-Axes
         * @public
         */
        DualHorizontalStackedCombination: "dual_horizontal_stacked_combination",
        /**
         * 100% Stacked Bar Chart
         * @public
         */
        PercentageStackedBar: "100_stacked_bar",
        /**
         * 100% Stacked Column Chart
         * @public
         */
        PercentageStackedColumn: "100_stacked_column",
        /**
         * 100% Stacked Bar Chart with 2 X-Axes
         * @public
         */
        PercentageDualStackedBar: "100_dual_stacked_bar",
        /**
         * 100% Stacked Column Chart with 2 Y-Axes
         * @public
         */
        PercentageDualStackedColumn: "100_dual_stacked_column",
        /**
         * Waterfall Chart
         * @public
         */
        Waterfall: "waterfall",
        /**
         * Horizontal Waterfall Chart
         * @public
         */
        HorizontalWaterfall: "horizontal_waterfall"
    };

    return ChartType;

}, /* bExport= */ true);

}; // end of sap/chart/ChartType.js
if ( !jQuery.sap.isDeclared('sap.chart.ColoringType') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

// Provides enumeration sap.chart.ColoringType
jQuery.sap.declare('sap.chart.ColoringType'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/ColoringType",function() {
    "use strict";


    /**
     * Enum of available colorings.
     *
     * @enum {string}
     * @public
     * @alias sap.chart.ColoringType
     */
    var ColoringType = {
        /**
         * Criticality is based on the semantic color palette. 
         *
         * It can be defined for measure values and dimension values.
         * <pre>
         * Criticality: {
         *     MeasureValues: {
         *         ...
         *     },
         *     DimensionValues: {
         *         ...
         *     }
         * }
         * </pre>
         *
         * <b>For measure values</b>, criticality can be based on <code>static</code>, <code>calculated</code>, <code>DynamicThresholds</code> and <code>ConstantThresholds</code>
         *
         * <code>Legend</code> is <b>optional</b> and can be used for custom legend labels.
         * <pre>
         * MeasureValues: {
         *     'measureName': {
         *         Static: ... ,
         *         Calculated: ... ,
         *         DynamicThresholds: {
         *             ...
         *         },
         *         ConstantThresholds: {
         *             ...
         *         },
         *         Legend: {
         *             Title: string,    // (optional) fixed, localized label
         *             Positive: string, // fixed, localized label
         *             Critical: string, // fixed, localized label
         *             Negative: string, // fixed, localized label
         *             Neutral:  string  // fixed, localized label
         *         }
         *     },
         *     'measureName': { 
         *         ...
         *     }
         * }
         * </pre>
         * <ul>
         *   <li><code>static</code>
         *
         *   It indicates that the measure is always considered in the same way, for example positive.
         *
         *   The value of <code>static</code> is listed in {@link sap.chart.coloring.CriticalityType}
         *
         *   Example:
         *
         *   In this case, all 'Profit' datapoints shall use Positive semantic color and all 'Revenue' datapoints shall use Negative semantic color.
         *   <pre>
         *   var oColorings = {
         *       Criticality: {
         *           MeasureValues: {
         *               Profit: {
         *                   Static: sap.chart.ColoringType.Positive
         *               },
         *               Revenue: {
         *                   Static: sap.chart.ColoringType.Negative
         *               }
         *           }
         *       }
         *   };
         *   var oActiveColoring = {
         *       coloring: sap.chart.ColoringType.Criticality,
         *       parameters: {
         *           measure: ['Profit', 'Revenue']
         *       }
         *   };
         *   </pre>
         *   </li>
         *   <li><code>Calculated</code>
         *
         *   Criticality is calculated by the backend service.
         *
         *   The value of <code>Calculated</code> is a dimension name. The criticality of the measure of a datapoint is determined by the value of this dimension
         *   and its textProperty(if exists) will be used as legend label.
         *
         *   The possible values of this certain dimension are listed in {@link sap.chart.coloring.CriticalityType}.
         *
         *   Example:
         *
         *   In this case, the criticality of 'Profit' measure is determined by the value of 'ProfitCriticality' dimension which is calculated by backend service.
         *   <pre>
         *   var oColorings = {
         *       Criticality: {
         *           MeasureValues: {
         *               Profit: {
         *                   Calculated: 'ProfitCriticality'
         *               }
         *           }
         *       }
         *   };
         *   var oActiveColoring = {
         *       coloring: sap.chart.ColoringType.Criticality,
         *       parameters: {
         *           measure: ['Profit']
         *       }
         *   };
         *   </pre>
         *   </li>
         *   <li><code>DynamicThresholds</code>
         *
         *   Criticality is expressed with thresholds for the boundaries between negative, critical, neutral, and positive.
         *
         *   The direction of improvement for measure values is mandatory, combined with corresponding thresholds.
         *
         *   Thresholds are optional. For unassigned values, defaults are determined in this order:
         *
         *   - For DeviationRange, an omitted LowValue translates into the smallest possible number (-INF), an omitted HighValue translates into the largest possible number (+INF)
         *
         *   - For ToleranceRange, an omitted LowValue will be initialized with DeviationRangeLowValue, an omitted HighValue will be initialized with DeviationRangeHighValue
         *
         *   - For AcceptanceRange, an omitted LowValue will be initialized with ToleranceRangeLowValue, an omitted HighValue will be initialized with ToleranceRangeHighValue
         *
         *   Please refer to {@link sap.chart.coloring.ImprovementDirectionType} for detailed usage.
         *   <pre>
         *   DynamicThresholds: {
         *       ImprovementDirection: string,    // refer to sap.chart.coloring.ImprovementDirectionType for detailed definition
         *       AcceptanceRangeLowValue: string or number, // property name or number
         *       AcceptanceRangeHighValue: string or number, // property name or number
         *       ToleranceRangeLowValue: string or number, // property name or number
         *       ToleranceRangeHighValue: string or number, // property name or number
         *       DeviationRangeLowValue: string or number, // property name or number
         *       DeviationRangeHighValue: string or number, // property name or number
         *   }
         *   </pre>
         *   Example:
         *
         *   In this case, the criticality of 'Profit' measure is determined by the value of 'ProfitAcceptanceRangeLowValue', 'ProfitToleranceRangeLowValue' and 'ProfitDeviationRangeLowValue' measure calculated with improvement direction <code>'Maximize'</code>.
        *   <pre>
         *   var oColorings = {
         *       Criticality: {
         *           MeasureValues: {
         *               Profit: {
         *                    DynamicThresholds : {
         *                        ImprovementDirection: sap.chart.coloring.ImprovementDirectionType.Maximize,
         *                        AcceptanceRangeLowValue: 'ProfitAcceptanceRangeLowValue',
         *                        ToleranceRangeLowValue: 'ProfitToleranceRangeLowValue',
         *                        DeviationRangeLowValue: 'ProfitDeviationRangeLowValue'
         *                    }
         *               }
         *           }
         *       }
         *   };
         *   var oActiveColoring = {
         *       coloring: sap.chart.ColoringType.Criticality,
         *       parameters: {
         *           measure: ['Profit']
         *       }
         *   };
         *   </pre>
         *   </li>
         *   <li><code>ConstantThresholds</code>
         *
         *   Criticality is expressed with thresholds for the boundaries between negative, critical, neutral, and positive.
         *
         *   The direction of improvement for measure values is mandatory, combined with corresponding thresholds.
         *
         *   Thresholds are optional. For unassigned values, defaults are determined in this order:
         *
         *   - For DeviationRange, an omitted LowValue translates into the smallest possible number (-INF), an omitted HighValue translates into the largest possible number (+INF)
         *
         *   - For ToleranceRange, an omitted LowValue will be initialized with DeviationRangeLowValue, an omitted HighValue will be initialized with DeviationRangeHighValue
         *
         *   - For AcceptanceRange, an omitted LowValue will be initialized with ToleranceRangeLowValue, an omitted HighValue will be initialized with ToleranceRangeHighValue
         *
         *   Also Aggregation level (the visible dimensions) must be specified for providing the context for assessing the criticality.
         *
         *   Legend label is shown as value range and do not support customization in ConstantThresholds.
         *
         *   Please refer to {@link sap.chart.coloring.ImprovementDirectionType} for detailed usage. 
         *   <pre>
         *   ConstantThresholds: {
         *       ImprovementDirection: string, refer to sap.chart.coloring.ImprovementDirectionType for detailed definition
         *       AggregationLevels: [{
         *            VisibleDimensions: ['dimensionName', ...],
         *            AcceptanceRangeLowValue: Number,
         *            AcceptanceRangeHighValue:Number,
         *            ToleranceRangeLowValue: Number,
         *            ToleranceRangeHighValue: Number,
         *            DeviationRangeLowValue: Number,
         *            DeviationRangeHighValue: Number
         *       },
         *       ...]
         *   }
         *   </pre>
         *   Example:
         *
         *   In this case, the criticality of 'Profit' measure is determined by two concrete thresholds calculated with improvement direction <code>'Maximize'</code>.
         *   <pre>
         *   var oColorings = {
         *       Criticality: {
         *           MeasureValues: {
         *               Profit: {
         *                    ConstantThresholds : {
         *                        ImprovementDirection: sap.chart.coloring.ImprovementDirectionType.Maximize,
         *                        AcceptanceRangeLowValue:100,
         *                        ToleranceRangeLowValue: 80,
         *                        DeviationRangeLowValue: 60
         *                    }
         *               }
         *           }
         *       }
         *   };
         *   var oActiveColoring = {
         *       coloring: sap.chart.ColoringType.Criticality,
         *       parameters: {
         *           measure: ['Profit']
         *       }
         *   };
         *   </pre>
         *   </li>
         * </ul>
         *
         * <b>For dimension values</b>
         *
         * Criticality can be expressed by assigning values to negative, critical, and positive. Unassigned dimension values are automatically assigned to neutral.
         *
         * <code>'Values'</code> is used to specify concrete dimension value(s). <code>'Legend'</code> is used to customize legend label which is mandatory when multiple dimension values defined in <code>'Values'</code>.
         *
         * <pre> 
         * DimensionValues: { 
         *     'dimensionName': {
         *          Positive: {
         *              Values: 'dimensionValue' or ['dimensionValue', ...]
         *              Legend: string // mandatory for value array
         *          },
         *          Critical: {
         *              Values: 'dimensionValue' or ['dimensionValue', ...]
         *              Legend: string // mandatory for value array
         *          },
         *          Negative: {
         *              Values: 'dimensionValue' or ['dimensionValue', ...]
         *              Legend: string // mandatory for value array
         *          },
         *          Neutral: {
         *              Values: 'dimensionValue' or ['dimensionValue', ...]
         *              Legend: string // mandatory for value array
         *          }
         *     },
         *     'dimensionName': {
         *         ... 
         *     } 
         * }
         * </pre>
         * Example:
         *
         * In this case, the criticality of 'OrderStatus' dimension is determined by values specified to different criticality classes.
         * <pre>
         * var oColorings = {
         *     Criticality: {
         *         DimensionValues: {
         *             OrderStatus: {
         *                  Positive : {
         *                      Values: 'Finished'
         *                  },
         *                  Critical : {
         *                      Values: 'Pending'
         *                  },
         *                  Negative : {
         *                      Values: ['Stopped', 'Not Started'],
         *                      Legend: 'Alert'
         *                  },
         *                  Neutral : {
         *                      Values: ['Processing', 'Surveyed'],
         *                      Legend: 'Normal'
         *                  }
         *             }
         *         }
         *     }
         * };
         * var oActiveColoring = {
         *     coloring: sap.chart.ColoringType.Criticality,
         *     parameters: {
         *         dimension: ['OrderStatus']
         *     }
         * };
         * </pre>
         * @public
         */
        Criticality: "Criticality",
        /**
         * Emphasis is about highlighting certain data points in a chart.
         *
         * It can be defined for dimension values.
         * <pre>
         * Emphasis: {
         *     DimensionValues: {
         *         ...
         *     }
         * }
         * </pre>
         * <b>For dimension values</b>
         *
         * Highlight a specified set of values of a dimension visible in the current chart layout. The qualitative color palette is used.
         *
         * <code>'Values'</code> is used to specify dimension value(s) for highlight. <code>'Legend'</code> is used to customize legend label whose <code>'Hightlighted'</code> is mandatory when multiple dimension values defined in <code>'Values'</code>.
         * <pre>
         * DimensionValues: {
         *     'dimensionName': {
         *         Values: 'dimensionValue' or ['dimensionValue', ...],
         *         Legend: {
         *            Highlighted: string // mandatory for value array
         *            Others: string      // optional
         *         }
         *     },
         *     'dimensionName': {
         *         ...
         *     }
         * }
         * </pre>
         * Example:
         *
         * In this case, 'German' and 'France' are highlighted in 'Country' dimension with customized legend label 'Europe'.
         * <pre>
         * var oColorings = {
         *     Emphasis: {
         *         DimensionValues: {
         *             Country: {
         *                 Values: ['German', 'France']
         *                 Legend: 'Europe'
         *             }
         *         }
         *     }
         * };
         * var oActiveColoring = {
         *     coloring: sap.chart.ColoringType.Emphasis,
         *     parameters: {
         *         dimension: ['Country']
         *     }
         * };
         * </pre>
         * @public
         */
        Emphasis: "Emphasis"
    };

    return ColoringType;

}, /* bExport= */ true);

}; // end of sap/chart/ColoringType.js
if ( !jQuery.sap.isDeclared('sap.chart.ScaleBehavior') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

// Provides enumeration for sap.chart.ScaleBehavior
jQuery.sap.declare('sap.chart.ScaleBehavior'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/ScaleBehavior",function() {
    "use strict";

    /**
     * @class
     * Enumeration for the value axes scale behavior of analytical chart.
     *
     * @static
     * @public
     * @alias sap.chart.ScaleBehavior
     */
    var ScaleBehavior = {
        /**
         * Value axes scale is automatic.
         * @public
         */
        AutoScale: "AutoScale",
        /**
         * Value axes scale is fixed.
         * @public
         */
        FixedScale: "FixedScale"
    };

    return ScaleBehavior;

}, /* bExport= */ true);

}; // end of sap/chart/ScaleBehavior.js
if ( !jQuery.sap.isDeclared('sap.chart.SeriesColorTracker') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */
/*
 * Keep track of series colors on different *pages*.
 */
jQuery.sap.declare('sap.chart.SeriesColorTracker'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/SeriesColorTracker",[], function() {
	"use strict";

	var _COLOR_FEEDS = {
			color: true,
			color2: true
	};
	
	function SeriesColorTracker() {
		this._mSeriesColor = {};
	}
	
	/**
	 * Convert CVOM data context into a string key
	 * @param {any} oCtx a single aCtx CVOM data context, which is an array of string/null/undefined/number/object
	 * @returns {string} string representation of the data context
	 */
	function seriesKey(oCtx) {
		var sType = jQuery.type(oCtx);
		switch (sType) {
		case "string":
			return '"' + oCtx + '"';
		case "null":
		case "undefined":
			return sType;
		case "array":
			return "[" + oCtx.map(seriesKey).join(",") + "]";
		case "object":
			return "{" + Object.keys(oCtx).map(function(sProp) {
				return '"' + sProp + '":' + seriesKey(oCtx[sProp]);
			}).join(",") + "}";
		case "number":
		case "boolean":
			return String(oCtx);
		default:
			return sType + "<" + String(oCtx) + ">";			
		}
	}
	// get item from mSeriesColor which id equal bindingIds. if not found, create a new one
	function getSeriesColorMapping(mSeriesColor, bindingIds){
		var seriesColor;
		for (var i = 0; i < mSeriesColor.length; ++i){
			var item = mSeriesColor[i];
			if (item.fields.length === bindingIds.length){
				var bFound = true;
				for (var j = 0; bFound && j < bindingIds.length; ++j){
					bFound = (bindingIds[j] === item.fields[j]);
				}
				if (bFound) {
					seriesColor = item;
				}
			}
		}
		// 
		if (!seriesColor){
		    seriesColor = {fields: bindingIds.slice(), results:{}};
			mSeriesColor.push(seriesColor);
		} 
		return seriesColor;
	}
	/**
	 * Add CVOM runtime scales to record if not tracked already
	 * @param {object[]} aRuntimeScales CVOM runtime scales
	 * [{feed:"color",
	 *   fields:["Country", "Year"},
	 *   results:[]}
	 *   ]
	 *   
	 *   this._mSeriesColor structure:{
	 *       "color":[{fields:["Country","Year"},  results:{}]
	 *   }
	 */
	SeriesColorTracker.prototype.add = function(aRuntimeScales) {
		var mAllSeriesColor = this._mSeriesColor,
			mSeriesColor;
		if (aRuntimeScales){
			aRuntimeScales.forEach(function(oRTScale) {
				var sFeed = oRTScale.feed;
				if (!_COLOR_FEEDS[sFeed]) {
					return;
				}
				mSeriesColor = mAllSeriesColor[sFeed];
				if (!mSeriesColor) {
					mSeriesColor = [];
					mAllSeriesColor[sFeed] = mSeriesColor;
				}	
				var curSeriesColor = getSeriesColorMapping(mSeriesColor, oRTScale.fields);
				var mapping = curSeriesColor.results;
				oRTScale.results.forEach(function(oResult) {
					var sKey = seriesKey(oResult.dataContext);
					if (!mapping[sKey]) {
					    mapping[sKey] = oResult;
					}
				});
			});
		}
	};
	
	/**
	 * Return currently tracked series colors in CVOM runtime scales format
	 * @returns {object} series colors
	 */
	SeriesColorTracker.prototype.get = function() {
		var aFeeds = Object.keys(this._mSeriesColor);
		var mSeriesColor = this._mSeriesColor;
		var result = [];
		for (var i = 0; i < aFeeds.length; ++i){
			var seriesColors = mSeriesColor[aFeeds[i]];
			var currentSeries = {
				feed:aFeeds[i],
				mappings:[]
			};
			for (var j = 0; j < seriesColors.length; ++j){
				var results = [];
				var colorMapping = seriesColors[j].results;
				var aKeys = Object.keys(colorMapping);
				for (var k = 0; k < aKeys.length; ++k){
					results.push(colorMapping[aKeys[k]]);
				}
				currentSeries.mappings.push({
					results: results,
					fields: seriesColors[j].fields
				});
			}
			result.push(currentSeries);
		}
		
		return result;
	};
	
	SeriesColorTracker.prototype.clear = function() {
		this._mSeriesColor = {};
	};
	
	return SeriesColorTracker;
});
}; // end of sap/chart/SeriesColorTracker.js
if ( !jQuery.sap.isDeclared('sap.chart.TimeUnitType') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

// Provides enumeration sap.chart.TimeUnitType
jQuery.sap.declare('sap.chart.TimeUnitType'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/TimeUnitType",function() {
    "use strict";


    /**
    * Enumeration for supported time unit types in analytical chart
    *
    * @namespace
    * @public
    * @alias sap.chart.TimeUnitType
    */
    var TimeUnitType = {
        /**
         * type is Edm.DateTime and V2 annotation sap:display-format is "Date" or timestamp
         * @public
         */
        Date: "Date",
        /**
         * type is Edm.string and V2 annotation sap:semantics is "yearmonthday", like "yyyyMMdd"
         * @public
         */
        yearmonthday: "yearmonthday",

        /**
         * type is Edm.string, like "yyyyQQQQQ"
         * @public
         */
        yearquarter: "yearquarter",

        /**
         * type is Edm.string, like "yyyyMM"
         * @public
         */
        yearmonth: "yearmonth",
        /**
         * type is Edm.string, like "yyyyww"
         * @public
         */
        yearweek: "yearweek",
	    /**
         * type is Edm.string, like "YYYY"
         * @public
         */
        fiscalyear: "fiscalyear",
        /**
         * type is Edm.string, like "YYYYPPP"
         * @public
         */
        fiscalyearperiod: "fiscalyearperiod"

    };


    return TimeUnitType;

}, /* bExport= */ true);

}; // end of sap/chart/TimeUnitType.js
if ( !jQuery.sap.isDeclared('sap.chart.coloring.ColorPalette') ) {
jQuery.sap.declare('sap.chart.coloring.ColorPalette'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/coloring/ColorPalette",[], function(
) {
	"use strict";
	var Palette = {};

	Palette.CRITICALITY = {
		Positive: [
		    'sapUiChartPaletteSemanticGoodLight3',
		    'sapUiChartPaletteSemanticGoodLight2',
		    'sapUiChartPaletteSemanticGoodLight1',
		    'sapUiChartPaletteSemanticGood',
		    'sapUiChartPaletteSemanticGoodDark1',
		    'sapUiChartPaletteSemanticGoodDark2'
		],
		Critical: [
			'sapUiChartPaletteSemanticCriticalLight3',
			'sapUiChartPaletteSemanticCriticalLight2',
			'sapUiChartPaletteSemanticCriticalLight1',
			'sapUiChartPaletteSemanticCritical',
			'sapUiChartPaletteSemanticCriticalDark1',
			'sapUiChartPaletteSemanticCriticalDark2'
		],
		Negative: [
			'sapUiChartPaletteSemanticBadLight3',
			'sapUiChartPaletteSemanticBadLight2',
			'sapUiChartPaletteSemanticBadLight1',
			'sapUiChartPaletteSemanticBad',
			'sapUiChartPaletteSemanticBadDark1',
			'sapUiChartPaletteSemanticBadDark2'
		],
		Neutral: [
			'sapUiChartPaletteSemanticNeutralLight3',
			'sapUiChartPaletteSemanticNeutralLight2',
			'sapUiChartPaletteSemanticNeutralLight1',
			'sapUiChartPaletteSemanticNeutral',
			'sapUiChartPaletteSemanticNeutralDark1',
			'sapUiChartPaletteSemanticNeutralDark2'
		]
	};

	Palette.EMPHASIS = {
		Highlight: "sapUiChartPaletteQualitativeHue2",
		Others: "sapUiChartPaletteQualitativeHue1"
	};

	return Palette;
});
}; // end of sap/chart/coloring/ColorPalette.js
if ( !jQuery.sap.isDeclared('sap.chart.coloring.CriticalityType') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.chart.coloring.CriticalityType'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/coloring/CriticalityType",function() {
    "use strict";

    /**
    * Enumeration for supported criticality types in analytical chart
    *
    * @enum {string}
    * @public
    * @alias sap.chart.coloring.CriticalityType
    */
    var CriticalityType = {
        /**
         * Negative
         * @public
         */
        Negative: "Negative",

        /**
         * Critical
         * @public
         */
        Critical: "Critical",

        /**
         * Positive
         * @public
         */
        Positive: "Positive",

        /**
         * Neutral
         * @public
         */
        Neutral: "Neutral"
    };

    return CriticalityType;

}, /* bExport= */ true);

}; // end of sap/chart/coloring/CriticalityType.js
if ( !jQuery.sap.isDeclared('sap.chart.data.MeasureSemantics') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.chart.data.MeasureSemantics'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/data/MeasureSemantics",function() {
    "use strict";

    /**
     * Enum of available semantics value for Measure.
     *
     * @enum {string}
     * @public
     * @alias sap.chart.data.MeasureSemantics
     */
    var MeasureSemantics = {
        /**
         * facts that happened in the past.
         * @public
         */
        Actual: "actual",
        /**
         * where values will be, e.g.: forecasts, estimations, predictions.
         * @public
         */
        Reference: "reference",
        /**
         * where values should be, e.g.: thresholds, targets.
         * @public
         */
        Projected: "projected"
    };

    return MeasureSemantics;

}, /* bExport= */ true);

}; // end of sap/chart/data/MeasureSemantics.js
if ( !jQuery.sap.isDeclared('sap.chart.pagination.PagingController') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */
/*
 * helper for paging mode.
 */
jQuery.sap.declare('sap.chart.pagination.PagingController'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.model.Sorter'); // unlisted dependency retained
sap.ui.define("sap/chart/pagination/PagingController",[ 'sap/ui/model/Sorter'], function( Sorter) {
	"use strict";

    var PAGE_SIZE = 500;

    function isRequestedDataAvailable(oBinding, start, length){

          var aContexts = oBinding.getContexts(start, length), bNoContexts;

		if (aContexts.length === 0 || aContexts.dataRequested) {
			bNoContexts = true;
		} else {
			bNoContexts = aContexts.some(function(oContext) {
						return oContext === undefined;
			});
		}

		return !bNoContexts;
	}

	var PagingController = function(oChart){

		this._mMeasureRange = {};
		this._iRenderedPageNo = -1;
		//if the size is small, paging will not be turned on even the paging is on
		this._bUnderPaging = false;
		this._iMaxPageNo = -1;
		this._iRemainingRecords = -1;
		this._iOffset = null;
		this._oChart = oChart;
		this._bInitialized = false;
		this._aPagingSorters = null;
		this._bMinMaxQueried = false;
		this._oColorTracker = oChart._oColorTracker;

        var oDataset =  this._oChart._getDataset();
        if (oDataset){
           oDataset.setRange(0, PAGE_SIZE * 2);
        }

         var oVizframe = this._oChart._getVizFrame();
         oVizframe.attachEvent("_scroll", PagingController.prototype._scrollHandler.bind(this));

	};

    PagingController.prototype.bindingChanged = function(){
        if (!this._bInitialized || !this._bMinMaxQueried){
            this.init(true);
        }else if (this.isUnderPaging()){
	        this.paging(this._scrollRatio);
	    }
    };
    
    PagingController.prototype.reset = function(){

        this._bInitialized = false;
        this._iRenderedPageNo = 0;
        this._mMeasureRange = {};
        this._bMinMaxQueried = false;
		this._oColorTracker.clear();

        var oBinding =  this._oChart.getBinding("data");
		var oDataset =  this._oChart._getDataset();
		if (!oDataset || !oBinding) {
			return;
		}

		var aFeeds = this._oChart._prepareFeeds();
	    aFeeds._order = aFeeds._order.filter(function(sFeed) {
			return sFeed !== "MND" && this._oChart.getDimensions().map(function(oValue){return oValue.getName();}).indexOf(sFeed) > -1;
		}.bind(this));

        this._aPagingSorters = null;


		this._oChart._getVizFrame()._runtimeScales(this._oColorTracker.get(), true);
        this._oChart._getVizFrame()._readyToRender(false);

        var iLength;
		if (this._oChart.getBindingInfo("data").length) {
			iLength = Math.min(PAGE_SIZE * 2, this._oChart.getBindingInfo("data").length);
		} else {
			iLength = PAGE_SIZE * 2;
		}

        oDataset.setRange(0, iLength);

        if (aFeeds._order.length) {
            var aSorters = this._oChart._aFeeds._order.map(function(sProperty) {
                return new Sorter(sProperty);
            });
            //oBinding.resetData();
            oBinding.sort(aSorters);
            this._aPagingSorters = aSorters;
        }
		oDataset.setPagingOption({
            bEnabled: false
		});
    };

    PagingController.prototype.getPagingSorters = function(){
         return this._aPagingSorters;
    };

    PagingController.prototype.isUnderPaging = function(){

          return !!this._bUnderPaging;
    };

	PagingController.prototype.init = function(bNeedQueryMinMax){

        this._bInitialized = true;
        this._bUnderPaging = false;

        var oVizframe = this._oChart._getVizFrame();

        var oDataset = oVizframe.getDataset();
		var oBinding = oDataset.getBinding("data");
		if (!oBinding) {
			return;
		}

		var iTotalSize = oBinding instanceof sap.ui.model.analytics.AnalyticalBinding ? oBinding.getTotalSize() : oBinding.getLength();

		var oPagingOption;
		if (iTotalSize >= 0) {
			if (this._oChart.getBindingInfo("data").length) {
				this._iTotalSize = Math.min(this._oChart.getBindingInfo("data").length, iTotalSize);
			} else {
				this._iTotalSize = iTotalSize;
			}

			if (this._iTotalSize > PAGE_SIZE * 2) {
				this._bUnderPaging = true;
				this._iMaxPageNo = Math.floor(this._iTotalSize / PAGE_SIZE) - 1;
				this._iRemainingRecords = this._iTotalSize % PAGE_SIZE;
				this._iOffset = null;
				this._iRenderedPageNo = 0;
				var dataRatio = PAGE_SIZE / this._iTotalSize;
				oPagingOption = {
					bEnabled: true,
					sMode: "reset",
					thumbRatio: dataRatio
				};

				oDataset.setRange(0 , PAGE_SIZE);
				if (bNeedQueryMinMax) {
					this._bMinMaxQueried = true;
					this._queryMinMax(this._oChart, oBinding, function(oQueryResult){
						var mMeasureRange = {};
						jQuery.each(oQueryResult, function(sMsrId, oResult) {
							mMeasureRange[sMsrId] = {
									min: oResult.min.value,
									max: oResult.max.value
							};
						});
						this._mMeasureRange = mMeasureRange;
						this._oChart._invalidateBy({
							source: this._oChart,
							keys: {
								vizFrame: true
							}
						});
						this._oChart.setBusy(false);
						oVizframe._readyToRender(isRequestedDataAvailable(oBinding , 0, PAGE_SIZE));
					}.bind(this));
				}else {
					oVizframe._readyToRender(isRequestedDataAvailable(oBinding , 0, PAGE_SIZE));
				}
				this._bUnderPaging = true;
			} else {
				this._mMeasureRange = {};
				oPagingOption = {
					bEnabled: false
				};

                this._bUnderPaging = false;
				oDataset.setRange(0 , this._iTotalSize);
				oVizframe._readyToRender(isRequestedDataAvailable(oBinding , 0, this._iTotalSize));
			}

			oDataset.setPagingOption(oPagingOption);
		}
	};

	PagingController.prototype.paging = function(ratio){
		var iCurrentPageNo = Math.floor(this._iTotalSize * ratio / PAGE_SIZE);
		var oVizFrame = this._oChart._getVizFrame();
		//we merge last two pages in case last page does not reach pageSize
		iCurrentPageNo = Math.min(iCurrentPageNo, this._iMaxPageNo);
		this._iOffset = null;

		var iStartIndex = Math.max((iCurrentPageNo - 1) * PAGE_SIZE, 0);
		var iLength, domain;

		if (iCurrentPageNo === 0) {
			iLength = PAGE_SIZE;
			domain = PAGE_SIZE;
		} else if (iCurrentPageNo === this._iMaxPageNo){
			iLength = PAGE_SIZE * 2 + this._iRemainingRecords;
			domain = PAGE_SIZE + this._iRemainingRecords;
		} else {
			iLength = PAGE_SIZE * 2;
			domain =  PAGE_SIZE;
		}

		this._iOffset = (this._iTotalSize * ratio - iCurrentPageNo * PAGE_SIZE) / domain;

		if (this._iRenderedPageNo === iCurrentPageNo) {
			//current page is rendered
			var translate = {
				plot: {
					transform: {
						translate: {
							translateByPage: {
								context: this._middleCtx,
								offset: this._iOffset
							}
						}
					}
				}
			};
			oVizFrame._states(translate);
		} else {
			if (this._pagingTimer) {
				jQuery.sap.clearDelayedCall(this._pagingTimer);
			}

			var oDataset = oVizFrame.getDataset();
			var oBinding = oDataset.getBinding("data");

			this._pagingTimer = jQuery.sap.delayedCall(50, this, function() {
				oDataset.setRange(iStartIndex, iLength);
				oDataset.setPagingOption({
						bEnabled: true,
						sMode: "update",
						thumbRatio: null
				});

				var isDataAvailable = isRequestedDataAvailable(oBinding , iStartIndex, iLength);
				if (isDataAvailable) {
					//analytical binding has these data in local
					//current page is not rendered
					this._iRenderedPageNo = iCurrentPageNo;
					oDataset.invalidate();
					oVizFrame._readyToRender(true);
					oVizFrame.invalidate();
					this._oColorTracker.add(oVizFrame._runtimeScales());
					oVizFrame._runtimeScales(this._oColorTracker.get(), true);
				} else {
					oVizFrame._readyToRender(false);
				}
			});

			this._sLoadingTimer = this._sLoadingTimer || jQuery.sap.delayedCall(200, this, function() {
				this._oChart._showLoading(true);
			});
		}
	};

    /**
     ** move chart plot to the middle of the page since we draw 2 pages at one time, after rendering complete
     ** we have to move the plot to the middle of the two pages.
    **/
	PagingController.prototype.vizFrameRenderCompleted = function() {

        if (this._sLoadingTimer) {
			jQuery.sap.clearDelayedCall(this._sLoadingTimer);
            this._sLoadingTimer = null;
		}

		this._oChart._showLoading(false);

		if (!this._bUnderPaging){
			return;
		}
        var oVizFrame = this._oChart._getVizFrame();
		var oDataset = oVizFrame.getDataset();
		var oBinding = oDataset.getBinding("data");
		var iRenderedPageNo = this._iRenderedPageNo;
		if (iRenderedPageNo !==  0) {
			var iMidRecordNo = iRenderedPageNo * PAGE_SIZE - 1;
			this._middleCtx = oBinding.getContexts(iMidRecordNo, 1)[0].getObject();
		} else {
			this._middleCtx = null;
		}

		if (this._middleCtx || this._iOffset) {
			var translate = {
					plot: {
						transform: {
							translate: {
								translateByPage: {
									context: this._middleCtx,
									offset: this._iOffset
								}
							}
						}
					}
				};
			oVizFrame._states(translate);
		}
	};

	PagingController.prototype._scrollHandler = function(oEvent){
        if (this._oChart._isEnablePaging()){
            this._scrollRatio = oEvent.getParameters().position;
		    this.paging(this._scrollRatio);
        }

    };

	// Request for the min/max at current aggregation level for all visible measures
	PagingController.prototype._queryMinMax = function(oChart, oBinding, fnCallback) {
		var aDims = oChart._getRequiredDimensions().map(function(oDim) {
				return oDim.getName();
			}),
			aMsrs = oChart._getRequiredMeasures().map(function(oMsr) {
				return oMsr.getName();
			});

		var oResult = aMsrs.reduce(function(oResult, sMsr) {
			oResult[sMsr] = {min: {}, max: {}};
			return oResult;
		}, {});

		function checkComplete() {
			var bAllComplete = aMsrs.every(function(sMsr) {
				return oResult[sMsr].min.requested && oResult[sMsr].max.requested;
			});
			if (bAllComplete) {
				fnCallback(oResult);
			}
		}

		function onsuccess(sMsr, sKey, oData) {
			oResult[sMsr][sKey].requested = true;
			oResult[sMsr][sKey].value = parseFloat(oData && oData.results[0][sMsr]);
			checkComplete();
		}

		function onerror(sMsr, sKey, oData) {
			oResult[sMsr][sKey].requested = true;
			oResult[sMsr][sKey].error = oData;
			checkComplete();
		}

		var aQueries = aMsrs.reduce(function(aQueries, sMsr) {
			return aQueries.concat({
				urlParameters: {
					"$select": aDims.concat(sMsr).join(","),
					"$top": 1,
					"$orderby": sMsr + " asc"
				},
				success: onsuccess.bind(null, sMsr, "min"),
				error: onerror.bind(null, sMsr, "min")
			}, {
				urlParameters: {
					"$select": aDims.concat(sMsr).join(","),
					"$top": 1,
					"$orderby": sMsr + " desc"
				},
				success: onsuccess.bind(null, sMsr, "max"),
				error: onerror.bind(null, sMsr, "max")
			});
		}, []);

		var sPath = oBinding.getPath(),
			oModel = oBinding.getModel();

		aQueries.forEach(function(oQuery) {
			oModel.read(sPath, oQuery);
		});

		return aQueries;
    };

    PagingController.prototype.getCurrentContexts = function(){
         var oVizframe = this._oChart._getVizFrame();
         var oDataset = oVizframe.getDataset();
         var range = oDataset.getRange();
         var iStart = range.iStartIndex, iLength;
		if (this._iRenderedPageNo === 0) {
			iLength = range.iLength * 2;
		} else {
			iLength = range.iLength;
		}

		return oDataset.getBinding("data").getContexts(iStart, iLength);
    };

    PagingController.prototype.getMeasureRange = function(){
        return this._mMeasureRange;
    };

	return PagingController;
});
}; // end of sap/chart/pagination/PagingController.js
if ( !jQuery.sap.isDeclared('sap.chart.utils.ChartUtils') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */
jQuery.sap.declare('sap.chart.utils.ChartUtils'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/utils/ChartUtils",['sap/chart/ChartType'], function(ChartType) {
	"use strict";

	var _CONFIG = {
		chartTypes: [
			ChartType.Bar,
			ChartType.Column,
			ChartType.Line,
			ChartType.Combination,
			ChartType.Pie,
			ChartType.Donut,
			ChartType.Scatter,
			ChartType.Bubble,
			ChartType.Heatmap,
			ChartType.Bullet,
			ChartType.VerticalBullet,
			ChartType.StackedBar,
			ChartType.StackedColumn,
			ChartType.StackedCombination,
			ChartType.HorizontalStackedCombination,
			ChartType.DualBar,
			ChartType.DualColumn,
			ChartType.DualLine,
			ChartType.DualStackedBar,
			ChartType.DualStackedColumn,
			ChartType.DualCombination,
			ChartType.DualHorizontalCombination,
			ChartType.DualStackedCombination,
			ChartType.DualHorizontalStackedCombination,
			ChartType.PercentageStackedBar,
			ChartType.PercentageStackedColumn,
			ChartType.PercentageDualStackedBar,
			ChartType.PercentageDualStackedColumn,
			ChartType.Waterfall,
			ChartType.HorizontalWaterfall
		],
		pagingChartTypes: [
		    ChartType.Bar,
			ChartType.Column,
			ChartType.Line,
			ChartType.Combination,
			ChartType.Bullet,
			ChartType.VerticalBullet,
			ChartType.StackedBar,
			ChartType.StackedColumn,
			ChartType.StackedCombination,
			ChartType.HorizontalStackedCombination,
			ChartType.DualBar,
			ChartType.DualColumn,
			ChartType.DualLine,
			ChartType.DualStackedBar,
			ChartType.DualStackedColumn,
			ChartType.DualCombination,
			ChartType.DualHorizontalCombination,
			ChartType.DualStackedCombination,
			ChartType.DualHorizontalStackedCombination,
			ChartType.PercentageStackedBar,
			ChartType.PercentageStackedColumn,
			ChartType.PercentageDualStackedBar,
			ChartType.PercentageDualStackedColumn
		],
		timeChartTypes: [
			"timeseries_line",
			"timeseries_column",
			"timeseries_bubble",
			"timeseries_scatter",
			"timeseries_combination",
			"dual_timeseries_combination",
			"timeseries_bullet",
			"timeseries_stacked_column",
			"timeseries_100_stacked_column",
			"timeseries_waterfall"
		],
		oAdapteredChartTypes: {
		    "line": "timeseries_line",
		    "column": "timeseries_column",
		    "scatter": "timeseries_scatter",
		    "bubble": "timeseries_bubble",
		    "combination": "timeseries_combination",
		    "dual_combination": "dual_timeseries_combination",
		    "vertical_bullet": "timeseries_bullet",
		    "stacked_column": "timeseries_stacked_column",
		    "100_stacked_column": "timeseries_100_stacked_column",
		    "waterfall": "timeseries_waterfall"
		},
		nonSemanticPatternChartType : [
			ChartType.Combination,
			ChartType.Pie,
			ChartType.Donut,
			ChartType.Scatter,
			ChartType.Bubble,
			ChartType.Heatmap,
			ChartType.StackedBar,
			ChartType.StackedColumn,
			ChartType.StackedCombination,
			ChartType.HorizontalStackedCombination,
			ChartType.DualStackedBar,
			ChartType.DualStackedColumn,
			ChartType.DualCombination,
			ChartType.DualHorizontalCombination,
			ChartType.DualStackedCombination,
			ChartType.DualHorizontalStackedCombination,
			ChartType.PercentageStackedBar,
			ChartType.PercentageStackedColumn,
			ChartType.PercentageDualStackedBar,
			ChartType.PercentageDualStackedColumn,
			ChartType.Waterfall,
			ChartType.HorizontalWaterfall,
			"timeseries_bubble",
			"timeseries_scatter",
			"timeseries_combination",
			"dual_timeseries_combination",
			"timeseries_stacked_column",
			"timeseries_100_stacked_column",
			"timeseries_waterfall"
		],
		lineChartType: [
			ChartType.Line,
			ChartType.DualLine,
			'timeseries_line'
		]
	};
	return {
		CONFIG: _CONFIG,
		makeNotifyParentProperty: function(sPropertyName) {
			return function(oValue, bSuppressInvalidate) {
				var oOldValue = this.mProperties[sPropertyName];

				oValue = this.validateProperty(sPropertyName, oValue);

				if (jQuery.sap.equal(oOldValue, oValue)) {
					return this;
				}

				this.setProperty(sPropertyName, oValue, bSuppressInvalidate);

				if (bSuppressInvalidate) {
					return this;
				}

				var oParent = this.getParent();
				if (oParent && typeof oParent._invalidateBy === "function") {
					oParent._invalidateBy({
						source: this,
						property: sPropertyName,
						oldValue: oOldValue,
						newValue: oValue
					});
				}

				return this;
			};
		},
		isStackedLikeChart: function(sChartType) {
			return sChartType.indexOf('stacked') >= 0 ||
				sChartType.indexOf('waterfall') >= 0;
		},
		isBulletChart: function(sChartType) {
			return sChartType.indexOf('bullet') >= 0;
		}
	};
});

}; // end of sap/chart/utils/ChartUtils.js
if ( !jQuery.sap.isDeclared('sap.chart.utils.DateFormatUtil') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */
/*
 * Parse and Format Date String depending on sap.ui.core.format.DateFormat
 */
jQuery.sap.declare('sap.chart.utils.DateFormatUtil'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.core.format.DateFormat'); // unlisted dependency retained
sap.ui.define("sap/chart/utils/DateFormatUtil",[
	'sap/chart/TimeUnitType',
	'sap/ui/core/format/DateFormat'
], function(
	TimeUnitType,
	DateFormat
) {
	"use strict";

	var PATTERN_TABLE = {};
	PATTERN_TABLE[TimeUnitType.yearmonthday] =  "yyyyMMdd";
	PATTERN_TABLE[TimeUnitType.yearquarter] =  "yyyyQQQQQ";
	PATTERN_TABLE[TimeUnitType.yearmonth] =  "yyyyMM";
	PATTERN_TABLE[TimeUnitType.yearweek] =  "yyyyww";


	function getInstance(sTimeUnitType) {
		var sPattern = PATTERN_TABLE[sTimeUnitType]; 
		if (sPattern) {
			return DateFormat.getDateInstance({pattern: sPattern});
		} else {
			return null;
		}
	}

	return {
		getInstance: getInstance
	};
});

}; // end of sap/chart/utils/DateFormatUtil.js
if ( !jQuery.sap.isDeclared('sap.chart.utils.SelectionAPIUtils') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */
jQuery.sap.declare('sap.chart.utils.SelectionAPIUtils'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/utils/SelectionAPIUtils",[
    
],function(

) {
    "use strict";

    function makeLookUp(aKeys) {
        return aKeys.reduce(function(mLookUp, sKey) {
            mLookUp[sKey] = true;
            return mLookUp;
        }, {});
    }
    function toVizCtx(aVisibleMeasures, aVisibleDimensions) {
        var mVisibleMsrs = makeLookUp(aVisibleMeasures);

        function dimWrapper(oContextObj) {
            return aVisibleDimensions.reduce(function(oPartialDataCtx, sDim) {
                if (oContextObj.hasOwnProperty(sDim)) {
                    oPartialDataCtx[sDim] = oContextObj[sDim];
                }
                return oPartialDataCtx;
            }, {});
        }

        return function(aRequestedMeasures, oContextObj) {
            return aRequestedMeasures.filter(function(sMsr) {
                return mVisibleMsrs[sMsr];
            }).map(function(sMsr) {
                var oDataCtx = dimWrapper(oContextObj);
                oDataCtx[sMsr] = "*";
                return {data: oDataCtx};
            });
        };
    }

    function toVizCSCtx(oCtx) {
        var oVizCtx = {data:{}},
            oMsrVal = oCtx.measures,
            oDimVal = oCtx.dimensions;

        if (oMsrVal) {
            oVizCtx.data.measureNames = (oMsrVal instanceof Array) ? {"in": oMsrVal} : oMsrVal;
        }

        jQuery.each(oDimVal || {}, function(k, v) {
            oVizCtx.data[k] = (v instanceof Array) ? {"in": v} : v;
        });

        return oVizCtx;
    }

    function fromVizCSCtx(oVizCtx) {
        var oData = oVizCtx.data;
        return Object.keys(oData).reduce(function(obj, k) {
            var v = oData[k];
            if (v.in && v.in instanceof Array) {
                v = v.in;
            }
            if (k === "measureNames") {
                obj.measures = v;
            } else if (!obj.dimensions) {
                obj.dimensions = {};
                obj.dimensions[k] = v;
            } else {
                obj.dimensions[k] = v;
            }
            return obj;
        }, {});
    }

    function buildSelectionVizCtx(aVisibleMeasures, aVisibleDimensions, oBinding, aContexts) {
        var converter = toVizCtx(aVisibleMeasures, aVisibleDimensions);
        return aContexts.reduce(function(aData, oCtx) {
            var aCtxs = oBinding.getContexts(oCtx.index, 1);
            if (aCtxs.length > 0) {
                aData = aData.concat(converter(oCtx.measures, aCtxs[0].getObject()));
            }
            return aData;
        }, []);
    }

    function filterVisibleMsr(data, mVisibleMsrs){
        return Object.keys(data).filter(function(sMsr){
            return (mVisibleMsrs.indexOf(sMsr) !== -1);
        });
    }

    function filterSemMsr(oSemanticTuples, mVisibleMsrs, mDataPoint){
        //Filter continues meausre accroding with projectedValueStartTime
        if (oSemanticTuples) {
            var sInvisibleSemMsr, tuple;
            for (tuple in oSemanticTuples) {
                if (oSemanticTuples.hasOwnProperty(tuple) && mDataPoint.data[tuple]) {
                    var semanticRule = oSemanticTuples[tuple];
                    sInvisibleSemMsr = (mDataPoint.data[semanticRule.timeAxis] < semanticRule.projectedValueStartTime) ? semanticRule.projected : semanticRule.actual;
                }
            }
            if (sInvisibleSemMsr) {
                //Hit continues series data point. Filter inVisible measure info.
                mDataPoint.measures = mDataPoint.measures.filter(function(sMsr){
                    return (sMsr !== sInvisibleSemMsr);
                });
                if (mDataPoint.dataName) {
                    mDataPoint.dataName = Object.keys(mDataPoint.dataName).reduce(function(dataName, key, i){
                        if (mVisibleMsrs.indexOf(key) !== -1){
                            dataName[key] = mDataPoint.dataName[key];
                        }
                        return dataName;
                    }, {});
                    if (jQuery.isEmptyObject(mDataPoint.dataName)) {
                        delete mDataPoint.dataName;
                    }
                }
            } else {
                var unboundMsrs = [];
                for (var key in oSemanticTuples) {
                    if (oSemanticTuples.hasOwnProperty(key)) {
                        tuple = oSemanticTuples[key];
                        unboundMsrs.push(tuple.actual);
                        unboundMsrs.push(tuple.projected);
                    }
                }
                //Hit normal series in a continues chart. Filter unbound measures.
                mDataPoint.measures = mDataPoint.measures.filter(function(sMsr){
                    return unboundMsrs.indexOf(sMsr) === -1;
                });
            }
        }
    }

    return {
        makeLookUp: makeLookUp,
        toVizCtx: toVizCtx,
        toVizCSCtx: toVizCSCtx,
        fromVizCSCtx: fromVizCSCtx,
        buildSelectionVizCtx: buildSelectionVizCtx,
        filterVisibleMsr : filterVisibleMsr,
        filterSemMsr: filterSemMsr,
        match: function(oRef, oVal, aMeasures) {
            return Object.keys(oRef).every(function(k) {
                if (aMeasures.indexOf(k) !== -1) {
                    return oVal.hasOwnProperty(k);
                } else {
                    return oRef[k] === oVal[k];
                }
            });
        }
    };
});

}; // end of sap/chart/utils/SelectionAPIUtils.js
if ( !jQuery.sap.isDeclared('sap.chart.utils.ValueAxisScaleUtils') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */
jQuery.sap.declare('sap.chart.utils.ValueAxisScaleUtils'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/utils/ValueAxisScaleUtils",[
	'sap/chart/AutoScaleMode',
	'sap/chart/ScaleBehavior',
	'sap/chart/ChartLog',
	'sap/chart/utils/ChartUtils'
], function(
	AutoScaleMode,
	ScaleBehavior,
	ChartLog,
	ChartUtils
) {
	"use strict";

	var ValueAxisScaleUtils = {};

	ValueAxisScaleUtils.getValueAxisScaleSetting = function(sChartType, oValueAxisScale, aAllMeasures, aVisibleMeasures) {
		var aMeasures = aAllMeasures.filter(function(oMeasure) {
			return aVisibleMeasures.indexOf(oMeasure.getName()) !== -1;
		});
	
		var sRole, sMeasure, oBoundaries = {};
		aMeasures.forEach(function(oMeasure) {
			sMeasure = oMeasure.getName();
			sRole = oMeasure._getFixedRole();
			if (sRole === 'axis1' || sRole === 'axis2') {
				if (!oBoundaries[sRole]) {
					oBoundaries[sRole] = {
						measures: [],
						min : Number.POSITIVE_INFINITY,
						max : Number.NEGATIVE_INFINITY
					};
				}
				oBoundaries[sRole].measures.push(sMeasure);
			}
		});

		var oBoundaryValue,
			bFixedScale = oValueAxisScale && oValueAxisScale.scaleBehavior === ScaleBehavior.FixedScale,
			bIsMultipleStacked = ChartUtils.isStackedLikeChart(sChartType) && aMeasures.length > 1,
			oMeasureBoundaryValues = (oValueAxisScale && oValueAxisScale.fixedScaleSettings
				&& oValueAxisScale.fixedScaleSettings.measureBoundaryValues) || {};
		if (bFixedScale) {
			if (bIsMultipleStacked) {
				var aStackedBoundaryValues = 
					(oValueAxisScale && oValueAxisScale.fixedScaleSettings && 
						oValueAxisScale.fixedScaleSettings.stackedMultipleMeasureBoundaryValues) || [];
				if (aStackedBoundaryValues && aStackedBoundaryValues.length > 0) {
					var getBoundarySetting = function(oBoundary) {
						return aStackedBoundaryValues.filter(function(obj) {
							return obj.measures && obj.measures.length > 0 && 
								obj.measures.sort().toString() === oBoundary.measures.sort().toString();
						});
					};
					for (var key in oBoundaries) {
						if (oBoundaries.hasOwnProperty(key)) {
							var oBoundary = oBoundaries[key];
							var aBoundarySetting = getBoundarySetting(oBoundary);
							if (aBoundarySetting && aBoundarySetting.length > 0) {
								oBoundaryValue = 
									aBoundarySetting[aBoundarySetting.length - 1].boundaryValues;
								if (oBoundaryValue && 
									(isFinite(oBoundaryValue.minimum) && typeof oBoundaryValue.minimum == "number") ||
									(isFinite(oBoundaryValue.maximum) && typeof oBoundaryValue.maximum == "number") ) {
									oBoundary.min = oBoundaryValue.minimum;
									oBoundary.max = oBoundaryValue.maximum;
								}
							}
						}
					}
				}
			} else {
				aMeasures.forEach(function(oMeasure) {
					sRole = oMeasure._getFixedRole();
					if (sRole === 'axis1' || sRole === 'axis2') {
						sMeasure = oMeasure.getName();			
						oBoundaryValue = oMeasureBoundaryValues[sMeasure];
						if (!oBoundaryValue || !(isFinite(oBoundaryValue.minimum) && typeof oBoundaryValue.minimum == "number" ) ||
							!(isFinite(oBoundaryValue.maximum) && typeof oBoundaryValue.maximum == "number")) {
							oBoundaries[sRole].min = Number.NEGATIVE_INFINITY;
							oBoundaries[sRole].max = Number.POSITIVE_INFINITY;
						}else {
							if (oBoundaries[sRole].min > oBoundaryValue.minimum) {
								oBoundaries[sRole].min = oBoundaryValue.minimum;
							}
							if (oBoundaries[sRole].max < oBoundaryValue.maximum) {
								oBoundaries[sRole].max = oBoundaryValue.maximum;
							}
						}
					}
				});
			}
		}

		bFixedScale = false;
		var aScale = [], bIsBullet = ChartUtils.isBulletChart(sChartType);
		for (var key in oBoundaries) {
			if (oBoundaries.hasOwnProperty(key)) {
				var oBoundary = oBoundaries[key];
				var bIsAuto = !(isFinite(oBoundary.min) && typeof oBoundary.min == "number" && isFinite(oBoundary.max) && typeof oBoundary.max == "number");
				var feed = key === 'axis1' ? "valueAxis" : "valueAxis2";
				if (bIsBullet) {
					feed = 'actualValues';
				}
				if (bIsAuto) {
					if (oValueAxisScale && oValueAxisScale.scaleBehavior === ScaleBehavior.FixedScale) {
						new ChartLog('error', 'Chart.ValueAxisScale', 
							feed + ' was switched to auto scale, because minimum or maximum value is missing in measure').display();
					}
				} else if (oBoundary.min > oBoundary.max) {
					new ChartLog('error', 'Chart.ValueAxisScale', 
						feed + ' was switched to auto scale, because minimum value exceeds maximum value').display();
				} else {
					bFixedScale = true;
				}
				aScale.push({
					"feed": feed,
					"type": "linear",
					"min": bIsAuto ? "auto" : oBoundary.min,
					"max": bIsAuto ? "auto" : oBoundary.max
				});
			}
		}

		var oProperty = {};
		if (!bFixedScale) {
			var bZeroAlwaysVisible = true, bSyncValueAxis = false;
			if (oValueAxisScale && oValueAxisScale.autoScaleSettings && 
				oValueAxisScale.autoScaleSettings.zeroAlwaysVisible === false) {
				bZeroAlwaysVisible = false;
			}
			if (oValueAxisScale && oValueAxisScale.autoScaleSettings && 
				oValueAxisScale.autoScaleSettings.syncWith === AutoScaleMode.VisibleData) {
				bSyncValueAxis = true;
			}

			oProperty = {
				plotArea: {
					adjustScale : !bZeroAlwaysVisible
				},
				interaction: {
					syncValueAxis : bSyncValueAxis
				}
			};
		}

		return {
			scale : aScale,
			property : oProperty
		};
	};

	return ValueAxisScaleUtils;
});
}; // end of sap/chart/utils/ValueAxisScaleUtils.js
if ( !jQuery.sap.isDeclared('sap.chart.data.Dimension') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.chart.data.Dimension'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained
sap.ui.define("sap/chart/data/Dimension",[
	"sap/ui/core/Element",
	"sap/chart/utils/ChartUtils"
], function(
	Element,
	ChartUtils
) {
	"use strict";
	var _SUPPORTED_ROLE = {category:true,category2:true,series:true};

	/**
	 * Constructor for a new ui5/data/Dimension.
	 *
	 * @param {string} [sId] id for the new control, generated automatically if no id is given 
	 * @param {object} [mSettings] initial settings for the new control
	 *
	 * @class
	 * Definition of a single dimension in a chart
	 * @extends sap.ui.core.Element
	 *
	 * @constructor
	 * @public
	 * @since 1.32.0
	 * @name sap.chart.data.Dimension
	 */
	var Dimension = Element.extend("sap.chart.data.Dimension", {
		metadata : {
			library : "sap.chart",
			properties : {
				/**
				 * Property in the "data" model holding the (always unique) Dimension key.
				 */
				name : {type : "string"},
				/**
				 * Label for the Dimension, either as a string literal or by a pointer using the binding syntax to some property containing the label.
				 *
				 * NOTE: This property was bound internally if automatically created via metadata of oData service and please call "unbindProperty" before setting.
				 */
				label: {type: "string"},
				/**
				 * Function returning a formatted text for a Dimension key value that will be used for axis labelling. If specified, this property takes precedence over the "textProperty" property of the Dimension.
				 * Dimension key value and the corresponding text will be passed to the supplied function as parameters.
				 */
				textFormatter: {type: "function"},
				/**
				 * Text for a Dimension key value, typically by a pointer using the binding syntax to some property containing the text.
				 *
				 * NOTE: This property was bound internally if automatically created via metadata of oData service and please call "unbindProperty" before setting.
				 */
				textProperty: {type: "string"},
				/**
				 * Whether a text is displayed. If the "textProperty" property has not been specified, it will be derived from the metadata.
				 */
				displayText: {type: "boolean", defaultValue: true},
				/**
				 * How the Dimension will influence the chart layout. Possible values are "category" or "series".
				 * The default is "category".
				 * NOTE: Has no effect if the Dimension is used as inResultDimensions by Chart
				 */
				role: {type: "string", defaultValue: "category"}
			}
		}
	});
	
	Dimension.prototype.setLabel = ChartUtils.makeNotifyParentProperty("label");	
	Dimension.prototype.setTextFormatter = ChartUtils.makeNotifyParentProperty("textFormatter");	
	var textPropertySetter = ChartUtils.makeNotifyParentProperty("textProperty");
	Dimension.prototype.setTextProperty = function(sValue, bSuppressInvalidate) {
		return textPropertySetter.apply(this, arguments);
	};
	Dimension.prototype.setDisplayText = ChartUtils.makeNotifyParentProperty("displayText");
	var roleSetter = ChartUtils.makeNotifyParentProperty("role");
	Dimension.prototype.setRole = function(sValue, bSuppressInvalidate) {
		if (!_SUPPORTED_ROLE[sValue]) {
			jQuery.error("Invalide Dimension role: " + sValue);
		}
		return roleSetter.apply(this, arguments);
	};
	Dimension.prototype._getFixedRole = function() {
		return this._sFixedRole || this.getRole();
	};
	return Dimension;
});

}; // end of sap/chart/data/Dimension.js
if ( !jQuery.sap.isDeclared('sap.chart.data.Measure') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.chart.data.Measure'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained
sap.ui.define("sap/chart/data/Measure",[
	"sap/ui/core/Element",
	"sap/chart/utils/ChartUtils",
	"sap/chart/data/MeasureSemantics"
], function(
	Element,
	ChartUtils,
	MeasureSemantics
) {
	"use strict";
	var _SUPPORTED_ROLE = {axis1:true,axis2:true,axis3:true,axis4:true};
	
	/**
	 * Constructor for a new ui5/data/Measure.
	 *
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 *
	 * @class
	 * Definition of a single measure in a chart
	 * @extends sap.ui.core.Element
	 *
	 * @constructor
	 * @public
	 * @since 1.32.0
	 * @name sap.chart.data.Measure
	 */
	var Measure = Element.extend("sap.chart.data.Measure", {
		metadata: {
			library : "sap.chart",
			properties: {
				/**
				 * Property in the "data" model holding the raw measure value.
				 */
				name: {type: "string"},
				/**
				 * Label for the Measure, either as a string literal or by a pointer using the binding syntax to some property containing the label.
				 */
				label: {type: "string"},
				// Need to discuss behavior for these 2 properties
				/**
				 * Unit for the measure, a pointer using the binding syntax to some field containing the unit.
				 * Value of the given field from the same data record will be displayed after formatted measure value in data label, tooltip and chart popover.
				 * NOTE: If the unit field is not set as visible dimension in chart, or more than one unit value exists
				 * for any visible dimension value combination, it will be rendered in the chart as well but with different layout when the field is set as visible dimension..
				 */
				unitBinding: {type: "string"},
				/**
				 * A (core UI5) format pattern to be used by the formatter to format the measure value.
				 * @deprecated
				 * Please use {@link sap.chart.Chart#setVizProperties} to set related formatStrings instead.
				 *
				 */
				valueFormat: {type: "string", defaultValue: null},
				/**
				 * How values of measure will be rendered in the chart. Possible role values are "axis1", "axis2", "axis3", and "axis4".
				 * The default is "axis1".
				 * They correspond to the well-known concepts of axis identifiers in the Cartesian coordinate system, e.g. a Y-axis in a bar/column/line chart, an X- and a Y-axis in a scatter chart, or two Y-axes in bar charts, and an optional third axis for the weight/size/intensity/temperature of a data point.
				 */
				role: {type: "string", defaultValue: "axis1"},
				/**
				 * The semantics of the measure.
				 *
				 * <b>NOTE:</b> Dimension-based coloring (see {@link sap.chart.Chart#setColorings}) does not work when semantics is set to {@link sap.chart.data.MeasureSemantics.Projected} or {@link sap.chart.data.MeasureSemantics.Reference} for visible measure(s).
				 */
				semantics: {type: "sap.chart.data.MeasureSemantics", defaultValue: MeasureSemantics.Actual},
				/**
				 * Semantically related measures for a measure with semantics "actual" value. It is an object with two properties:
				 * <ol>
				 *   <li>"projectedValueMeasure" identifing the projected value measure, and</li>
				 *   <li>"referenceValueMeasure" identifing the reference value measure.</li>
				 * </ol>
				 */
				semanticallyRelatedMeasures: {type: "object", defaultValue: null}
			}
		}
	});

	Measure.prototype.setLabel = ChartUtils.makeNotifyParentProperty("label");
	var roleSetter = ChartUtils.makeNotifyParentProperty("role");
	Measure.prototype.setRole = function(sValue, bSuppressInvalidate) {
		if (!_SUPPORTED_ROLE[sValue]) {
			jQuery.error("Invalide Measure role: " + sValue);
		}
		return roleSetter.apply(this, arguments);
	};
	Measure.prototype.setUnitBinding = ChartUtils.makeNotifyParentProperty("unitBinding");
	Measure.prototype.setValueFormat = ChartUtils.makeNotifyParentProperty("valueFormat");
	Measure.prototype.setSemantics = ChartUtils.makeNotifyParentProperty("semantics");
	Measure.prototype.setSemanticallyRelatedMeasures = ChartUtils.makeNotifyParentProperty("semanticallyRelatedMeasures");
	Measure.prototype._getFixedRole = function() {
		return this._sFixedRole || this.getRole();
	};
	return Measure;
});

}; // end of sap/chart/data/Measure.js
if ( !jQuery.sap.isDeclared('sap.chart.data.TimeDimension') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.chart.data.TimeDimension'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/data/TimeDimension",[
	"sap/chart/data/Dimension",
	"sap/chart/utils/ChartUtils"
], function(
	Dimension,
	ChartUtils
) {
	"use strict";

	/**
	 * Constructor for a new ui5/data/TimeDimension.
	 *
	 * @param {string} [sId] id for the new control, generated automatically if no id is given 
	 * @param {object} [mSettings] initial settings for the new control
	 *
	 * @class
	 * Definition of a single time dimension in a chart
	 * @extends sap.chart.data.Dimension
	 *
	 * @constructor
	 * @public
	 * @since 1.38.0
	 * @name sap.chart.data.TimeDimension
	 */
	var TimeDimension = Dimension.extend("sap.chart.data.TimeDimension", {
		metadata : {
			library : "sap.chart",
			properties : {
				/**
				 * Detailed unit infomation of TimeDimension. Please refer to {@link sap.chart.TimeUnitType TimeUnitType}.
				 */
				timeUnit : {type : "sap.chart.TimeUnitType"},
				/**
				 * Detailed fiscalYearPeriodCount of TimeDimension. It contains period numbers of fiscal years, like
				 * <pre>
				 * {
				 *	 default: 12,
				 *	 deviations: {
				 *	 	 "2012": 10,
				 *	 	 "2013": 16
				 *	 }
				 * }
				 * </pre>
				 */
				fiscalYearPeriodCount : {type : "object"},
				/**
				 * A time value (aligned with 'timeUnit') to indicate the start point of projected values.
				 */
				projectedValueStartTime : { type: "any"}
			}
		}
	});
	
	TimeDimension.prototype.setTimeUnit = ChartUtils.makeNotifyParentProperty("timeUnit");
	TimeDimension.prototype.setFiscalYearPeriodCount = ChartUtils.makeNotifyParentProperty("fiscalYearPeriodCount");
	TimeDimension.prototype.setProjectedValueStartTime = ChartUtils.makeNotifyParentProperty("projectedValueStartTime");

	return TimeDimension;
});

}; // end of sap/chart/data/TimeDimension.js
if ( !jQuery.sap.isDeclared('sap.chart.utils.ChartTypeAdapterUtils') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */
jQuery.sap.declare('sap.chart.utils.ChartTypeAdapterUtils'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/utils/ChartTypeAdapterUtils",[
    'sap/chart/utils/ChartUtils'
],function(
    ChartUtils
) {
    "use strict";

    var ChartTypeAdapterUtils = {};

    function timeSeriesAdaptHandler(sChartType, aDimensions) {
        var bHasTimeDimension = aDimensions.some(function(oDim) {
            return oDim instanceof sap.chart.data.TimeDimension;
        });
        if (bHasTimeDimension) {
            return ChartUtils.CONFIG.oAdapteredChartTypes[sChartType];
        } else {
            return sChartType;
        }
    }

    ChartTypeAdapterUtils.adaptChartType = function(sChartType, aDimensions) {
        if (ChartUtils.CONFIG.oAdapteredChartTypes[sChartType]) {
            return timeSeriesAdaptHandler(sChartType, aDimensions);
        } else {
            return sChartType;
        }
    };

    return ChartTypeAdapterUtils;
});

}; // end of sap/chart/utils/ChartTypeAdapterUtils.js
if ( !jQuery.sap.isDeclared('sap.chart.utils.DataSourceUtils') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */
jQuery.sap.declare('sap.chart.utils.DataSourceUtils'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/utils/DataSourceUtils",[
	'sap/chart/data/Dimension',
	'sap/chart/data/TimeDimension',
	'sap/chart/data/Measure',
	'sap/chart/TimeUnitType'
], function(
	Dimension,
	TimeDimension,
	Measure,
	TimeUnitType
) {
	"use strict";

	function getEntitySet(bIsAnalytical, oBinding) {
		var sPath = oBinding.path;
		var sNamedEntitySet = (oBinding.parameters || {}).entitySet;
		if (!sNamedEntitySet) {
			// assume absolute path complying with conventions from OData4SAP spec
			sNamedEntitySet = sPath.split("/")[1];

			if (sNamedEntitySet.indexOf("(") != -1) {
				sNamedEntitySet = sNamedEntitySet.split("(")[0] + (bIsAnalytical ? "Results" : "Set");
			}
		}
		return sNamedEntitySet;
	}

	function _bindingSyntax(sResultType, sDimensionName, type) {
		return "{/#" + sResultType + "/" + sDimensionName + "/@sap:" + type + "}";
	}

	function detectDimension(oProps, oConfig) {
		//Fiscal timeUnits can be handled as well.  
		var Clazz = Dimension;
		if (oProps.type === "Edm.DateTime" && oProps['sap:display-format'] === "Date") {
			//TODO: sap:display-format is V2 annotation, use V4 style when annotation translation is ready
			Clazz = TimeDimension;
			oConfig.timeUnit = TimeUnitType.Date;
		} else if (oProps.type === "Edm.String" && TimeUnitType[oProps['sap:semantics']]) {
			//TODO: sap:semantics is V2 annotation, use V4 style when annotation translation is ready
			Clazz = TimeDimension;
			oConfig.timeUnit = oProps['sap:semantics'];
		}

		return Clazz;
	}

	var _ANALYTICAL = {
		getEntitySet: getEntitySet.bind(null, true),
		deriveColumns: function(oModel, oBindingInfo) {
			var oResult = oModel.getAnalyticalExtensions().findQueryResultByName(_ANALYTICAL.getEntitySet(oBindingInfo));
			if (!oResult) {
				throw new Error("value of the \"isAnalytical\" property does not match the Data Service in use");
			}
			var sResultType = oResult.getEntityType().getQName();
			sResultType = sResultType.slice(sResultType.lastIndexOf(".") + 1);
			var sResultSchemaNamespace = oResult.getEntityType().getSchema().namespace;

			var fnMakeDim = _ANALYTICAL.makeDimension.bind(this, sResultType, sResultSchemaNamespace, oResult);
			var fnMakeMsr = _ANALYTICAL.makeMeasure.bind(this, sResultType);

			return {
				dimensions: jQuery.map(oResult.getAllDimensions(), fnMakeDim),
				measures: jQuery.map(oResult.getAllMeasures(), fnMakeMsr)
			};
		},
		makeDimension: function(sResultType, sResultSchemaNamespace, oResult, oDimension) {
			var sDimName = oDimension.getName();
			var oConfig = {
				name: sDimName,
				label: _bindingSyntax(sResultType, sDimName, "label"),
				textProperty: _bindingSyntax(sResultType, sDimName, "text")
			};

			var sAnnotationAccess = _ANALYTICAL.ANNOTATION_ACCESS_TEMPLATE
					.replace(/%SCHEMANS/, sResultSchemaNamespace)
					.replace(/%RESULTTYPE/, sResultType)
					.replace(/%DIMENSION/, sDimName);

			var oUnifiedDimensionProperties = oResult.getModel().getODataModel().getMetaModel().getProperty(sAnnotationAccess);

			var Clazz = detectDimension(oUnifiedDimensionProperties, oConfig);

			return new Clazz(oConfig);
		},
		makeMeasure: function(sResultType, oMeasure) {
			return new Measure({
				name: oMeasure.getName(),
				label: _bindingSyntax(sResultType, oMeasure.getName(), "label")
			});
		},
		updateModel: function(oChart) {
			function createDimAnalyticalInfos(oDim, bInResult, bInVisible) {
				var sTextProperty = oDim.getTextProperty(),
					aInfos = [{ name: oDim.getName(), grouped: false, inResult: !!bInResult, visible: !bInVisible }];
				if (oDim.getDisplayText() && sTextProperty) {
					aInfos.push({ name: sTextProperty, grouped: false, inResult: !!bInResult, visible: !bInVisible });
				}
				return aInfos;
			}

			function createMsrAnalyticalInfos(oMsr) {
				var sUnitBinding = oMsr.getUnitBinding(),
					aInfos = [{ name: oMsr.getName(), total: false, inResult: false, visible: true }];
				if (sUnitBinding) {
					aInfos.push({ name: sUnitBinding, total: false, inResult: false, visible: true });
				}
				return aInfos;
			}

			var oBinding = oChart.getBinding("data");
			if (!oBinding) {
				return;
			}

			var aDims = oChart._getVisibleDimensions(true);
			var aMsrs = oChart._getVisibleMeasures(true);
			var aInResultDims = oChart._normalizeDorM(oChart.getInResultDimensions(), true);

			var aInfos = aDims.reduce(function(aInfos, oDim) {
				return aInfos.concat(createDimAnalyticalInfos(oDim));
			}, []).concat(aInResultDims.reduce(function(aInfos, oDim) {
				return aInfos.concat(createDimAnalyticalInfos(oDim, true, true));
			}, [])).concat(aMsrs.reduce(function(aInfos, oMsr) {
				return aInfos.concat(createMsrAnalyticalInfos(oMsr));
			}, []));

			var oCandidateColoringSetting = oChart._getCandidateColoringSetting();
			var oColoringAdditionalMsrs = oCandidateColoringSetting.additionalMeasures || [];
			var oColoringAdditionalDims = oCandidateColoringSetting.additionalDimensions || [];
			if (oColoringAdditionalMsrs.length) {
				aInfos = aInfos.concat(oChart._normalizeDorM(oColoringAdditionalMsrs).reduce(function(aInfo, oMsr) {
					return aInfo.concat(createMsrAnalyticalInfos(oMsr));
				}, []));
			}
			if (oColoringAdditionalDims.length) {
				aInfos = aInfos.concat(oChart._normalizeDorM(oColoringAdditionalDims, true).reduce(function(aInfo, oDim) {
					return aInfo.concat(createDimAnalyticalInfos(oDim));
				}, []));
			}

			oBinding.updateAnalyticalInfo(aInfos);
		},
		ANNOTATION_ACCESS_TEMPLATE: "/dataServices/schema/[${" +
			// ${xxx} will be interpolated by UI5 compiler, so we have to break all these annotations into separate strings
			"namespace" + "}==='%SCHEMANS']/entityType/[${" +
			"name" + "}==='%RESULTTYPE']/property/[${" +
			"name" + "}==='%DIMENSION']/"
	};

	var _NON_ANALYTICAL = {
		getEntitySet: getEntitySet.bind(null, false),
		deriveColumns: function(oModel, oBindingInfo) {
			var oMetaModel = oModel.getMetaModel(),
				mColumns = {dimensions: [], measures: []};
			if (oMetaModel) {
				var sQNameEntityType = oMetaModel.getODataEntitySet(_NON_ANALYTICAL.getEntitySet(oBindingInfo)).entityType;
				var oEntityType = oMetaModel.getODataEntityType(sQNameEntityType);

				jQuery.each(oEntityType.property, function(i, oProp) {
					var ColumnClazz = _NON_ANALYTICAL.CLAZZ[oProp.type];
					if (!ColumnClazz) {
						throw new Error("Unsupported type: " + oProp.type);
					}
					var oConfig = { name: oProp.name };
					if (oProp.hasOwnProperty("sap:label")) {
						oConfig.label = oProp["sap:label"];
					}

					if (ColumnClazz === Measure) {
						mColumns.measures.push(new ColumnClazz(oConfig));
					} else {
						if (oProp.hasOwnProperty("sap:text")) {
							oConfig.textProperty = oProp["sap:text"];
						}

						ColumnClazz = detectDimension(oProp, oConfig);
						mColumns.dimensions.push(new ColumnClazz(oConfig));
					}
				});
			}

			return mColumns;
		},
		CLAZZ: {
			"Null": Dimension,
			"Edm.Binary": Dimension,
			"Edm.Boolean": Dimension,
			"Edm.Byte": Measure,
			"Edm.DateTime": Dimension,
			"Edm.Decimal": Measure,
			"Edm.Double": Measure,
			"Edm.Single": Measure,
			"Edm.Guid": Dimension,
			"Edm.Int16": Measure,
			"Edm.Int32": Measure,
			"Edm.Int64": Measure,
			"Edm.SByte": Measure,
			"Edm.String": Dimension,
			"Edm.Time": Dimension,
			"Edm.DateTimeOffset": Dimension
		},
		updateModel: function(oChart, aDimensions, aMeasures) {
			if (oChart.getModel() instanceof sap.ui.model.odata.ODataModel) {
				var aDimColumns = aDimensions.reduce(function(aDimColumns, oDim) {
					if (oDim.getTextProperty()) {
						return aDimColumns.concat(oDim.getName(), oDim.getTextProperty());
					} else {
						return aDimColumns.concat(oDim.getName());
					}
				}, []);
				var aMsrColumns = aMeasures.reduce(function(aMsrColumns, oMsr) {
					if (oMsr.getUnitBinding()) {
						return aMsrColumns.concat(oMsr.getName(), oMsr.getUnitBinding());
					} else {
						return aMsrColumns.concat(oMsr.getName());
					}
				}, []);

				//TODO: use cached bindingInfo here and rebindData, consider move this logic to bindAggregation
				oChart._oBindingInfo.parameters = oChart._oBindingInfo.parameters || {};
				oChart._oBindingInfo.parameters.entitySet = _NON_ANALYTICAL.getEntitySet(oChart._oBindingInfo);
				oChart._oBindingInfo.parameters.select = aDimColumns.concat(aMsrColumns).join(",");
				oChart.bindData(oChart._oBindingInfo);
				if (oChart._isEnablePaging() && oChart._getPagingController().getPagingSorters()) {
					oChart.getBinding("data").sort(oChart._getPagingController().getPagingSorters());
				}
			} else {
				return;
			}
		}
	};

	function impl(methodName) {
		return function(bIsAnalytical) {
			var implementation = bIsAnalytical ? _ANALYTICAL : _NON_ANALYTICAL;
			return implementation[methodName];
		};
	}

	return {
		deriveColumns: impl("deriveColumns"),
		updateModel: impl("updateModel"),
		getEntitySet: impl("getEntitySet")
	};
});

}; // end of sap/chart/utils/DataSourceUtils.js
if ( !jQuery.sap.isDeclared('sap.chart.coloring.ColoringUtils') ) {
jQuery.sap.declare('sap.chart.coloring.ColoringUtils'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/coloring/ColoringUtils",[
	'sap/chart/ChartLog',
	'sap/chart/data/TimeDimension'
], function(
	ChartLog,
	TimeDimension
) {
	"use strict";
	var type = jQuery.type;

	var Util = {};
	Util.find = function(sMsrName, aList) {
		for (var i = 0; i < aList.length; i++) {
			if (sMsrName === aList[i].getName()) {
				return aList[i];
			}
		}
		return null;
	};

	Util.isNumber = function() {
		for (var i = 0; i < arguments.length; i++) {
			if (type(arguments[i]) !== 'number') {
				return false;
			}
		}
		return true;
	};

	Util.thresholdValue = function(values) {
		values = values.filter(function(e){
			return values != null;
		});

		var bString = values.map(function(e){
			return type(e) === "string";
		});

		return function (oCtx, oAdditionCtx) {
			for (var ii = 0; ii < values.length; ii++) {
				var result;
				if (bString[ii]) {
					// use addition context when threshold is in visible measures in order to differeniate:
					//    1. coloring measure which refers to threshold measure
					//    2. unmentioned threshold measure
					if (oCtx[values[ii]] != null) {
						result = oCtx[values[ii]];
					} else {
						result = oAdditionCtx[values[ii]];
					}				
				} else {
					result = values[ii];
				}
				if (result != null) {
					return result;
				}
			}
		};
	};

	Util.isInRange = function(val, lo, hi, loInclusive, hiInclusive) {
		if (!Util.isNumber(val, lo, hi)) {
			return false;
		}
		var loTest = loInclusive ? (lo <= val) : (lo < val);
		var hiTest = hiInclusive ? (val <= hi) : (val < hi);

		return loTest && hiTest;
	};

	Util.assignColor = function(aColors, iLvls) {
		switch (iLvls) {
			case 1:
				return [aColors[3]];
			case 2:
				return [aColors[1], aColors[3]];
			case 3:
				return [aColors[1], aColors[3], aColors[5]];
			case 4:
				return aColors.slice(1, 5);
			case 5:
				return aColors.slice(1, 6);
			case 6:
				return aColors.slice(0, 6);
			default:
				return null;
		}
	};

	Util.assignUnmentionedColor = function(aColors, iLvls) {
		switch (iLvls) {
			case 1:
				return [aColors[1]];
			case 2:
				return [aColors[1], aColors[5]];
			case 3:
				return [aColors[1], aColors[2], aColors[4]];
			case 4:
				return [aColors[1], aColors[2], aColors[4], aColors[5]];
			case 5:
			    return aColors.filter(function(idx) {
				    return idx !== 3;
			    });
			default:
				return null;
		}
	};

	Util.dimOrMsrUse = function(oColorings, oParams, oDimMsr, supportedType){
		var	type = Object.keys(oColorings).filter(function(sType) {
				return supportedType.indexOf(sType) > -1;
		});
		if (oParams.dimension && oParams.measure) {
			//clid5
			throw new ChartLog('error', 'activeColoring', 'Either "dimension" or "measure" can be set in activeColoring.parameters, but not both of them.');
		} else if (oParams.measure) {
			type = 'MeasureValues';
		} else if (oParams.dimension) {
			type = 'DimensionValues';
		} else if (type.length > 1) {
			//clid6
			throw new ChartLog('error', 'colorings.Criticality', 'Both "MeasureValues" and "DimensionValues" exist in Criticality, please resolve by activeColoring property.');
		} else if (type.length === 1) {
			type = type[0];
		}
		return type;
	};

	var _notIn = function(src, des, errorType, prefix, postfix) {
		src.forEach(function(value){
			if (des.indexOf(value) < 0) {
				throw new ChartLog('error', errorType, prefix + value + postfix);
			}
		});
	};

	var checkVisibleMsr = function(measure, aMsr) {
		var aVisibleMsr = aMsr.map(function(oMsr){
			return oMsr.getName();
		});
		//clid7
		_notIn(measure, aVisibleMsr, 'activeColoring.parameters.measure', 'Active measure, ', ', should be visible.');
	};

	var checkVisibleDim = function(dimension, aDim) {
		var aVisibleDim = aDim.map(function(oDim){
			return oDim.getName();
		});
		//clid9
		_notIn(dimension, aVisibleDim, 'activeColoring.parameters.dimension', 'Active dimension, ', ', should be visible.');
	};

	var msrConfig = function(measure, coloringMsr) {
		var measureValue = Object.keys(coloringMsr);
		//clid8
		_notIn(measure, measureValue, 'activeColoring.parameters.measure', 'Active measure, ', ', should be configured in coloring.');
	};

	var dimConfig = function(dimension, coloringDim) {
		var dimensionValue = Object.keys(coloringDim);
		//clid11
		_notIn(dimension, dimensionValue, 'activeColoring.parameters.dimension', 'Active dimension, ', ', should be configured in coloring.');
	};

	var multipleDim = function(dimension){
		if (dimension.length > 1) {
			//clid10
			throw new ChartLog('error', 'activeColoring.parameters.dimension', 'Multiple dimensions are defined. Please resolve by activeColoring property.');
		}
	};

	var timeDim = function(dimension, aVisibleDimension, type){
		var oDim = Util.find(dimension, aVisibleDimension);
		if (oDim instanceof TimeDimension && oDim.getRole() === 'category') {
			//clid27&&clid28
			throw new ChartLog('error', 'Colorings.' + type + '.DimensionValues', 'Do not support coloring on timeDimension, ' + oDim.getName() + '.');
		}
	};

	var isHeatmap = function(options) {
		if (options.bMBC) {
			//clid29
			throw new ChartLog('error', 'Colorings', 'Heatmap only support Criticality.MeasureValues.ConstantThresholds.');
		}
	};

	var hasColoring = function(oDimMsr, options) {
		if (!options.bWaterfall && ((options.bShowUnmentionedMsr && oDimMsr.aMsr.length > 1) || options.bHasOtherSeriesDim || 
			options.bIsPie && oDimMsr.aDim.length > 1)){
			//clid22
			throw new ChartLog('error', 'Colorings.' + options.type + '.DimensionValues', 
				'Semantic coloring could not be applied if chart already has coloring.');
		}
	};

	Util.checkColoringDimension = function(aActiveDimension, oDimMsr, aColoringDimension, options) {
		var aVisibleDimension = oDimMsr.aDim;
		checkVisibleDim(aActiveDimension, aVisibleDimension);
		dimConfig(aActiveDimension, aColoringDimension);
		multipleDim(aActiveDimension);
		timeDim(aActiveDimension[0], aVisibleDimension, options.type);
		isHeatmap(options);
		hasColoring(oDimMsr, options);
	};

	Util.checkColoringMeasure = function(aActiveMeasure, aVisibleMeasure, aColoringMeasure) {
		checkVisibleMsr(aActiveMeasure, aVisibleMeasure);
		msrConfig(aActiveMeasure, aColoringMeasure);
	};

	Util.notIn = _notIn;

	return Util;
});

}; // end of sap/chart/coloring/ColoringUtils.js
if ( !jQuery.sap.isDeclared('sap.chart.coloring.criticality.DimensionValues') ) {
jQuery.sap.declare('sap.chart.coloring.criticality.DimensionValues'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/coloring/criticality/DimensionValues",[
	'sap/chart/coloring/ColoringUtils',
	'sap/chart/ChartLog',
	'sap/chart/data/TimeDimension',
	'sap/chart/coloring/CriticalityType'
], function(
	ColoringUtils,
	ChartLog,
	TimeDimension,
	CriticalityType
) {
	"use strict";
	var type = jQuery.type;

	var Dim = {};

	var validate = function(aColoringDimension, aActiveDimension, oDimMsr, options) {
		var tempOpt = jQuery.extend({}, options),
			bHasOtherSeriesDim = oDimMsr.aDim.some(function(oDim) {
				return oDim._getFixedRole() === "series" && oDim.getName() !== aActiveDimension[0];
			});
		tempOpt.bHasOtherSeriesDim = bHasOtherSeriesDim;
		tempOpt.type = 'Criticality';
		ColoringUtils.checkColoringDimension(aActiveDimension, oDimMsr, aColoringDimension, tempOpt);
		var dimensionColoring = aColoringDimension[aActiveDimension[0]],
			categorys = Object.keys(dimensionColoring),
			oActiveDimension = ColoringUtils.find(aActiveDimension[0], oDimMsr.aDim),
			bIsSeriesBased = oActiveDimension.getRole() === 'series' ? true : false;
		categorys.forEach(function(category){
			var values = dimensionColoring[category].Values,
				legend = dimensionColoring[category].Legend;
			values = type(values) === 'array' ? values : [values];
			if (values.length > 1 && !legend) {
				//clid17
				throw new ChartLog('error', 'Colorings.Criticality.DimensionValues', 'Legend is mandatory when one criticality type has multiple values.');
			}
			if ((bIsSeriesBased || options.bIsPie) && values.length > 1) {
				//clid20
				throw new ChartLog('error', 'Colorings.Criticality.DimensionValues', 'Criticality on Series Dimension, only single value could be assigned to each CriticalityType.');
			}
		});
	};

	Dim.qualify = function(oConfig, activeDimension, oDimMsr, options) {
		validate(oConfig, activeDimension, oDimMsr, options);
		var sDimName = activeDimension[0], oCandidateSetting;
		if (sDimName) {
			oCandidateSetting = {
				dim: sDimName,
				setting: oConfig
			};
		}
		return oCandidateSetting;
	};

	Dim.parse = function(oConfig, aDim, oStatus, oLocale, options) {
		var oSetting = {},
			oLegend = {},
			sDimName = oConfig.dim,
			aCriticalityValues = [],
			oDimConfig = oConfig.setting[sDimName],
			aNeutralValues = [];

		jQuery.each(oDimConfig, function(key, val) {
			var alevels = (type(val) !== "array") ? [val] : val;
			if (key !== CriticalityType.Neutral) {
				oSetting[key] = alevels.map(function(level) {
					return (type(level.Values) === "array") ? level.Values : [level.Values];
				});
				aCriticalityValues = Array.prototype.concat.apply(aCriticalityValues, oSetting[key]);
			}
			oLegend[key] = alevels.map(function(level) {
				var sVal = (type(level.Values) === "array") ? level.Values[0] : level.Values;
				var sLegend = (level.Legend != null) ? level.Legend : sVal;
				return sLegend;
			});
		});

		if (oDimConfig.Neutral) {
			aNeutralValues = (type(oDimConfig.Neutral.Values) === "array") ? oDimConfig.Neutral.Values : [oDimConfig.Neutral.Values];
		}

		var fnNeutralCb = function (oCtx) {
			return aCriticalityValues.indexOf(oCtx[sDimName]) === -1;
		};

		function genChecker(aValues) {
			return function(oCtx) {
				return aValues.indexOf(oCtx[sDimName]) !== -1;
			};
		}
		var mCallbacks = {
			Negative: (oSetting.Negative || []).map(genChecker),
			Critical: (oSetting.Critical || []).map(genChecker),
			Positive: (oSetting.Positive || []).map(genChecker),
			Neutral: [fnNeutralCb]
		};

		return {
			callbacks: mCallbacks,
			legend: oLegend,
			aCriticalityValues: aCriticalityValues.concat(aNeutralValues),
			status: oStatus
		};
	};

	Dim.getContextHandler = function(oCandidateSetting, oLocale, options) {
		var sDim = oCandidateSetting.dim,
			aCriticalityValues = oCandidateSetting.parsed.aCriticalityValues;

		return function(oContext) {
			var sVal = oContext.getProperty(sDim),
				oCriticalityDim = this.getDimensionByName(sDim);
			if (aCriticalityValues.indexOf(sVal) === -1 ) {
				if (oCriticalityDim._getFixedRole() === "series" || options.bIsPie) {
					//clid21
					var oChartLog = new ChartLog('error', 'Colorings.Criticality.DimensionValues', 'Criticality on Series Dimension, all series must be applied coloring.');
					oCandidateSetting.chartLog = oChartLog;
				} else {
					oCandidateSetting.parsed.legend.Neutral = oLocale.getText("COLORING_TYPE_OTHER");
				}
			}
		};
	};

	return Dim;
});

}; // end of sap/chart/coloring/criticality/DimensionValues.js
if ( !jQuery.sap.isDeclared('sap.chart.coloring.criticality.measureValues.ThresholdsUtils') ) {
jQuery.sap.declare('sap.chart.coloring.criticality.measureValues.ThresholdsUtils'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/coloring/criticality/measureValues/ThresholdsUtils",[
	'sap/chart/coloring/ColoringUtils',
	'sap/chart/coloring/CriticalityType',
	'sap/chart/ChartLog'
], function(
	ColoringUtils,
	CriticalityType,
	ChartLog
) {
	"use strict";
	var Thresholds = {};

	var Msr = {
		formulas: {}
	};

	var NEGATIVE = CriticalityType.Negative;
	var CRITICAL = CriticalityType.Critical;
	var POSITIVE = CriticalityType.Positive;
	var NEUTRAL = CriticalityType.Neutral;

	function genSegment(iUpperBound, sCriticalityType, iLvl) {
		return {
			upperBound: iUpperBound,
			CriticalityType: sCriticalityType
		};
	}

	Thresholds.fillOmit = function(oAcpRange, oTolRange, oDevRange){
		// Thresholds are optional. For unassigned values, defaults are determined in this order:
		oDevRange.hi = (oDevRange.hi == undefined) ? Number.POSITIVE_INFINITY : oDevRange.hi;
		oDevRange.lo = (oDevRange.lo == undefined) ? Number.NEGATIVE_INFINITY : oDevRange.lo;
		oTolRange.hi = (oTolRange.hi == undefined) ? oDevRange.hi : oTolRange.hi;
		oTolRange.lo = (oTolRange.lo == undefined) ? oDevRange.lo : oTolRange.lo;
		oAcpRange.hi = (oAcpRange.hi == undefined) ? oTolRange.hi : oAcpRange.hi;
		oAcpRange.lo = (oAcpRange.lo == undefined) ? oTolRange.lo : oAcpRange.lo;
	};

	Thresholds.checkThreshold = function(sDir, oAcpRange, oTolRange, oDevRange, bConstant) {
		var bCorrect;
		var loIsNum = ColoringUtils.isNumber(oAcpRange.lo, oDevRange.lo, oTolRange.lo);
		var hiIsNum = ColoringUtils.isNumber(oAcpRange.hi, oTolRange.hi, oDevRange.hi);

		switch (sDir) {
			case 'maximize':
				bCorrect = loIsNum && (oDevRange.lo <= oTolRange.lo && oTolRange.lo <= oAcpRange.lo);
				break;
			case 'minimize':
				bCorrect = hiIsNum && (oAcpRange.hi <= oTolRange.hi && oTolRange.hi <= oDevRange.hi);
				break;
			case 'target':
				bCorrect = (loIsNum && hiIsNum) && 
					(oDevRange.lo <= oTolRange.lo) && (oTolRange.lo <= oTolRange.hi) && (oTolRange.hi <= oDevRange.hi) && 
					(oTolRange.lo <= oAcpRange.lo) && (oAcpRange.lo <= oAcpRange.hi) && (oAcpRange.hi <= oTolRange.hi);
				break;
			default:
		}

		if (!bCorrect) {
			//clid17
			var name = bConstant ? "ConstantThresholds" : "DynamicThresholds";
			throw new ChartLog('error', 'Colorings.Criticality.' + name,  'Invalid Thresholds settings.');
		}
	};

	Thresholds.MBCimprovement = function(sDir, oAcpRange, oTolRange, oDevRange) {
		var devHi = oDevRange.hi;
        var devLo = oDevRange.lo;
        var tolHi = oTolRange.hi;
        var tolLo = oTolRange.lo;
        var acpHi = oAcpRange.hi;
        var acpLo = oAcpRange.lo; 
		var aSegments = [];
		var aBoundaryOrder, aCriticalityOrder;
		switch (sDir) {
			case 'maximize':
				aBoundaryOrder = [devLo, tolLo, acpLo, Number.POSITIVE_INFINITY];
				aCriticalityOrder = [NEGATIVE, CRITICAL, NEUTRAL, POSITIVE];
				break;
			case 'minimize':
				aBoundaryOrder = [acpHi, tolHi, devHi, Number.POSITIVE_INFINITY];
				aCriticalityOrder = [POSITIVE, NEUTRAL, CRITICAL, NEGATIVE];
				break;
			case 'target':
				aBoundaryOrder = [devLo, tolLo, acpLo, acpHi, tolHi, devHi, Number.POSITIVE_INFINITY];
				aCriticalityOrder = [NEGATIVE, CRITICAL, NEUTRAL, POSITIVE, NEUTRAL, CRITICAL, NEGATIVE];
				break;
			default:
				throw new Error('Unsupported ImprovementDirection: ' + sDir);
		}

		//remove 0 section
		var removeIndexArray = [];
		switch (sDir) {
			case 'maximize':
				//dev -> tol -> acp
				removeIndexArray[0] = (devLo === -Infinity);
				removeIndexArray[1] = (devLo === tolLo);
				removeIndexArray[2] = (tolLo === acpLo);
				removeIndexArray[3] = (acpLo === Infinity);
				break;
			case 'minimize':
				//dev -> tol -> acp
				removeIndexArray[0] = (acpHi === -Infinity);
				removeIndexArray[1] = (acpHi === tolHi);
				removeIndexArray[2] = (tolHi === devHi);
				removeIndexArray[3] = (devHi === Infinity);
				break;
			case 'target':
				//dev -> tol -> acp <- acp <-tol <- dev
				removeIndexArray[0] = (devLo === -Infinity);
				removeIndexArray[1] = (devLo === tolLo);
				removeIndexArray[2] = (tolLo === acpLo);
				removeIndexArray[3] = (acpLo === acpHi); 
				removeIndexArray[4] = (acpHi === tolHi);
				removeIndexArray[5] = (tolHi === devHi);
				removeIndexArray[6] = (devHi === Infinity);
				break;
			default:
				throw new Error('Unsupported ImprovementDirection: ' + sDir);
		}


		aBoundaryOrder = aBoundaryOrder.filter(function(e, index){
			return !removeIndexArray[index];
		});
		aCriticalityOrder = aCriticalityOrder.filter(function(e, index){
			return !removeIndexArray[index];
		});

		aSegments = aCriticalityOrder.map(function(sCriticalityType, index) {
			return genSegment(aBoundaryOrder[index], sCriticalityType, 0);
		});
		return {
			segments: aSegments,
			min: Number.POSITIVE_INFINITY,
			max: Number.NEGATIVE_INFINITY
		};
	};

	//decorate function
	function dec(fn){
		return [function(oCtx, additionCtx) {
					return fn(oCtx, additionCtx);
				}];
	}

	Thresholds.improvement = function(sDir, sMsr, oAcpRange, oTolRange, oDevRange) {
		var devHi = oDevRange.hi;
        var devLo = oDevRange.lo;
        var tolHi = oTolRange.hi;
        var tolLo = oTolRange.lo;
        var acpHi = oAcpRange.hi;
        var acpLo = oAcpRange.lo; 

        //pass alternative value for dynamic threshold
        //will be used when value is omitted
		var devHiFn = ColoringUtils.thresholdValue([devHi, Number.POSITIVE_INFINITY]);
		var devLoFn = ColoringUtils.thresholdValue([devLo, Number.NEGATIVE_INFINITY]);
		var tolHiFn = ColoringUtils.thresholdValue([tolHi, devHi, Number.POSITIVE_INFINITY]);
		var tolLoFn = ColoringUtils.thresholdValue([tolLo, devLo, Number.NEGATIVE_INFINITY]);
		var acpHiFn = ColoringUtils.thresholdValue([acpHi, tolHi, devHi, Number.POSITIVE_INFINITY]);
		var acpLoFn = ColoringUtils.thresholdValue([acpLo, tolLo, devLo, Number.NEGATIVE_INFINITY]);

		var result = {};

		switch (sDir) {
			case 'maximize':
				//dev -> tol -> acp
				result["Negative"] = (devLo == -Infinity) ? null : dec(Msr.formulas.maximize.negative(sMsr, devLoFn));
				result["Critical"] = (devLo == tolLo) ? null : dec(Msr.formulas.maximize.critical(sMsr, devLoFn, tolLoFn));
				result["Neutral"] = ( tolLo == acpLo) ? null : dec(Msr.formulas.maximize.critical(sMsr, tolLoFn, acpLoFn));
				result["Positive"] = (acpLo == Infinity) ? null : dec(Msr.formulas.maximize.positive(sMsr, acpLoFn));
				break;
			case 'minimize':
				//dev -> tol -> acp
				result["Negative"] = (devHi == Infinity) ? null : dec(Msr.formulas.minimize.negative(sMsr, devHiFn));
				result["Critical"] = (tolHi == devHi) ? null : dec(Msr.formulas.minimize.critical(sMsr, tolHiFn, devHiFn));
				result["Neutral"] = (acpHi == tolHi) ? null : dec(Msr.formulas.minimize.neutral(sMsr, acpHiFn, tolHiFn));
				result["Positive"] = (acpHi == -Infinity) ? null : dec(Msr.formulas.minimize.positive(sMsr, acpHiFn));
				break;
			case 'target':
				//dev -> tol -> acp <- acp <-tol <- dev
				result["Negative"] = (devLo == -Infinity && devHi === Infinity) ? null : dec(Msr.formulas.target.negative(sMsr, devLoFn, devHiFn));
				result["Critical"] = (devLo == tolLo && tolHi == devHi) ? null : dec(Msr.formulas.target.critical(sMsr, devLoFn, tolLoFn, tolHiFn, devHiFn));
				result["Neutral"] = (tolLo == acpLo && acpHi == tolHi) ? null : dec(Msr.formulas.target.neutral(sMsr, tolLoFn, acpLoFn, acpHiFn, tolHiFn));
				// acpLo <= m <= acpHi, the range can be one single number 
				result["Positive"] = dec(Msr.formulas.target.positive(sMsr, acpLoFn, acpHiFn));
				break;
			default:
				throw new Error('Unsupported ImprovementDirection: ' + sDir);
		}

		return result;
	};

	Msr.formulas.maximize = {
		negative: function(sMsrName, fnDevLo) {
			return function(oCtx, oAdditionCtx) {
				var nVal = oCtx[sMsrName];
				var nHi = fnDevLo(oCtx, oAdditionCtx);
				return ColoringUtils.isInRange(nVal, Number.NEGATIVE_INFINITY, nHi, null, false);
			};
		},
		critical: function(sMsrName, fnDevLo, fnTolLo) {
			return function(oCtx, oAdditionCtx) {
				var nVal = oCtx[sMsrName];
				var nLo = fnDevLo(oCtx, oAdditionCtx);
				var nHi = fnTolLo(oCtx, oAdditionCtx);

				return ColoringUtils.isInRange(nVal, nLo, nHi, true, false);
			};
		},

		neutral: function(sMsrName, fnTolLo, fnAcpLo) {
			return function(oCtx, oAdditionCtx) {
				var nVal = oCtx[sMsrName];
				var nLo = fnTolLo(oCtx, oAdditionCtx);
				var nHi = fnAcpLo(oCtx, oAdditionCtx);
				return ColoringUtils.isInRange(nVal, nLo, nHi, true, false);
			};
		},

		positive: function(sMsrName, fnAcpLo) {
			return function(oCtx, oAdditionCtx) {
				var nVal = oCtx[sMsrName];
				var nLo = fnAcpLo(oCtx, oAdditionCtx);
				return ColoringUtils.isInRange(nVal, nLo, Number.POSITIVE_INFINITY, true);
			};
		}
	};

	Msr.formulas.minimize = {
		negative: function(sMsrName, fnDevHi) {
			return function(oCtx, oAdditionCtx) {
				var nVal = oCtx[sMsrName];
				var nLo = fnDevHi(oCtx, oAdditionCtx);
				return ColoringUtils.isInRange(nVal, nLo, Number.POSITIVE_INFINITY, false);
			};
		},
		critical: function(sMsrName, fnTolHi, fnDevHi) {
			return function(oCtx, oAdditionCtx) {
				var nVal = oCtx[sMsrName];
				var nLo = fnTolHi(oCtx, oAdditionCtx);
				var nHi = fnDevHi(oCtx, oAdditionCtx);
				return ColoringUtils.isInRange(nVal, nLo, nHi, false, true);
			};
		},
		neutral: function(sMsrName, fnAcpHi, fnTolHi) {
			return function(oCtx, oAdditionCtx) {
				var nVal = oCtx[sMsrName];
				var nLo = fnAcpHi(oCtx, oAdditionCtx);
				var nHi = fnTolHi(oCtx, oAdditionCtx);
				return ColoringUtils.isInRange(nVal, nLo, nHi, false, true);
			};
		},
		positive: function(sMsrName, fnAcpHi) {
			return function(oCtx, oAdditionCtx) {
				var nVal = oCtx[sMsrName];
				var nHi = fnAcpHi(oCtx, oAdditionCtx);
				return ColoringUtils.isInRange(nVal, Number.NEGATIVE_INFINITY, nHi, null, true);
			};
		}
	};

	Msr.formulas.target = {
		negative: function(sMsrName, fnDevLo, fnDevHi) {
			return function(oCtx, oAdditionCtx) {
				var nVal = oCtx[sMsrName];
				var nLeftHi = fnDevLo(oCtx, oAdditionCtx);
				var nRightLo = fnDevHi(oCtx, oAdditionCtx);

				var inLeft = ColoringUtils.isInRange(nVal, Number.NEGATIVE_INFINITY, nLeftHi, null, false);
				var inRight = ColoringUtils.isInRange(nVal, nRightLo, Number.POSITIVE_INFINITY, false);
				return inLeft || inRight;
			};
		},
		critical: function(sMsrName, fnDevLo, fnTolLo, fnTolHi, fnDevHi) {
			return function(oCtx, oAdditionCtx) {
				var nVal = oCtx[sMsrName];
				var nLeftLo = fnDevLo(oCtx, oAdditionCtx),
					nLeftHi = fnTolLo(oCtx, oAdditionCtx);
				var nRightLo = fnTolHi(oCtx, oAdditionCtx),
					nRightHi = fnDevHi(oCtx, oAdditionCtx);

				var inLeft = ColoringUtils.isInRange(nVal, nLeftLo, nLeftHi, true, false);
				var inRight = ColoringUtils.isInRange(nVal, nRightLo, nRightHi, false, true);

				return inLeft || inRight;
			};
		},
		neutral: function(sMsrName, fnTolLo, fnAcpLo, fnAcpHi, fnTolHi) {
			return function(oCtx, oAdditionCtx) {
				var nVal = oCtx[sMsrName];
				var nLeftLo = fnTolLo(oCtx, oAdditionCtx),
					nLeftHi = fnAcpLo(oCtx, oAdditionCtx);
				var nRightLo = fnAcpHi(oCtx, oAdditionCtx),
					nRightHi = fnTolHi(oCtx, oAdditionCtx);

				var inLeft = ColoringUtils.isInRange(nVal, nLeftLo, nLeftHi, true, false);
				var inRight = ColoringUtils.isInRange(nVal, nRightLo, nRightHi, false, true);

				return inLeft || inRight;
			};
		},
		positive: function(sMsrName, fnAcpLo, fnAcpHi) {
			return function(oCtx, oAdditionCtx) {
				var nVal = oCtx[sMsrName];
				var nLo = fnAcpLo(oCtx, oAdditionCtx);
				var nHi = fnAcpHi(oCtx, oAdditionCtx);

				return ColoringUtils.isInRange(nVal, nLo, nHi, true, true);
			};
		}
	};

	return Thresholds;
});
}; // end of sap/chart/coloring/criticality/measureValues/ThresholdsUtils.js
if ( !jQuery.sap.isDeclared('sap.chart.coloring.emphasis.DimensionValues') ) {
jQuery.sap.declare('sap.chart.coloring.emphasis.DimensionValues'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/coloring/emphasis/DimensionValues",[
	'sap/chart/coloring/ColoringUtils',
	'sap/chart/coloring/criticality/DimensionValues',
	'sap/chart/ChartLog'
], function(
	ColoringUtils,
	DimensionValues,
	ChartLog
) {
	"use strict";
	var type = jQuery.type;
	
	var Dim = {};

	var validate = function(aColoringDimension, aActiveDimension, oDimMsr, options) {
		var tempOpt = jQuery.extend({}, options);
		tempOpt.bHasOtherSeriesDim = oDimMsr.aDim.some(function(oDim) {
			return oDim._getFixedRole() === "series" && oDim.getName() !== aActiveDimension[0];
		});
		tempOpt.type = 'Emphasis';
		ColoringUtils.checkColoringDimension(aActiveDimension, oDimMsr, aColoringDimension, tempOpt);
		var dimensionColoring = aColoringDimension[aActiveDimension[0]],
			values = dimensionColoring.Values,
			legend = dimensionColoring.Legend || {};
		if (values.length > 1 && !legend.Highlighted) {
			//clid18
			throw new ChartLog('error', 'Colorings.Emphasis.DimensionValues', 'Legend.Highlighted is mandatory when Highlight has multiple values.');
		}
	};

	Dim.qualify = function(oConfig, activeDimension, oDimMsr, options) {
		validate(oConfig, activeDimension, oDimMsr, options);
		var oCandidateSetting;
		if (activeDimension[0]) {
			oCandidateSetting = {
				dim: activeDimension[0],
				setting: oConfig
			};
		}
		return oCandidateSetting;
	};

	Dim.parse = function(oConfig, oLocale) {
		var oLegend = {},
			sDimName = oConfig.dim,
			oDimConfig = oConfig.setting[sDimName],
			values = oDimConfig.Values;
		var aHighlightedValues = (type(values) === "array") ? values : [values];
		var fnHightlightCb = function (oCtx) {
			return aHighlightedValues.indexOf(oCtx[sDimName]) > -1;
		};

		if (oDimConfig.Legend && oDimConfig.Legend.Highlighted != null) {
			oLegend.Highlight = oDimConfig.Legend.Highlighted;
		} else {
			oLegend.Highlight = aHighlightedValues[0];
		}
		if (oDimConfig.Legend && oDimConfig.Legend.Others) {
			oLegend.Others = oDimConfig.Legend.Others;
		} else {
			oLegend.Others = oLocale.getText("COLORING_TYPE_OTHER");
		}

		var mCallbacks = {
			Highlight: fnHightlightCb
		};

		return {
			callbacks: mCallbacks,
			legend: oLegend
		};
	};

	return Dim;
});

}; // end of sap/chart/coloring/emphasis/DimensionValues.js
if ( !jQuery.sap.isDeclared('sap.chart.coloring.emphasis.Emphasis') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.chart.coloring.emphasis.Emphasis'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/coloring/emphasis/Emphasis",[
	'sap/chart/coloring/emphasis/DimensionValues',
	'sap/chart/coloring/ColorPalette',
	'sap/chart/coloring/ColoringUtils',
	'sap/chart/ChartLog',
	'sap/chart/data/TimeDimension'
], function(
	DimensionValues,
	ColorPalette,
	ColoringUtils,
	ChartLog,
	TimeDimension
) {
	"use strict";
	var type = jQuery.type,
		SUPPORTED_TYPES = ['DimensionValues', 'MeasureValues'];

	function createRules(aCandidateSettings, aLegendOrder) {
		var oCandidateSetting = aCandidateSettings[0];
		var aCbs = oCandidateSetting.parsed.callbacks.Highlight || [];
		var oLegend = oCandidateSetting.parsed.legend;
		var aRules = [];
		aRules.push({
			callback: aCbs,
			properties: {
				color: ColorPalette.EMPHASIS.Highlight
			},
			displayName: oLegend.Highlight
		});

		var oOthers = {
			properties: {
				color: ColorPalette.EMPHASIS.Others
			},
			displayName: oLegend.Others
		};

		return {
			rules: aRules,
			others: oOthers
		};
	}

	function getRuleGenerator(aCandidateSettings, aLegendOrder) {
		return function() {
			var props = {
				plotArea: {
					dataPointStyle: createRules(aCandidateSettings)
				}
			};
			return {
				properties: props
			};
		};
	}

	return {
		getCandidateSetting: function(oColorings, oActiveColoring, aTuples, oDimMsr, oStatus, options, oLocale) {
			var oEmphasis = oColorings.Emphasis || {},
				oParams = oActiveColoring.parameters || {};
			var sUseType = ColoringUtils.dimOrMsrUse(oEmphasis, oParams, oDimMsr, SUPPORTED_TYPES);
			var oCandidateSetting;

			switch (sUseType) {
				case 'DimensionValues':
					var activeDimension = oParams.dimension || Object.keys(oEmphasis.DimensionValues);
					if (type(activeDimension) === 'string') {
						activeDimension = [activeDimension];
					}
					oCandidateSetting = DimensionValues.qualify(oEmphasis.DimensionValues, activeDimension, oDimMsr, options);
					if (oCandidateSetting) {
						oCandidateSetting.parsed = DimensionValues.parse(oCandidateSetting, oLocale);
						oCandidateSetting.ruleGenerator = getRuleGenerator([oCandidateSetting]);
					}
					break;
				default:
					return {};
			}

			if (oCandidateSetting.length) {
				oCandidateSetting.subType = sUseType;
			}

			return oCandidateSetting;
		}
	};
});

}; // end of sap/chart/coloring/emphasis/Emphasis.js
if ( !jQuery.sap.isDeclared('sap.chart.coloring.criticality.measureValues.MeasureUtils') ) {
jQuery.sap.declare('sap.chart.coloring.criticality.measureValues.MeasureUtils'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/coloring/criticality/measureValues/MeasureUtils",[
	'sap/chart/coloring/ColoringUtils',
	'sap/chart/coloring/criticality/measureValues/ThresholdsUtils',
	'sap/chart/ChartLog',
	'sap/chart/coloring/CriticalityType',
	'sap/chart/data/MeasureSemantics'
], function(
	ColoringUtils,
	ThresholdsUtils,
	ChartLog,
	CriticalityType,
	MeasureSemantics
) {
	"use strict";
	var type = jQuery.type;

	var Msr = {
		Static: {},
		Calculated: {},
		DynamicThresholds: {},
		ConstantThresholds: {},
		Unmentioned: {}
	};

	var SUPPORTED_IMPROVEMENT = ['Maximize', 'Minimize', 'Target'];

	Msr.Static.validate = function(oSetting, sMsr, oDimMsr, aTuples, aCriticalityTypes) {
		var staticType = oSetting[sMsr].Static;

		var semanticRoleHandler = function(key, semanticRole) {
			if (oTuple[semanticRole] === sMsr) {
				bMatched = true;
				if (oTuple.staticType) {
					if (oTuple.staticType !== staticType) {
						var sMsrs = '';
						Object.keys(MeasureSemantics).forEach(function(key, index, arr) {
							var semanticRole = MeasureSemantics[key];
							if (oTuple[semanticRole]) {
								if (index !== (arr.length - 1)) {
									sMsrs += oTuple[semanticRole] + ', ';
								} else {
									sMsrs += oTuple[semanticRole];
								}
							}
						});
						//clid31
						throw new ChartLog('error', 'Colorings.Criticality.Static', 'When ' +
							sMsrs + ' have semantic relationship, they must use the same Criticality type.');
					}
				} else {
					oTuple.staticType = staticType;
					if (aCriticalityTypes[staticType]) {
						//clid13
						throw new ChartLog('error', 'Colorings.Criticality.Static', 'Measures, ' +
							aCriticalityTypes[staticType] + ' and ' + sMsr + ', which use Static Criticality must have different types.');
					} else {
						aCriticalityTypes[staticType] = sMsr;
					}
				}
				return false;
			}
		};
		
		var bMatched = false;
		for (var i = 0; i < aTuples.length; ++i) {
			var oTuple = aTuples[i];
			jQuery.each(MeasureSemantics, semanticRoleHandler);
			if (bMatched) {
				break;
			}
		}

		return {supportMultiMsr : true};
	};

	Msr.Static.parse = function(oConfig, options, oParsed) {
		var sMsr = oConfig.msr ? oConfig.msr.getName() : undefined;
		var sStaticProperty = oConfig.settings[oConfig.type];
		oParsed.callbacks = Msr.Static.getCallbacks(sStaticProperty, sMsr);
		var oDefaultLegend = oConfig.msr.getLabel() || oConfig.msr.getName();
		var oCustomLegend = oConfig.settings.Legend || {};
		oParsed.legend[sStaticProperty] =  (oCustomLegend[sStaticProperty] != null) ? oCustomLegend[sStaticProperty] : oDefaultLegend;
	};

	Msr.Static.getCallbacks = function(sCriticalityType, sMsr) {
		var cb = {};
		cb[sCriticalityType] = [function(oCtx) {
			return oCtx.hasOwnProperty(sMsr);
		}];
		return cb;
	};

	Msr.Calculated.validate = function(oSetting, sMsr, oDimMsr) {
		var sCalculatedDim = oSetting[sMsr].Calculated;
		var sMatchedDim = oDimMsr.allDim.filter(function(sDim) {
			return sDim === sCalculatedDim;
		})[0];
		if (!sMatchedDim) {
			//clid23
			throw new ChartLog('error', 'Colorings.Criticality.Calculated', 'Calculated property, ' + sCalculatedDim + ', does not exist in data model.');
		}
	};

	Msr.Calculated.parse = function(oConfig, options, oParsed, bMBC) {
		var sCalculatedProperty = oConfig.settings[oConfig.type];
		if (!ColoringUtils.find(sCalculatedProperty, options.aDims)) {
			oParsed.additionalDimensions.push(sCalculatedProperty);
		}
		oParsed.status = options.oStatus;
	};

	Msr.Calculated.getCallbacks = function(sPropName, sCriticalityType, sMsr) {
		var cb = function(oCtx) {
			return (oCtx[sPropName] === sCriticalityType) && oCtx.hasOwnProperty(sMsr);
		};
		return [cb];
	};

	Msr.Calculated.getContextHandler = function(aCandidateSettings, bMBC, oLocale) {
		var oCandidate = aCandidateSettings[0];
		var sCalculatedProperty = oCandidate.settings[oCandidate.type];
		return function(oContext) {
			var oStatus = oCandidate.parsed.status;
			oStatus.legend = oStatus.legend || {};
			oStatus.callbacks = oStatus.callbacks || {};
			oCandidate.parsed.legend = oStatus.legend;
			oCandidate.parsed.callbacks = oStatus.callbacks;

			var sCriticalityType = oContext.getProperty(sCalculatedProperty);
			if (CriticalityType[sCriticalityType]) {
				var oCalculatedProperty = this.getDimensionByName(sCalculatedProperty);
				var bDisplayText = this.getDimensionByName(sCalculatedProperty).getDisplayText();
				aCandidateSettings.legendTitle = aCandidateSettings.legendTitle || oCalculatedProperty.getLabel();
				var sCalculatedTextProperty = oCalculatedProperty.getTextProperty();
				if (sCalculatedTextProperty && bDisplayText) {
					var sCriticalityTypeText = oContext.getProperty(sCalculatedTextProperty);
					oCandidate.parsed.legend[sCriticalityType] = sCriticalityTypeText;
				} else if (sCriticalityType) {
					oCandidate.parsed.legend[sCriticalityType] = oLocale.getText("COLORING_TYPE_" + sCriticalityType.toUpperCase());
				}
				var sMsr = oCandidate.msr.getName();
				var cb = Msr.Calculated.getCallbacks(sCalculatedProperty, sCriticalityType, sMsr);
				oCandidate.parsed.callbacks[sCriticalityType] = cb;
			}
		};
	};

	Msr.DynamicThresholds.validate = function(oSetting, sMsr, oDimMsr) {
		var allMsr = oDimMsr.allMsr;
		var arr = [],
			settings = oSetting[sMsr].DynamicThresholds, sDir;
		if (SUPPORTED_IMPROVEMENT.indexOf(settings.ImprovementDirection) > -1) {
			sDir = settings.ImprovementDirection;
		} else {
			//clid32
			throw new ChartLog('error', 'Colorings.Criticality.DynamicThresholds', 'ImprovementDirection should be one of \'Maximize\', \'Minimize\' and \'Target\'.');
		}

		var lowArr = [settings.ToleranceRangeLowValue, settings.DeviationRangeLowValue, settings.AcceptanceRangeLowValue];
		var hiArr = [settings.ToleranceRangeHighValue, settings.DeviationRangeHighValue, settings.AcceptanceRangeHighValue];

		switch (sDir) {
			case "Maximize":
				arr = lowArr;
				break;
			case "Minimize":
				arr = hiArr;
				break;
			case "Target":
				arr = lowArr.concat(hiArr);
				break;
			default:
		}

		if (ColoringUtils.isNumber.apply(null, arr)) {
			//clid20
			throw new ChartLog('error', 'Colorings.Criticality.DynamicThresholds', 'Invalid Thresholds settings.');
		}

		//clid25
		//dynamic threshold allow number or empty
		//so we only check measure name
		arr = arr.filter(function(e){
			return typeof e == "string";
		});
		ColoringUtils.notIn(arr, allMsr, 'Colorings.Criticality.DynamicThresholds', 'Thresholds measure, ', ', does not exist in data model.');
	};

	Msr.DynamicThresholds.parse = function(oConfig, options, oParsed, bMBC, oLocale) {
		var oSetting = oConfig.settings[oConfig.type];
		var sMsr = oConfig.msr ? oConfig.msr.getName() : undefined;
		var sDir = oSetting.ImprovementDirection.toLowerCase();
		var oTolRange = {
			lo: oSetting.ToleranceRangeLowValue,
			hi: oSetting.ToleranceRangeHighValue
		};
		var oDevRange = {
			lo: oSetting.DeviationRangeLowValue,
			hi: oSetting.DeviationRangeHighValue
		};
		var oAcpRange = {
			lo: oSetting.AcceptanceRangeLowValue,
			hi: oSetting.AcceptanceRangeHighValue
		};

		ThresholdsUtils.fillOmit(oAcpRange, oTolRange, oDevRange);

		oParsed.additionalMeasures = [oAcpRange.lo, oAcpRange.hi, oTolRange.lo, oTolRange.hi, oDevRange.lo, oDevRange.hi].filter(function(val) {
			return type(val) === 'string' && options.aMsrs.filter(function(msr){return msr.getName() === val;}).length == 0;
		});
		oParsed.callbacks = ThresholdsUtils.improvement(sDir, sMsr, oAcpRange, oTolRange, oDevRange);

		var oDefaultLegend = {};
		jQuery.each(CriticalityType, function(key, value) {
			oDefaultLegend[value] = oLocale.getText("COLORING_TYPE_" + value.toUpperCase());
		});
		oParsed.legend = jQuery.extend(true, {}, oDefaultLegend, oConfig.settings.Legend);
	};

	Msr.DynamicThresholds.getContextHandler = function(aCandidateSettings, bMBC, oLocale) {
		var oCandidate = aCandidateSettings[0],
			oSetting = oCandidate.settings[oCandidate.type],
			sDir = oSetting.ImprovementDirection.toLowerCase();

			function _getValue(oContext, key){
				var result;
				if (typeof key === "number") {
					result = key;
				} else {
					result = key ? oContext.getProperty(key) : null;
					if (typeof result === "string") {
						result = Number.parseFloat(result);
					}
				}
				return result;
			}

		return function(oContext) {
			var oTolRange = {};
			oTolRange.lo = _getValue(oContext, oSetting.ToleranceRangeLowValue);
			oTolRange.hi = _getValue(oContext, oSetting.ToleranceRangeHighValue);

			var oDevRange = {};
			oDevRange.lo = _getValue(oContext, oSetting.DeviationRangeLowValue);
			oDevRange.hi = _getValue(oContext, oSetting.DeviationRangeHighValue);
			
			var oAcpRange = {};
			oAcpRange.lo = _getValue(oContext, oSetting.AcceptanceRangeLowValue);
			oAcpRange.hi = _getValue(oContext, oSetting.AcceptanceRangeHighValue);
			
			ThresholdsUtils.fillOmit(oAcpRange, oTolRange, oDevRange);
			ThresholdsUtils.checkThreshold(sDir, oAcpRange, oTolRange, oDevRange);
		};
	};

	Msr.ConstantThresholds.validate = function(oSetting, sMsr) {
		var	settings = oSetting[sMsr].ConstantThresholds;
		if (SUPPORTED_IMPROVEMENT.indexOf(settings.ImprovementDirection) === -1) {
			//clid32
			throw new ChartLog('error', 'Colorings.Criticality.ConstantThresholds', 'ImprovementDirection should be one of \'Maximize\', \'Minimize\' and \'Target\'.');
		}
		return {supportHeatMap : true};
	};

	Msr.ConstantThresholds.parse = function(oConfig, options, oParsed, bMBC, oLocale) {
		var oSetting = oConfig.settings[oConfig.type];
		var sMsr = oConfig.msr ? oConfig.msr.getName() : undefined;
		var sMsrName = oConfig.msr ? oConfig.msr.getLabel() || oConfig.msr.getName() : undefined;
		var sDir = oSetting.ImprovementDirection.toLowerCase();
		var oTolRange = {
			lo: oConfig.byAggregation.ToleranceRangeLowValue,
			hi: oConfig.byAggregation.ToleranceRangeHighValue
		};
		var oDevRange = {
			lo: oConfig.byAggregation.DeviationRangeLowValue,
			hi: oConfig.byAggregation.DeviationRangeHighValue
		};
		var oAcpRange = {
			lo: oConfig.byAggregation.AcceptanceRangeLowValue,
			hi: oConfig.byAggregation.AcceptanceRangeHighValue
		};

		ThresholdsUtils.fillOmit(oAcpRange, oTolRange, oDevRange);
		ThresholdsUtils.checkThreshold(sDir, oAcpRange, oTolRange, oDevRange, true);
		if (bMBC) {
			oParsed.legend = ThresholdsUtils.MBCimprovement(sDir, oAcpRange, oTolRange, oDevRange);
		} else {
			oParsed.callbacks = ThresholdsUtils.improvement(sDir, sMsr, oAcpRange, oTolRange, oDevRange);	
			oParsed.legend = Msr.ConstantThresholds.getLegend(sDir, sMsrName, oAcpRange, oTolRange, oDevRange, oLocale);
		}
	};  

	//mathSymbol
	var ge = "\u2265"; //>=
	var lt = "<";
	var le = "\u2264"; //<=
	var gt = ">";

	var symbolsRevert = {
		"<" : ">",
		">" : "<",
		"\u2265" : "\u2264",
		"\u2264" : "\u2265"
	};

	Msr.ConstantThresholds.getLegend = function(sDir, sMsr, oAcpRange, oTolRange, oDevRange, oLocale) {
		var oLegend = {};
		var devHi = oDevRange.hi;
		var devLo = oDevRange.lo;
		var tolHi = oTolRange.hi;
		var tolLo = oTolRange.lo;
		var acpHi = oAcpRange.hi;
		var acpLo = oAcpRange.lo; 	

		//make sure legend item is not empty
		//also not showing mathematically-meaningless item. e.g "1 < speed < infinity" or speed < infinity"
		function getText(tokens, deleteInfinity, checkEmptyRange){
			var len = tokens.length;
			var firstInf = tokens[0] === Number.POSITIVE_INFINITY;
			var firstNegInf = tokens[0] === Number.NEGATIVE_INFINITY;
			var lastInf = tokens[len - 1] === Number.POSITIVE_INFINITY;
			var lastNegInf = tokens[len - 1] === Number.NEGATIVE_INFINITY;

			// 1 < speed <= 1 is mathematically-meaningless
			if (checkEmptyRange && tokens[0] === tokens[len - 1]) {
				return "";
			}

			if (deleteInfinity) {
				if (len === 5 && !(firstNegInf && lastInf)) {
					//keep  -inf < measure < infi
					if (lastInf || lastNegInf) {
						tokens = tokens.slice(0, 3);
					}
					if (firstInf || firstNegInf) {
						tokens = tokens.slice(2);
					}
					if (tokens.length <= 1) {
						return "";
					}
				}else if (len === 3 && (firstInf || firstNegInf || lastInf || lastNegInf)) {
					return "";
				}
			}
			//replace infi with translation
			tokens = tokens.map(function(e){
				if (e === Number.POSITIVE_INFINITY) {
					return oLocale.getText("POSITIVE_INFINITY");
				}else if (e === Number.NEGATIVE_INFINITY) {
					return oLocale.getText("NEGATIVE_INFINITY");
				}
				return e;
			});

			//not 25 < speed, but speed > 25
			if (tokens.length === 3 && ColoringUtils.isNumber(tokens[0])) {
				var sym = symbolsRevert[tokens[1]];
				tokens = [tokens[2], sym, tokens[0]];
			}
			return tokens.join(" ");
		}
		
		var strHasLength = function(e){
			return e && e.length > 0;
		};

		var handlePair = function(pair){
			return pair.filter(strHasLength).join(' , ');
		};

		switch (sDir) {
			case 'maximize':
				oLegend = {
					Positive: getText([sMsr, ge, acpLo]),
					Critical: getText([devLo, le, sMsr, lt, tolLo], true),
					Neutral: getText([tolLo, le, sMsr, lt, acpLo], true),
					Negative: getText([sMsr, lt, devLo])
				};
				break;
			case 'minimize':
				oLegend = {
					Positive: getText([sMsr, le, acpHi]),
					Critical: getText([tolHi, lt, sMsr, le, devHi], true),
					Neutral: getText([acpHi, lt, sMsr, le, tolHi], true),
					Negative: getText([sMsr, gt, devHi])
				};
				break;
			case 'target':
				oLegend = {
					Positive: getText([acpLo, le, sMsr, le, acpHi], true),
					Critical: handlePair([getText([devLo, le, sMsr, lt, tolLo], true, true), getText([tolHi, lt, sMsr, le, devHi], true, true)]),
					Neutral: handlePair([getText([tolLo, le, sMsr, lt, acpLo], true, true), getText([acpHi, lt, sMsr, le, tolHi], true, true)]),
					Negative: handlePair([getText([sMsr, lt, devLo], true),  getText([sMsr, gt, devHi], true)])
				};
				break;  
			default:
		}
		return oLegend;
	};

	Msr.ConstantThresholds.getContextHandler = function(aCandidateSettings, bMBC) {
		if (bMBC) {
			var oCandidate = aCandidateSettings[0];
			var sMsr = oCandidate.msr.getName();
			var oLegend = oCandidate.parsed.legend;
			return function(oContext) {
				var iVal = oContext.getProperty(sMsr);
				oLegend.min = Math.min(oLegend.min, iVal);
				oLegend.max = Math.max(oLegend.max, iVal);
			};
		} else {
			return null;
		}
	};

	return Msr;
});
}; // end of sap/chart/coloring/criticality/measureValues/MeasureUtils.js
if ( !jQuery.sap.isDeclared('sap.chart.coloring.criticality.measureValues.MeasureValues') ) {
jQuery.sap.declare('sap.chart.coloring.criticality.measureValues.MeasureValues'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/coloring/criticality/measureValues/MeasureValues",[
	'sap/chart/coloring/ColoringUtils',
	'sap/chart/coloring/ColorPalette',
	'sap/chart/coloring/criticality/measureValues/MeasureUtils',
	'sap/chart/ChartLog',
	'sap/chart/data/MeasureSemantics'
], function(
	ColoringUtils,
	ColorPalette,
	MeasureUtils,
	ChartLog,
	MeasureSemantics
) {
	"use strict";
	var MeasureValues = {};
	var SUPPORTED_MEASUREVALUES_KEYS = ["Static", "Calculated", "DynamicThresholds", "ConstantThresholds"];

	function checkValidate(type, aTuples, msr, oDimMsr, aActiveMeasure, aColoringMeasure, options, aCriticalityType){
		var result = {supportMultiMsr : false, supportHeatMap : false};
		var multiMsr = aActiveMeasure.length > 1;
		if (MeasureUtils[type].validate) {
			jQuery.extend(result, MeasureUtils[type].validate(aColoringMeasure, msr, oDimMsr, aTuples, aCriticalityType));
		}
		if (multiMsr && !result.supportMultiMsr) {
			//clid 12
			throw new ChartLog('error', 'Colorings.Criticality', 'Only support multiple active measures when using Static Criticality.');
		}
		if (options.bMBC && !result.supportHeatMap) {
			//clid29
			throw new ChartLog('error', 'Colorings', 'Heatmap only support Criticality.MeasureValues.ConstantThresholds.');
		}
	}

	var validate = function(aColoringMeasure, aTuples, oDimMsr, aActiveMeasure, options) {
		var aVisibleMeasure = oDimMsr.aMsr;
		ColoringUtils.checkColoringMeasure(aActiveMeasure, aVisibleMeasure, aColoringMeasure);
		var aCriticalityType = [];
		aActiveMeasure.forEach(function(msr, index){
			var aValidTypes = Object.keys(aColoringMeasure[msr]).filter(function(key) {
				return SUPPORTED_MEASUREVALUES_KEYS.indexOf(key) > -1;
			}).sort();
			var isLegalCombination = isLegalCombinationFn(aValidTypes);

			if (aValidTypes.length > 1 && !isLegalCombination) {
				//clid14
				throw new ChartLog('error', 'Colorings.Criticality.MeasureValues', 
					'The combination of "DynamicThresholds"and "ConstantThresholds" or only one of "Static", "Calculated", "DynamicThresholds", or "ConstantThresholds" can be applied to the measure, ' + msr + '.');
			}

			if (!isLegalCombination && aValidTypes.length === 1) {

				checkValidate(aValidTypes[0], aTuples, msr, oDimMsr, aActiveMeasure, aColoringMeasure, options, aCriticalityType);
			}
		});

		function bHasSeriesDim(aVisibleDimension) {
			return aVisibleDimension.some(function(oDim) {
				return oDim._getFixedRole() === "series";
			});
		}
		if (bHasSeriesDim(oDimMsr.aDim) || 
			(options.bTimeChart && options.bWaterfall && oDimMsr.aDim.length > 1) ||
			(options.bIsPie && oDimMsr.aDim.length)) {
			//clid16
			throw new ChartLog('error', 'colorings.Criticality.MeasureValues', 'Semantic coloring could not be applied if chart already has coloring.');
		}
	};

	function isLegalCombinationFn(types){
		return types.length === 2 && types[0] == "ConstantThresholds" && types[1] === "DynamicThresholds";
	}

	function findConfigByMsr(aCandidateConfigs, sMsrName) {
		var oMatchedConfig = aCandidateConfigs.filter(function(oConfig) {
			return oConfig.msr.getName() === sMsrName;
		})[0];
		return oMatchedConfig;
	}

	function extendStaticCandidateConfigs(aCandidateConfigs, aTuples, aMsrs) {
		if (aCandidateConfigs.sMethod === 'Static') {
			var aExtendedCandidateConfigs = [];
			aTuples.forEach(function(oTuple) {
				jQuery.each(MeasureSemantics, function(currentKey, currentSemanticRole) {
					var sCurrentMsrName = oTuple[currentSemanticRole];
					if (sCurrentMsrName) {
						var oMarchedConfig = findConfigByMsr(aCandidateConfigs, oTuple[currentSemanticRole]);
						if (!oMarchedConfig) {
							// measure without 'Static' config need to be extended by tuple's setting
							jQuery.each(MeasureSemantics, function(key, semanticRole) {
								if (currentSemanticRole !== semanticRole) {
									var oConfigToAlign = findConfigByMsr(aCandidateConfigs, oTuple[semanticRole]);
									if (oConfigToAlign) {
										var oMsr = aMsrs.filter(function(oMsr) {
											return oMsr.getName() === sCurrentMsrName;
										})[0];
										var oExtendConfig = {
											msr: oMsr,
											settings: {
												Static: oConfigToAlign.settings.Static
											},
											type: 'Static'
										};
										aExtendedCandidateConfigs.push(oExtendConfig);
									}
								}
							});
						} else {
							oTuple.criticalityType = oMarchedConfig.settings.Static;
						}
					}
				});
			});
			aCandidateConfigs.push.apply(aCandidateConfigs, aExtendedCandidateConfigs);
		}
	}

	MeasureValues.qualify = function(oConfig, aTuples, aActiveMsrs, oDimMsr, oStatus, options) {
		validate(oConfig, aTuples, oDimMsr, aActiveMsrs, options);
		var aCandidateConfigs = [],
			aMentionedMsrs = [],
			sAggregationKey = oDimMsr.aDim.map(function(oDim) {
				return oDim.getName();
			}).sort();

		jQuery.each(oConfig, function(sMeasureName, oSetting) { 
			var aSettingKeys = Object.keys(oSetting);
			var oMatchedMsr = ColoringUtils.find(sMeasureName, oDimMsr.aMsr);
			var aExcludeLegend = aSettingKeys.filter(function(key) {
				return key !== "Legend";
			}).sort();

			if (aActiveMsrs.length && aActiveMsrs.indexOf(sMeasureName) === -1) {
				// filter inactive config
				return;
			}
	
			var found = false, sKey;
			//aExcludeLegend.length should be 1 or 2
			//to find the suitable criticality for coloring
			for (var ii = 0; ii < aExcludeLegend.length && !found; ii++) {
				sKey = aExcludeLegend[ii];
				aCandidateConfigs.sMethod = sKey;
				if (sKey === "ConstantThresholds") {
					var oMatchedByAggregation = null, oGlobalSetting = null;
					for (var jj = 0; jj < oSetting[sKey].AggregationLevels.length; jj++) {
						if (oSetting[sKey].AggregationLevels[jj].VisibleDimensions) {
							var sAggKeyToTest = oSetting[sKey].AggregationLevels[jj].VisibleDimensions.sort();
							if (sAggKeyToTest.join(",") === sAggregationKey.join(",")) {
								oMatchedByAggregation = oSetting[sKey].AggregationLevels[jj];
							}
						} else {
							// if user does not explicitly assign VisibleDimensions or sets as null, we intend to ignore this constraint by default.
							oGlobalSetting = oSetting[sKey].AggregationLevels[jj];
						}
					}
					oMatchedByAggregation = oMatchedByAggregation || oGlobalSetting;
					if (oMatchedByAggregation) {
						found = true;
						// Aggregation Level is invalidated if filter is set by customer
						if (!options.bFiltered) {
							aCandidateConfigs.push({
								type: sKey,
								msr: oMatchedMsr,
								settings: oSetting,
								byAggregation: oMatchedByAggregation
							});
							aMentionedMsrs.push(oMatchedMsr.getName());
						}
					}
				} else {
					found = true;
					aCandidateConfigs.push({
						type: sKey,
						msr: oMatchedMsr,
						settings: oSetting
					});
					aMentionedMsrs.push(oMatchedMsr.getName());
				}
			}

			if (!found) {
				//clid19
				throw new ChartLog("error", 'Colorings.Criticality.MeasureValues.ConstantThresholds', "No aggregation levels matched with current visible dimensions.");
			}

			//we skip validation for the combination, we do it here for the chosen criticality
			if (isLegalCombinationFn(aExcludeLegend)) {
				checkValidate(sKey, aTuples, oMatchedMsr.getName(), oDimMsr, aActiveMsrs, oConfig, options);
			}
		});
	    
		//extend static settings according to tuples	
		extendStaticCandidateConfigs(aCandidateConfigs, aTuples, oDimMsr.aMsr);

		if (aCandidateConfigs.length) {
			var iUnMentionedTupleCount = 0;
			aTuples.forEach(function(oTuple) {
				var bMentioned = false;
				jQuery.each(MeasureSemantics, function(key, semanticRole) {
					if (aMentionedMsrs.indexOf(oTuple[semanticRole]) > -1) {
						bMentioned = true;
						return false;
					}
				});
				if (!bMentioned) {
					oTuple.iUnMentionedIndex = iUnMentionedTupleCount++;
				}
			});

			if (iUnMentionedTupleCount > 3) {
				//clid15
				throw new ChartLog("error", 'Colorings.Criticality.MeasureValues', "Too many unmentioned measures (the maximum number is 3).");
			}
		}

		aCandidateConfigs.bShowUnmentionedMsr = options.bShowUnmentionedMsr;

		return aCandidateConfigs;
	};

	MeasureValues.parse = function(oConfig, oDimMsr, oStatus, oOptions, oLocale) {
		var bMBC = oOptions.bMBC,
			options = {
				aMsrs: oDimMsr.aMsr,
				aDims: oDimMsr.aDim,
				oStatus: oStatus
			},
			oParsed = {
				msr: oConfig.msr,
				callbacks: {},
				additionalDimensions: [],
				legend: {}
			};
		MeasureUtils[oConfig.type].parse(oConfig, options, oParsed, bMBC, oLocale);
		return oParsed;
	};

	MeasureValues.getContextHandler = function(sCriticalityMethod, aCandidateSettings, bMBC, oLocale) {
		if (MeasureUtils[sCriticalityMethod].getContextHandler) {
			return MeasureUtils[sCriticalityMethod].getContextHandler(aCandidateSettings, bMBC, oLocale);
		} else {
			return null;
		}
	};

	return MeasureValues;
});
}; // end of sap/chart/coloring/criticality/measureValues/MeasureValues.js
if ( !jQuery.sap.isDeclared('sap.chart.coloring.criticality.Criticality') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.chart.coloring.criticality.Criticality'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/coloring/criticality/Criticality",[
	'sap/chart/coloring/criticality/measureValues/MeasureValues',
	'sap/chart/coloring/criticality/DimensionValues',
	'sap/chart/coloring/ColoringUtils',
	'sap/chart/coloring/ColorPalette',
	'sap/chart/coloring/CriticalityType',
	'sap/chart/data/MeasureSemantics'
], function(
	MeasureValues,
	DimensionValues,
	ColoringUtils,
	ColorPalette,
	CriticalityType,
	MeasureSemantics
) {
	"use strict";
	var type = jQuery.type;
	var SUPPORTED_TYPES = ['DimensionValues', 'MeasureValues'];
	var aMeasureLegendOrder = [
		CriticalityType.Positive,
		CriticalityType.Neutral,
		CriticalityType.Critical,
		CriticalityType.Negative,
		'Unmentioned'
	];
	var aDimensionLegendOrder = [
		CriticalityType.Positive,
		CriticalityType.Critical,
		CriticalityType.Negative,
		CriticalityType.Neutral
	];

	function createRules(aCandidateSettings, aLegendOrder) {
		var aRules = [];
		aLegendOrder.forEach(function(sCriticalityType) {
			aCandidateSettings.forEach(function(oCandidateSetting) {
				if (oCandidateSetting.chartLog) {
					throw oCandidateSetting.chartLog;
				}
				var aCbs = oCandidateSetting.parsed.callbacks[sCriticalityType] || [];
				aCbs.forEach(function(fnCb, idx) {
					var aColors, sDisplayName;
					if (sCriticalityType === "Unmentioned") {
						aColors = ColoringUtils.assignUnmentionedColor(ColorPalette.CRITICALITY.Neutral, aCbs.length);
						sDisplayName = oCandidateSetting.parsed.legend[idx];
					} else {
						aColors = ColoringUtils.assignColor(ColorPalette.CRITICALITY[sCriticalityType], aCbs.length);
						var oLegend = oCandidateSetting.parsed.legend[sCriticalityType];
						sDisplayName = (type(oLegend) === "array") ? oLegend[idx] : oLegend;
					}
					var oRule = {
						callback: fnCb,
						properties: {
							color: aColors[idx]
						},
						displayName: sDisplayName
					};
					aRules.push(oRule);
				});
			});
		});
		return aRules;
	}

	function createScales(aCandidateSettings) {
		var oCandidate = aCandidateSettings[0];
		var oLegend = oCandidate.parsed.legend;

		var aPalettes = [], aBoundaries = [];
		var bNeedMin = oLegend.segments[0].upperBound > oLegend.min;
		var bNeedMax = (oLegend.segments.length < 2) || (oLegend.segments[oLegend.segments.length - 2].upperBound < oLegend.max);

		oLegend.segments.forEach(function(oSegment) {
			var color = ColoringUtils.assignColor(ColorPalette.CRITICALITY[oSegment.CriticalityType], 1)[0];
			aPalettes.push(color);
			aBoundaries.push(oSegment.upperBound);
		});

		if (bNeedMin) {
			aBoundaries = [oLegend.min].concat(aBoundaries);
		} else {
			aPalettes.splice(0, 1);
		}

		if (bNeedMax) {
			aBoundaries[aBoundaries.length - 1] = oLegend.max;
		} else {
			aPalettes.splice(aPalettes.length - 1, 1);
			aBoundaries.splice(aBoundaries.length - 1, 1);
		}

		var numOfSegments = aPalettes.length;
		if (aPalettes.length === 1) {
			aPalettes = [aPalettes[0], aPalettes[0]];
			numOfSegments = 2;
		}else if (aPalettes.length === 0) {
			return null;
		}

		return {
			feed: "color",
			palette: aPalettes,
			numOfSegments: numOfSegments,
			legendValues: aBoundaries
		};
	}

	function getLegendProps(aCandidateSettings) {
		var oLegendProps;
		if (aCandidateSettings && aCandidateSettings.legendTitle) {
			oLegendProps = {
				title: {
					text: aCandidateSettings.legendTitle,
					visible: true
				}
			};
		}
		return oLegendProps;
	}

	function getRuleGenerator(aCandidateSettings, aLegendOrder) {
		return function() {
			var colorScale, properties;
			if (aCandidateSettings.bMBC) {
				colorScale = createScales(aCandidateSettings);
			} else {
				var rules = createRules(aCandidateSettings, aLegendOrder);
				properties = {
					plotArea: {
						dataPointStyle: {
							rules: rules
						}
					},
					legend: getLegendProps(aCandidateSettings)
				};
			}
			return {
				colorScale: colorScale,
				properties: properties
			};
		};
	}

	function adjustTuplesOrderByColoring(aTuples, aColorings) {
		var aSemanticRoles = [
		MeasureSemantics.Actual,
		MeasureSemantics.Projected,
		MeasureSemantics.Reference
		];

		var aMeasureLegendOrder = [
		CriticalityType.Positive,
		CriticalityType.Neutral,
		CriticalityType.Critical,
		CriticalityType.Negative
		];

		var aColoringTuples = [];
		var aNonColoringTuples = [];
		var bMultipleCriticality = false;

		aTuples.forEach(function(oTuple) {
			var bColoring = false;
			var nonColoringSemantics = [];
			oTuple.order = [];

			if (oTuple.criticalityType) {
				bMultipleCriticality = true;
			}

			aSemanticRoles.forEach(function(semanticRole) {
				if (oTuple[semanticRole]) {
					var oMarchedColoringMsr = aColorings.filter(function(oMsr) {
						return oTuple[semanticRole] === oMsr.msr.getName();
					})[0];
					if (oMarchedColoringMsr) {
						bColoring = true;
						oTuple.order.push(semanticRole);
					} else {
						nonColoringSemantics.push(semanticRole);
					}
				}
			});

			oTuple.order = oTuple.order.concat(nonColoringSemantics);
			if (bColoring) {
				aColoringTuples.push(oTuple);
			} else {
				aNonColoringTuples.push(oTuple);
			}
		});	

		if (bMultipleCriticality) {
			aColoringTuples.sort(function(oTupleA, oTupleB) {
				return aMeasureLegendOrder.indexOf(oTupleA.criticalityType) - aMeasureLegendOrder.indexOf(oTupleB.criticalityType);
			});
		}

		aTuples.splice(0, aTuples.length);
		aTuples.push.apply(aTuples, aColoringTuples.concat(aNonColoringTuples));
	}

	return {
		getCandidateSetting: function(oColorings, oActiveColoring, aTuples, oDimMsr, oStatus, options, oLocale) {
			var oCriticality = oColorings.Criticality || {},
				oParams = oActiveColoring.parameters || {};
			var sUseType = ColoringUtils.dimOrMsrUse(oCriticality, oParams, oDimMsr, SUPPORTED_TYPES);
			var oCandidateSetting = {
				additionalMeasures: [],
				additionalDimensions: []
			};
			var bMBC = options.bMBC, aQualifiedSettings, oParsed, sCriticalityMethod;

			switch (sUseType) {
				case 'DimensionValues':
					var activeDimension = oParams.dimension || Object.keys(oCriticality.DimensionValues);
					if (type(activeDimension) === 'string') {
						activeDimension = [activeDimension];
					}
					aQualifiedSettings = DimensionValues.qualify(oCriticality.DimensionValues, activeDimension, oDimMsr, options);
					if (aQualifiedSettings) {
						oCandidateSetting.qualifiedSettings = aQualifiedSettings;
						aQualifiedSettings.parsed = DimensionValues.parse(aQualifiedSettings, oDimMsr.aDim, oStatus, oLocale, options);
						oCandidateSetting.contextHandler = DimensionValues.getContextHandler(aQualifiedSettings, oLocale, options);
						oCandidateSetting.ruleGenerator = getRuleGenerator([aQualifiedSettings], aDimensionLegendOrder);
					}
					break;
				case 'MeasureValues':
					var activeMeasure = oParams.measure || Object.keys(oCriticality.MeasureValues);
					if (type(activeMeasure) === 'string') {
						activeMeasure = [activeMeasure];
					}
					aQualifiedSettings = MeasureValues.qualify(oCriticality.MeasureValues, aTuples, activeMeasure, oDimMsr, oStatus, options);
					if (aQualifiedSettings.sMethod) {
						jQuery.each(aQualifiedSettings, function(i, oQualified) {
							oParsed = MeasureValues.parse(oQualified, oDimMsr, oStatus, options, oLocale);
							jQuery.each(oParsed.additionalMeasures, function(i, sThresholdMsrName) {
								oCandidateSetting.additionalMeasures.push(sThresholdMsrName);
							});
							jQuery.each(oParsed.additionalDimensions, function(i, sCalculatedName) {
								oCandidateSetting.additionalDimensions.push(sCalculatedName);
							});
							oQualified.parsed = oParsed;
							if (oQualified.settings.Legend && oQualified.settings.Legend.Title) {
								aQualifiedSettings.legendTitle = oQualified.settings.Legend.Title;
							}
						});
						sCriticalityMethod = aQualifiedSettings.sMethod;
						oCandidateSetting.contextHandler = MeasureValues.getContextHandler(sCriticalityMethod, aQualifiedSettings, bMBC, oLocale);
						oCandidateSetting.qualifiedSettings = aQualifiedSettings;
						oCandidateSetting.ruleGenerator = getRuleGenerator(aQualifiedSettings, aMeasureLegendOrder);
						aQualifiedSettings.bMBC = bMBC;

						adjustTuplesOrderByColoring(aTuples, aQualifiedSettings);
					}
					break;
				default:
					return {};
			}

			if (aQualifiedSettings.length) {
				oCandidateSetting.subType = sUseType;
			}

			return oCandidateSetting;
		},
		getLegendProps: getLegendProps
	};
});

}; // end of sap/chart/coloring/criticality/Criticality.js
if ( !jQuery.sap.isDeclared('sap.chart.utils.MeasureSemanticsUtils') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.chart.utils.MeasureSemanticsUtils'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/utils/MeasureSemanticsUtils",[
	'sap/chart/coloring/ColoringUtils',
	'sap/chart/coloring/ColorPalette',
	'sap/chart/data/MeasureSemantics',
	'sap/chart/coloring/CriticalityType',
	'sap/chart/ChartLog',
	'sap/chart/ColoringType',
	'sap/chart/coloring/criticality/Criticality',
	'sap/chart/utils/ChartUtils'
], function(
	ColoringUtils,
	ColorPalette,
	MeasureSemantics,
	CriticalityType,
	ChartLog,
	ColoringType,
	Criticality,
	ChartUtils
) {
	"use strict";

	var COLOR_PALETTE = ['sapUiChartPaletteQualitativeHue1',
						 'sapUiChartPaletteQualitativeHue2',
						 'sapUiChartPaletteQualitativeHue3',
						 'sapUiChartPaletteQualitativeHue4',
						 'sapUiChartPaletteQualitativeHue5',
						 'sapUiChartPaletteQualitativeHue6',
						 'sapUiChartPaletteQualitativeHue7',
						 'sapUiChartPaletteQualitativeHue8',
						 'sapUiChartPaletteQualitativeHue9',
						 'sapUiChartPaletteQualitativeHue10',
						 'sapUiChartPaletteQualitativeHue11'
					 ],
		DUAL_COLOR_PALETTE = [['sapUiChartPaletteSequentialHue1',
                    'sapUiChartPaletteSequentialHue1Light2',
                    'sapUiChartPaletteSequentialHue1Dark1'
                ],
                ['sapUiChartPaletteSequentialHue2',
                    'sapUiChartPaletteSequentialHue2Light2',
                    'sapUiChartPaletteSequentialHue2Dark1'
                ]],
		SINGLE_TARGET_COLOR = 'sapUiChartPaletteSequentialNeutralDark2',
		SINGLE_NEUTRAL_COLOR = 'sapUiChartPaletteSemanticNeutral',
		LINE_TYPE = {
			actual : 'solid',
			projected : 'dash',
			reference : 'dot'
		},
		PATTERN = {
			projected : 'diagonalLightStripe',
			reference : 'noFill'
		};
	var aMeasureLegendOrder = [
		CriticalityType.Positive,
		CriticalityType.Neutral,
		CriticalityType.Critical,
		CriticalityType.Negative
	];

	function rel(oMsr) {
		var oResult = {};
		if (oMsr.getSemanticallyRelatedMeasures) {
			var oRel = oMsr.getSemanticallyRelatedMeasures();
			if (oRel) {
				if (oRel.projectedValueMeasure) {
					oResult.projected = oRel.projectedValueMeasure;
				}
				if (oRel.referenceValueMeasure) {
					oResult.reference = oRel.referenceValueMeasure;
				}
				return oResult;
			}
		}

		return oResult;
	}

	function calc(aMsrs, aInvisibleMsrs) {
		var mComputed = aMsrs.reduce(function(mComputed, oMsr) {
			mComputed[oMsr.getName()] = {
				msr: oMsr,
				sem: (oMsr.getSemantics && oMsr.getSemantics()) || "actual",
				rel: rel(oMsr)
			};
			return mComputed;
		}, {});

		// remove mis matched (semantics, relation semantics) from each semantic
		// relation
		jQuery.each(mComputed, function(sMsr, oCfg) {
			if (oCfg.sem === "actual") {
				jQuery.each(oCfg.rel, function(sSem, sTargetMsr) {
					if (mComputed[sTargetMsr] && mComputed[sTargetMsr].sem !== sSem) {
						delete oCfg.rel[sSem];
						var chartLog = new ChartLog("error","Semantic Pattern", sTargetMsr + " shouldn't be used as " + sSem + " in semantic relation. ");
						chartLog.display();
					}
				});
			}
		});

		if (aInvisibleMsrs) {
			for (var i = 0; i < aInvisibleMsrs.length; i++) {
				var oMsr = aInvisibleMsrs[i];
				var oRel = rel(oMsr);
				if (oRel.projected && oRel.reference && mComputed[oRel.projected] && mComputed[oRel.reference]) {
					mComputed[oRel.projected] = {
						msr: oMsr,
						sem: 'projected',
						rel: {
							reference : oRel.reference
						}
					};
				}
			}
		}

		return mComputed;
	}

	function makeTuples(aMsrs, mSems, isRestored) {
		var aTuples = [], index = 0, chartLog;

		jQuery.each(aMsrs.slice().sort(function(a, b) {
			var semA = mSems[a.getName()].sem,
				semB = mSems[b.getName()].sem;
			if (semA < semB) {
				return -1;
			} else if (semA > semB) {
				return 1;
			} else {
				return aMsrs.indexOf(a) - aMsrs.indexOf(b);
			}
		}), function(idx, oMsr) {
			var sName = oMsr.getName();
			if (!mSems[sName]) {
				return;
			}

			var oSemCfg = mSems[sName];
			var oTuple = {};
			var sLabel;

			oTuple[isRestored ? 'actual' : oSemCfg.sem] = sName;
			if (oMsr.getLabel) {
				sLabel = oMsr.getLabel();
				if (sLabel) {
					oTuple.labels = {};
					oTuple.labels[oSemCfg.sem] = sLabel;
				}
			}
			oTuple.index = index++;

			if (!isRestored && (oSemCfg.sem === "actual" || oSemCfg.sem === "projected")) {
				if (oSemCfg.rel.projected) {
					if (mSems[oSemCfg.rel.projected]) {
						oTuple.projected = oSemCfg.rel.projected;
						//Keep labels
						if (mSems[oSemCfg.rel.projected].msr.getLabel) {
							sLabel = mSems[oSemCfg.rel.projected].msr.getLabel();
							if (sLabel) {
								oTuple.labels = jQuery.extend(true, oTuple.labels, {
									projected: sLabel
								});
							}
						}
						delete mSems[oSemCfg.rel.projected];
					} else {
						chartLog = new ChartLog('error', 'Semantic Pattern', oSemCfg.msr.getName() + ' has an invalid projected semantic relation.');
						chartLog.display();
					}
				}
				if (oSemCfg.rel.reference) {
					if (mSems[oSemCfg.rel.reference]) {
						oTuple.reference = oSemCfg.rel.reference;
						if (mSems[oSemCfg.rel.reference].msr.getLabel) {
							sLabel = mSems[oSemCfg.rel.reference].msr.getLabel();
							if (sLabel) {
								oTuple.labels = jQuery.extend(true, oTuple.labels, {
									reference: sLabel
								});
							}
						}
						delete mSems[oSemCfg.rel.reference];
					} else {
						chartLog = new ChartLog('error', 'Semantic Pattern', oSemCfg.msr.getName() + ' has an invalid reference semantic relation.');
						chartLog.display();
					}
				}
				delete mSems[sName];
			}
			oTuple.order = [
				MeasureSemantics.Actual,
				MeasureSemantics.Projected,
				MeasureSemantics.Reference
			];
			aTuples.push(oTuple);

		});

		return aTuples;
	}

	var addDataPointStyleRules = function(semanticProps, rule){
		if (!semanticProps.dataPointStyle) {
			semanticProps = jQuery.extend(true, semanticProps, {
				"dataPointStyle": {
					"rules": [],
					others : null
				}
			});
		}
		semanticProps.dataPointStyle.rules.push(rule);
	};

	var getColorsBySemanticPattern = function(chartType, index, valueAxisID){
		var length, colorPalette;
		if (chartType.indexOf('dual') === -1) {
			colorPalette = COLOR_PALETTE;
			length = COLOR_PALETTE.length;
		} else {
			var axisIndex = (valueAxisID === 'valueAxis') ? 0 : 1;
			colorPalette = DUAL_COLOR_PALETTE[axisIndex];
			length = colorPalette.length;
		}
		return {
			actual : colorPalette[ index % length],
			projected : colorPalette[ index % length],
			reference : colorPalette[ index % length]
		};
	};

	var getCallback = function(oTuple, semantics, fnCb) {
		if (oTuple.projectedValueStartTime && oTuple.timeAxis && semantics !== MeasureSemantics.Reference) {
			fnCb = fnCb || function() {
				return true;
			};
			var isContinuous = function(ctx) {
				return ctx.hasOwnProperty(oTuple.semanticMsrName);
			};
			if (semantics === MeasureSemantics.Actual) {
				return function(ctx) {
					return fnCb(ctx) && isContinuous(ctx) && (new Date(ctx[oTuple.timeAxis]).getTime() < oTuple.projectedValueStartTime);
				};
			} else if (semantics === MeasureSemantics.Projected) {
				return function(ctx) {
					return fnCb(ctx) && isContinuous(ctx) && (new Date(ctx[oTuple.timeAxis]).getTime() >= oTuple.projectedValueStartTime);
				};
			}
		} else {
			fnCb = fnCb || function(ctx){
				return ctx.hasOwnProperty(oTuple[semantics]);
			};
			return fnCb;
		}
	};

	var getColor = function(oTuple, oColorings, semanticRole, options) {
		var colors, color;
		if (oColorings) {
			if (oTuple.iUnMentionedIndex == undefined) {
				// unMentioned measure in tuple with coloring
				color = SINGLE_NEUTRAL_COLOR;
			} else {
				colors = ColoringUtils.assignUnmentionedColor(ColorPalette.CRITICALITY.Neutral, options.unMentionedTuplesNumber);
				color = colors[oTuple.iUnMentionedIndex];
			}
		} else {
			if (semanticRole === MeasureSemantics.Reference && options.hasSingleReference) {
				color = SINGLE_TARGET_COLOR;
			} else {
				colors = getColorsBySemanticPattern(options.chartType, oTuple.index, oTuple.valueAxisID);
				color = colors[semanticRole];
			}
		}
		return color;
	};

	var generateRulesBySemanticRole = function(oTuple, oColorings, semanticRole, semanticProps, options) {
		var color, oColoringSetting, dataName = {}, oProps;
		var sMsrName = oTuple[semanticRole];
		var sColoringType;

		(oColorings || []).forEach(function(oSetting) {
			if (oSetting.parsed.msr && oSetting.parsed.msr.getName() === sMsrName) {
				oColoringSetting = oSetting.parsed;
				sColoringType = oSetting.type;
			}
		});

		var	sLabel = (oTuple.labels && oTuple.labels[semanticRole]) ? oTuple.labels[semanticRole] : sMsrName;
		if (oTuple.semanticMsrName && (semanticRole === MeasureSemantics.Actual || semanticRole === MeasureSemantics.Projected)) {
			dataName[oTuple.semanticMsrName] = sLabel;
		}

		if (oColoringSetting) {
			// handle measure with Coloring
			aMeasureLegendOrder.forEach(function(sCriticalityType) {
				var aCbs = oColoringSetting.callbacks[sCriticalityType];
				if (aCbs) {
					var fnCallback = getCallback(oTuple, semanticRole, aCbs[0]);
					color = ColoringUtils.assignColor(ColorPalette.CRITICALITY[sCriticalityType], aCbs.length)[0];
					oProps = {
						"color": color,
						"pattern": PATTERN[semanticRole]
					};
					if (ChartUtils.CONFIG.lineChartType.indexOf(options.chartType) > -1) {
						oProps.lineType = LINE_TYPE[semanticRole];
						if (sColoringType === 'Static') {
							oProps.lineColor = color;
						}
					}
					addDataPointStyleRules(semanticProps, {
						"callback": fnCallback,
						"properties": oProps,
						"displayName": oColoringSetting.legend[sCriticalityType],
						"dataName": dataName
					});
				}
			});
		} else {
			if (!oColorings || oColorings.bShowUnmentionedMsr) {
				var fnCallback = getCallback(oTuple, semanticRole);
				color = getColor(oTuple, oColorings, semanticRole, options);

				oProps = {
					'color': color,
					"pattern": PATTERN[semanticRole]
				};

				if (ChartUtils.CONFIG.lineChartType.indexOf(options.chartType) > -1) {
					oProps.lineType = LINE_TYPE[semanticRole];
					oProps.lineColor = color;
				}

				addDataPointStyleRules(semanticProps, {
					"callback": fnCallback,
					"properties": oProps,
					"displayName": sLabel,
					"dataName": dataName
				});
			}
		}
	};

	var isReferenceTuple = function(tuple){
		return tuple.reference && (!(tuple.actual || tuple.projected));
	};

	var generateRulesByTuples = function(aTuples, oColorings, semanticProps, chartType) {
		var hasSingleReference = (aTuples.filter(function(oTuple) {
			return oTuple.reference;
		}).length === 1);

		var iUnMentionedTuples = aTuples.filter(function(oTuple) {
			return oTuple.hasOwnProperty('iUnMentionedIndex');
		}).length;

		aTuples.forEach(function(oTuple) {
			oTuple.order.forEach(function(semanticRole) {
				var bNeedSemanticRule = true;
				if (chartType.indexOf('bullet') > -1) {
					bNeedSemanticRule = (semanticRole !== MeasureSemantics.Reference || isReferenceTuple(oTuple));
				}
				if (oTuple.hasOwnProperty(semanticRole) && bNeedSemanticRule) {
					var options = {
						chartType: chartType,
						hasSingleReference: hasSingleReference,
						unMentionedTuplesNumber: iUnMentionedTuples
					};
					generateRulesBySemanticRole(oTuple, oColorings, semanticRole, semanticProps, options);
				}
			});
		});
	};

	var getSemanticVizSettings = function(chartType, semanticTuples, semanticColorings, bEnablePattern, bDataPointStyleSetByUser, bLegendSetByUser) {
		semanticColorings = semanticColorings || {};
		var bCriticalityMeasureValues =
		    (semanticColorings.type === ColoringType.Criticality &&
			semanticColorings.subType === "MeasureValues" &&
			!(semanticColorings.qualifiedSettings && semanticColorings.qualifiedSettings.bMBC));
		var oProps = {
		};
		if (!bDataPointStyleSetByUser) {
			// if user once set dataPointStyle, do not empty it since vizFrame may cache it when lw-uvb is pending for creation
			oProps.plotArea = {
				dataPointStyle: null
			};
		}
		if (!bLegendSetByUser) {
			oProps.legend = {
				title: {
					text: null,
					//hard code template value here since it is not available in Analtyical Chart level
					visible: chartType.indexOf('waterfall') > -1 ? true : false
				}
			};
		}

		var oScales, replace = true;
		if ((bEnablePattern && hasSemanticRelation(semanticTuples)) || bCriticalityMeasureValues) {
			var aColorings = bCriticalityMeasureValues ? semanticColorings.qualifiedSettings : null;
			generateRulesByTuples(semanticTuples, aColorings, oProps.plotArea, chartType);
			jQuery.extend(true, oProps.legend, Criticality.getLegendProps(aColorings));
		} else if (semanticColorings.ruleGenerator) {
			try {
				var rule = semanticColorings.ruleGenerator();
				jQuery.extend(true, oProps, rule.properties);
				oScales = rule.colorScale;
			} catch (e) {
				if (e instanceof ChartLog) {
					e.display();
				} else {
					throw e;
				}
			}
		}
		if (oScales) {
			replace = false;
		}
		return {
			properties: oProps,
			scales: oScales ? [oScales] : [],
			replaceColorScales: replace
		};
	};

	function hasSemanticRelation(aTuples) {
		if (aTuples) {
			return aTuples.some(function(oTuple) {
				return oTuple.hasOwnProperty(MeasureSemantics.Projected)
				|| oTuple.hasOwnProperty(MeasureSemantics.Reference);
			});
		}
		return false;
	}

	return {
		getTuples: function(aMsrs, aInvisibleMsrs, isRestored) {
			return makeTuples(aMsrs, calc(aMsrs, aInvisibleMsrs), isRestored);
		},
		getSemanticVizSettings : getSemanticVizSettings,
		hasSemanticRelation: hasSemanticRelation
	};
});

}; // end of sap/chart/utils/MeasureSemanticsUtils.js
if ( !jQuery.sap.isDeclared('sap.chart.utils.RoleMapper') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.chart.utils.RoleMapper'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/utils/RoleMapper",[
	'sap/chart/data/TimeDimension',
	'sap/chart/utils/MeasureSemanticsUtils',
	'sap/chart/utils/ChartUtils',
	'sap/chart/utils/DateFormatUtil',
	'sap/chart/data/MeasureSemantics',
	'sap/chart/ChartLog'
], function(
	TimeDimension,
	MeasureSemanticsUtils,
	ChartUtils,
	DateFormatUtil,
	MeasureSemantics,
	ChartLog
) {
	"use strict";

	function RoleMapper(sFeedingId) {
		this._bTimeFed = false;
	}

	RoleMapper.prototype.toFeedingId = function(oDim) {
		if (oDim instanceof TimeDimension && !this._bTimeFed) {
			this._bTimeFed = true;
			return "timeAxis";
		} else {
			return "@context";
		}
	};

	function isTimeChart(chartType) {
		return ChartUtils.CONFIG.timeChartTypes.indexOf(chartType) > -1;
	}

	function semanticBulletMsrs(aSemanticTuples, mMsrs, oMsrFeeds) {
		var oSemFeeds = {
			actualValues: [],
			targetValues: []
		};

		jQuery.each(aSemanticTuples, function(idx, oTuple) {
			if (oTuple.actual) {
				oSemFeeds.actualValues.push(mMsrs[oTuple.actual]);
				oTuple.valueAxisID = 'actualValues';
			}
			if (oTuple.projected) {
				oSemFeeds.actualValues.push(mMsrs[oTuple.projected]);	
				oTuple.valueAxisID = 'actualValues';
			}
			if (oTuple.reference) {
				if ((oTuple.actual || oTuple.projected)) {
					oSemFeeds.targetValues.push(mMsrs[oTuple.reference]);
					oTuple.valueAxisID = 'targetValues';
				} else {
					oSemFeeds.actualValues.push(mMsrs[oTuple.reference]);	
					oTuple.valueAxisID = 'actualValues';
				}
			}
		});

		delete oMsrFeeds["@semanticBulletMsrs"];

		jQuery.extend(oMsrFeeds, oSemFeeds);
	}

	function buildBulletMsrs(aSemanticTuples, oMsrFeeds){
		var aMsrs = oMsrFeeds["@semanticBulletMsrs"];
		if (aMsrs) {
			var oFeeds = {
				actualValues: []
			};
			for (var i = 0 ; i < aMsrs.length; i++) {
				oFeeds.actualValues.push(aMsrs[i]);
			}

			for (var i = 0 ; i < aSemanticTuples.length; i++) {
				aSemanticTuples[i].valueAxisID = 'actualValues';
			}

			delete oMsrFeeds["@semanticBulletMsrs"];

			jQuery.extend(oMsrFeeds, oFeeds);
		}
	}

	RoleMapper.semantics = {
		hasSemanticMeasures : function(oFeeds){
			return Object.keys(oFeeds.msrs).some(function(key){
				var result = false;
				var aMsrs = oFeeds.msrs[key];
				result = aMsrs.some(function(msr){
					if (msr.getSemantics) {
						var role = msr.getSemantics();
						return role && role !== 'actual';
					}
				});
				return result;
			});
		},
		semanticPatternMsrs : function(oFeeds, chartType, bIsInValidatedSemanticPattern){
			var aAllSemanticTuples = [], aAllSemanticContext = [], mMsrs = {}, hasValidSemanticRules, chartLog;
			//No color feeds and time axis's max size is 1
			var hasContinuesSemanticRules = isTimeChart(chartType) && (oFeeds.dims.timeAxis && oFeeds.dims.timeAxis.length === 1);

			var aMsrFeedingOrder = ['valueAxis', 'valueAxis2'];
			var aMsrFeedings = Object.keys(oFeeds.msrs).sort(function(sFeedA, sFeedB) {
				return aMsrFeedingOrder.indexOf(sFeedA) - aMsrFeedingOrder.indexOf(sFeedB);
			});
			var hasSemanticRules = this.hasSemanticMeasures(oFeeds);
			//Build internal semantic tuples structure. 
			aMsrFeedings.forEach(function(key){
				var aMsrs = oFeeds.msrs[key], aInvisibleMsrs;
				//Get a new Object which use measure name as key
				jQuery.extend(true, mMsrs, aMsrs.reduce(function(mMsrs, oMsr) {
					mMsrs[oMsr.getName()] = oMsr;
					return mMsrs;
				}, {}));

				if (chartType && chartType.indexOf('bullet') > -1 && oFeeds.invisibleMsrs) {
					aInvisibleMsrs = oFeeds.invisibleMsrs.filter(function(oMsr){
						return oMsr.getSemantics() === 'actual' && oMsr.getSemanticallyRelatedMeasures();
					});
				}

				if (jQuery.isEmptyObject(oFeeds.dims)) {
					chartLog = new ChartLog('error', 'Semantic Pattern', 
						"Semantic Pattern doesn't work when there is no dimension.");
					bIsInValidatedSemanticPattern = bIsInValidatedSemanticPattern || true;
				} else if (oFeeds.dims.color && oFeeds.dims.color.length > 0) {
					chartLog = new ChartLog('error', 'Semantic Pattern', 
						"Semantic pattern doesn't work when there is series dimension.");
					bIsInValidatedSemanticPattern = bIsInValidatedSemanticPattern || true;
				}

				var aSemanticTuples = MeasureSemanticsUtils.getTuples(aMsrs, aInvisibleMsrs, bIsInValidatedSemanticPattern);
				
				// hasSemanticRules = aSemanticTuples.filter(function(tuple){
				// 	//Only have actual meausre
				// 	return tuple.actual && !tuple.projected && !tuple.reference;
				// }).length !== aMsrs.length;
				
				aSemanticTuples.forEach(function(value){
					value.valueAxisID = key;
				});
				if (hasSemanticRules && bIsInValidatedSemanticPattern && chartLog) {
					chartLog.display();
				}
				aAllSemanticTuples = aAllSemanticTuples.concat(aSemanticTuples);
			});

			//Handle bullet chart
			if (chartType && chartType.indexOf('bullet') > -1) {
				hasContinuesSemanticRules = hasContinuesSemanticRules &&
					aAllSemanticTuples.some(function(tuple){
						return tuple.actual && tuple.projected;
					});
				hasValidSemanticRules = aAllSemanticTuples.some(function(tuple){
					return (tuple.actual && tuple.projected) || 
						(tuple.actual && tuple.reference) ||
						(tuple.projected && tuple.reference);
				});
				if (hasValidSemanticRules && (!hasContinuesSemanticRules)) {
					//Bullet has semantic relation. Bullet's feed should be changed.
					semanticBulletMsrs(aAllSemanticTuples, mMsrs, oFeeds.msrs);
				} else {
					//If no semantic relation, draw as simple bar. 
					buildBulletMsrs(aAllSemanticTuples, oFeeds.msrs);
				}
			}
					
			if ((!bIsInValidatedSemanticPattern) && hasContinuesSemanticRules) {
				var aSemanticContext = [];
				var filterContextMsr = function(oMsr){
					var filter = aSemanticContext.indexOf(oMsr.getName()) === -1;
					if (!filter) {
						aAllSemanticContext.push(oMsr);
					}
					return filter;
				};
				for (var i = 0 ; i < aAllSemanticTuples.length; i++) {
					var tuple = aAllSemanticTuples[i];					
					var timeAxis = oFeeds.dims.timeAxis[0];
					
					var projectedValueStartTime = timeAxis.getProjectedValueStartTime();
					if (projectedValueStartTime) {
						//Format startTime value according with timeUnit setting	
						var timeUnit = timeAxis.getTimeUnit(), startTime;
						if (timeUnit === 'fiscalyearperiod' || timeUnit === 'fiscalyear') {
							startTime = projectedValueStartTime;
						} else {
							var oDateInstance = DateFormatUtil.getInstance(timeUnit);
							if (oDateInstance) {
								if (oDateInstance.parse(projectedValueStartTime)) {
									startTime = oDateInstance.parse(projectedValueStartTime).getTime();
								}
							} else {
								startTime = new Date(projectedValueStartTime).getTime();
							}
						}
						if (startTime) {
							var oCurMsr = oFeeds.msrs[tuple.valueAxisID];
							if (tuple.actual && tuple.projected) {
								tuple.timeAxis = oFeeds.dims.timeAxis[0].getName();
								tuple.projectedValueStartTime = startTime;
								tuple.semanticMsrName = tuple.actual + "-" + tuple.projected;
								aSemanticContext.push(tuple.actual);
								aSemanticContext.push(tuple.projected);
								oCurMsr.push(mMsrs[tuple.actual].clone().setName(tuple.semanticMsrName));
							}
							oFeeds.msrs[tuple.valueAxisID] = oCurMsr.filter(filterContextMsr);			
						} else {
							chartLog = new ChartLog('error', 'Semantic Pattern', "The value of projectedValueStartTime is invalid.");
							chartLog.display();
						}
					}
				}
			}
			if ((aAllSemanticTuples.length > 0) && (!bIsInValidatedSemanticPattern)) {
				//Reorder feed's measures
				var aAllSemanticTuplesList = [];
				var aMsrOrder = ['actual', 'projected', 'semanticMsrName', 'reference'];

				aAllSemanticTuples.forEach(function(elem){
					for (var i = 0; i < aMsrOrder.length; i++) {
						if (elem[aMsrOrder[i]]) {
							aAllSemanticTuplesList.push(elem[aMsrOrder[i]]);	
						}
					}
				});
				jQuery.each(oFeeds.msrs, function(key){
					oFeeds.msrs[key].sort(function(a, b){
						return aAllSemanticTuplesList.indexOf(a.getName()) - aAllSemanticTuplesList.indexOf(b.getName());
					});
				});
			}

			return {
				semanticTuples : aAllSemanticTuples,
				contexts: aAllSemanticContext
			};
		}
	};

	return RoleMapper;
});

}; // end of sap/chart/utils/RoleMapper.js
if ( !jQuery.sap.isDeclared('sap.chart.coloring.Colorings') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.chart.coloring.Colorings'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/coloring/Colorings",[
	"sap/chart/coloring/criticality/Criticality",
	"sap/chart/coloring/emphasis/Emphasis",
	'sap/chart/ChartLog'
], function(
	Criticality,
	Emphasis,
	ChartLog
) {
	"use strict";

	var SUPPORTED_TYPES = ['Criticality', 'Emphasis'];

	function checkColoring(oColorings, oActiveColoring, oDimMsr) {
		var inResultDim = oDimMsr.aInResultDim,
			sColoring = oActiveColoring.coloring || null;
		if (inResultDim && inResultDim.length) {
			//clid1
			throw new ChartLog('error', '', "Semantic coloring could not be applied if inResult Dimensions exist.");
		}
		if (!oActiveColoring || !oActiveColoring.coloring) {
			//clid2
			throw new ChartLog('error', 'activeColoring', "The activeColoring is mandatory.");
		}
		if (SUPPORTED_TYPES.indexOf(sColoring) < 0) {
			//clid3
			throw new ChartLog('error', 'activeColoring', "The active coloring type, " + sColoring + ", is not supported.");
		} else if (Object.keys(oColorings).indexOf(sColoring) < 0){
			//clid4
			throw new ChartLog('error', 'activeColoring', "The active coloring type, " + sColoring + ", should be configured in Coloring.");
		}
	}

	function skipTimeBullet(aMsr){
		if (aMsr.length <= 1) {
			return false;
		}
		if (aMsr.length > 2) {
			return true;
		} 

		var actual, reference, error = false;
		aMsr.forEach(function(e){
			var name = e.getSemantics();
			if (name === "actual" && !actual) {
				actual = e;
			} else if (name === "reference" && !reference) { 
				reference = e;
			} else {
				error = true;
			}	
		});

		error = error || (actual && reference && actual.getSemanticallyRelatedMeasures() !== reference.getName());
		return error;
	}

	return {
		getCandidateSetting: function(oColorings, oActiveColoring, aTuples, oDimMsr, oStatus, sChartType, oLocale, ops) {
			checkColoring(oColorings, oActiveColoring || {}, oDimMsr);
			var coloringClz, options = {},
				colorMapping = {
					'Criticality': Criticality,
					'Emphasis': Emphasis
				};
			coloringClz = colorMapping[oActiveColoring.coloring];
			options.bMBC = sChartType === "heatmap";
			options.bShowUnmentionedMsr = !(sChartType && sChartType.indexOf("scatter") > -1 || 
											sChartType && sChartType.indexOf("bubble") > -1);
			options.bIsPie = sChartType === "pie" || sChartType === "donut";
			options.bWaterfall = sChartType && sChartType.indexOf("waterfall") > -1;
			options.bTimeChart = sChartType && sChartType.indexOf("timeseries") > -1;
			jQuery.extend(true, options, ops);
			if (sChartType === "timeseries_bullet" && skipTimeBullet(oDimMsr.aMsr)) {
				return {};
			}

			if (coloringClz) {
				var oCandidateSetting = coloringClz.getCandidateSetting(oColorings, oActiveColoring, aTuples, oDimMsr, oStatus, options, oLocale);
				oCandidateSetting.type = oActiveColoring.coloring;
				return oCandidateSetting;
			} else {
				return {};
			}
		}
	};
});
}; // end of sap/chart/coloring/Colorings.js
if ( !jQuery.sap.isDeclared('sap.chart.utils.RoleFitter') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.chart.utils.RoleFitter'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.viz.ui5.data.DimensionDefinition'); // unlisted dependency retained
jQuery.sap.require('sap.viz.ui5.data.MeasureDefinition'); // unlisted dependency retained
jQuery.sap.require('sap.viz.ui5.controls.common.feeds.FeedItem'); // unlisted dependency retained
jQuery.sap.require('sap.viz.ui5.controls.common.feeds.AnalysisObject'); // unlisted dependency retained
sap.ui.define("sap/chart/utils/RoleFitter",[
	'sap/viz/ui5/data/DimensionDefinition',
	'sap/viz/ui5/data/MeasureDefinition',
	'sap/viz/ui5/controls/common/feeds/FeedItem',
	'sap/viz/ui5/controls/common/feeds/AnalysisObject',
	'sap/chart/TimeUnitType',
	'sap/chart/utils/DateFormatUtil',
	'sap/chart/utils/ChartUtils',
	'sap/chart/utils/RoleMapper',
	'sap/chart/ChartLog'
], function(
	DimensionDefinition,
	MeasureDefinition,
	FeedItem,
	AnalysisObject,
	TimeUnitType,
	DateFormatUtil,
	ChartUtils,
	RoleMapper,
	ChartLog
) {
	"use strict";

	var suggestFeeds = function() {
		return sap.viz.vizservices.BVRService.suggestFeeds.apply(null, arguments);
	};
	var validateFeeds = function(chartType, feedItems) {
		var oResults = sap.viz.vizservices.FeedService.validate(chartType, feedItems);
		if (!oResults.valid) {
			var bindings = oResults.results ? oResults.results.bindings : null;
			if (bindings && Object.keys(bindings).every(function(item) {
					return bindings[item].allowMND && (!bindings[item].missing || bindings[item].missing === 1) && !bindings[item].incorrect;
				})) {
				// previously we suggest mnd to check feeding, but BVR will remove invalid feeding items in some case
				// currently for case whose feeding only miss mnd, we let it pass directly
				return {
					valid: true
				};
			}
		}
		return oResults;
	};
	
	var _mRoleFeedMapping = [
		{"types":"*","toViz":{"category|category2":"categoryAxis","series":"color","axis1|axis2|axis3|axis4":"valueAxis"}},
		{"types":"column|bar|stacked_bar|stacked_column|line|combination|100_stacked_bar|100_stacked_column|stacked_combination|horizontal_stacked_combination","toViz":{}},
		{"types":"scatter|bubble|time_bubble|timeseries_scatter|timeseries_bubble","toViz":{"category|category2":"@context","axis1":"valueAxis","axis2":"valueAxis2"}},
		{"types":"bubble|time_bubble","toViz":{"axis3":"bubbleWidth"}},
		{"types":"pie|donut","toViz":{"category|series|category2":"color","axis1|axis2|axis3|axis4":"size"}},
		{"types":"bullet|vertical_bullet","toViz":{"axis1|axis2|axis3|axis4": "@semanticBulletMsrs"}},
		{"types":"dual_combination|dual_horizontal_combination|dual_stacked_bar|100_dual_stacked_bar|dual_stacked_column|100_dual_stacked_column|dual_bar|dual_column|dual_line|dual_stacked_combination|dual_horizontal_stacked_combination","toViz":{"axis1":"valueAxis","axis2|axis3|axis4":"valueAxis2"}},
		{"types":"timeseries_line|timeseries_column|timeseries_combination|timeseries_stacked_column|timeseries_100_stacked_column","toViz":{"category":"timeAxis"}},
		{"types":"timeseries_scatter","toViz":{"category":RoleMapper,"axis2|axis3":false}},
		{"types":"timeseries_bubble","toViz":{"category":RoleMapper,"axis2":false,"axis3":"bubbleWidth"}},
		{"types":"dual_timeseries_combination","toViz":{"category":"timeAxis", "axis1":"valueAxis", "axis2|axis3|axis4":"valueAxis2"}},
		{"types":"heatmap","toViz":{"category":"categoryAxis","category2|series":"categoryAxis2","axis1|axis2|axis3|axis4":"color"}},
		{"types":"waterfall|horizontal_waterfall","toViz":{"series":"waterfallType"}},
		{"types":"timeseries_bullet","toViz":{"category|series":"timeAxis", "axis1|axis2|axis3|axis4": "@semanticBulletMsrs"}},
		{"types":"timeseries_waterfall","toViz":{"category|series":"timeAxis"}}
	].reduce(function(m, row) {
		var cfg = Object.keys(row.toViz).reduce(function(cfg, roles) {
			roles.split("|").forEach(function(r) {
				cfg[r] = row.toViz[roles];
				return cfg;
			});
			return cfg;
		}, {});
		row.types.split("|").forEach(function(type) {
			if (!m.hasOwnProperty(type)) {
				m[type] = [];
			}
			m[type].push(cfg);
		});
		return m;
	}, {});

	var _mRoleLookUp = Object.keys(_mRoleFeedMapping).reduce(function(m, type) {
		if (type !== "*") {
			m[type] = jQuery.extend.apply(null, [true, {}].concat(_mRoleFeedMapping["*"].concat(_mRoleFeedMapping[type])));
		}
		return m;
	}, {});

	function _groupBy(aList, oKey, fnVal) {
		var keyFn = (typeof oKey === "function") ? oKey : function(obj) {
			return obj[oKey];
		};
		return aList.reduce(function(oGrouped, oElement) {
			var key = keyFn(oElement),
				val = (typeof fnVal === "function") ? fnVal(oElement) : oElement;
			if (key && !oGrouped[key]) {
				oGrouped[key] = [val];
			} else if (key) {
				oGrouped[key].push(val);
			}
			return oGrouped;
		}, {});
	}

	function _calibrate(mDef, aDimsOrMsrs) {
		var oGrouped = {}, mRoleMapping;
		aDimsOrMsrs.forEach(function(v){
			var role = v._sFixedRole || v.getRole();
			if (mDef.hasOwnProperty(role)) {
				var key = mDef[role];
				if (key) {
					if (typeof key === "function") {
						if (!mRoleMapping) {
							mRoleMapping = new key();
						}
						key = mRoleMapping.toFeedingId(v);
					}
					if (!oGrouped[key]) {
						oGrouped[key] = [];
					}
					oGrouped[key].push(v);
				}
			}
		});
		return oGrouped;
	}

	var LwFeed = {
		from: FeedItem.fromLightWeightFmt,
		build: function(oObject) {
			var aLwFeeds = [];
			jQuery.each(oObject.dims, function(k, v) {
				aLwFeeds.push({
					id: k,
					type: "Dimension",
					values: v.map(analysisObjectFmt("Dimension"))
				});
			});
			jQuery.each(oObject.msrs, function(k, v) {
				aLwFeeds.push({
					id: k,
					type: "Measure",
					values: v.map(analysisObjectFmt("Measure"))
				});
			});
			return aLwFeeds;
		}
	};

	function analysisObjectFmt(sType) {
		return function(oDorM) {
			var sId = oDorM.getName();
			if (sId === "MND") {
				// feeding MND is special, its type is not Dimension
				return {
					id: "MND",
					type: "MND"
				};
			}
			var analysisObj = {
				id: sId,
				name: sId,
				type: sType
			};

			if (oDorM instanceof sap.chart.data.TimeDimension) {
				analysisObj.dataType = "Date";
			}

			return analysisObj;
		};
	}

	function wrapDimension(oDimension, isTimeChart) {
		var sName = oDimension.getName(),
			sLabel = oDimension.getLabel(),
			sText = oDimension.getTextProperty(),
			fFormatter = oDimension.getTextFormatter(),
			bDisplyaText = oDimension.getDisplayText();
		var oDimConfig = {
			identity: sName,
			name: sLabel || sName,
			value: "{" + sName + "}"
		};

		if (typeof fFormatter === "function") {
			oDimConfig.displayValue = {
				formatter: fFormatter,
				parts: [{
					path: sName,
					type: new sap.ui.model.type.String()
				}]
			};
			if (sText) {
				oDimConfig.displayValue.parts.push({
					path: sText,
					type: new sap.ui.model.type.String()
				});
			}
		} else if (bDisplyaText && sText) {
			oDimConfig.displayValue = "{" + sText + "}";
		}

		var oDimensionDefinition = new DimensionDefinition(oDimConfig);
		if (isTimeChart && oDimension instanceof sap.chart.data.TimeDimension) {
			var oDateInstance = DateFormatUtil.getInstance(oDimension.getTimeUnit());
			if (oDateInstance) {
				var fnParser = oDateInstance.parse.bind(oDateInstance);
				oDimensionDefinition.getBindingInfo("value").formatter = function(oValue) {
					return fnParser(oValue);
				};				
			}

			oDimensionDefinition.setDataType("Date");
			oDimensionDefinition._setTimeUnit(oDimension.getTimeUnit());
		}
		return oDimensionDefinition;
	}

	function wrapMeasure(oMeasure) {
		var sName = oMeasure.getName();

		var oMsrDef = new MeasureDefinition({
			identity: sName,
			name: oMeasure.getLabel() || sName,
			value: "{" + sName + "}"
		});
		oMsrDef._setUnitBinding(oMeasure.getUnitBinding());
		return oMsrDef;
	}

	function dimOrder(sChartType, aFeeds) {
		var oMetadata = sap.viz.api.metadata.Viz.get("info/" + sChartType),
			mBindings = _groupBy(oMetadata.bindings, "role"),
			mFeeds = _groupBy(aFeeds, "id"),
			aCatFeeds = mBindings["layout.category"] || [],
			aSerFeeds = mBindings["mark.color"] || [];

		if (aCatFeeds.length === 0) {
			return [];
		} else {
			var aOrder = [];

			jQuery.each(aCatFeeds.concat(aSerFeeds), function(id, oBnd) {
				var oFeed = mFeeds[oBnd.id];
				if (oFeed && oFeed.length > 0) {
					jQuery.each(oFeed[0].values, function(iid, oVal) {
						aOrder.push(oVal.id);
					});
				}
			});

			return aOrder;
		}
	}

	function isTimeChart(chartType) {
		return ChartUtils.CONFIG.timeChartTypes.indexOf(chartType) > -1;
	}

	function isBulletChart(chartType) {
		return chartType && chartType.indexOf('bullet') > -1 ;
	}

	function checkInvisibleMsrsSemantic(aInvisibleMeasures) {
		jQuery.each(aInvisibleMeasures, function(id, oMsr) {
			if (oMsr && (oMsr.getSemantics && oMsr.getSemantics() !== 'actual' ||
				oMsr.getSemanticallyRelatedMeasures && !jQuery.isEmptyObject(oMsr.getSemanticallyRelatedMeasures()))) {
				new ChartLog('error', 'Semantic Pattern', " Semantic pattern rule defined in invisible measures doesn't work.").display();
			}
		});
	}

	function fitBasic(sChartType, aDimensions, aMeasures, bEnableSemanticPattern, aInvisibleMeasures) {
		var mRoleToFeed = _mRoleLookUp[sChartType];
		var oMapped = {
			dims: _calibrate(mRoleToFeed, aDimensions),
			msrs: _calibrate(mRoleToFeed, aMeasures)
		};
		if (isBulletChart(sChartType)) {
			oMapped.invisibleMsrs = aInvisibleMeasures;
		} else {
			checkInvisibleMsrsSemantic(aInvisibleMeasures);
		}
		var aContexts = null, oSemanticsMsrsRules = null;

		if (oMapped.dims["@context"]) {
			aContexts = oMapped.dims["@context"];
			delete oMapped.dims["@context"];
		}
		
		var bIsInValidatedSemanticPattern = false;
		if (!bEnableSemanticPattern) {
			if (RoleMapper.semantics.hasSemanticMeasures(oMapped)){
				var chartLog;
				if (ChartUtils.CONFIG.nonSemanticPatternChartType.indexOf(sChartType) === -1) {
					chartLog = new ChartLog('error', 'Semantic Pattern', "Semantic pattern doesn't work when there is dataPointStyle or seriesStyle defined.");
					bIsInValidatedSemanticPattern = true;
				} else {
					chartLog = new ChartLog('error', 'Semantic Pattern', sChartType + " doesn't support semantic pattern feature.");	
					bIsInValidatedSemanticPattern = true;
				}
				chartLog.display();
			}		
		}
		oSemanticsMsrsRules = RoleMapper.semantics.semanticPatternMsrs(oMapped, sChartType, bIsInValidatedSemanticPattern);
		aContexts = (aContexts || []).concat(oSemanticsMsrsRules.contexts);	
		
		var aFeeds = LwFeed.build(oMapped);
		aFeeds.contexts = aContexts;
		aFeeds.semanticTuples = oSemanticsMsrsRules.semanticTuples;	

		return aFeeds;
	}

	var INRESULT_SUPPORT = [{
		chartTypes: "bar,column,line,combination,heatmap,bullet,vertical_bullet,stacked_bar,stacked_column,stacked_combination,horizontal_stacked_combination,dual_bar,dual_column,dual_line,dual_stacked_bar,dual_stacked_column,dual_combination,dual_horizontal_combination,dual_stacked_combination,dual_horizontal_stacked_combination,100_stacked_bar,100_stacked_column,100_dual_stacked_bar,100_dual_stacked_column,waterfall,horizontal_waterfall".split(","),
		feed: "categoryAxis"
	}, {
		chartTypes: "donut,pie,scatter,bubble".split(","),
		feed: "color"
	}];
	
	function appendInResults(sChartType, aFeeds, aInResults) {
		var i, sFeedId;
		for (i = 0; i < INRESULT_SUPPORT.length; i++) {
			if (INRESULT_SUPPORT[i].chartTypes.indexOf(sChartType) !== -1) {
				sFeedId = INRESULT_SUPPORT[i].feed;
				break;
			}
		}

		var bHasAppendableFeed = aFeeds.some(function(oFeed) {
			return oFeed.id === sFeedId;
		});
		// no visible dimension, reconstruct feedItems with MND
		if (!bHasAppendableFeed) {
			var aFeedsWithMND = suggestFeeds("info/" + sChartType, aFeeds, [{id:"MND",type:"MND"}]).feedItems;
			aFeeds.splice(0, aFeeds.length);
			aFeedsWithMND.forEach(function(oFeed) {
				if (oFeed.values.length > 0) {
					aFeeds.push(oFeed);
				}
			});
			aFeeds = enforceFeedType(sChartType, aFeeds);
		}
		for (i = 0; i < aFeeds.length; i++) {
			if (aFeeds[i].id === sFeedId && aFeeds[i].type === "Dimension") {
				aFeeds[i].values = aFeeds[i].values.concat(aInResults.map(function(oDim) {
					return {id: oDim.getName(), name: oDim.getName(), type: "Dimension", inResult: true};
				}));
			}
		}

		return validateFeeds("info/" + sChartType, aFeeds);
	}

	function resetFixedRole(aDorMs) {
		aDorMs.forEach(function(oDorM) {
			oDorM._sFixedRole = oDorM.getRole();
		});
	}

	function fixRole(sChartType, aFeeds, aDorMs) {
		aFeeds.forEach(function(oFeed) {
			oFeed.values.forEach(function(oFeedItem) {
				var oDorM = aDorMs.filter(function(oDorM) {
					return oDorM.getName() === oFeedItem.id;
				})[0];
				if (oDorM) {
					jQuery.each(_mRoleLookUp[sChartType], function(key, val) {
						if (val === oFeed.id) {
							oDorM._sFixedRole = key;
							return false;
						}
					});
				}
			});
		});
	}

	function isValidSemantic(sChartType, semanticTuples){
		//TODO hard code to handle time bullet with MND.
		var isValid = sChartType.indexOf('timeseries_bullet') === -1;
		if (!isValid) {
			isValid = semanticTuples.length > 1 && semanticTuples.every(function(element){
				return (element.actual && element.reference) || (element.projected && element.reference);
			});
		}

		return isValid;
	}

	function fit(sChartType, aDimensions, aMeasures, aInResults, bEnableSemanticPattern, aInvisibleMeasures) {
		var aDorMs = aDimensions.concat(aMeasures).concat(aInResults);
		resetFixedRole(aDorMs);

		var aFeeds = fitBasic(sChartType, aDimensions, aMeasures, bEnableSemanticPattern, aInvisibleMeasures);
		var oValidation = validateFeeds("info/" + sChartType, aFeeds);
		var aContexts = aFeeds.contexts, 
			semanticTuples = aFeeds.semanticTuples,
			continueSemanticTuples = [];
		
		if (!oValidation.valid) {
			aFeeds = fix(sChartType, oValidation, aFeeds, aDimensions, aMeasures);
			oValidation = validateFeeds("info/" + sChartType, aFeeds);

			// store fixed role in Dimension/Measure if fixed by BVR
			fixRole(sChartType, aFeeds, aDorMs);

			if (ChartUtils.CONFIG.nonSemanticPatternChartType.indexOf(sChartType) === -1 && bEnableSemanticPattern) {
				//Rebuild semantic pattern rules and feeds because of feed has been fixed. 
				if (isValidSemantic(sChartType, semanticTuples)) {
					aFeeds = fitBasic(sChartType, aDimensions, aMeasures, bEnableSemanticPattern);
					aContexts = aFeeds.contexts;
					semanticTuples = aFeeds.semanticTuples;
				}
			}
		} else {
			fixRole(sChartType, aFeeds, aDorMs);
		}
		

		if (semanticTuples) {
			continueSemanticTuples = semanticTuples.filter(function(tuple){
				return tuple.projectedValueStartTime;
			});
		}

		if (oValidation.valid && aInResults && aInResults.length > 0) {
			var mVisDims = _groupBy(aDimensions, function(o) {return o.getName();});
			appendInResults(sChartType, aFeeds, aInResults.filter(function(oDim) {
				return !mVisDims[oDim.getName()];
			}));
		}

		var	mVisibles = aFeeds.reduce(function(map, f) {
			f.values.forEach(function(v) {
				map[v.id] = true;
			});
			return map;
		}, {});

		var aFeedItems = LwFeed.from(aFeeds);

		if (aContexts) {
			aContexts.forEach(function(ctx) {
				mVisibles[ctx.getName()] = true;
			});
			aFeedItems._context = aContexts.map(function(ctx) {
				var name = ctx.getName();
				var isShowInTooltip = true;
				for (var i = 0; i < continueSemanticTuples.length; i++) {
					if (name === continueSemanticTuples[i].actual || name === continueSemanticTuples[i].projected) {
						isShowInTooltip = false;
						break;
					}
				}
				return {
					id : name,
					showInTooltip : isShowInTooltip
				};
			});
		}

		aFeedItems._unused = unUsedDimsOrMsrs(aFeeds, aDimensions, aMeasures).filter(function(name) {
			return !mVisibles[name];
		});
		aFeedItems._def = createDefinitions(aDimensions, oValidation.valid ? aInResults : [], aMeasures, mVisibles, semanticTuples, isTimeChart(sChartType));
		aFeedItems._order = dimOrder(sChartType, aFeeds);
		aFeedItems._valid = oValidation.valid;
		aFeedItems._semanticTuples = semanticTuples;

		return aFeedItems;
	}

	function getBindingMap(sChartType) {
		return _groupBy(sap.viz.api.metadata.Viz.get("info/" + sChartType).bindings, "id");
	}

	function enforceFeedType(sChartType, aFeeds, mBindings) {
		mBindings = mBindings || getBindingMap(sChartType);
		aFeeds.forEach(function(oFeed) {
			oFeed.type = mBindings[oFeed.id][0].type;
		});
		return aFeeds;
	}

	function fix(sChartType, oValidation, aEffectiveFeeds, aDimensions, aMeasures) {
		var mBindings = getBindingMap(sChartType),
			bDimError = false,
			bMsrError = false;
		var mValidationBindings = oValidation.results.bindings;
		Object.keys(mValidationBindings).forEach(function(k) {
			if (!mBindings[k]) {
				return;
			}
			if (mBindings[k][0].type === "Measure") {
				bMsrError = true;
			}
			if (mBindings[k][0].type === "Dimension" && !(mValidationBindings[k].allowMND &&
					(!mValidationBindings[k].missing || mValidationBindings[k].missing === 1))) {
				bDimError = true;
			}
		});
		var aGoodFeeds = aEffectiveFeeds.filter(function(feed) {
			return !((feed.type === "Dimension") ? bDimError : bMsrError);
		}), mGoodDimOrMsr = aGoodFeeds.reduce(function(map, feed) {
			(feed.values || []).forEach(function(v) {
				map[v.id] = true;
			});
			return map;
		}, {});
		if (aEffectiveFeeds.contexts) {
			aEffectiveFeeds.contexts.forEach(function(ctx) {
				mGoodDimOrMsr[ctx.getName()] = true;
			});
		}
		var aDimAnalysisObjs = aDimensions.map(analysisObjectFmt("Dimension")),
			aMsrAnalysisObjs = aMeasures.map(analysisObjectFmt("Measure"));

		var aSuggested = suggestFeeds("info/" + sChartType, aGoodFeeds, aDimAnalysisObjs.concat(aMsrAnalysisObjs).filter(function(ao) {
			return !mGoodDimOrMsr[ao.id];
		})).feedItems;

		enforceFeedType(sChartType, aSuggested, mBindings);

		return aSuggested;
	}

	function unUsedDimsOrMsrs(aFeeds, aDimensions, aMeasures) {
		var	mUsed = aFeeds.reduce(function(map, f) {
			f.values.forEach(function(v) {
				map[v.id] = true;
			});
			return map;
		}, {});

		return aDimensions.concat(aMeasures).filter(function(n) {
			return !mUsed[n.getName()];
		}).map(function(n) {
			return n.getName();
		});
	}

	function createDefinitions(aDimensions, aInResults, aMeasures, mVisibles, aSemanticsMsrsRules, isTimeChart) {
		var oDateInstance;
		if (isTimeChart) {
			var timeAxis;
			for (var i = 0; i < aDimensions.length; i++) {
				if (aDimensions[i] instanceof sap.chart.data.TimeDimension) {
					timeAxis = aDimensions[i];
					break;
				}
			}
			oDateInstance = DateFormatUtil.getInstance(timeAxis.getTimeUnit());
		}
		return {
			dim: aDimensions.reduce(function(aVisibleDimDefs, oDim) {
				if (mVisibles[oDim.getName()]) {
					aVisibleDimDefs.push(wrapDimension(oDim, isTimeChart));
				}
				return aVisibleDimDefs;
			}, []).concat(aInResults.map(function(oDim) {
				var oDimDef = wrapDimension(oDim);
				oDimDef._setInResult(true);
				return oDimDef;
			})),
			msr: aMeasures.reduce(function(aVisibleMsrDefs, oMsr) {
				if (mVisibles[oMsr.getName()]) {
					aVisibleMsrDefs.push(wrapMeasure(oMsr));
				}
				return aVisibleMsrDefs;
			}, []).concat((aSemanticsMsrsRules || []).reduce(function(arr, rule){
				if (rule.timeAxis && rule.projectedValueStartTime) {
					arr.push(new MeasureDefinition({
						identity: rule.actual + "-" + rule.projected,
						name: ((rule.labels && rule.labels.actual) || rule.actual) + "-" + ((rule.labels && rule.labels.projected) || rule.projected),
						value: {
							parts: [rule.timeAxis, rule.actual, rule.projected],
							formatter : function(values) {
								var value = values, time;
								if (values && values.length > 1) {
									var date = values[0];
									if (date) {
										if (oDateInstance) {
											var parsedDate = oDateInstance.parse(date);
											if (parsedDate) {
												time = parsedDate.getTime();
											}
										} else {
											time = new Date(date).getTime();
										}
										if (time && (time < rule.projectedValueStartTime)) {
											value = values[1];
										} else {
											value = values[2];
										}
									}
								}
								return value;
							}
						}
					}));
				}
				return arr;
			}, []))
		};
	}

	return {
		fit: fit,
		compatible: function(sChartType, aDimensions, aMeasures) {
			var sInternalChartType = "info/" + sChartType,
				compatibility = {
					used: {},
					error: null,
					compatible: true
				};
			var aFeeds = fitBasic(sChartType, aDimensions, aMeasures),
				oValidation = validateFeeds(sInternalChartType, aFeeds);

			if (!oValidation.valid) {
				aFeeds = fix(sChartType, oValidation, aFeeds, aDimensions, aMeasures);
				oValidation = validateFeeds(sInternalChartType, aFeeds);
				compatibility.needFix = true;
			}
			if (oValidation.valid) {
				compatibility.used = _groupBy(aFeeds, function(oFeed) {
					return oFeed.type;
				}, function(oFeed) {
					return oFeed.values.filter(function(oVal) {
						return oVal.type === "Dimension" || oVal.type === "Measure";
					}).map(function(oVal) {
						return oVal.id;
					});
				});
				jQuery.each(compatibility.used, function(k, v) {
					compatibility.used[k] = v.reduce(function(aAll, aNames) {
						return aAll.concat(aNames);
					}, []);
				});
			} else {
				compatibility.compatible = false;
				var aChartFeedings = sap.viz.api.metadata.Viz.get(sInternalChartType).bindings,
					mFeedingByType = _groupBy(aChartFeedings, "type", function(o) {return o.id;}),
					mMissingByType = {dim: 0, msr: 0, time: 0};

				jQuery.each(oValidation.results.bindings, function(k, v) {
					if (!v.missing) { // only support missing error currently
						return;
					}
					if (mFeedingByType.Dimension.indexOf(k) !== -1 && !(v.allowMND && v.missing === 1)) {
						// for invalid feeding, since we do not suggest mnd during validation, so remove mnd error here
						mMissingByType[k === "timeAxis" ? "time" : "dim"] += v.missing;
					} else if (mFeedingByType.Measure.indexOf(k) !== -1) {
						mMissingByType.msr += v.missing;
					}
				});
				compatibility.error = {
					missing: mMissingByType
				};

			}

			return compatibility;
		}
	};
});

}; // end of sap/chart/utils/RoleFitter.js
if ( !jQuery.sap.isDeclared('sap.chart.library') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

/**
 * Initialization Code and shared classes of library sap.chart.
 */
jQuery.sap.declare('sap.chart.library'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('jquery.sap.global'); // unlisted dependency retained
jQuery.sap.require('sap.viz.ui5.format.ChartFormatter'); // unlisted dependency retained
jQuery.sap.require('sap.ui.core.library'); // unlisted dependency retained
jQuery.sap.require('sap.viz.library'); // unlisted dependency retained
sap.ui.define("sap/chart/library",[
	'jquery.sap.global',
	'sap/viz/ui5/format/ChartFormatter',
	'sap/ui/core/library', // library dependency
	'sap/viz/library',
	'sap/chart/utils/RoleFitter',
	'sap/chart/ChartType',
	'sap/chart/AutoScaleMode',
	'sap/chart/ScaleBehavior',
	'sap/chart/data/MeasureSemantics',
	'sap/chart/coloring/CriticalityType',
	'sap/chart/ColoringType'
], function(
	jQuery,
	ChartFormatter,
	corelib, 
	vizlib, 
	RoleFitter, 
	ChartType, 
	AutoScaleMode,
	ScaleBehavior,
	MeasureSemantics
) {
	"use strict";

	/**
	 * Chart controls based on Vizframe
	 *
	 * @namespace
	 * @name sap.chart
	 * @public
	 */

	// delegate further initialization of this library to the Core
	sap.ui.getCore().initLibrary({
		name: "sap.chart",
		dependencies: ["sap.ui.core", "sap.viz"],
		types: [
			"sap.chart.data.MeasureSemantics"
		],
		interfaces: [],
		controls: [
			"sap.chart.Chart"
		],
		elements: [
			"sap.chart.data.Dimension",
			"sap.chart.data.TimeDimension",
			"sap.chart.data.Measure"
		],
		noLibraryCSS: true,
		version: "1.50.6"
	});


	/**
	 * @class
	 * Enumeration for supported selection mode in analytical chart
	 *
	 * @static
	 * @public
	 * @alias sap.chart.SelectionMode
	 */
	sap.chart.SelectionMode = {
		/**
		 * Multi selection mode, multiple sets of data points can be selected at once.
		 * @public
		 */
		Multi: "MULTIPLE",
		/**
		 * Single selection mode, only one set of data points can be selected at once.
		 * @public
		 */
		Single: "SINGLE",
		/**
		 * None selection mode, no data points can be selected.
		 * @public
		 */
		None : "NONE"
	};

	/**
	 * @class
	 * Enumeration for supported selection behavior in analytical chart
	 *
	 * @static
	 * @public
	 * @alias sap.chart.SelectionBehavior
	 */
	sap.chart.SelectionBehavior = {
		/**
		 * Data point selection behavior, only one data point can be selected at once.
		 * @public
		 */
		DataPoint: "DATAPOINT",
		/**
		 * Category selection behavior, one category of data points can be selected at once.
		 * @public
		 */
		Category: "CATEGORY",
		/**
		 * Series selection behavior, one seies of data points can be selected at once.
		 * @public
		 */
		Series: "SERIES"
	};
	
	/**
	 * @class
	 * Enumeration for supported message types in analytical chart.
	 *
	 * @static
	 * @public
	 * @alias sap.chart.MessageId
	 */
	sap.chart.MessageId = {
		/**
		 * No data message, metadata is defined but all data values are empty.
		 * @public
		 */
		NoData: "NO_DATA",
		/**
		 * Multiple units message, multiple unites are not allowed in one measure for analytical chart.
		 * @public
		 */
		MultipleUnits: "MULTIPLE_UNITS"
	};

	/**
	 * Package with additional chart APIs
	 * @namespace
	 * @public
	 */
	sap.chart.api = {};

	/**
	 * Returns all chart types currently supported by chart control (subset of viz types).
	 *
	 * @public
	 * @returns {object} a map with chartType as key, localized chart name as value.
	 */
	sap.chart.api.getChartTypes = function() {
		var sPath = jQuery.sap.getModulePath("sap.chart");
		var oBundle = jQuery.sap.resources({
			url: sPath + "/i18n/i18n.properties"
		});

		return Object.keys(sap.chart.ChartType).reduce(function(oMap, sChartTypeKey) {
			var sChartType = sap.chart.ChartType[sChartTypeKey];
			oMap[sChartType] = oBundle.getText("info/" + sChartType);
			return oMap;
		}, {});
	};

	/**
	 * Package with additional chart data APIs
	 * @namespace
	 * @public
	 */
	sap.chart.data = sap.chart.data || {};

	/**
	 * Package with colorings enumeration
	 * @namespace
	 * @public
	 */
	sap.chart.coloring = sap.chart.coloring || {};

	/**
	* Enumeration for supported ImprovementDirection types in analytical chart
	*
	* @enum {string}
	* @public
	* @alias sap.chart.coloring.ImprovementDirectionType
	*/
	sap.chart.coloring.ImprovementDirectionType = {
		/**
		 * Lower is better.
		 * 
		 * Positive if the value is lower than or equal to <code>AcceptanceRangeHighValue</code>.
		 * 
		 * Neutral if the value is greater than <code>AcceptanceRangeHighValue</code> and lower than or equal to <code>ToleranceRangeHighValue</code>.
		 * 
		 * Critical if the value is greater than <code>ToleranceRangeHighValue</code> and lower than or equal to <code>DeviationRangeHighValue</code>.
		 * 
		 * Negative if the value is greater than <code>DeviationRangeHighValue</code>.
		 * @public
		 */
		Minimize: "Minimize",

		/**
		 * Closer to the target is better.
		 * 
		 * Positive if the value is greater than or equal to <code>AcceptanceRangeLowValue</code> and lower than or equal to <code>AcceptanceRangeHighValue</code>.
		 * 
		 * Neutral if the value is greater than or equal to <code>ToleranceRangeLowValue</code> and lower than <code>AcceptanceRangeLowValue</code> OR greater than <code>AcceptanceRangeHighValue</code> and lower than or equal to <code>ToleranceRangeHighValue</code>.
		 * 
		 * Critical if the value is greater than or equal to <code>DeviationRangeLowValue</code> and lower than <code>ToleranceRangeLowValue</code> OR greater than <code>ToleranceRangeHighValue</code> and lower than or equal to <code>DeviationRangeHighValue</code>.
		 * 
		 * Negative if the value is lower than <code>DeviationRangeLowValue</code> or greater than <code>DeviationRangeHighValue</code>.
		 * @public
		 */
		Target: "Target",

		/**
		 * Higher is better.
		 * 
		 * Positive if the value is greater than or equal to <code>AcceptanceRangeLowValue</code>.
		 * 
		 * Neutral if the value is lower than <code>AcceptanceRangeLowValue</code> and greater than or equal to <code>ToleranceRangeLowValue</code>.
		 *
		 * Critical if the value is lower than <code>ToleranceRangeLowValue</code> and greater than or equal to <code>DeviationRangeLowValue</code>.
		 * 
		 * Negative if the value is lower than <code>DeviationRangeLowValue</code>.
		 * @public
		 */
		Maximize: "Maximize"
	};

	/**
	 * Get the Dimensions and Measures layout for a certain ChartType with provided Dimensions and Measures.
	 *
	 * @param {string} sChartType chart type
	 * @param {object[]} aDimensions visible Dimensions of the form {name: sName}
	 * @param {object[]} aMeasures visible Measures of the form {name: sName}.
	 *
	 * @public
	 * @returns {object} the chart layout object of the following form:
	 * <pre>
	 * {
	 *   dimensions: [],     // names of dimensions that will be rendered
	 *	 measures:	 [],     // names of measures that will be rendered
	 *	 errors:	 [],     // reasons of why the chart cannot be rendered with the given (chartType, dimensions, measures) combination
	 * }
	 */
	sap.chart.api.getChartTypeLayout = function(sChartType, aDimensions, aMeasures) {
		var aDims, aMsrs;
		if (!sChartType) {
			throw new Error("Invalid chart type: " + String(sChartType));
		}
		if (aDimensions) {
			aDims = aDimensions.map(function(oDimCfg, i) {
				if (oDimCfg && oDimCfg.name) {
					return {
						getName: function() {return oDimCfg.name;},
						getRole: function() {return oDimCfg.role || "category";}
					};
				} else {
					throw new Error("Invalid Dimension at [" + i + "]: " + String(oDimCfg) + ". Dimension should be an object of the format{name:'name'}.");
				}
			});
		} else {
			aDims = [];
		}
		if (aMeasures) {
			aMsrs = aMeasures.map(function(oMsrCfg, i) {
				if (oMsrCfg && oMsrCfg.name) {
					return {
						getName: function() {return oMsrCfg.name;},
						getRole: function() {return oMsrCfg.role || "axis1";}
					};
				} else {
					throw new Error("Invalid Measure at [" + i + "]: " +  String(oMsrCfg) + ". Measure should be an object of the format{name:'name'}.");
				}
			});
		} else {
			aMsrs = [];
		}

		var oCompatibility = RoleFitter.compatible(sChartType, aDims, aMsrs);

		return {
			dimensions: oCompatibility.used.Dimension || [],
			measures: oCompatibility.used.Measure || [],
			errors: Object.keys(oCompatibility.error || {}).reduce(function(aErrs, sCause) {
				return aErrs.concat({cause: sCause, detail: oCompatibility.error[sCause]});
			}, [])
		};
	};

	var chartFormatter = ChartFormatter.getInstance();

	if (!(sap.viz.api.env.Format.numericFormatter() instanceof ChartFormatter)) {
		sap.viz.api.env.Format.numericFormatter(chartFormatter);
	}

	return sap.chart;

});

}; // end of sap/chart/library.js
if ( !jQuery.sap.isDeclared('sap.chart.Chart') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */
jQuery.sap.declare('sap.chart.Chart'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.viz.ui5.controls.VizFrame'); // unlisted dependency retained
jQuery.sap.require('sap.viz.ui5.controls.common.BaseControl'); // unlisted dependency retained
jQuery.sap.require('sap.viz.ui5.data.Dataset'); // unlisted dependency retained
jQuery.sap.require('sap.viz.ui5.data.FlattenedDataset'); // unlisted dependency retained
jQuery.sap.require('sap.viz.ui5.data.DimensionDefinition'); // unlisted dependency retained
jQuery.sap.require('sap.viz.ui5.data.MeasureDefinition'); // unlisted dependency retained
jQuery.sap.require('sap.ui.model.analytics.ODataModelAdapter'); // unlisted dependency retained
jQuery.sap.require('sap.viz.ui5.controls.common.feeds.FeedItem'); // unlisted dependency retained
jQuery.sap.require('sap.ui.model.Filter'); // unlisted dependency retained
jQuery.sap.require('sap.ui.model.FilterOperator'); // unlisted dependency retained
jQuery.sap.require('sap.ui.model.analytics.odata4analytics'); // unlisted dependency retained
jQuery.sap.require('sap.ui.core.LocaleData'); // unlisted dependency retained
jQuery.sap.require('sap.viz.ui5.format.ChartFormatter'); // unlisted dependency retained
jQuery.sap.require('sap.viz.ui5.utils.CommonUtil'); // unlisted dependency retained
sap.ui.define("sap/chart/Chart",[
	'sap/chart/library',
	'sap/viz/ui5/controls/VizFrame',
	'sap/viz/ui5/controls/common/BaseControl',
	'sap/viz/ui5/data/Dataset',
	'sap/viz/ui5/data/FlattenedDataset',
	'sap/viz/ui5/data/DimensionDefinition',
	'sap/viz/ui5/data/MeasureDefinition',
	'sap/chart/data/Dimension',
	'sap/chart/data/TimeDimension',
	'sap/chart/data/Measure',
	'sap/ui/model/analytics/ODataModelAdapter',
	'sap/chart/utils/RoleFitter',
	'sap/chart/utils/ChartUtils',
	'sap/chart/utils/ChartTypeAdapterUtils',
	'sap/chart/utils/DateFormatUtil',
	'sap/chart/utils/DataSourceUtils',
	'sap/chart/utils/SelectionAPIUtils',
	'sap/chart/utils/MeasureSemanticsUtils',
	'sap/viz/ui5/controls/common/feeds/FeedItem',
	'sap/ui/model/Filter',
	'sap/ui/model/FilterOperator',
	'sap/ui/model/analytics/odata4analytics',
	'sap/chart/TimeUnitType',
	'sap/chart/coloring/Colorings',
	'sap/chart/ChartLog',
	'sap/chart/pagination/PagingController',
	'sap/ui/core/LocaleData',
	'sap/chart/SeriesColorTracker',
	'sap/viz/ui5/format/ChartFormatter',
	'sap/chart/utils/ValueAxisScaleUtils',
	'sap/chart/AutoScaleMode',
	'sap/chart/ScaleBehavior',
	'sap/viz/ui5/utils/CommonUtil'
], function(
	library,
	VizFrame,
	BaseControl,
	Dataset,
	FlattenedDataset,
	DimensionDefinition,
	MeasureDefinition,
	Dimension,
	TimeDimension,
	Measure,
	ODataModelAdapter,
	RoleFitter,
	ChartUtils,
	ChartTypeAdapterUtils,
	DateFormatUtil,
	DataSourceUtils,
	SelectionAPIUtils,
	MeasureSemanticsUtils,
	FeedItem,
	Filter,
	FilterOperator,
	odata4analytics,
	TimeUnitType,
	Colorings,
	ChartLog,
	PagingController,
	LocaleData,
	SeriesColorTracker,
	ChartFormatter,
	ValueAxisScaleUtils,
	AutoScaleMode,
	ScaleBehavior,
	CommonUtil
) {
	"use strict";

	/**
	 * Constructor for a new Chart.
	 *
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 *
	 * @class
	 * UI5 Chart control
	 *
	 * @extends sap.viz.ui5.controls.common.BaseControl
	 *
	 * @constructor
	 * @public
	 * @since 1.32.0
	 * @alias sap.chart.Chart
	 */
	var Chart = BaseControl.extend("sap.chart.Chart", {
		metadata: {
			library: "sap.chart",
			properties: {
				/**
				 * Type of the Chart.
				 *
				 */
				chartType						: {type: "string", defaultValue: "bar"},
				/**
				 * Configuration for initialization to VizControl. This property could only set via settings parameter in Constructor.
			 	 */
				uiConfig : {type : "object", group : "Misc"},
				/**
				 * Names of the Dimensions to be displayed in the Chart, all available dimensions will automatically append when the property isAnalytical is false.
				 *
				 * Depending on chart type, insufficient number of visible <code>Dimension</code>s will cause error.
				 */
				visibleDimensions						: {type: "string[]", defaultValue: []},
				/**
				 * Names of the inResult dimensions.
				 *
				 * inResult dimension do not show up in chart layout, i.e. axis/legend. They do show in tooltip, popover, and in selection results.
				 */
				inResultDimensions						: {type: "string[]", defaultValue: []},
				/**
				 * Names of the Measures to be displayed in the Chart.
				 *
				 * Depending on chart type, insufficient number of visible <code>Measure</code>s will cause errors.
				 */
				visibleMeasures						  : {type: "string[]", defaultValue: []},
				/** Chart properties, refer to chart property <a href="../../vizdocs/index.html" target="_blank">documentation</a> for more details. */
				vizProperties								: {type: "object", group: "Misc"},/**
				/** Chart scales, refer to chart property <a href="../../vizdocs/index.html" target="_blank">documentation</a> for more details. */
				vizScales										: {type : "object[]", group : "Misc"},
				/** Whether or not an aggregated entity set is bound to the chart. */
				isAnalytical								 : {type: "boolean"},
				/**
				 * Chart selection behavior.
				 *
				 */
				selectionBehavior						: {type: "sap.chart.SelectionBehavior", defaultValue: sap.chart.SelectionBehavior.DataPoint},
				/**
				 * Chart selection mode.
				 *
				 */
				selectionMode			: {type: "sap.chart.SelectionMode", defaultValue: sap.chart.SelectionMode.Multi},
				/**
				 * Enable pagination mode.
				 *
				 * Pagination mode empowers users to visualize dataset page by page by scrolling back or forth. Currently there are some limitations of this mode in some chart transversal features, such as:
				 * <ol>
				 *   <li>Selection status might lost for new batch data</li>
				 *   <li>Keyboard navigation will be only available for current continuous batch data</li>
				 *	 <li>Zoom out might have inconsistent behavior, Hence the gesture in mobile might have the same issue</li>
				 *	 <li>Time charts did not enable pagination yet</li>
				 *	 <li>Series color might be inconsistent before/after jump pages</li>
				 * </ol>
				 * Please refer to release notes for details.
				 */
				enablePagination			 : {type: "boolean", defaultValue: false},
				
				/**
                 * Enable Stable color mode.
                 * To keep the same colors for the same dimension values or measure names.
                 */
				enableStableColor             : {type: "boolean", defaultValue: false},

				/**
                 * Enable scaling factor.
                 */
				enableScalingFactor             : {type: "boolean", defaultValue: false},
				/**
				 *
				 Chart custom messages.
				*/
				customMessages				  : {type: "object", defaultValue: null},
				/**
				 * Chart colorings.
				 *
				 * Holds an object with information about the possible options how colors can be applied for indicating <code>Criticality</code> or <code>Emphasis</code> in the chart.
				 * <pre>
				 * Colorings: {
				 *     Criticality: {
				 *         …
				 *     },
				 *     Emphasis: {
				 *         …
				 *     }
				 * }
				 * </pre>
				 *
				 * <b>NOTE:</b> Dimension-based coloring does not work when {@link sap.chart.data.Measure#setSemantics} is set to {@link sap.chart.data.MeasureSemantics.Projected} or {@link sap.chart.data.MeasureSemantics.Reference} for visible measure(s).
				 *
				 * Refer to<br/>
				 *   {@link sap.chart.ColoringType.Criticality}<br/>
				 *   {@link sap.chart.ColoringType.Emphasis}<br/>
				 * for detailed usage
				 */
				colorings: {type: "object", defaultValue: null},
				/**
				 * Active coloring configurations.
				 *
				 * specifies which coloring of the possible colorings is to be applied for the current chart layout. It holds an object with two properties：
				 *
				 * <ol>
				 *   <li>coloring: <b>mandatory</b>, specify which kind of coloring should take effect in current chart layout. Possible values refer to {@link sap.chart.ColoringType}</li>
				 *   <li>parameters:
				 *     <ul>
				 *       <li>
				 *         <code>Criticality</code> supports two parameters: <code>"dimension"</code> and <code>"measure"</code>. Both are <b>optional</b>, one (and only one) must be provided.
				 *         This setting disambiguates when multiple colorings for different visible dimensions and measures are applicable.
				 *
				 *         <code>"measure"</code> supports two input types:
				 *           <ol>
				 *             <li><code>string</code> for single measure name</li>
				 *             <li><code>string[]</code> of multiple measure names(only supported in <b>static</b>), which is relevant in case of a <b>static</b> measure criticality defined on multiple measures.</li>
				 *           </ol>
				 *         <code>"dimension"</code> holds the dimension name as string value.
				 *       </li>
				 *       <li>
				 *         <code>Emphasis</code> supports only one parameter: <code>"dimension"</code> which is <b>optional</b>.
				 *
				 *         <code>"dimension"</code> holds the dimension name as string value.
				 *       </li>
				 *     </ul>
				 *   </li>
				 * </ol>
				 *
				 * Example:
				 * <pre>
				 * activeColoring: {
				 *     coloring: sap.chart.ColoringType.Criticality,
				 *     parameters: {
				 *         dimension: "AvailabilityStatus”
				 *     }
				 * }
				 * </pre>
				 */
				activeColoring: {type: "object", defaultValue: null},
				/**
				 * Value Axis Scale.
				 *
				 * Specifies the scale of the chart value axes.
				 *
				 * <ol>
				 *   <li>scaleBehavior: <b>optional</b>, determines whether or not all value axes in the chart should have a fixed scale. Possible values refer to {@link sap.chart.ScaleBehavior}. The default value is sap.chart.ScaleBehavior.AutoScale.
				 *       In order to apply a fixed scale, boundary values for minimum and maximum must have been specified for all visible measures, and the axes boundaries are then created from the largest maximum and the smallest minimum value of the measures put on the respective axis.
				 *       If any visible measure lacks this information, or scaleBehavior is set to sap.chart.ScaleBehavior.AutoScale, the chart will apply an automatic scaling for all value axes.
				 *   </li>
				 *   <li>fixedScaleSettings:
				 *     <ul>
				 *       <li>measureBoundaryValues: An object holding the fixed “minimum” and “maximum” values for all the measures.
				 *         Stacked chart with only one measrue also uses this object to describe the fixed “minimum” and “maximum” value.
				 *         <ul>
				 *           <li>
				 *             <code>measure</code> Measure name
				 *           </li>
				 *         </ul>
				 *       </li>
				 *       <li>stackedMultipleMeasureBoundaryValues: An array of objects holding the fixed “minimum” and “maximum” values only for stacked chart with mulitple measures.
				 *         <ul>
				 *           <li>
				 *             <code>measures</code> the array of measure name applied to the axis.
				 *           </li>
				 *           <li>
				 *             <code>boundaryValues：</code> An object holding the fixed “minimum” and “maximum” value all the measures applied to certain axis.
				 *           </li>
				 *         </ul>
				 *       </li>
				 *     </ul>
				 *   </li>
				 *   <li>autoScaleSettings:
				 *     <ul>
				 *       <li>
				 *         <code>zeroAlwaysVisible</code> forces the value axis to always display the zero value (only a few chart types support the opposite), which is <b>optional</b>. The default value is true.
				 *       </li>
				 *       <li>
				 *         <code>syncWith</code> selects how the chart adapts the value axis to the data: The axis boundaries may be determined from the loaded data, which is <b>optional</b>.
				 *         Possible values refer to {@link sap.chart.AutoScaleMode}.
				 *       </li>
				 *     </ul>
				 *   </li>
				 * </ol>
				 *
				 * Example:
				 * <pre>
				 * valueAxisScale: {
				 *     scaleBehavior: sap.chart.ScaleBehavior,
				 *     fixedScaleSettings: {
				 *         measureBoundaryValues: {
				 *             measure_1: {
				 *                 minimum: Number,
				 *                 maximum: Number
				 *             },
				 *             measure_2: {
				 *                 minimum: Number,
				 *                 maximum: Number
				 *             }
				 *         },
				 *         stackedMultipleMeasureBoundaryValues: [{
	             *             measures: [ 'measure_1', 'measure_2', … ],
	             *             boundaryValues： {
	             *                 minimum: Number,
				 *                 maximum: Number
	             *             }
				 *         }， {
	             *             measures: [ 'measure_3', 'measure_4', … ],
	             *             boundaryValues： {
	             *                 minimum: Number,
				 *                 maximum: Number
	             *             }
				 *         }]
				 *     },
				 *     autoScaleSettings: {
				 *         zeroAlwaysVisible: Boolean,
				 *         syncWith: sap.chart.autoScaleMode
				 *     }
				 * }
				 * </pre>
				 *
				 * Refer to<br/>
				 *   {@link sap.chart.AutoScaleMode.DataSet}<br/>
				 *   {@link sap.chart.AutoScaleMode.VisibleData}<br/>
				 *   {@link sap.chart.ScaleBehavior.AutoScale}<br/>
				 *   {@link sap.chart.ScaleBehavior.FixedScale}<br/>
				 * for detailed usage
				 */
				valueAxisScale: {type: "object", defaultValue: null}

			},
			aggregations: {
				/** Actual data. It can be bound to an (analytical) OData model. */
				data	   : {type: "sap.ui.core.Element", multiple: true, bindable: "bindable"},
				/** Internal VizFrame instance which does the actual rendering work. */
				_vizFrame  : {type: "sap.viz.ui5.controls.VizFrame", multiple: false, visibility: "hidden"},
				/** Dimensions of the data. */
				dimensions : {type: "sap.chart.data.Dimension", multiple: true},
				/** Measures of the data. */
				measures   : {type: "sap.chart.data.Measure", multiple: true}
			},
			events: {
				/** fired after a drill-down operation */
				drilledDown : {
					parameters : {
						/** array of strings holding the names of the added dimensions */
						dimensions : {type : "string[]"}
					}
				},
				/** fired after a drill-up operation */
				drilledUp : {
					parameters : {
						/** array of strings holding the names of the removed dimensions */
						dimensions : {type : "string[]"}
					}
				},
				/** Event fires when the rendering ends. */
				renderComplete : {},
				/** Event fires when certain data point(s) is(are) selected, data context of selected item(s) would be passed in. */
				selectData	   : {},
				/** Event fires when certain data point(s) is(are) deselected, data context of deselected item(s) would be passed in */
				deselectData   : {},
				/** Event fires when fixed scale is turned off by adding or removing dimension */
				valueAxisFixedScaleTurnedOff : {}
			}
		},
		renderer: function(oRm, oControl) {
			// write the HTML into the render manager
			oRm.write("<div");
			oRm.writeControlData(oControl);
			oRm.addStyle("width", oControl.getWidth());
			oRm.addStyle("height", oControl.getHeight());
			oRm.writeStyles();
			oRm.write(">");

			oRm.renderControl(oControl.getAggregation("_vizFrame"));

			oRm.write("</div>");
		}
	});

	Chart.getMetadata().getAggregation("data")._doesNotRequireFactory = true;

	// ******** Overridden property getters/setters ********

	function vizFrameSize (sValue) {
		return sValue.indexOf("%") !== -1 ? "100%" : sValue;
	}
	Chart.prototype.setHeight = function(sValue) {
		this.setProperty("height", sValue);
		var oVizFrame = this._getVizFrame();
		if (oVizFrame) {
			oVizFrame.setHeight(vizFrameSize(this.getProperty("height")));
		}
		return this;
	};

	Chart.prototype.setWidth = function(sValue) {
		this.setProperty("width", sValue);
		var oVizFrame = this._getVizFrame();
		if (oVizFrame) {
			oVizFrame.setWidth(vizFrameSize(this.getProperty("width")));
		}
		return this;
	};

	Chart.prototype.setChartType = function(sChartType, bSuppressInvalidate) {
		this.setProperty("chartType", sChartType, bSuppressInvalidate);
		this._bIsPagingChartType =  ChartUtils.CONFIG.pagingChartTypes.indexOf(sChartType) > -1;
		
		if (this._isEnablePaging()) {
			this._getPagingController().init(false);
		} else {
			//TODO, move this logic out of chart.js
			var oDataset = this._getDataset();
			if (oDataset) {
				oDataset.setPagingOption(null);
				oDataset.setRange(-1, -1);
			}
		}
		this._invalidateBy({
			source: this,
			keys: {
				vizFrame: true
			}
		});

		this._bNeedToApplyDefaultProperties = true;
		return this;
	};

	Chart.prototype.setColorings = function(oValue) {
		this.setProperty("colorings", oValue);

		this._invalidateBy({
			source: this,
			keys: {
				vizFrame: true,
				checkBinding: true
			}
		});

		return this;
	};

	Chart.prototype.setActiveColoring = function(oValue) {
		this.setProperty("activeColoring", oValue);

		this._invalidateBy({
			source: this,
			keys: {
				vizFrame: true,
				checkBinding: true
			}
		});

		return this;
	};

	Chart.prototype.setValueAxisScale = function(oValue) {
		this._bEnbableValueAxisScale = true;
		this.setProperty("valueAxisScale", oValue);

		if (this._oValueScaleSetting && this._oValueScaleSetting.fireValueAxisFixedScaleTurnedOff) {
			this._oValueScaleSetting.fireValueAxisFixedScaleTurnedOff = false;
			this._oValueScaleSetting.resetValueAxisScale = true;
		}

		this._invalidateBy({
			source: this,
			keys: {
				vizFrame: true
			}
		});

		return this;
	};

	Chart.prototype._setValueAxisScale = function() {
		var oValueAxisScale = this.getValueAxisScale(),
			bApplyInitialValeScale = !this._rendered && !!oValueAxisScale,
			bUpdateValueScale = !(this._mNeedToUpdate['binding'] && this._oValueScaleSetting) && this._bEnbableValueAxisScale;
		if ( bApplyInitialValeScale || bUpdateValueScale) {
			//When inital chart with vizScales and vizValueScales, to make sure the flag is true.
			if (!this._bEnbableValueAxisScale) {
				this._bEnbableValueAxisScale = true;
			}
			this._oValueScaleSetting =  ValueAxisScaleUtils.getValueAxisScaleSetting(
			this.getChartType(), oValueAxisScale, this.getMeasures(), this.getVisibleMeasures());
		}
	};

	Chart.prototype._getValueAxisScaleSetting = function() {
		return this._bEnbableValueAxisScale ? this._oValueScaleSetting || {} : {};
	};

	Chart.prototype._validateValueScaleOnDimChange = function(aNewDimensions, aOldDimensions) {
		if (aOldDimensions && this._oValueScaleSetting) {
			var oValueAxisScale = this.getValueAxisScale();
			if (oValueAxisScale && oValueAxisScale.scaleBehavior === ScaleBehavior.FixedScale) {
				var aDimUpdated = [];
				aNewDimensions.forEach(function(oDimension) {
					var idx = aOldDimensions.indexOf(oDimension);
					if (idx < 0) {
						aDimUpdated.push(oDimension);
					} else {
						aOldDimensions.splice(idx, 1);
					}
				});
				aDimUpdated = aDimUpdated.concat(aOldDimensions);
				
				if (aDimUpdated.length > 0) {
					var bFixedScale = false, sChartType = this.getChartType();
					if (ChartUtils.isStackedLikeChart(sChartType)) {
						bFixedScale = true;
						aDimUpdated.forEach(function(oDimension) {
							if (oDimension._getFixedRole() !== 'series') {
								bFixedScale = false;
							}
						});
					}
					if (!bFixedScale) {
						this._oValueScaleSetting.fireValueAxisFixedScaleTurnedOff = true;
						oValueAxisScale.scaleBehavior = ScaleBehavior.AutoScale;
						this.setProperty('valueAxisScale', oValueAxisScale);
						this.fireValueAxisFixedScaleTurnedOff();
						if (this._oValueScaleSetting.resetValueAxisScale) {
							oValueAxisScale = this.getValueAxisScale();
							this.setProperty('valueAxisScale', oValueAxisScale);
						}
						this._oValueScaleSetting =
							ValueAxisScaleUtils.getValueAxisScaleSetting(
								sChartType, oValueAxisScale, this.getMeasures(),
								this.getVisibleMeasures());
					}
				} else {
					this._oValueScaleSetting =
						ValueAxisScaleUtils.getValueAxisScaleSetting(
							this.getChartType(), oValueAxisScale,
							this.getMeasures(), this.getVisibleMeasures());
				}
			}
		}
	};

	/**
	 * Adds some dimension to the aggregation dimensions.
	 *
	 * Render a chart with time axis when the dimension type is {@link sap.chart.data.TimeDimension}.
	 * Please be advised that time axis is supported with limited chart types (column, line, combination, stacked_column, bubble, scatter, dual_combination, vertical_bullet, waterfall).
	 *
	 * @name sap.chart.Chart#addDimension
	 * @public
	 * @function
	 * @param {sap.chart.data.Dimension|sap.chart.data.TimeDimension} oDimension
	 * The dimension to add; if empty, nothing is inserted
	 * @return {sap.chart.Chart} Reference to this in order to allow method chaining
	 */

	/**
	 * Removes a dimension from the aggregation dimensions, remove a visible dimension is unsupported when the property isAnalytical is false.
	 *
	 * @public
	 *
	 * @param {int|string|sap.chart.data.Dimension} oDimension
	 * The dimension to remove or its index or id.
	 *
	 * @return {sap.chart.data.Dimension} The removed dimension or null
	 */
	Chart.prototype.removeDimension = function(oDimension) {
		var aVisibleDimensions = this._getVisibleDimensions() || [];
		var iIndex;
		if (this.getIsAnalytical() === false && oDimension && oDimension.getName()) {
			iIndex = aVisibleDimensions.indexOf(oDimension.getName());
			if (iIndex !== -1) {
				jQuery.sap.log.error('Data source does not support aggregation. The method "removeDimension" therefore cannot be used!');
				return;
			}
		}
		var oResult = this.removeAggregation("dimensions", oDimension);

		if (oResult) {
			iIndex = aVisibleDimensions.indexOf(oResult.getName());
			if (iIndex !== -1) {
				aVisibleDimensions.splice(iIndex, 1);
				this.setVisibleDimensions(aVisibleDimensions);
			}
			var aInResultDimensions = this.getInResultDimensions() || [];
			iIndex = aInResultDimensions.indexOf(oResult.getName());
			if (iIndex !== -1) {
				aInResultDimensions.splice(iIndex, 1);
				this.setInResultDimensions(aInResultDimensions);
			}
		}
		return oResult;
	};

	/**
	 * Removes all the controls from the aggregation dimensions, only works when the property isAnalytical is true.
	 *
	 * Additionally, it unregisters them from the hosting UIArea.
	 *
	 * @public
	 *
	 * @return {sap.chart.data.Dimension[]} An array of the removed elements (might be empty)
	 */
	Chart.prototype.removeAllDimensions = function() {
		var oResult;
		if (this.getIsAnalytical() === false) {
			jQuery.sap.log.error('Data source does not support aggregation. The method "removeAllDimensions" therefore cannot be used!');
		} else {
			oResult = this.removeAllAggregation("dimensions");
			this.setVisibleDimensions([]);
			this.setInResultDimensions([]);
		}

		return oResult;
	};

	/**
	 * Destroys all the dimensions in the aggregation dimensions, only works when the property isAnalytical is true.
	 *
	 * @public
	 *
	 * @return {sap.chart.Chart} Reference to this in order to allow method chaining
	 */
	Chart.prototype.destroyDimensions = function() {
		var oResult;
		if (this.getIsAnalytical() === false) {
			jQuery.sap.log.error('Data source does not support aggregation. The method "destroyDimensions" therefore cannot be used!');
		} else {
			oResult = this.destroyAggregation("dimensions");
			this.setVisibleDimensions([]);
			this.setInResultDimensions([]);
		}

		return oResult;
	};

	Chart.prototype.removeMeasure = function(oMeasure) {
		var oResult = this.removeAggregation("measures", oMeasure);

		if (oResult) {
			var aVisibleMeasures = this._getVisibleMeasures() || [],
			iIndex = aVisibleMeasures.indexOf(oResult.getName());
			if (iIndex !== -1) {
				aVisibleMeasures.splice(iIndex, 1);
				this.setVisibleMeasures(aVisibleMeasures);
			}
		}
		return oResult;
	};

	Chart.prototype.removeAllMeasures = function() {
		var oResult = this.removeAllAggregation("measures");
		this.setVisibleMeasures([]);
		return oResult;
	};

	Chart.prototype.destroyMeasures = function() {
		var oResult = this.destroyAggregation("measures");
		this.setVisibleMeasures([]);
		return oResult;
	};
	Chart.prototype._getVisibleDimensions = function(bNormalize) {
		var oStackTop = this._getDrillStateTop();
		var aDims = oStackTop ? oStackTop.dimensions : this.getProperty("visibleDimensions");
		return bNormalize ? this._normalizeDorM(aDims, true) : aDims;
	};

	Chart.prototype.getVisibleDimensions = function() {
		var aVisibleDimensions = this._getVisibleDimensions();
		return this._aFeeds ? aVisibleDimensions.filter(function(d) {
			return this._aFeeds._unused.indexOf(d) === -1;
		}, this) : aVisibleDimensions;
	};

	Chart.prototype._getVisibleMeasures = function(bNormalize) {
		var oStackTop = this._getDrillStateTop();
		var aMsrs = oStackTop ? oStackTop.measures : this.getProperty("visibleMeasures");
		return bNormalize ? this._normalizeDorM(aMsrs) : aMsrs;
	};

	Chart.prototype.getVisibleMeasures = function() {
		var aVisibleMeasures = this._getVisibleMeasures();
		return this._aFeeds ? aVisibleMeasures.filter(function(d) {
			return this._aFeeds._unused.indexOf(d) === -1;
		}, this) : aVisibleMeasures;
	};

	/**
	 * Sets a new value for property visibleDimensions.
	 *
	 * Names of the Dimensions to be displayed in the Chart, all available dimensions will automatically append when the property isAnalytical is false.
	 *
	 * Depending on chart type, insufficient number of visible Dimensions will cause error.
	 *
	 * When called with a value of null or undefined, the default value of the property will be restored.
	 *
	 * Default value is [].
	 *
	 * @public
	 *
	 * @param {string[]} sVisibleDimensions
	 * New value for property visibleDimensions
	 *
	 * @return {sap.chart.Chart} Reference to this in order to allow method chaining
	 */
	Chart.prototype.setVisibleDimensions = function(sVisibleDimensions, bSuppressInvalidate) {
		var mSanity = this._dimensionSanityCheck({visible: sVisibleDimensions});
		this.setProperty("visibleDimensions", sVisibleDimensions, bSuppressInvalidate);
		this.setProperty("inResultDimensions", mSanity.inResult, bSuppressInvalidate);
		this._createDrillStack();
		this._invalidateBy({
			source: this,
			keys: {
				binding: true,
				dataSet: true,
				vizFrame: true
			}
		});

		return this;
	};

	Chart.prototype.setInResultDimensions = function(aInResultDimensionNames, bSuppressInvalidate) {
		var mSanity = this._dimensionSanityCheck({inResult: aInResultDimensionNames});
		this.setProperty("inResultDimensions", aInResultDimensionNames, bSuppressInvalidate);
		this.setProperty("visibleDimensions", mSanity.visible, bSuppressInvalidate);
		this._createDrillStack();
		this._invalidateBy({
			source: this,
			keys: {
				binding: true,
				dataSet: true,
				vizFrame: true
			}
		});
	};

	Chart.prototype.setVisibleMeasures = function(aMeasureNames, bSuppressInvalidate) {
		this.setProperty("visibleMeasures", aMeasureNames, bSuppressInvalidate);
		this._createDrillStack();
		this._invalidateBy({
			source: this,
			keys: {
				binding: true,
				dataSet: true,
				vizFrame: true
			}
		});

		return this;
	};
	
	Chart.prototype.setEnableStableColor = function(bValue){
	    bValue = !!bValue;
	    if (this.getProperty("enableStableColor") !== bValue){
	        this.setProperty("enableStableColor", bValue);
	        this._invalidateBy({
	            source:this,
	            keys:{
	                vizFrame:true
	            }
	        });
	    }
	};
	

	/**
	 * Sets a new value for property enablePagination, only works for oData model.
	 *
	 * <b>NOTE:</b> setEnablePagination currently only works in constructor.
	 *
	 * Enable pagination mode.
	 *
	 * Pagination mode empowers users to visualize dataset page by page by scrolling back or forth. Currently there are some limitations of this mode in some chart transversal features, such as:
	 * <ol>
	 *   <li>Selection status might lost for new batch data</li>
	 *   <li>Keyboard navigation will be only available for current continuous batch data</li>
	 *	 <li>Zoom out might have inconsistent behavior, hence the gesture in mobile might have the same issue</li>
	 *	 <li>Time charts did not enable pagination yet</li>
	 *	 <li>Series color might be inconsistent before/after jump pages</li>
	 *	 <li>parameter <code>oBindingInfo.length</code> during {@link sap.ui.base.ManagedObject#bindAggregation bindAggregation} of {@link #getData data} will not be respected in value axis scale</li>
	 * </ol>
	 * Please refer to release notes for details.
	 *
	 * When called with a value of null or undefined, the default value of the property will be restored.
	 *
	 * Default value is false.
	 *
	 * @public
	 *
	 * @param {boolean}	bEnablePagination
	 * New value for property enablePagination
	 *
	 * @return {sap.chart.Chart} Reference to this in order to allow method chaining
	 */
	Chart.prototype.setEnablePagination = function(bEnablePagination, bSuppressInvalidate) {
		if (!this._bIsInitialized) {
			this.setProperty("enablePagination", bEnablePagination, bSuppressInvalidate);

			this._invalidateBy({
				source: this,
				keys: {
					binding: true,
					dataSet: true,
					vizFrame: true,
					drillStack: true
				}
			});
		}
		return this;
	};

	// ******** Private helper functions ********
	/*
	 * Since we allow inResult and visible to race for a Dimension, we need to move a Dimension out of visible if it's
	 * being set as InResult, and vice versa.
	 */
	Chart.prototype._dimensionSanityCheck = function(oDims) {
		var aVisibles = oDims.visible || this.getVisibleDimensions() || [],
			aInResult = oDims.inResult || this.getInResultDimensions() || [];

		var mSummary = [].concat(aVisibles).concat(aInResult).reduce(function(mSumm, sId) {
			var bVisible  = aVisibles.indexOf(sId) !== -1,
				bInResult = aInResult.indexOf(sId) !== -1;
			if (bVisible && bInResult) {
				mSumm.common[sId] = true;
			} else if (bVisible) {
				mSumm.visible[sId] = true;
			} else if (bInResult) {
				mSumm.inResult[sId] = true;
			}

			return mSumm;
		}, {
			visible: {},
			inResult:{},
			common:  {}
		});

		mSummary.visible = Object.keys(mSummary.visible);
		mSummary.inResult = Object.keys(mSummary.inResult);
		mSummary.common = Object.keys(mSummary.common);

		return mSummary;
	};

	Chart.prototype._prepareFeeds = function() {
		if (!this._aFeeds) {
			var aDimensions = this._normalizeDorM(this._getVisibleDimensions(), true),
				aMeasures = this._normalizeDorM(this._getVisibleMeasures(), false),
				aInResults = this._normalizeDorM(this.getInResultDimensions(), true),
				aInvisibleMeasures;
			this._sAdapteredChartType = this.getEnablePagination() ? this.getChartType() : ChartTypeAdapterUtils.adaptChartType(this.getChartType(), aDimensions);
			
			//Semantic relation can also start from invisible measures.
			var aVisibleMeasures = this._getVisibleMeasures();
			aInvisibleMeasures = this._normalizeDorM(this.getMeasures().filter(function(value){
				return aVisibleMeasures.indexOf(value.getName()) === -1;
			}), false);
			
			this._aFeeds = RoleFitter.fit(this._sAdapteredChartType, aDimensions, aMeasures, aInResults, this._enableSemanticPattern(), aInvisibleMeasures);
			if ((!this._aFeeds._valid || this._aFeeds._unused.length) && this._sAdapteredChartType !== this.getChartType()) {
				// fall back to original chart type if feeding is invalid for adapted chart type
				this._sAdapteredChartType = this.getChartType();
				this._aFeeds = RoleFitter.fit(this._sAdapteredChartType, aDimensions, aMeasures, aInResults, this._enableSemanticPattern());
			}
			if (this._sAdapteredChartType !== this.getChartType()) {
				this._bNeedToApplyDefaultProperties = true;
			}
		}
		return this._aFeeds;
	};



	/**
	 * Convert an array containing any number of Dimension/Measure instances (object) and Dimension/Measure names (string)
	 * an array of Dimension/Measure instances. And filter out any Dimensions/Measures that are not in the Dimension/Measure
	 * aggregation.
	 *
	 * @param {array} aMixed the mixed array of Dimension/Measure instances and names
	 * @param {boolean} bIsDimension whether the input array are Dimensions
	 * @return {array} an array of Dimension/Measure instances that present in the visible Dimension/Measure aggregation
	 *				   result.error will contain all the non-normalizable input from the mixed array passed in
	 * @private
	 */
	Chart.prototype._normalizeDorM = function(aMixed, bIsDimension) {
		var aAll = bIsDimension ? this.getDimensions() : this.getMeasures(),
			mLookUp = aAll.reduce(function(mMap, oDimOrMsr) {
				mMap[oDimOrMsr.getName()] = oDimOrMsr;
				return mMap;
			}, {}),
			clazz = bIsDimension ? Dimension : Measure;

		var oResult = aMixed.reduce(function(oResult, oNameOrDM) {
			var sName;
			if (typeof oNameOrDM === "string") {
				sName = oNameOrDM;
			} else if (oNameOrDM instanceof clazz) {
				sName = oNameOrDM.getName();
			} else {
				oResult.errors.push(oNameOrDM);
			}
			if (mLookUp[sName]) {
				oResult.normalized.push(mLookUp[sName]);
			} else {
				oResult.errors.push(oNameOrDM);
			}
			return oResult;
		}, {
			normalized: [],
			errors: []
		});

		var aNormalized = oResult.normalized;
		if (oResult.errors.length > 0) {
			aNormalized.errors = oResult.errors;
		}

		return aNormalized;
	};

	/**
	 * Calculate redundant Dimensions and Measures from selected data points (selection)
	 * against visible Dimensions and Measures.
	 *
	 * A Dimension is considered to be redundant if all selected data points share the same value for it.
	 * A Measure is considered to be redundant if none of the selected data point are of this measure.
	 *
	 * @return {object} key, value pairs for redundant Dimensions and Measures.
	 *					For Dimensions, key is the Dimension name and value is the redundant value;
	 *					For Measures, key is "measureNames" and value is an map having the redundant Measure names as keys
	 * @private
	 */
	Chart.prototype._redundantsFromSelection = function() {
		var aSelections = this._getVizFrame().vizSelection();
		if (!aSelections || aSelections.length === 0) {
			return {measureNames: {}};
		}
		var oSemanticTuples = this._getContinuesSemanticTuples();

		var mSelectionSummary = aSelections.reduce(function(mSummary, oSelection) {
			var aInvisibleSemMsr = [];
			for (var tuple in oSemanticTuples) {
				if (oSemanticTuples.hasOwnProperty(tuple)) {
					var semanticRule = oSemanticTuples[tuple];
					if (oSelection.data[tuple]) {
						//Filter measures according with semantic relations
						aInvisibleSemMsr.push((oSelection.data[semanticRule.timeAxis] < semanticRule.projectedValueStartTime) ? semanticRule.projected : semanticRule.actual);
					} else {
						//Filter internal unbound measures which is invisible for chart.
						aInvisibleSemMsr.push(semanticRule.actual);
						aInvisibleSemMsr.push(semanticRule.projected);
					}
				}
			}

			jQuery.each(oSelection.data, function(k, v) {
				if (!(aInvisibleSemMsr.length > 0 && aInvisibleSemMsr.indexOf(k) > -1)) {
					if (!mSummary[k]) {
						mSummary[k] = [];
					}
					if (mSummary[k].indexOf(v) === -1) {
						mSummary[k].push(v);
					}
				}
			});
			return mSummary;
		}, {});

		var mRedundants = this._getVisibleDimensions().reduce(function(mRedundantDimensions, sDimensionName) {
			var aValues = mSelectionSummary[sDimensionName];
			if (aValues.length === 1) {
				mRedundantDimensions[sDimensionName] = aValues[0];
			}
			return mRedundantDimensions;
		}, {});

		mRedundants.measureNames = this._getVisibleMeasures().reduce(function(mRedundantMeasures, sMsrName) {
			if (!mSelectionSummary[sMsrName]) {
				mRedundantMeasures[sMsrName] = true;
			}
			return mRedundantMeasures;
		}, {});

		return mRedundants;
	};

	/**
	 * Derive a filter from the selected data points (selection).
	 * The returned Filter will make sure only the Dimension values that presents in the selection are retained.
	 *
	 * NOTE: Redundant Measures is to be handled in the request rather than here in Filter
	 *
	 * @return {sap.ui.model.Filter} the Filter instance
	 * @private
	 */
	Chart.prototype._deriveFilterFromSelection = function() {
		var aVisibleDimensions = this._getVisibleDimensions();
		var that = this;
		var aFilterCfgs = this._getVizFrame().vizSelection().map(function(oSelection) {
			var oConfig = aVisibleDimensions.reduce(function(oFilterCfg, sDimensionName) {
				var oDimension = that.getDimensionByName(sDimensionName);
				var value;
				value = oSelection.data[sDimensionName];
				if (ChartUtils.CONFIG.timeChartTypes.indexOf(that._sAdapteredChartType) > -1 &&
					 oDimension instanceof TimeDimension) {
					var oDateInstance = DateFormatUtil.getInstance(oDimension.getTimeUnit());
					if (oDateInstance) {
						var fnFormat = oDateInstance.format.bind(oDateInstance);
						value = fnFormat(new Date(oSelection.data[sDimensionName]));
					}
				}
				oFilterCfg.filters.push(new Filter({path: sDimensionName, operator: FilterOperator.EQ, value1: value}));
				oFilterCfg.signature.push(sDimensionName + "=" + oSelection.data[sDimensionName]);
				return oFilterCfg;
			}, {
				filters: [],
				signature: []
			});
			oConfig.signature = oConfig.signature.join(";");
			return oConfig;
		});

		var mUniqFilters = aFilterCfgs.reduce(function(mFilters, oCfg) {
			if (!mFilters[oCfg.signature] && oCfg.filters.length > 0) {
				mFilters[oCfg.signature] = new Filter(oCfg.filters, true);
			}
			return mFilters;
		}, {});

		var aFilters = Object.keys(mUniqFilters).map(function(k) {
			return mUniqFilters[k];
		});
		if (aFilters.length > 1) {
			return new sap.ui.model.Filter(aFilters, false);
		} else if (aFilters.length === 1) {
			return aFilters[0];
		} else {
			return null;
		}
	};

	/**
	 * Check that the dimension to be drilled down actually can be drilled down
	 *
	 * @private
	 * @param {array} aIncomingDimensions an array of Dimensions to be drilled down
	 * @return {boolean} true if the chart can drill down on all provided Dimensions, otherwise return false
	 */
	Chart.prototype._checkDrilldownValid = function(aIncomingDimensions) {
		var mVisibleDimensions = this._getVisibleDimensions().concat(this.getInResultDimensions()).reduce(function(mMap, sDimensionName) {
			mMap[sDimensionName] = true;
			return mMap;
		}, {});

		// Prevent drill down again on dimensions that are visible already
		if (aIncomingDimensions.some(function(oDim) {
			return mVisibleDimensions[oDim.getName()];
		})) {
			jQuery.sap.log.error("Drill down not possible, because one of the given dimensions is already drilled down!");
			return false;
		}

		var mArgumentDimensionNames = aIncomingDimensions.reduce(function(oResult, oDimension) {
			oResult[oDimension.getName()] = oDimension;
			return oResult;
		}, {});

		// recursively check the filter tree for a dimension which we want to drill down into
		function findFilter(oFilter) {
			if (jQuery.isArray(oFilter.aFilters)) { // Subtree
				return oFilter.aFilters.some(findFilter);
			} else { // Leaf
				return !!mArgumentDimensionNames[oFilter.sPath];
			}
		}

		var oStackTop = this._getDrillStateTop();
		if (oStackTop && oStackTop.filter && findFilter(oStackTop.filter)) {
			jQuery.sap.log.error("Drill down not possible, because one of the given dimensions is already filtered!");
			return false;
		}

		return true;
	};

	/**
	 * Create the drill stack from visible Dimensions and Measures.
	 *
	 * The created drill stack should allow user to drill up by removing one visible Dimension
	 * each time until no Dimension is left
	 * @private
	 */
	Chart.prototype._createDrillStack = function() {
		var aVisibleDimensions = this.getProperty("visibleDimensions") || [],
			aVisibleMeasures = this.getProperty("visibleMeasures") || [],
			aStack = [{
				dimensions: [],
				measures: aVisibleMeasures,
				filter: undefined
			}],
			aStackDimensions = [];

		for (var i = 0; i < aVisibleDimensions.length; i++) {
			aStackDimensions.push(aVisibleDimensions[i]);
			aStack.push({
				dimensions: aStackDimensions.slice(),
				measures: aVisibleMeasures,
				filter: undefined
			});
		}

		this._drillStateStack = aStack;
	};

	/**
	 * Invalidate certain aspect of the Chart control so it gets updated accordingly on the re-render phase.
	 *
	 * It is not required to update all aspects on each invalidation because some causes only changes certain, but not all, aspect.
	 * For example
	 *	 a. If the cause is Dimension/Measure property (label, role, or format etc) change, it is not necessary to update the binding and drill state;
	 *	 b. If the cause is visibleDimensions/visibleMeasures change, it is required to update almost everything.
	 * and the cases goes on.
	 *
	 * @param {object} oCause the cause of the invalidation
	 * @private
	 */
	Chart.prototype._invalidateBy = function(oCause) {
		var oSource = oCause.source;

		var aAdditionalDims = this._oCandidateColoringSetting ? (this._oCandidateColoringSetting.additionalDimensions || []) : [];
		if (oSource === this) {
			jQuery.each(oCause.keys || {}, function(k, v) {
				this._markForUpdate(k, v);
			}.bind(this));
		} else if (oSource instanceof Measure && this._getVisibleMeasures().indexOf(oSource.getName()) !== -1) {
			this._markForUpdate("dataSet", true);
			this._markForUpdate("vizFrame", true);
			if (oCause.property === "unitBinding" ||
				(this.getColorings() && (oCause.property === 'semantics' || oCause.property === 'semanticallyRelatedMeasures'))
				// measure semantics will infuluence colorings and may need update binding in some cases
				) {
				this._markForUpdate("binding", true);
			}
		} else if (oSource instanceof Dimension && this._getVisibleDimensions().concat(aAdditionalDims).indexOf(oSource.getName()) !== -1) {
	        this._markForUpdate("dataSet", true);
			this._markForUpdate("vizFrame", true);
			if (oSource.getDisplayText() && (oCause.property === "textProperty" || oCause.property === "displayText" )) {
				this._markForUpdate("binding", true);
			}
		}

		this.invalidate(oCause);
	};

	Chart.prototype._handleNonAnalyticalFeeding = function() {
		var that = this;
		var inResult = this.getInResultDimensions();
		var visibleDimensions = this._getVisibleDimensions(),
			allDimensions = this.getDimensions().map(function(oValue) {
				return oValue.getName();
			});
		//arr contains textProperty
		var arr = [];
		allDimensions.forEach(function(dimension) {
			if (that.getDimensionByName(dimension)) {
				var textProperty = that.getDimensionByName(dimension).getTextProperty();
				if (textProperty) {
					arr.push(textProperty);
				}
			}
		});

		/*Merge visibleDimensions and allDimensions, remove duplicate items, and textProperty and inresultDimension.
		 *Keep the user settings of visinleDimensions, then auto append other dimensions for user.
		 *Filter unitBinding/textProperty/inResult behind auto appending to prevent this three dimensions are already exist in visibleDimensons.
		 */
		var vDimensions = visibleDimensions.concat(allDimensions.filter(function(item) {
			return (visibleDimensions.indexOf(item) < 0);
		})).filter(function(item) {
			return (arr.indexOf(item) < 0) && (inResult.indexOf(item) < 0);
		});
		this.setProperty("visibleDimensions", vDimensions);
		this._createDrillStack();
	};

	// ******** Private updaters. These updaters are meant to be triggered by the _render function. ********

	Chart.prototype._markForUpdate = function(key, bNeedUpdate) {
		if (!this._mNeedToUpdate) {
			this._mNeedToUpdate = {};
		}
		this._mNeedToUpdate[key] = bNeedUpdate;
		var fnOnInvalidate = this._updaters.onInvalidate[key];
		if (fnOnInvalidate) {
			fnOnInvalidate.call(this);
		}
	};
	Chart.prototype._updaters = (function() {
		return {
			onInvalidate: {
				vizFrame: function() {
					this._aFeeds = null;
					this._bColoringParsed = null;
				},
				checkBinding: function() {
					this._bColoringParsed = null;
				},
				binding: function() {
					this._bColoringParsed = null;
				},
				loopData: function() {
					this._bColoringParsed = null;
				}
			},
			checkBinding: function() {
				// sync point for colorings & activeColoring properties to decide if binding should be updated
				var oCandidateColoringSetting = this._getCandidateColoringSetting();
				var aAdditionalDimensions = oCandidateColoringSetting.additionalDimensions;
				var aAdditionalMeasures = oCandidateColoringSetting.additionalMeasures;
				if ((aAdditionalDimensions && aAdditionalDimensions.length) ||
					(aAdditionalMeasures && aAdditionalMeasures.length)) {
				    this._mNeedToUpdate["binding"] = true;
				}
			},
			drillStack: function() {
				this._createDrillStack();
			},
			dataSet: function() {
				this._getDataset().invalidate();
			},
			/* This BINDING is NOT the chart binding */
			binding: function() {
				var oBinding = this._getDataset().getBinding("data"),
					inResult = this.getInResultDimensions();
				if (!oBinding) {
					return;
				}


				var aDimensions = this._getVisibleDimensions(true).concat(this._normalizeDorM(inResult, true));
				var aMeasures = this._getVisibleMeasures(true);
				DataSourceUtils.updateModel(this.getIsAnalytical())(this, aDimensions, aMeasures);

				var oStackTop = this._getDrillStateTop();
				if (aDimensions.length > 0 || aMeasures.length > 0) {
					//this._getVizFrame()._pendingDataRequest(true); // prevent vizFrame from updating by an empty dataset before data is received
					this._getVizFrame()._readyToRender(false);
					this.setBusy(true);
				}
				this._bFilterCalledByChart = true;
				oBinding.filter((oStackTop && oStackTop.filter) ? oStackTop.filter : undefined);
				if (this._bEnbableValueAxisScale) {
					this._validateValueScaleOnDimChange(aDimensions, this._aDimensions);
				}
				this._aDimensions = aDimensions;
			},
			vizFrame: function() {
				var that = this,
				oDataset = this._getDataset(),
				oVizFrame = this._getVizFrame();
				if (this._mNeedToUpdate['binding']) {
					if (this._isEnablePaging()) {
						this._getPagingController().reset();
						this._oColoringStatus = {};
					} else {
						//TODO, move this logical out of chart
						this._getDataset().setPagingOption(null);
					}
				} else {
					// loop cached data if there is no binding change
					this._markForUpdate('loopData', true);
				}
				if ( this.getEnableStableColor()){
					this._oColorTracker.add(oVizFrame._runtimeScales());
					oVizFrame._runtimeScales(this._oColorTracker.get(), true);
				 
				} else {
					this._resetRuntimeScale();
				}
				var mMeasureRange = this._isEnablePaging() ? this._getPagingController().getMeasureRange() : {};


				oDataset.removeAllAggregation("dimensions", true);
				oDataset.removeAllAggregation("measures", true);

				oVizFrame.removeAllAggregation("feeds", true);

				if (this.getIsAnalytical() === false) {
					this._handleNonAnalyticalFeeding();
				}
				var aFeeds = this._prepareFeeds();
				aFeeds._def.dim.forEach(function(oDim) {
					oDataset.addAggregation("dimensions", oDim, true);
				}, this);
				aFeeds._def.msr.forEach(function(oMsr) {
					if (oMsr) {
						var oRange = mMeasureRange[oMsr.getIdentity()];
						if (oRange) {
							oMsr.setRange([oRange.min, oRange.max]);
						}
						if (!that.getDimensionByName(oMsr.getUnit())) {
							oMsr.setUnit(null);
						}
						oDataset.addAggregation("measures", oMsr, true);
					}
				}, this);
				aFeeds.forEach(function(oFeedItem) {
					oVizFrame.addFeed(oFeedItem);
				});
				this._semanticTuples = aFeeds._semanticTuples;
				var oCandidateColoringSetting = this._getCandidateColoringSetting();

				var aDatasetContexts = aFeeds._context || [];
				var aAdditionalMeasures = oCandidateColoringSetting.additionalMeasures || [];
				var aAdditionalDimensions = oCandidateColoringSetting.additionalDimensions || [];

				aAdditionalMeasures.forEach(function(sMsr) {
					aDatasetContexts.push({
						id: sMsr,
						showInTooltip: false
					});
					oDataset.addMeasure(new MeasureDefinition({
						name: sMsr,
						identity: sMsr,
						value: '{' + sMsr + '}'
					}));
				});

				aAdditionalDimensions.forEach(function(sDim) {
					aDatasetContexts.push({
						id: sDim,
						showInTooltip: false
					});
					oDataset.addDimension(new DimensionDefinition({
						name: sDim,
						identity: sDim,
						value: '{' + sDim + '}'
					}));
				});

				oDataset.setContext(aDatasetContexts);

				oVizFrame.invalidate();
				oDataset.invalidate();
				oVizFrame.setVizType(this._sAdapteredChartType);
				
				oVizFrame._setCustomMessages(this.getCustomMessages());
				this._setValueAxisScale();
				//LoopData will call _setEffectiveScales and setVizProperties
				if (!this._mNeedToUpdate['loopData']) {
					this._setEffectiveScales();
					oVizFrame.setVizProperties(this._getEffectiveProperties());
				}
			},
			loopData: function() {
				var oVizFrame = this._getVizFrame();
				try {
					this._prepareData();
				} catch (e) {
					if (e instanceof ChartLog) {
						e.display();
					} else {
						throw e;
					}
				}
				var oVizProperties = this._getEffectiveProperties();
				//TODO: merge 'using DisplayName' logic into one loop in 'prepareData'
				this._usingDisplayNameForSemantics(oVizProperties);
				oVizFrame.setVizProperties(oVizProperties);
				this._setEffectiveScales();
			}
		};

		//return [oDrillStackUpdater, oDataSetUpdater, oVizFrameUpdater, oBindingUpdater];
	})();

	// ******** Private Accessors ********
	Chart.prototype._getDrillStateTop = function() {
		return this._drillStateStack ? this._drillStateStack[this._drillStateStack.length - 1] : null;
	};

	Chart.prototype._getVizFrame = function() {
		return this.getAggregation("_vizFrame");
	};

	Chart.prototype._getDataset = function() {
		var oVizFrame = this._getVizFrame();
		return oVizFrame ? oVizFrame.getDataset() : null;
	};

	Chart.prototype._prepareData = function() {
		// 1) get context handler of Colorings
		var	oColoringHandler = this._getCandidateColoringSetting().contextHandler;

		// 2) loop context if necessary in Colorings
		var aContextHandlers = [];
		if (oColoringHandler) {
			aContextHandlers.push(oColoringHandler);
			try {
				this._loopContext(aContextHandlers);
			} catch (e) {
				if (e instanceof ChartLog) {
					e.display();
					// invalidate coloring setting if error
					this._oCandidateColoringSetting = {};
				} else {
					throw e;
				}
			}
		}

		// 3) Generate semantic rules with Pattern and Coloring
		this._oSemanticVizSettings = MeasureSemanticsUtils.getSemanticVizSettings(
			this._sAdapteredChartType,
			this._semanticTuples,
			this._oCandidateColoringSetting,
			this._enableSemanticPattern(),
			this._bDataPointStyleSetByUser,
			this._bLegendSetByUser
		);
	};

	Chart.prototype._getContexts = function() {
		var oBinding = this.getBinding("data");
		if (oBinding) {
			if (this._isEnablePaging() && this._getPagingController().isUnderPaging()) {
				return this._getPagingController().getCurrentContexts();
			} else {
				var iStart = 0;
				var iLength = oBinding instanceof sap.ui.model.analytics.AnalyticalBinding ? oBinding.getTotalSize() : oBinding.getLength();
				return oBinding.getContexts(iStart, iLength);
			}
		} else {
			return [];
		}
	};

	Chart.prototype._loopContext = function(aContextHandlers) {
		var aContexts = this._getContexts();
		if (aContexts.length > 0 && !aContexts.dataRequested) {
			var that = this;
			aContexts.forEach(function(oContext) {
				aContextHandlers.forEach(function(fnContextHandler) {
					fnContextHandler.call(that, oContext);
				});
			});
		}
	};
	
	Chart.prototype._filterHandler = function() {
		if (!this._bFilterCalledByChart) {
			this._bFilterCalledByCustomer = true;

			// Coloring.Criticality.MeasureValues.ConstantThresholds shall take Filter into consideration
			// filter will eventually trigger bindingChange, re-calculate coloring setting at that time
			this._bColoringParsed = false;
		}
		this._bFilterCalledByChart = false;
	};

	Chart.prototype._dataRefreshListener = function(oEvent) {
		if (oEvent.getParameters().reason === 'filter') {
			this._filterHandler();
		}
	};

	Chart.prototype._bindingChangeListener = function(oEvent) {
		var oVizFrame = this._getVizFrame();
		if (oEvent.getParameters().reason === 'filter') {
			//set filter on client model will directly trigger 'dataChange' event
			this._filterHandler();
		}

		if (this.getEnableStableColor()){

			this._oColorTracker.add(oVizFrame._runtimeScales());
			oVizFrame._runtimeScales(this._oColorTracker.get(), true);
		}

		//Here we can get the source dataset, and then set the data's displayValue to lengend's displayName in the semantic rules of vizProperties automatically for specific requirement.
		oVizFrame.invalidate(); // prevent an unnecessary immediate VizFrame re-render, re-render should happen after all invalidates
		this.setBusy(false);
		if (this._isEnablePaging()) {
			this._getPagingController().bindingChanged();
		} else {
			//allow vizframe to render
			oVizFrame._readyToRender(true);
		}

		try {
			this._prepareData();
		} catch (e) {
			if (e instanceof ChartLog) {
				e.display();
			}
		}

		var oVizProperties = this._getEffectiveProperties();
		//TODO: merge 'using DisplayName' logic into one loop in 'prepareData'
		this._usingDisplayNameForSemantics(oVizProperties);

		oVizFrame.setVizProperties(oVizProperties);
		this._setEffectiveScales();
		this._bFilterCalledByChart = false;
		this._bFilterCalledByCustomer = false;
	};
	
	Chart.prototype._resetRuntimeScale = function(){
		this._oColorTracker.clear();
		this._getVizFrame()._runtimeScales(this._oColorTracker.get(), true);
	};

	Chart.prototype._hasUserSemanticProps = function() {
		var oVizProperties = this.getProperty("vizProperties");
		if (oVizProperties && oVizProperties.plotArea) {
			if (oVizProperties.plotArea.dataPointStyle || oVizProperties.plotArea.seriesStyle) {
				return true;
			}
		}
		return false;
	};

	Chart.prototype._enableSemanticColoring = function() {
		var result = true;
		if (this._sAdapteredChartType === "heatmap") {
			var oVizScales = this.getProperty("vizScales") || [];
			var oVizColorScale = oVizScales.filter(function(oVizScale) {
				return oVizScale.feed === "color";
			})[0];
			if (oVizColorScale) {
				result = false;
			}
		} else {
			if (this._hasUserSemanticProps()) {
				result = false;
			}
		}
		return result;
	};

	/************* Semantic Pattern's internal method *******************/
	
	Chart.prototype._enableSemanticPattern = function() {
		return !this._hasUserSemanticProps() &&
		ChartUtils.CONFIG.nonSemanticPatternChartType.indexOf(this._sAdapteredChartType) === -1;
	};

	Chart.prototype._hasSemanticPattern = function() {
		return this._enableSemanticPattern() && MeasureSemanticsUtils.hasSemanticRelation(this._semanticTuples);
	};

	Chart.prototype._getContinuesSemanticTuples = function(){
		var tuples = {};
		if (this._hasSemanticPattern()) {
			tuples = this._semanticTuples.reduce(function(arrs, tuple){
				if (tuple.semanticMsrName) {
					arrs[tuple.semanticMsrName] = tuple;
				}
				return arrs;
			}, {});
		}
		return tuples;
	};

	Chart.prototype._getContinuesSemanticMap = function(){
		var tuples = [];
		if (this._hasSemanticPattern()) {
			tuples = this._semanticTuples.filter(function(tuple){
				return tuple.projectedValueStartTime;
			});
		}
		return tuples;
	};

	Chart.prototype._getInternalVisibleMeasures = function(){
		var aMsrs = this._getVisibleMeasures();
		if (this._hasSemanticPattern()) {
			aMsrs = aMsrs.concat(this._getContinuesSemanticMap().map(function(tuple){
				return tuple.semanticMsrName;
			}));
		}
		return aMsrs;
	};

	Chart.prototype._buildSelectedDataPoints = function(oBinding, aDataPoints){
		//For get/setSelectedDataPoints API
		//Build vizframe's selected datapoint structure.
		var aMsrs = this._getInternalVisibleMeasures(),
			aDims = this._getVisibleDimensions().concat(this.getInResultDimensions()),
			aSelectedDataPoints = this._getEffectiveContinuesDataPoints(aDataPoints);
		return SelectionAPIUtils.buildSelectionVizCtx(aMsrs, aDims, oBinding, aSelectedDataPoints);
	};

	Chart.prototype._getEffectiveContinuesSeries = function(aSeries){
		var aSelectedSeries = aSeries.slice(), continuesSemanticTuples = this._getContinuesSemanticMap();
		if (this._hasSemanticPattern()) {
			var msrsMap = aSelectedSeries.map(function(series){
				return series.measures;
			});

			continuesSemanticTuples.forEach(function(tuple){
				if (msrsMap.indexOf(tuple.actual) > -1 || msrsMap.indexOf(tuple.projected) > -1) {
					aSelectedSeries = aSelectedSeries.filter(function(series){
						return series.measures !== tuple.actual && series.measures !== tuple.projected;
					});
					if (msrsMap.indexOf(tuple.actual) > -1 && msrsMap.indexOf(tuple.projected) > -1) {
						aSelectedSeries.push({
							measures : tuple.semanticMsrName
						});
					}
				}
			});
		}
		return aSelectedSeries;
	};

	Chart.prototype._getEffectiveContinuesDataPoints = function(aDataPoints){
		var aSelectedDataPoints = aDataPoints.slice(),  continuesSemanticTuples = this._getContinuesSemanticMap();
		if (this._hasSemanticPattern()) {
			var actIndex, proIndex, measures, tuple;
			for (var i = 0; i < aSelectedDataPoints.length; i++) {
				measures = aSelectedDataPoints[i].measures;
				for (var j = 0; j < continuesSemanticTuples.length; j++) {
					tuple = continuesSemanticTuples[j];
					actIndex = measures.indexOf(tuple.actual);
					if (actIndex > -1) {
						measures.splice(actIndex, 1);
					}
					proIndex = measures.indexOf(tuple.projected);
					if (proIndex > -1) {
						measures.splice(proIndex, 1);
					}
					if (actIndex > -1 || proIndex > -1) {
						measures.push(tuple.semanticMsrName);
					}
				}
			}
		}
		return aSelectedDataPoints;
	};

	Chart.prototype._buildSelectEventData = function(data) {
		if (data && data.length > 0 && this._hasSemanticPattern()) {
			var value, tuple;
			var continuesSemanticTuples = this._getContinuesSemanticMap();
			for (var i = 0; i < data.length; i++) {
				value = jQuery.extend(true, {}, data[i].data);
				for (var j = 0; j < continuesSemanticTuples.length; j++) {
					tuple = continuesSemanticTuples[j];
					if (value.measureNames === tuple.semanticMsrName) {
						//Need to filter interval unbound measures
						//TODO check null value case
						if (value[tuple.timeAxis] < tuple.projectedValueStartTime) {
							value.measureNames = tuple.actual;
							delete value[tuple.projected];
							delete value[tuple.semanticMsrName];
						} else {
							value.measureNames = tuple.projected;
							delete value[tuple.actual];
							delete value[tuple.semanticMsrName];
						}
					} else {
						if (value[tuple.actual] && value.measureNames !== tuple.actual) {
							delete value[tuple.actual];
						}
						if (value[tuple.projected] && value.measureNames !== tuple.projected) {
							delete value[tuple.projected];
						}
					}
				}
				data[i].data = value;
			}
		}
	};
	// ******** overridden functions ********

	// override standard aggregation methods for 'data' and report an error when they are used
	/**
	 * Unsupported.
	 * Chart manages the "data" aggregation only via data binding. The method "addData" therefore cannot be used programmatically!
	 *
	 * @public
	 */
	Chart.prototype.addData = function() {
		jQuery.sap.log.error('Chart manages the "data" aggregation only via data binding. The method "addData" therefore cannot be used programmatically!');
	};

	/**
	 * Unsupported.
	 * Chart manages the "data" aggregation only via data binding. The method "destroyData" therefore cannot be used programmatically!
	 *
	 * @public
	 */
	Chart.prototype.destroyData = function() {
		jQuery.sap.log.error('Chart manages the "data" aggregation only via data binding. The method "destroyData" therefore cannot be used programmatically!');
	};

	/**
	 * Unsupported.
	 * Chart manages the "data" aggregation only via data binding. The method "getData" therefore cannot be used programmatically!
	 *
	 * @public
	 */
	Chart.prototype.getData = function() {
		jQuery.sap.log.error('Chart manages the "data" aggregation only via data binding. The method "getData" therefore cannot be used programmatically!');
	};

	/**
	 * Unsupported.
	 * Chart manages the "data" aggregation only via data binding. The method "indexOfData" therefore cannot be used programmatically!
	 *
	 * @public
	 */
	Chart.prototype.indexOfData = function() {
		jQuery.sap.log.error('Chart manages the "data" aggregation only via data binding. The method "indexOfData" therefore cannot be used programmatically!');
	};

	/**
	 * Unsupported.
	 * Chart manages the "data" aggregation only via data binding. The method "insertData" therefore cannot be used programmatically!
	 *
	 * @public
	 */
	Chart.prototype.insertData = function() {
		jQuery.sap.log.error('Chart manages the "data" aggregation only via data binding. The method "insertData" therefore cannot be used programmatically!');
	};

	/**
	 * Unsupported.
	 * Chart manages the "data" aggregation only via data binding. The method "removeData" therefore cannot be used programmatically!
	 *
	 * @public
	 */
	Chart.prototype.removeData = function() {
		jQuery.sap.log.error('Chart manages the "data" aggregation only via data binding. The method "removeData" therefore cannot be used programmatically!');
	};

	/**
	 * Unsupported.
	 * Chart manages the "data" aggregation only via data binding. The method "removeAllData" therefore cannot be used programmatically!
	 *
	 * @public
	 */
	Chart.prototype.removeAllData = function() {
		jQuery.sap.log.error('Chart manages the "data" aggregation only via data binding. The method "removeAllData" therefore cannot be used programmatically!');
	};

    Chart.prototype._createOData4SAPAnalyticsModel = function(oModel) {
		var oOData4SAPAnalyticsModel = null;
		try {
			oOData4SAPAnalyticsModel = new odata4analytics.Model(new odata4analytics.Model.ReferenceByModel(oModel));
		} catch (exception) {
			return undefined;
		}
		return oOData4SAPAnalyticsModel;

	};

	/**
	 * Gets current value of property isAnalytical.
	 *
	 * Whether or not an aggregated entity set is bound to the chart.
	 *
	 * The proeprty isAnalytical will programmatically set according to data source. When the data source has an aggregated entity set, isAnalytical is true, otherwise it's false.
	 *
	 * @public
	 *
	 * @return {boolean} Value of property isAnalytical
	 */
	Chart.prototype.getIsAnalytical = function() {
		return this.getProperty("isAnalytical");
	};

	/**
	 * Whether or not an aggregated entity set is bound to the chart. Deprecated.
	 *
	 * @public
	 */
	Chart.prototype.setIsAnalytical = function(oValue, bSuppressInvalidate) {
		if (this._bIsInitialized) {
			jQuery.sap.log.error('The proeprty isAnalytical will programmatically set according to data source. The method "setIsAnalytical" therefore cannot be used!');
		} else {
			this.setProperty("isAnalytical", oValue, bSuppressInvalidate);
		}
	};

	Chart.prototype._setIsAnalyticalProperty = function(oOData4SAPAnalyticsModel, oBindingInfo) {
		var oValue = oOData4SAPAnalyticsModel.findQueryResultByName(DataSourceUtils.getEntitySet(this.getIsAnalytical())(oBindingInfo)) !== undefined;
		if (this.getIsAnalytical() !== oValue) {
			this.setProperty("isAnalytical", oValue);
		}
	};

	Chart.prototype.bindAggregation = function(sName, oBindingInfo) {
		if (sName === "data") {
			// This may fail, in case the model is not yet set.
			// If this case happens, the ODataModelAdapter is added by the overriden _bindAggregation,
			// which is called during setModel(...)
			this._oBindingInfo = jQuery.extend(true, {}, oBindingInfo);
			var oModel = this.getModel(oBindingInfo.model);
			var oOData4SAPAnalyticsModel;
			if (oModel) {
				if (oModel instanceof sap.ui.model.json.JSONModel) {
					if (this.getIsAnalytical() !== false) {
						this.setProperty("isAnalytical", false);
					} else if (this.getEnablePagination() !== false) {
						this.setProperty("enablePagination", false);
					}
				} else {
					oOData4SAPAnalyticsModel = this._createOData4SAPAnalyticsModel(oModel);
					this._setIsAnalyticalProperty(oOData4SAPAnalyticsModel, oBindingInfo);
				}
				if (this.getIsAnalytical()) {
					if (oBindingInfo) {
						var bNoPaging = true;
						if (oBindingInfo.length != undefined || this._isEnablePaging()) {
							bNoPaging = false;
						}
						oBindingInfo.parameters = jQuery.extend(true, {}, {
									analyticalInfo: [{name: ""}] ,
									useBatchRequests: true,
									provideGrandTotals: false,
									provideTotalsResultSize: false,
									autoexpand: false,
									reloadSingleUnitMeasures: true,
									noPaging: bNoPaging
								},
								oBindingInfo.parameters);
					}

					ODataModelAdapter.apply(oModel);
					if (oOData4SAPAnalyticsModel) {
						oModel.setAnalyticalExtensions(oOData4SAPAnalyticsModel);
					}
				}
			}
		}
		return BaseControl.prototype.bindAggregation.apply(this, arguments);
	};

	Chart.prototype._bindAggregation = function(sName, oBindingInfo) {
		if (sName === "data") {
			// This may fail, in case the model is not yet set.
			// If this case happens, the ODataModelAdapter is added by the overriden _bindAggregation, which is called during setModel(...)
			var oModel = this.getModel(oBindingInfo.model);
			if (oModel) {
				if (oModel instanceof sap.ui.model.json.JSONModel) {
					if (this.getIsAnalytical() !== false) {
						this.setProperty("isAnalytical", false);
					} else if (this.getEnablePagination() !== false) {
						this.setProperty("enablePagination", false);
					}
				} else {
					var oOData4SAPAnalyticsModel = this._createOData4SAPAnalyticsModel(oModel);
					this._setIsAnalyticalProperty(oOData4SAPAnalyticsModel, oBindingInfo);
				}
				if (this.getIsAnalytical()) {
					if (oBindingInfo) {
						var bNoPaging = true;
						if (oBindingInfo.length != undefined || this._isEnablePaging()) {
							bNoPaging = false;
						}
						oBindingInfo.parameters = jQuery.extend(true, {}, {
									analyticalInfo: [{name: ""}] ,
									useBatchRequests: true,
									provideGrandTotals: false,
									provideTotalsResultSize: false,
									autoexpand: false,
									reloadSingleUnitMeasures: true,
									noPaging: bNoPaging
								},
								oBindingInfo.parameters);
					}

					ODataModelAdapter.apply(oModel);
					if (oOData4SAPAnalyticsModel) {
						oModel.setAnalyticalExtensions(oOData4SAPAnalyticsModel);
					}
				}

				this._deriveColumns(oModel, oBindingInfo);
			}


			var oDataset = this._getDataset();
			oDataset.bindAggregation("data", oBindingInfo);
			this._invalidateBy({
				source: this,
				keys: {
					binding: true,
					vizFrame: true
				}
			});
		} else {
			BaseControl.prototype._bindAggregation.apply(this, arguments);
		}
	};

	Chart.prototype._dataErrorListener = function(mEventParams){
		var oVizFrame = this._getVizFrame();
		if (oVizFrame){
			oVizFrame._readyToRender(true);
			oVizFrame.invalidate();
			this.setBusy(false);
		}
	};


	Chart.prototype.unbindAggregation = function(sName, bSuppressReset) {
		if (sName === "data") {
			var oDataset = this._getDataset();
			if (oDataset) {
				oDataset.unbindAggregation.apply(oDataset, arguments);
			}
			bSuppressReset = true; // since we explicitly prohibit call to destroyData
		}
		return BaseControl.prototype.unbindAggregation.apply(this, [sName, bSuppressReset]);
	};

	Chart.prototype.unbindData = function() {
		//remove all dimensions/visibleDimensions,measures/visibleMeasures
		if (!this.getIsAnalytical()) {
			this.removeAllAggregation("dimensions");
			this.removeAllAggregation("measures");
			this.setProperty("visibleDimensions", []);
			this.setProperty("inResultDimensions", []);
			this.setProperty("visibleMeasures", []);
			this._createDrillStack();
		}
		this.unbindAggregation("data");
	};

	Chart.prototype._deriveColumns = function(oModel, oBindingInfo) {
		// derive dimensions and measures from metadata, if not yet set
		var aDimensions = this.getAggregation("dimensions");
		var aMeasures = this.getAggregation("measures");
		if ((aDimensions === null || aDimensions.length === 0) && (aMeasures === null || aMeasures.length === 0)) {
			var mColumns = DataSourceUtils.deriveColumns(this.getIsAnalytical())(oModel, oBindingInfo);
			mColumns.dimensions.forEach(this.addDimension.bind(this));
			mColumns.measures.forEach(this.addMeasure.bind(this));
		}
	};

	/*
	 * @override
	 * @private
	 */
	Chart.prototype.onBeforeRendering = function() {
		BaseControl.prototype.onBeforeRendering.apply(this, arguments);
		var aOrder = ["onInvalidate", "drillStack", "dataSet", "vizFrame", "checkBinding", "binding", "loopData"];
		// ensure "vizFrame" updaters earlier than binding since semantic coloring depends on auto-feeding
		aOrder.forEach(function(key) {
			if (this._mNeedToUpdate[key]) {
				this._updaters[key].call(this);
			}
		}.bind(this));

		jQuery.each(this._mNeedToUpdate, function(key) {
			this._mNeedToUpdate[key] = false;
		}.bind(this));
	};

	// Override to prevent Basecontrol._render from createing DOM node, since Chart performs rendering via _vizFrame
	Chart.prototype.onAfterRendering = function () {
		this._showLoading(this._bLoading);
		this._rendered = true;
	};

	Chart.prototype.onlocalizationChanged = function() {
		this._invalidateBy({
			source: this,
			keys: {
				vizFrame: true
			}
		});
	};

	/*
	 * @override
	 */
	Chart.prototype.exit = function() {
		this._getDataset().unbindAggregation('data', true);
		this._oColorTracker.clear();
		BaseControl.prototype.exit.apply(this, arguments);
		var oVizFrame = this._getVizFrame();
		if (this._delegateEventHandlers) {
			this._delegateEventHandlers.forEach(function(oHandler) {
				oVizFrame["detach" + oHandler.name](oHandler.handler, this);
				delete oHandler.handler;
			}, this);
			delete this._delegateEventHandlers;
		}
		oVizFrame.detachRenderComplete(this._vizFrameRenderCompleteHandler, this);
		oVizFrame.detachEvent("_zoomDetected", vizFrameZoomDetectedHandler.bind(this), this);
		oVizFrame.detachEvent("_selectionDetails", vizFrameSelectionDetailsHandler.bind(this), this);
	};

	
	/*
	 * @override
	 */
	Chart.prototype.applySettings = function() {
		sap.ui.core.Control.prototype.applySettings.apply(this, arguments);

		var oDataset = new FlattenedDataset();
		oDataset.attachEvent("dataChange", {}, this._bindingChangeListener, this);
		oDataset.attachEvent("dataRefresh", {}, this._dataRefreshListener, this);
		oDataset.attachEvent("dataError", {}, this._dataErrorListener, this);

		// make applicationSet : fiori as default. If we write it in the metadata, the jsdoc could not be generated correctly.
		var uiConfig = jQuery.extend(true, {}, {
			'applicationSet': 'fiori'
		}, this.getUiConfig());
		this.setUiConfig(uiConfig);
		this._bNeedToApplyDefaultProperties = true;
		this._oSemanticVizSettings = {};

		var oVizFrame = new VizFrame({
			width: vizFrameSize(this.getWidth()),
			height: vizFrameSize(this.getHeight()),
			vizType: this.getChartType(),
			uiConfig: this.getUiConfig(),
			vizProperties: this._getEffectiveProperties()
		});

		oVizFrame.setDataset(oDataset);
		oVizFrame.attachRenderComplete(null, this._updateLoadingIndicator.bind(this));

		oVizFrame.attachEvent("_zoomDetected", vizFrameZoomDetectedHandler.bind(this));

		// The loading page should hide after renderfail when in pagination.
		oVizFrame.attachEvent("renderFail", null, function(e) {
			var pagingController =  this._getPagingController();
			if (pagingController._sLoadingTimer) {
				jQuery.sap.clearDelayedCall(pagingController._sLoadingTimer);
				pagingController._sLoadingTimer = null;
			}
			this._showLoading(false);
		}, this);

		this._rendered = false;
        //prevent chart to be rendered if no dimension or measure is feed
        oVizFrame._readyToRender(false);

		this.setAggregation("_vizFrame", oVizFrame);
		this._delegateEvents();

		this._sAdapteredChartType = this.getChartType();
		this._bIsInitialized = true;
		this._oCandidateColoringSetting = {};

		this._oColoringStatus = {};
	    this._mNeedToUpdate = {};
        this._oColorTracker = new SeriesColorTracker();
        if (this._isEnablePaging()) {
			this._getPagingController();
		}
	};

	/**
	 * Set the chart custom messages. Supported messages please refer to enum {@link sap.chart.MessageId}.
	 *
	 * The user should handle the message localization.
	 *
	 * Example:
	 *
	 * <pre>
	 * oChart.setCustomMessages({
	 *	 'NO_DATA': "No data. Please change your filter"
	 * });
	 * </pre>
	 *
	 *When called with an invalid value, the default value will be restored.
	 *
	 * @param {object} oCustomMessages object containing customMessage values to update
	 * @public
	 * @returns {sap.chart.Chart}
	 */
	Chart.prototype.setCustomMessages = function(oCustomMessages) {
		this.setProperty("customMessages", oCustomMessages);
		var oVizFrame = this._getVizFrame();
		if (oVizFrame) {
			oVizFrame._setCustomMessages(oCustomMessages);
		}
		return this;
	};

	/*
	 * Internal API - get zoom information.
	 * @return {object} the zooming enablement and current zooming level of Chart.
	 */
	Chart.prototype._getZoomInfo = function() {
		var oVizFrame = this._getVizFrame();
		if (oVizFrame) {
			return oVizFrame._getZoomInfo();
		}
	};

	// ******** Public API ********

	/**
	 * Reset to visible layout.
	 * @public
	 * @returns {sap.chart.Chart} Reference to <code>this</code> in order to allow method chaining
	 */
	Chart.prototype.resetLayout = function() {
		this._invalidateBy({
			source: this,
			keys: {
				binding: true,
				vizFrame: true,
				drillStack: true,
				dataSet: true
			}
		});
		return this;
	};

	// ******************** Datapoint Selection ********************
	/**
	 * Select one or more data points, specified by datapoint objects.
	 *
	 * Datapoint object has the following structure:
	 * <pre>
	 * {
	 * 		groupId:  "groupId",		  // group ID (optional)
	 * 		index:		index,				  // index of the data in the group
	 * 		measures: ["measureId"]   // measure IDs
	 * }
	 * </pre>
	 *
	 * Only works when selectionBehavior is "DATAPOINT"
	 *
	 * @param {array} aDataPoints an array of datapoint objects.
	 *
	 * @public
	 * @returns {sap.chart.Chart} Reference to <code>this</code> in order to allow method chaining
	 */
	Chart.prototype.setSelectedDataPoints = function(aDataPoints) {
		if (this.getSelectionMode() !== library.SelectionMode.None) {
			var oBinding = this.getBinding("data"),
			oVizFrame = this._getVizFrame();
			if (!oBinding || !oVizFrame || this.getSelectionBehavior().toUpperCase() !== "DATAPOINT") {
				return this;
			}
			oVizFrame.vizSelection([], {clearSelection: true});
			oVizFrame.vizSelection(this._buildSelectedDataPoints(oBinding, aDataPoints), {
				selectionMode: this.getSelectionMode()
			});
		}
		return this;

	};

	/**
	 * Add one or more data points to current data point selection, specified by datapoint objects.
	 *
	 * Datapoint object has the following structure:
	 * <pre>
	 * {
	 * 		groupId:  "groupId",		  // group ID (optional)
	 * 		index:		index,				  // index of the data in the group
	 * 		measures: ["measureId"]   // measure IDs
	 * }
	 * </pre>
	 *
	 * Only works when selectionBehavior is "DATAPOINT"
	 *
	 * @param {array} aDataPoints an array of datapoint objects.
	 *
	 * @public
	 *
	 * @returns {sap.chart.Chart} Reference to <code>this</code> in order to allow method chaining
	 */
	Chart.prototype.addSelectedDataPoints = function(aDataPoints) {
		if (this.getSelectionMode() !== library.SelectionMode.None) {
			var oBinding = this.getBinding("data"),
			oVizFrame = this._getVizFrame();
			if (!oBinding || !oVizFrame || this.getSelectionBehavior().toUpperCase() !== "DATAPOINT") {
				return this;
			}
			oVizFrame.vizSelection(this._buildSelectedDataPoints(oBinding, aDataPoints), {
				selectionMode: library.SelectionMode.Multi
			});
		}
		return this;
	};

	/**
	 * Return a total number and an array of datapoint objects (including a Context object) of currently selected data points.
	 *
	 * Datapoint object has the following structure:
	 * <pre>
	 * {
	 * 		index:		index,		  // index of the data in the group
	 * 		measures: ["measureId"]   // measure IDs (data points created from the same Context object
	 * 														  // differing only in measure names are merged together)
	 * 		context:  [Context]		   // Context object
	 *		unit: {
	 *			measureId : ""	  // unit of measure
	 *		}
	 *		dataName: {
	 *			measureId or dimensionId : ""      // dataName of measure or dimension
	 *		}
	 * }
	 * </pre>
	 *
	 * Only works when selectionBehavior is "DATAPOINT"
	 *
	 * @public
	 *
	 * @return {object} a total number of selected data points, and an array of datapoint objects.
	 */
	Chart.prototype.getSelectedDataPoints = function() {
		var oVizFrame = this._getVizFrame();
		if (!oVizFrame || this.getSelectionBehavior().toUpperCase() !== "DATAPOINT") {
			return {
				count: 0,
				dataPoints: []
			};
		}
		var oSemanticTuples = this._getContinuesSemanticTuples();
		var mVisibleMsrs = this._getVisibleMeasures(),
			oDataSet = this._getDataset(),
			aSelectedDataPoints = oVizFrame.vizSelection() || [], mSelectedDataPoints = {};
		for (var i = 0, len = aSelectedDataPoints.length; i < len; i++) {
			var dataPoint = aSelectedDataPoints[i],
				idx = dataPoint.data._context_row_number;
			if (!mSelectedDataPoints[idx]) {
				mSelectedDataPoints[idx] = {
					index: idx,
					measures: [],
					context: oDataSet.findContext({"_context_row_number": idx})
				};
			}
			dataPoint.measures = SelectionAPIUtils.filterVisibleMsr(dataPoint.data, mVisibleMsrs);
			if (!jQuery.isEmptyObject(oSemanticTuples)) {
				SelectionAPIUtils.filterSemMsr(oSemanticTuples, mVisibleMsrs, dataPoint);
			}
			mSelectedDataPoints[idx].measures = mSelectedDataPoints[idx].measures.concat(dataPoint.measures);
			if (dataPoint.unit) {
				mSelectedDataPoints[idx].unit = jQuery.extend(true, mSelectedDataPoints[idx].unit, dataPoint.unit);
			}
			if (dataPoint.dataName) {
				mSelectedDataPoints[idx].dataName = jQuery.extend(true, mSelectedDataPoints[idx].dataName, dataPoint.dataName);
			}
		}
		return {
			count: aSelectedDataPoints.length,
			dataPoints: Object.keys(mSelectedDataPoints).map(function(id) {
				return mSelectedDataPoints[id];
			})
		};
	};

	/**
	 * Deselect one or more data points from current data point selections, specified by datapoint objects.
	 *
	 * Datapoint object has the following structure:
	 * <pre>
	 * {
	 * 		groupId:  "groupId",		  // group ID (optional)
	 * 		index:		index,				  // index of the data in the group
	 * 		measures: ["measureId"]   // measure IDs
	 * }
	 * </pre>
	 *
	 * Only works when selectionBehavior is "DATAPOINT"
	 *
	 * @public
	 *
	 * @param {array} aDataPoints an array of datapoint objects.
	 *
	 * @returns {sap.chart.Chart} Reference to <code>this</code> in order to allow method chaining
	 */
	Chart.prototype.removeSelectedDataPoints = function(aDataPoints) {
		if (this.getSelectionMode() !== library.SelectionMode.None) {
			var oBinding = this.getBinding("data"),
			oVizFrame = this._getVizFrame();
			if (!oVizFrame || this.getSelectionBehavior().toUpperCase() !== "DATAPOINT") {
				return this;
			}
			var aToRemove = this._buildSelectedDataPoints(oBinding, aDataPoints);
			oVizFrame.vizSelection(aToRemove, {
				deselection: true
			});
		}
		return this;
	};

	// ******************** Category Selection ********************
	/**
	 * Select one or more categories, specified by category objects.
	 *
	 * Category object has the following structure:
	 * <pre>
	 * {
	 *	   measure: measureName,
	 *	   dimensions: {
	 *		   dimensionName1: dimensionValue1,
	 *		   dimensionName2: dimensionValue2,
	 *		   ...
	 *	   }
	 * }
	 * </pre>
	 *
	 * Only works when selectionBehavior is "CATEGORY"
	 *
	 * @public
	 *
	 * @param {array} aCategories an array of category objects
	 *
	 * @returns {sap.chart.Chart} Reference to <code>this</code> in order to allow method chaining
	 */
	Chart.prototype.setSelectedCategories = function(aCategories) {
		if (this.getSelectionMode() !== library.SelectionMode.None) {
			var oVizFrame = this._getVizFrame(),
			sBehavior = this.getSelectionBehavior().toUpperCase();
			if (!oVizFrame || sBehavior !== "CATEGORY") {
				return this;
			}
			oVizFrame.vizSelection([], {clearSelection: true});
			oVizFrame.vizSelection(aCategories.map(SelectionAPIUtils.toVizCSCtx), {
				selectionMode: this.getSelectionMode()
			});
		}
		return this;
	};

	/**
	 * Add one or more categories to current category selections, specified by category objects.
	 *
	 * Category object has the following structure:
	 * <pre>
	 * {
	 *	   measure: measureName,
	 *	   dimensions: {
	 *		   dimensionName1: dimensionValue1,
	 *		   dimensionName2: dimensionValue2,
	 *		   ...
	 *	   }
	 * }
	 * </pre>
	 *
	 * Only works when selectionBehavior is "CATEGORY"
	 *
	 * @public
	 *
	 * @param {array} aCategories an array of category objects
	 *
	 * @returns {sap.chart.Chart} Reference to <code>this</code> in order to allow method chaining
	 */
	Chart.prototype.addSelectedCategories = function(aCategories) {
		if (this.getSelectionMode() !== library.SelectionMode.None) {
			var oVizFrame = this._getVizFrame(),
			sBehavior = this.getSelectionBehavior().toUpperCase();
			if (!oVizFrame || sBehavior !== "CATEGORY") {
				return this;
			}
			oVizFrame.vizSelection(aCategories.map(SelectionAPIUtils.toVizCSCtx), {
				selectionMode: library.SelectionMode.Multi
			});
		}
		return this;
	};

	/**
	 * Deselect one or more categories from current category selections, specified by category objects.
	 *
	 * Category object has the following structure:
	 * <pre>
	 * {
	 *	   measure: measureName,
	 *	   dimensions: {
	 *		   dimensionName1: dimensionValue1,
	 *		   dimensionName2: dimensionValue2,
	 *		   ...
	 *	   }
	 * }
	 * </pre>
	 *
	 * Only works when selectionBehavior is "CATEGORY"
	 *
	 * @public
	 *
	 * @param {array} aCategories an array of category objects
	 *
	 * @returns {sap.chart.Chart} Reference to <code>this</code> in order to allow method chaining
	 */
	Chart.prototype.removeSelectedCategories = function(aCategories) {
		if (this.getSelectionMode() !== library.SelectionMode.None) {
			var oVizFrame = this._getVizFrame(),
			sBehavior = this.getSelectionBehavior().toUpperCase();
			if (!oVizFrame || sBehavior !== "CATEGORY") {
				return this;
			}
			oVizFrame.vizSelection(aCategories.map(SelectionAPIUtils.toVizCSCtx), {
				deselection: true
			});
		}
		return this;
	};

	/**
	 * Return category objects of currently selected categories and a total number of selected data points.
	 *
	 * Category object has the following structure:
	 * <pre>
	 * {
	 *	   measure: measureName,
	 *	   dimensions: {
	 *		   dimensionName1: dimensionValue1,
	 *		   dimensionName2: dimensionValue2,
	 *		   ...
	 *	   }
	 * }
	 * </pre>
	 *
	 * Return 0 and empty list if selectionBehavior is not "CATEGORY"
	 *
	 * @public
	 *
	 * @return {object} a total number of selected data points, and an array of category objects for selected categories.
	 */
	Chart.prototype.getSelectedCategories = function() {
		var oVizFrame = this._getVizFrame(),
			sBehavior = this.getSelectionBehavior().toUpperCase();
		if (!oVizFrame || sBehavior !== "CATEGORY") {
			return {
				count: 0,
				categories: []
			};
		} else {
			var aSelections = oVizFrame.vizSelection();
			return {
				count: aSelections.length,
				categories: (aSelections.category || []).map(SelectionAPIUtils.fromVizCSCtx)
			};
		}
	};

	// ******************** Series Selection ********************
	/**
	 * Select one or more series, specified by series objects.
	 *
	 * Series object has the following structure:
	 * <pre>
	 * {
	 *	   measure: measureName,
	 *	   dimensions: {
	 *		   dimensionName1: dimensionValue1,
	 *		   dimensionName2: dimensionValue2,
	 *		   ...
	 *	   }
	 * }
	 * </pre>
	 *
	 * Only works when selectionBehavior is "SERIES"
	 *
	 * @public
	 *
	 * @param {array} aSeries an array of series objects
	 *
	 * @returns {sap.chart.Chart} Reference to <code>this</code> in order to allow method chaining
	 */
	Chart.prototype.setSelectedSeries = function(aSeries) {
		if (this.getSelectionMode() !== library.SelectionMode.None) {
			var oVizFrame = this._getVizFrame(),
			sBehavior = this.getSelectionBehavior().toUpperCase();
			if (!oVizFrame || sBehavior !== "SERIES") {
				return this;
			}
			oVizFrame.vizSelection([], {clearSelection: true});
			var aSelectedSeries = this._getEffectiveContinuesSeries(aSeries);
			oVizFrame.vizSelection(aSelectedSeries.map(SelectionAPIUtils.toVizCSCtx), {
				selectionMode: this.getSelectionMode()
			});
		}
		return this;
	};

	/**
	 * Add one or more series to current series selections, specified by series objects.
	 *
	 * Series object has the following structure:
	 * <pre>
	 * {
	 *	   measure: measureName,
	 *	   dimensions: {
	 *		   dimensionName1: dimensionValue1,
	 *		   dimensionName2: dimensionValue2,
	 *		   ...
	 *	   }
	 * }
	 * </pre>
	 *
	 * Only works when selectionBehavior is "SERIES"
	 *
	 * @public
	 *
	 * @param {array} aSeries an array of series objects
	 *
	 * @returns {sap.chart.Chart} Reference to <code>this</code> in order to allow method chaining
	 */
	Chart.prototype.addSelectedSeries = function(aSeries) {
		if (this.getSelectionMode() !== library.SelectionMode.None) {
			var oVizFrame = this._getVizFrame(),
			sBehavior = this.getSelectionBehavior().toUpperCase();
			if (!oVizFrame || sBehavior !== "SERIES") {
				return this;
			}
			var aSelectedSeries = this._getEffectiveContinuesSeries(aSeries);
			oVizFrame.vizSelection(aSelectedSeries.map(SelectionAPIUtils.toVizCSCtx), {
				selectionMode: library.SelectionMode.Multi
			});
		}
		return this;
	};

	/**
	 * Deselect one or more series from current series selections, specified by series objects.
	 *
	 * Series object has the following structure:
	 * <pre>
	 * {
	 *	   measure: measureName,
	 *	   dimensions: {
	 *		   dimensionName1: dimensionValue1,
	 *		   dimensionName2: dimensionValue2,
	 *		   ...
	 *	   }
	 * }
	 * </pre>
	 *
	 * Only works when selectionBehavior is "SERIES"
	 *
	 * @public
	 *
	 * @param {array} aSeries an array of series objects
	 *
	 * @returns {sap.chart.Chart} Reference to <code>this</code> in order to allow method chaining
	 */
	Chart.prototype.removeSelectedSeries = function(aSeries) {
		if (this.getSelectionMode() !== library.SelectionMode.None) {
			var oVizFrame = this._getVizFrame(),
			sBehavior = this.getSelectionBehavior().toUpperCase();
			if (!oVizFrame || sBehavior !== "SERIES") {
				return this;
			}
			var aSelectedSeries = this._getEffectiveContinuesSeries(aSeries);
			oVizFrame.vizSelection(aSelectedSeries.map(SelectionAPIUtils.toVizCSCtx), {
				deselection: true
			});
		}
		return this;
	};

	/**
	 * Return series objects of currently selected series and a total number of selected data points.
	 *
	 * Series object has the following structure:
	 * <pre>
	 * {
	 *	   measure: measureName,
	 *	   dimensions: {
	 *		   dimensionName1: dimensionValue1,
	 *		   dimensionName2: dimensionValue2,
	 *		   ...
	 *	   }
	 * }
	 * </pre>
	 *
	 * Return 0 and empty list if selectionBehavior is not "SERIES"
	 *
	 * @public
	 *
	 * @return {object} object containing a total number of selected data points,
	 * and an array of series objects for selected series.
	 *
	 */
	Chart.prototype.getSelectedSeries = function() {
		var oVizFrame = this._getVizFrame(),
			sBehavior = this.getSelectionBehavior().toUpperCase();
		if (!oVizFrame || sBehavior !== "SERIES") {
			return {
				count: 0,
				series: []
			};
		} else {
			var aSelections = oVizFrame.vizSelection(),
				aSeries = (aSelections.series || []).map(SelectionAPIUtils.fromVizCSCtx),
				aSemanticMsrs = [], semanticTuples = this._getContinuesSemanticTuples();

			aSeries = aSeries.filter(function(series){
				var accepted = true;
				if (series && series.measures) {
					var semanticTuple = semanticTuples[series.measures];
					if (semanticTuple &&  semanticTuple.semanticMsrName === series.measures) {
						aSemanticMsrs.push({
							measures : semanticTuple.actual
						});
						aSemanticMsrs.push({
							measures : semanticTuple.projected
						});
						accepted = false;
					}
				}
				return accepted;
			});
			aSeries = aSeries.concat(aSemanticMsrs);
			return {
				count: aSelections.length,
				series: aSeries
			};
		}
	};

	// ******** Drill down/up API ********

	/**
	 * Drill down on specific Dimension(s), only works when the property isAnalytical is true.
	 *
	 * The drill down Dimension(s) must present in the Dimension aggregation
	 * and must NOT present in previous drill down or be visible already.
	 *
	 * <b>NOTE:</b> parameter <code>oBindingInfo.length</code> during {@link sap.ui.base.ManagedObject#bindAggregation bindAggregation} of {@link #getData data} always takes effect in drill workflow.
	 *
	 * @public
	 *
	 * @param {array} vDimensions an array, or just a single instance, of either Dimension instance or Dimension name to drill down
	 */
	Chart.prototype.drillDown = function(vDimensions) {
		if (this.getIsAnalytical() === false) {
			jQuery.sap.log.error('Data source does not support drillDown/drillUp. The method "drillDown" therefore cannot be used!');
			return;
		}
		// make sure that only dimensions are drilled down
		if (vDimensions && !(vDimensions instanceof Array)) {
			vDimensions = [vDimensions];
		}
		var aDimensions = this._normalizeDorM(vDimensions, true);

		if (aDimensions.length === 0) {
			return;
		}
		if (!this._checkDrilldownValid(aDimensions)) {
			jQuery.sap.log.warning("Drill down not possible for " + aDimensions + ". Already drilled down.");
			return;
		}

		var oStackTop = this._getDrillStateTop(),
			mRedundants = this._redundantsFromSelection(),
			oSelectionFilter = this._deriveFilterFromSelection();

		var oNewFilter;
		if (oSelectionFilter) {
			oNewFilter = !(oStackTop && oStackTop.filter) ? oSelectionFilter : new Filter([oSelectionFilter, oStackTop.filter], true);
		}

		// dimension(s) can be used for drill down
		this._drillStateStack.push({
			dimensions: oStackTop.dimensions.slice().concat(aDimensions.map(function(oDim) {
				return oDim.getName();
			})).filter(function(sDim) {
				return !mRedundants[sDim];
			}),
			measures:  oStackTop.measures.filter(function(sMsr) {
				return !mRedundants.measureNames[sMsr];
			}),
			filter: oNewFilter,
			redundant: mRedundants
		});

		var aDimensionNames = aDimensions.map(function(oDim) {
			return oDim.getName();
		});
		this.fireDrilledDown({
			dimensions: aDimensionNames
		});
		this._invalidateBy({
			source: this,
			keys: {
				binding: true,
				vizFrame: true
			}
		});
	};

	/**
	 * Drill up to previous drill down state, only works when the property isAnalytical is true.
	 *
	 * <b>NOTE:</b> parameter <code>oBindingInfo.length</code> during {@link sap.ui.base.ManagedObject#bindAggregation bindAggregation} of {@link #getData data} always takes effect in drill workflow.
	 *
	 * @param {Integer} iIndex index of drill state in history to drill up. Default to the previous state in history if available.
	 *
	 * @public
	 */
	Chart.prototype.drillUp = function(iIndex) {
		if (this.getIsAnalytical() === false) {
			jQuery.sap.log.error('Data source does not support drillDown/drillUp. The method "drillUp" therefore cannot be used!');
			return;
		}
        if (arguments.length === 0) {
			iIndex = this._drillStateStack.length - 2;
		}
		var oNewStackTop = this._drillStateStack[iIndex];
		if (oNewStackTop && iIndex != this._drillStateStack.length - 1) {
			var oPreviousState = this._drillStateStack.pop();
			this._drillStateStack.splice(iIndex + 1);
			this.fireDrilledUp({
				dimensions: oPreviousState.dimensions.filter(function(d) {
					return oNewStackTop.dimensions.indexOf(d) === -1;
				})
			});
			this._invalidateBy({
				source: this,
				keys: {
					binding: true,
					vizFrame: true
				}
			});
		}
	};

	/**
	 * Return all drill down states, only works when the property isAnalytical is true.
	 *
	 * @return {Object[]} array of drill state objects
	 * @public
	 */
	Chart.prototype.getDrillStack = function() {
		if (this.getIsAnalytical() === false) {
			jQuery.sap.log.error('Data source does not support drillDown/drillUp. The method "getDrillStack" therefore cannot be used!');
			return;
		}
		return jQuery.map(this._drillStateStack || [], function(oState, i) {
			return {
				dimension: oState.dimensions.slice(),
				measure: oState.measures.slice(),
				filter: oState.filter
			};
		});
	};

	/**
		 * Setter for property uiConfig. uiConfig could only set via settings parameter
		 * of constructor.
		 *
		 * uiConfig from base type could config the instance. Supported uiConfig
		 * keyword: applicationSet, showErrorMessage
		 *
		 * Example:
		 *
		 * <pre>
		 * var chart = new sap.chart.Chart({
		 *  'chartType' : 'bar',
		 *  'uiConfig' : {
		 *		  'applicationSet' : 'fiori',
		 *		  'showErrorMessage' : true
		 *  }
		 * });
		 * </pre>
		 *
		 * @param {object}
		 *						oUiConfig the UI configuration
		 * @public
		 * @name sap.chart.Chart#setUiConfig
		 * @function
		 */
	Chart.prototype.setUiConfig = function(oUiConfig) {
		this.setProperty("uiConfig", oUiConfig);
		if (this._getVizFrame()) {
			this._getVizFrame().setUiConfig(oUiConfig);
		}
	};

	var VizPropertiesHelper = (function() {
		var BLACKLIST = [
			"interaction.selectability.mode",		// via setSelectionMode API
			"interaction.selectability.behavior"	// via setSelectionBehavior API
		];

		function deleteProp(obj, propPath) {
			var target = obj,
				vals;
			vals = propPath.reduce(function(entries, prop) {
				if (target.hasOwnProperty(prop)) {
					entries.push({parent: target, val: target[prop], key:prop});
					target = target[prop];
				}
				return entries;
			}, []);
			if (vals.length !== propPath.length) {
				return;
			}
			var entry = vals.pop();
			delete entry.parent[entry.key];
			while (vals.length > 0) {
				entry = vals.pop();
				if (Object.keys(entry.val).length > 0) {
					return;
				} else {
					delete entry.parent[entry.key];
				}
			}
		}

		function sanitize(oVizProperties, type) {
			var oResult = jQuery.extend(true, {}, oVizProperties);
			BLACKLIST.forEach(function(prop) {
				delete oResult[prop];
				deleteProp(oResult, prop.split("."));
			});
			return oResult;
		}
		return {
			sanitize: sanitize,
			modify: function(oProps, sKey, fnReplace) {
				var aPath = sKey.split("."),
					oNode = oProps;
				while (aPath.length > 1 && oNode.hasOwnProperty(aPath[0])) {
					oNode = oNode[aPath.shift()];
				}
				var sProp = aPath[0];
				if (aPath.length === 1 && oNode.hasOwnProperty(sProp)) {
					oNode[sProp] = fnReplace(oNode[sProp]);
				}
			}
		};
	})();

	/**
	 * Change Chart's properties.
	 *
	 * Chart's properties will be updated with the parameter.
	 *
	 * Refer to chart property <a href="../../vizdocs/index.html" target="_blank">documentation</a> for more details.
	 *
	 * @param {object}
	 *			  oVizProperties object containing vizProperty values to update
	 * @public
	 */
	Chart.prototype.setVizProperties = function(oVizProperties) {
		oVizProperties = VizPropertiesHelper.sanitize(oVizProperties);
		this.setProperty("vizProperties", oVizProperties);
		
		if (oVizProperties.plotArea && oVizProperties.plotArea.dataPointStyle) {
			this._bDataPointStyleSetByUser = true;
			this._invalidateBy({
				source: this,
				keys: {
					// update vizFrame since feeding depends on semantic rules in coloring case
					vizFrame: true,
					loopData: true
				}
			});
		}
		
		if (oVizProperties.legend && oVizProperties.legend.title) {
			this._bLegendSetByUser = true;
		}
		
		// always call setVizProperties of vizframe to cache properties when initialization
		// currently there is no implementation to operate cached property(e.g. modify dataPointStyle's displayName)
		// in this case we respect user's oginial input
		if (this._getVizFrame()) {
			this._getVizFrame().setVizProperties(this._getEffectiveProperties());
		}
	};

	/**
	 * Return Chart's properties.
	 *
	 * Refer to chart property <a href="../../vizdocs/index.html" target="_blank">documentation</a> for more details.
	 *
	 * @returns {object} the Chart properties object
	 * @public
	 */
	Chart.prototype.getVizProperties = function() {
		var oVizFrame = this._getVizFrame();
		var oVizProps = VizPropertiesHelper.sanitize(oVizFrame ? oVizFrame.getVizProperties() : this.getProperty("vizProperties"));

		function stripUnit(oFmtStr) {
			var oFormatter = sap.viz.api.env.Format.numericFormatter();
			if (!oFormatter || jQuery.type(oFormatter.stripUnit) !== "function") {
				return oFmtStr;
			}

			if (jQuery.type(oFmtStr) === "string") {
				return oFormatter.stripUnit(oFmtStr);
			} else if (jQuery.type(oFmtStr) === "object") {
				jQuery.each(oFmtStr, function(k, v){
					oFmtStr[k] = oFormatter.stripUnit(v);
				});
				return oFmtStr;
			} else {
				return oFmtStr;
			}
		}

		VizPropertiesHelper.modify(oVizProps, "plotArea.dataLabel.formatString", stripUnit);
		VizPropertiesHelper.modify(oVizProps, "tooltip.formatString", stripUnit);

		return oVizProps;
	};

	/**
	 * Change Chart's scales.
	 *
	 * Chart's scales will be updated with the parameters.
	 *
	 * Refer to chart property <a href="../../vizdocs/index.html" target="_blank">documentation</a> for more details.
	 *
	 * @param {object[]}
	 *			  oVizScales array of vizScale objects
	 * @public
	 */
	Chart.prototype.setVizScales = function(oVizScales) {
		this.setProperty("vizScales", oVizScales);
		this._aVizValueScales = oVizScales.filter(function(oVizScale) {
			return oVizScale.feed === "valueAxis" ||
				oVizScale.feed === "valueAxis2" ||
				oVizScale.feed === "actualValues";
		});
		if (this._aVizValueScales && this._aVizValueScales.length > 0) {
			this._bEnbableValueAxisScale = false;
		}
		if (this._getVizFrame()) {
			this._getVizFrame().setVizScales(oVizScales);
		}
	};

	/**
	 * Return Chart's scales.
	 *
	 * Refer to chart property <a href="../../vizdocs/index.html" target="_blank">documentation</a> for more details.
	 *
	 * @returns {object[]} an array of scale objects
	 * @public
	 */
	Chart.prototype.getVizScales = function() {
		var oVizFrame = this._getVizFrame();
		return oVizFrame ? oVizFrame.getVizScales() : this.getProperty("vizScales");

	};

	// ******** Delegations of VizFrame API ********
	/**
	 * Get the UID for Chart. It supports other controls to connect to a viz instance.
	 *
	 * @return {string} Chart UID
	 * @public
	 */
	Chart.prototype.getVizUid = function() {
		return this._getVizFrame().getVizUid();
	};

	/**
	 * Zoom the chart plot.
	 *
	 * Example:
	 * <pre>
	 *	var oChart = new sap.chart.Chart(...);
	 *	oChart.zoom({direction: "in"});
	 * </pre>
	 *
	 * @param {object} oConfig
	 *			  contains a "direction" attribute with value "in" or "out" indicating zoom to enlarge or shrink respectively
	 * @public
	 */
	Chart.prototype.zoom = function(oConfig) {
		this._getVizFrame().zoom(oConfig);
	};

	// ******** Delegations of VizFrame events ********
	var DELEGATED_EVENTS = ["selectData", "deselectData"];
	Chart.prototype._delegateEvents = function() {
		if (this._delegateEventHandlers) {
			return;
		}
		var oVizFrame = this._getVizFrame();
		this._delegateEventHandlers = DELEGATED_EVENTS.map(function(sEvent) {
			var sName = sEvent.charAt(0).toUpperCase() + sEvent.slice(1);
			var handler = function(oEvent) {
				var oParameters = oEvent.getParameters();
				this._buildSelectEventData(oParameters.data);
				delete oParameters.id;
				this.fireEvent(sEvent, oParameters);
			};
			handler = handler.bind(this);

			oVizFrame["attach" + sName](null, handler);
			return {
				name: sName,
				handler: handler
			};
		}, this);

		this._vizFrameRenderCompleteHandler = vizFrameRenderCompleteHandler.bind(this);
		oVizFrame.attachRenderComplete(null, this._vizFrameRenderCompleteHandler);
		oVizFrame.attachEvent("_selectionDetails", vizFrameSelectionDetailsHandler.bind(this));
	};

	/**
	 * @private
	 */
	Chart.getChartTypes = sap.chart.api.getChartTypes;

	/**
	 * Returns available and unavailable chart types with current Dimensions and Measures.
	 * An error info will be returned along with each unavailable chart types.
	 *
	 * <pre>
	 * {
	 *		 available: [{
	 *				 chart: "chartType"
	 *		 }, ...],
	 *		 unavailable: [{
	 *				 chart: "chartType"
	 *				 error: {
	 *						 missing: {
	 *								 Dimension: n,
	 *								 Measure: n,
	 *								 DateTimeDimension: n
	 *						 }
	 *				 }
	 *		 }, ...]
	 * }
	 * </pre>
	 *
	 * @public
	 *
	 * @returns {object} chart types and errors for unavailable chart types, grouped by availability
	 */
	Chart.prototype.getAvailableChartTypes = function () {
		var aDims = this._getVisibleDimensions(true),
			aMsrs = this._getVisibleMeasures(true);
		return ChartUtils.CONFIG.chartTypes.reduce(function(oResult, sChartType) {
			var oCompatibility = RoleFitter.compatible(sChartType, aDims, aMsrs);
			if (oCompatibility.compatible) {
				oResult.available.push({chart: sChartType});
			} else {
				var oMissing = {};
				if (oCompatibility.error.missing.dim) {
					oMissing.Dimension = oCompatibility.error.missing.dim;
				}
				if (oCompatibility.error.missing.time) {
					oMissing.DateTimeDimension = oCompatibility.error.missing.time;
				}
				if (oCompatibility.error.missing.msr) {
					oMissing.Measure = oCompatibility.error.missing.msr;
				}
				oResult.unavailable.push({
					chart: sChartType,
					error: oMissing
				});
			}
			return oResult;
		}, {
			available: [],
			unavailable: []
		});
	};

	Chart.prototype._getDynamicScaleProp =  function(){
		return { 
			general : {
				enableScalingFactor: this.getEnableScalingFactor()
			}
		};
	};

	Chart.prototype._getEffectiveProperties = function() {
		var oVizProperties = {
			'title' : {
				'visible' : false
			}
		};
		if (this._bNeedToApplyDefaultProperties) {
			oVizProperties = jQuery.extend(true, oVizProperties, this._getDefaultVizProperties());
			this._bNeedToApplyDefaultProperties = false;
		}

		oVizProperties = jQuery.extend(true, oVizProperties,
			this._oSemanticVizSettings.properties || {},
			this.getProperty("vizProperties"),
			this._getHostedVizProperties(),
			this._getPagingVizProperties(),
			this._getTimeProperties(),
			this._getValueAxisScaleSetting().property || {},
			this._getDynamicScaleProp());

		return oVizProperties;
	};

	Chart.prototype._setEffectiveScales = function() {
		/* Priority order: 
		* 1. valueAxisScales > vizValueScales.
		* 2. vizColorScales > _oSemanticScales(_oSemanticScales will be empty if vizColorScales is not set).
		* So effecttiveScales is consist of valueAxisScales, vizScales(including vizValueScales and vizColorScales), and semanticScales.
		*/
		var oVizFrame = this._getVizFrame(),
			oVizScales = this.getProperty('vizScales'),
			oValueAxisScaleSetting = this._getValueAxisScaleSetting(),
			vizColorScale = (oVizScales || []).filter(function(oScale){
				return oScale.feed === 'color';
			});
		var effecttiveScales = CommonUtil.extendScales(oVizScales, oValueAxisScaleSetting.scale || [], this._oSemanticVizSettings.scales || []);
		if (this._oSemanticVizSettings.replaceColorScales && vizColorScale.length === 0) {
			//Clear color scale if there isn't any color scales setting.
			oVizFrame.setVizScales(effecttiveScales, {replace: true});
		} else {
			oVizFrame.setVizScales(effecttiveScales);
		}
	};

	Chart.prototype._usingDisplayNameForSemantics = function(oVizProperties) {
		//check whether the parameter is undefined or null
		var isExist = function(o) {
			if ((typeof (o) === 'undefined') || (o === null)) {
				return false;
			}
			return true;
		};

		if (oVizProperties.plotArea && oVizProperties.plotArea.dataPointStyle && oVizProperties.plotArea.dataPointStyle.rules) {
			
			/*
			If semantic rules meet the following 4 conditions:
			(1) aRules[i].displayName === undefined : displayName isn’t defined
			(2) akeys.length === 1 : Only one sematic rules condition;
			(3) oDataContext[key].hasOwnProperty("equal") == true : use ‘equal’ label;
			(4) aVisibleDimensions.indexOf(key) !== -1 : the condition is for dimension;
			Then if the value of 'equal' is equal to some value in oBindingData, when meet the any of the following 2 conditions:
			(1) this.getDimensionByName(key).getTextProperty() === undefined
			(2) this.getDimensionByName(key).getDisplayText() === false
			set the corresponding value of 'equal' to the the rule's displayName. otherwise, set the displayText to the rule's displayName.
			Otherwise show the default "Semantic Range1".
			*/

			//currently, there are only two types of binding
			var aContexts = this._getContexts();
			if (aContexts.length > 0 && !aContexts.hasOwnProperty("dataRequested")) {
				var aVisibleDimensions = this.getVisibleDimensions(),
					aRules = oVizProperties.plotArea.dataPointStyle.rules;
				for (var i = 0; i < aRules.length; i++) {
					var oDataContext = aRules[i].dataContext;
					if (oDataContext && oDataContext.length !== 0) {
						var akeys = Object.keys(oDataContext);
						if ( !isExist(aRules[i].displayName) && akeys.length === 1) {
							var key = akeys[0];
							if (oDataContext[key].hasOwnProperty("equal") && aVisibleDimensions.indexOf(key) !== -1) {
								var sTextProperty = this.getDimensionByName(key).getTextProperty();
								for (var j = 0; j < aContexts.length; j++) {
									if (aContexts[j].getProperty(key) === oDataContext[key].equal) {
										var sDisplayName = aContexts[j].getProperty(sTextProperty);
										if (!isExist(sTextProperty) || !isExist(sDisplayName) || typeof (sDisplayName) === "object" || this.getDimensionByName(key).getDisplayText() === false) {
											aRules[i].displayName = oDataContext[key].equal;
											break;
										} else {
											aRules[i].displayName = sDisplayName;
											break;
										}
									}
								}
							}
						}
					}
				}
			}
		}
	};

	Chart.prototype._getCandidateColoringSetting = function() {
		if (!this._bColoringParsed) {
			if (this._enableSemanticColoring()) {
				this._bColoringParsed = true;
				this._oCandidateColoringSetting = {};
				var oDimMsr = {},
				oColoring = this.getColorings(),
				oActiveColoring = this.getActiveColoring();
				oDimMsr.aMsr = this._normalizeDorM(this.getVisibleMeasures());

				var oStackTop = this._getDrillStateTop();
				var aRedundantDims = [], aVisibleDims;
				if (oStackTop.redundant) {
				// consider redundant dimensions as visible dim when matching ConstantThresholds.AggregationLevels.VisibleDimensions
				var aRedundantDims = Object.keys(oStackTop.redundant).filter(function(key) {
					return key !== 'measureNames';
				});
			}
			aVisibleDims = this._normalizeDorM(this.getVisibleDimensions().concat(aRedundantDims), true);
			oDimMsr.aDim = aVisibleDims;

			oDimMsr.aInResultDim = this._normalizeDorM(this.getInResultDimensions(), true);
			oDimMsr.allMsr = this.getMeasures().map(function(oMsr){
				return oMsr.getName();
			});
			oDimMsr.allDim = this.getDimensions().map(function(oDim){
				return oDim.getName();
			});

			if (oColoring) {
				try {
					var sUrl = jQuery.sap.getResourcePath("sap/chart/i18n/i18n.properties");
					var oBundle = jQuery.sap.resources({
						url: sUrl
					});
					var options = {
						bFiltered: this._bFilterCalledByCustomer
					};
					this._oCandidateColoringSetting = Colorings.getCandidateSetting(oColoring, oActiveColoring, this._semanticTuples, oDimMsr, this._oColoringStatus || {}, this._sAdapteredChartType || this.getChartType(), oBundle, options);
					//use original chartType here since adapted chartType is not ready in some workflow
				} catch (e) {
					if (e instanceof ChartLog) {
						e.display();
					} else {
						throw e;
					}
				}
			}
		} else {
			this._oCandidateColoringSetting = {};
		}

	}
		return this._oCandidateColoringSetting;
	};


	// ---------------- Hosted VizProperties ----------------
	Chart.prototype._hostedVizProperties = {
		selectionMode: {prop: "interaction.selectability.mode"},
		selectionBehavior: {prop: "interaction.selectability.behavior"}
	};

	Chart.prototype._getHostedVizProperties = function() {
		return Object.keys(this._hostedVizProperties).reduce(function(obj, prop) {
			var oSubProp = this._hostedVizProperties[prop].prop.split(".").reverse().reduce(function(obj, path) {
				var result = {};
				result[path] = obj;
				return result;
			}, this.getProperty(prop));
			return jQuery.extend(true, obj, oSubProp);
		}.bind(this), {});

    };

	Chart.prototype._getDefaultVizProperties = function() {
		// Use UI5 formatter by default in analytic chart
		var type = 'info/' + (this._sAdapteredChartType || this.getChartType());
		var bIsPercentage = (type.indexOf("info/100_") === 0);
		var bIsPie = (type === "info/pie" || type === "info/donut");
		var oDefaults = {
			interaction: {
				extraEventInfo: true
			}
		};

		return jQuery.extend(true, oDefaults,
							 applyDefaultFormatString({}, type,
													  ["valueAxis.label.formatString", "valueAxis2.label.formatString"],
													  bIsPercentage ? '' : ChartFormatter.DefaultPattern.SHORTFLOAT),
							 applyDefaultFormatString({}, type,
													  ["legend.formatString", "sizeLegend.formatString"],
													  ChartFormatter.DefaultPattern.SHORTFLOAT_MFD2),
							 applyDefaultFormatString({}, type,
													  ["plotArea.dataLabel.formatString"],
													  bIsPie ? '' : ChartFormatter.DefaultPattern.SHORTFLOAT_MFD2),
							 applyDefaultFormatString({}, type,
													  ["tooltip.formatString"],
													  bIsPercentage ? '' : ChartFormatter.DefaultPattern.STANDARDFLOAT));

		function setPropertiesValue(properties, path, value) {
			if (path.length === 0) {
				return value;
			}
			properties = properties || {};
			var p = properties[path[0]];
			properties[path[0]] = setPropertiesValue(p, path.slice(1), value);
			return properties;
		}

		function getPropertiesDefination(propDef, path) {
			if (propDef == null || path.legnth === 0) {
				return propDef;
			}
			var e = propDef[path[0]];
			if (e && e.children) {
				return getPropertiesDefination(e.children, path.slice(1));
			}
			return e;
		}

		function applyDefaultFormatString(properties, chartType, formatStringPaths, formatString) {
			var metadata = sap.viz.api.metadata.Viz.get(chartType);
			if (metadata) {
				var propDef = metadata.properties;
				formatStringPaths.forEach(function(path) {
					path = path.split(".");
					var p = getPropertiesDefination(propDef, path);
					if (p && p.hasOwnProperty("defaultValue")) {
						setPropertiesValue(properties, path, formatString);
					}
				});
			}
			return properties;
		}
	};

	Chart.prototype._getPagingVizProperties = function() {
		if (this._isEnablePaging()) {
			var oPagingProperties = {
				interaction: {
					zoom: {
						enablement: false
					},
					selectability: {
						mode: "NONE"
					}
				},
				plotArea: {
					isFixedDataPointSize: true
				}
			};
			return oPagingProperties;
		} else {
			return {};
		}
	};

	Chart.prototype._getTimeProperties = function() {
		var aTimeLevels = ["year", "month", "day"]; //default value
		var oFiscalYearPeriodCount = null;  //default value
		var that = this;
		var sTimeDim = this.getVisibleDimensions().filter(function(sDim) {
			var oDim = that.getDimensionByName(sDim);
			return (oDim instanceof sap.chart.data.TimeDimension && oDim._getFixedRole() === "category");
		})[0];
		
		var sweekConfig = "ISO";
		var iMinDays, iFirstDayOfWeek, region;

		if (sTimeDim) {
			var oTimeDim = this.getDimensionByName(sTimeDim);
			switch (oTimeDim.getTimeUnit()) {
				case TimeUnitType.yearmonthday:
					aTimeLevels = ["year", "month", "day"];
					break;
				case TimeUnitType.yearquarter:
					aTimeLevels = ["year", "quarter"];
					break;
				case TimeUnitType.yearmonth:
					aTimeLevels = ["year", "month"];
					break;
				case TimeUnitType.yearweek:
					aTimeLevels = ["year", "week"];

					var oLocale = sap.ui.getCore().getConfiguration().getFormatSettings().getFormatLocale(),
						oLocaleData = LocaleData.getInstance(oLocale),
						region = oLocale.getRegion();

					iMinDays = oLocaleData.getMinimalDaysInFirstWeek();
					iFirstDayOfWeek = oLocaleData.getFirstDayOfWeek();
					iFirstDayOfWeek = iFirstDayOfWeek === 0 ? 7 : iFirstDayOfWeek;  //info uses 7 for Sunday
					sweekConfig = "Gregorian";
					break;
				case TimeUnitType.fiscalyear:
					aTimeLevels = ["fiscal_year"];
					break;
				case TimeUnitType.fiscalyearperiod:
					aTimeLevels = ["fiscal_period", "fiscal_year"];
					break;
				default:
			}
			
			oFiscalYearPeriodCount = oTimeDim.getFiscalYearPeriodCount();
		}

		var oProps = this.getProperty("vizProperties");
		if (oProps && oProps.timeAxis) {
			// user properties have higher priority
			var timeAxis = oProps.timeAxis;
			if (timeAxis.levels) {
				aTimeLevels = timeAxis.levels;
			}
			if (timeAxis.fiscal && timeAxis.fiscal.periodNumbers) {
				oFiscalYearPeriodCount = timeAxis.fiscal.periodNumbers;
			}
		}

		return {
			"timeAxis": {
				"levels": aTimeLevels,
				"fiscal": {
					"periodNumbers": oFiscalYearPeriodCount
				},
				"levelConfig" : {
					"week" : {
						"type" : sweekConfig,
						"minDays" : iMinDays,
						"firstDayOfWeek" : iFirstDayOfWeek,
						"region" : region
					}
				}
			}
		};
	};

	Chart.prototype.setSelectionMode = function (oValue) {
		this.setProperty("selectionMode", oValue);
		var oVizFrame = this._getVizFrame();
		if (oVizFrame) {
			oVizFrame.setVizProperties({interaction: {selectability: {mode: oValue}}});
		}
		return this;
	};

	Chart.prototype.getSelectionMode = function () {
		var oVizFrame = this._getVizFrame();
		if (oVizFrame) {
			return oVizFrame.getVizProperties().interaction.selectability.mode;
		} else {
			return this.getProperty("selectionMode");
		}
	};

	Chart.prototype.setSelectionBehavior = function(oValue){
		this.setProperty("selectionBehavior", oValue);
		var oVizFrame = this._getVizFrame();
		if (oVizFrame) {
			oVizFrame.setVizProperties({interaction: {selectability: {behavior: oValue}}});
		}
		return this;
	};


	Chart.prototype.setEnableScalingFactor = function(value){
		this.setProperty("enableScalingFactor", value);
		this._invalidateBy({
			source: this,
			keys: {
				vizFrame: true
			}
		});
		return this;
	};

	/**
	 * return the scaling factor. Or return null when scaling factor is disable.
	 *
	 * @public
	 *
	 * @return {object} A scaling factor object or null
	 */
	Chart.prototype.getScalingFactor = function(){
		var oVizFrame = this._getVizFrame();
		if (oVizFrame) {
			var temp = oVizFrame._states()["dynamicScale"];
			if (temp) {
				var result = null;
				var keys = ["primaryValues", "secondaryValues"];
				var axes = [temp.valueAxis, temp.valueAxis2];
				for (var ii = 0; ii < keys.length; ii++) {
					var scaleFactor = axes[ii];
					if (scaleFactor && (scaleFactor.symbol || scaleFactor.unit)) {
						result = result || {};
						var key = keys[ii];
						result[key] = {
							scalingFactor: scaleFactor.symbol
						};

						if (scaleFactor.unit) {
							result[key]["unit"] = scaleFactor.unit;
						}
					}
				}
				return result;
			}
		}
		return null;
	};

	Chart.prototype.getSelectionBehavior = function () {
		var oVizFrame = this._getVizFrame();
		if (oVizFrame) {
			return oVizFrame.getVizProperties().interaction.selectability.behavior;
		} else {
			return this.getProperty("selectionBehavior");
		}
	};

	// ---------------- Public Helpers ----------------
	/**
	 * Return Dimension with the given name.
	 *
	 * @param {string} sName name of the Dimension to get
	 * @public
	 * @return {sap.chart.data.Dimension} Dimension of the specified name.
	 */
	Chart.prototype.getDimensionByName = function(sName) {
		return this.getDimensions().filter(function(d) {return d.getName() === sName;})[0];
	};
	/**
	 * Return Measure with the given name.
	 *
	 * @param {string} sName name of the Measure to get
	 * @public
	 * @return {sap.chart.data.Measure} Measure of the specified name.
	 */
	Chart.prototype.getMeasureByName = function(sName) {
		return this.getMeasures().filter(function(m) {return m.getName() === sName;})[0];
	};
	/**
	 * Return all TimeDimensions from current Dimensions.
	 *
	 * @public
	 * @return {array} Dimensions which are instance of TimeDimension.
	 */
	Chart.prototype.getTimeDimensions = function() {
		return this.getDimensions().filter(function(d) {return d instanceof TimeDimension;});
	};

	Chart.prototype._isEnablePaging = function() {
		this._bMobile = sap.ui.Device.system.tablet || sap.ui.Device.system.phone;
		var ret = this.getEnablePagination() && this._bIsPagingChartType && !this._bMobile;
		return ret;
	};

	function vizFrameRenderCompleteHandler(oEvent) {
		var oParameters = oEvent.getParameters();
		delete oParameters.id;

		if (this._isEnablePaging()) {
			this._getPagingController().vizFrameRenderCompleted();
		}

		this.fireEvent("renderComplete", oParameters);
	}

	function vizFrameZoomDetectedHandler(oEvent) {
		var oParameters = oEvent.getParameters();
		delete oParameters.id;
		this.fireEvent("_zoomDetected", oParameters);
	}

	function vizFrameSelectionDetailsHandler(oEvent) {
		var oParameters = oEvent.getParameters();
		delete oParameters.id;
		var oDataSet = this._getDataset();
		oParameters.data.forEach(function(data){
			data.context = oDataSet.findContext({
				"_context_row_number": data.data._context_row_number
			});
		});
		this.fireEvent("_selectionDetails", oParameters);
	}


	/*
	 * TODO: Comment this function later
	 * debug function to draw page scale on scroll bar
	 */
//		Chart.prototype._drawPageScale = function() {
//			var dataLength = this._iTotalSize;
//			var pageLength = this._iPageSize;
//				var thumb = $(".v-m-scrollbarThumb")[0].getBoundingClientRect();
//				var track = $(".v-m-scrollbarTrack")[0].getBoundingClientRect();
//
//				for (var i = 0; i * pageLength < dataLength; ++i) {
//						var line = $("<line>");
//						$("body").append(line);
//						line.css({
//								position: "absolute",
//								"background-color": "red",
//								width: 1,
//								height: thumb.height,
//								left: thumb.right + i * pageLength / dataLength * (track.width - thumb.width),
//								top: thumb.top
//						});
//				}
//		};

	Chart.prototype._showLoading = function(bLoading) {
		var $this = this.$();
		if (!$this) {
			return;
		}

		if (!bLoading) {
			if (this._$loadingIndicator) {
				this._$loadingIndicator.remove();
			}
		} else {
			if (!this._$loadingIndicator) {
				this._$loadingIndicator = this._createLoadingIndicator();
			}
			this._updateLoadingIndicator();
			$this.append(this._$loadingIndicator);
		}
		this._bLoading = bLoading;
	};

	Chart.prototype._createLoadingIndicator = function() {
		var $indicator = jQuery(sap.ui.core.BusyIndicatorUtils.getElement());
		var $text = jQuery("<p>").attr("class", "loading-text").text("Loading");
		$text.css({
			"position": "absolute",
			"transform": "translateY(-3em)",
			"width": "100%",
			"text-align": "center"
		});
		$text.insertBefore($indicator.children()[0]);
		$indicator.css({opacity: 1});
		return $indicator;
	};

	Chart.prototype._updateLoadingIndicator = function() {
		var $this = this.$();
		if (!$this || !this._$loadingIndicator) {
			return;
		}
		var sChartType = this._sAdapteredChartType,
			bHorizontal = sChartType === "bar" || sChartType.indexOf("horizontal") !== -1;
		var $plot = $this.find(".v-plot-bound"),

			oThisOffset = $this.offset(),
			oPosition = {
				top: oThisOffset.top,
				left: oThisOffset.left,
				width: $this.width(),
				height: $this.height()
			};

		if ($plot.length) {
			var oPlotOffset = $plot.offset(),
				oPlotBound = $plot[0].getBoundingClientRect(); // jQuery returns 0 for width/height of this element somehow
			oPosition.top = oPlotOffset.top - 1;
			oPosition.left = oPlotOffset.left;

			oPosition.width = oPlotBound.width + 1;
			if (bHorizontal) {
				oPosition.height = Math.ceil(oPlotBound.height + 1);
			} else {
				oPosition.height = Math.floor(oPlotBound.height + 1);
			}
		}
		this._$loadingIndicator.css(oPosition);

		var $text = this._$loadingIndicator.find(".loading-text");
		//var $next = $text.next();
		$text.css({
			"top": oPosition.height / 2,
			"font-weight": sap.ui.core.theming.Parameters.get("sapUiChartTitleFontWeight"),
			"font-size": sap.ui.core.theming.Parameters.get("sapUiChartMainTitleFontSize"),
			"color": sap.ui.core.theming.Parameters.get("sapUiChartMainTitleFontSize")
		});

		this._$loadingIndicator.css({
			"background-color": sap.ui.core.theming.Parameters.get("sapUiExtraLightBG")
		});
	};

	Chart.prototype._getRequiredDimensions = function() {
		var aVisDims = this._getVisibleDimensions(),
			aInResultDims = this.getInResultDimensions();
		return this._normalizeDorM(aVisDims.concat(aInResultDims), true);
	};

	Chart.prototype._getRequiredMeasures = function() {
		return this._getVisibleMeasures(true);
	};

	/**
     * Export the current chart as SVG String.
     * The chart is ready to be exported to SVG ONLY after the initialization is finished.
     * Any attempt to export to SVG before that will result in an empty SVG string.
     * @public
     * @param {Object} [option]
     * <pre>
     * {
     *     width: Number - the exported svg will be scaled to the specific width.
     *     height: Number - the exported svg will be scaled to the specific height.
     *     hideTitleLegend: Boolean - flag to indicate if the exported SVG includes the original title and legend.
     *     hideAxis: Boolean - flag to indicate if the exported SVG includes the original axis.
     * }
     * </pre>
     * @return {string} the SVG string of the current viz or empty svg if error occurs.
     */
	Chart.prototype.exportToSVGString = function(option) {
		var sSVGString = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\"/>",
			oVizFrame = this._getVizFrame();
		if (oVizFrame) {
			sSVGString = oVizFrame.exportToSVGString(option);
		}
		return sSVGString;
	};

	Chart.prototype._getPagingController = function(){
        if (!this._pagingController){
            this._pagingController = new PagingController(this);
        }

        return this._pagingController;
	};

	return Chart;
});

}; // end of sap/chart/Chart.js
