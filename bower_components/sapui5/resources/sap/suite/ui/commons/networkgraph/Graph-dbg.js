sap.ui.define([
	"sap/suite/ui/commons/library",
	"jquery.sap.global",
	"sap/ui/core/Control",
	"./SvgBase",
	"./Node",
	"./Line",
	"./Group",
	"./layout/LayeredLayout",
	"./Tooltip",
	"sap/ui/core/Popup",
	"sap/ui/model/json/JSONModel",
	"sap/m/SuggestionItem",
	"./Utils",
	"sap/m/ButtonType",
	"sap/m/Label",
	"sap/m/OverflowToolbar",
	"sap/m/OverflowToolbarButton",
	"sap/m/SearchField",
	"sap/m/ToolbarSpacer",
	"sap/ui/core/CustomData",
	"sap/ui/model/Filter",
	"./KeyboardNavigator"
], function (library, jQuery, Control, SvgBase, Node, Line, Group, LayeredLayout, Tooltip, Popup, JSONModel,
			 SuggestionItem, Utils, ButtonType, Label, OverflowToolbar, OverflowToolbarButton, SearchField,
			 ToolbarSpacer, CustomData, Filter, KeyboardNavigator) {

	// enums
	var Orientation = library.networkgraph.Orientation;

	var AGG_NODES = "nodes",
		AGG_LINES = "lines",
		AGG_GROUPS = "groups";

	var ZOOM_MILESTONES = [0.05, 0.1, 0.25, 0.33, 0.50, 0.67, 0.75, 0.80, 0.90, 1, 1.1, 1.25, 1.5, 1.75, 2, 2.5, 3, 4, 5],
		DEFAULT_ZOOM_MILESTONE_INDEX = 9,
		ZOOM_OUT_RATING = 0.4,
		SUGGESTION_ITEMS_LIMIT = 100000;

	var SUGGESTIONS = {
		Group: "group",
		Node: "node",
		Line: "line",
		IsLastKey: "islast",
		TypeKey: "type"
	};

	var StatusType = Object.freeze({
		Node: "Node",
		Line: "Line"
	});

	var oResourceBundle = sap.ui.getCore().getLibraryResourceBundle("sap.suite.ui.commons");

	// indicates current count of suggestion items when they are rendered
	var iSuggestItemCount = 0,
		MAX_DISPLAY_ITEM = 100;

	var LimitedSuggestionItem = SuggestionItem.extend("sap.suite.ui.commons.networkgraph.LimitedSuggestionItem", {
		render: function (oRenderManager, oItem, sSearch, bSelected) {
			if (iSuggestItemCount++ < MAX_DISPLAY_ITEM) {
				SuggestionItem.prototype.render.call(this, oRenderManager, oItem, sSearch, bSelected);
			}
		}
	});

	/**
	 * Constructor for a new Graph.
	 *
	 * @class
	 * The network graph control allows you to display data as a network of nodes connected by lines.
	 * The nodes can be circular or rectangular and can be joined into groups. You can define custom attributes for
	 * nodes and groups of nodes as well as apply layout algorithms that define the graph's appearance.
	 *
	 * @extends sap.suite.ui.commons.networkgraph.SvgBase
	 *
	 * @constructor
	 * @public
	 * @alias sap.suite.ui.commons.networkgraph.Graph
	 */
	var Graph = SvgBase.extend("sap.suite.ui.commons.networkgraph.Graph", {
		metadata: {
			library: "sap.suite.ui.commons",
			properties: {
				/**
				 * The height of the graph.
				 */
				height: {
					type: "sap.ui.core.CSSSize", group: "Appearance", defaultValue: "100%"
				},
				/**
				 * The width of the graph.
				 */
				width: {
					type: "sap.ui.core.CSSSize", group: "Appearance", defaultValue: "100%"
				},
				/**
				 * Orientation of the graph flow. This property is used by layout algorithms.
				 */
				orientation: {
					type: "sap.suite.ui.commons.networkgraph.Orientation",
					group: "Behavior",
					defaultValue: Orientation.LeftRight
				},
				/**
				 * An image to be rendered on the background.
				 */
				backgroundImage: {
					type: "sap.ui.core.URI", group: "Appearance", defaultValue: null
				}
			},
			aggregations: {
				/**
				 * Holds the lines to be displayed in the graph.
				 */
				lines: {
					type: "sap.suite.ui.commons.networkgraph.Line", multiple: true, singularName: "line"
				},
				/**
				 * Holds the nodes to be displayed in the graph.
				 */
				nodes: {
					type: "sap.suite.ui.commons.networkgraph.Node", multiple: true, singularName: "node"
				},
				/**
				 * Holds a list of groups used in the graph.
				 */
				groups: {
					type: "sap.suite.ui.commons.networkgraph.Group", multiple: true, singularName: "group"
				},
				/**
				 * A custom legend to be rendered instead of the autogenerated one.
				 */
				legend: {
					type: "sap.ui.core.Control", multiple: false
				},
				/**
				 * Defines the layout algorithm to be used. If not defined, {@link sap.suite.ui.commons.networkgraph.layout.LayeredLayout} is used.
				 */
				layoutAlgorithm: {
					type: "sap.suite.ui.commons.networkgraph.layout.LayoutAlgorithm", multiple: false
				}
			},
			associations: {
				/**
				 * Controls or IDs that describe this control. This association is used by screen reader software.
				 */
				ariaDescribedBy: {type: "sap.ui.core.Control", multiple: true, singularName: "ariaDescribedBy"},

				/**
				 * Controls or IDs that label this control. This association is used by screen reader software.
				 */
				ariaLabelledBy: {type: "sap.ui.core.Control", multiple: true, singularName: "ariaLabelledBy"}
			},
			events: {
				/**
				 * This event is fired when the graph is fully rendered.
				 */
				graphReady: {},
				/**
				 * This event is fired when the layouting algorithm has finished arranging the graph and SVG rendering starts.
				 */
				afterLayouting: {},
				/**
				 * This event is fired just before the layout computation begins.
				 */
				beforeLayouting: {},
				/**
				 * This event is fired when zooming in or out.
				 */
				zoomChanged: {},
				/**
				 * This event is fired when an error has occured and the graph cannot be rendered properly.
				 */
				failure: {
					parameters: {
						/**
						 * Type of an error. This parameter can be used for decision making in the calling code.
						 */
						type: "String",
						/**
						 * A human readable message with a description of what went wrong.
						 */
						message: "String"
					}
				},
				/**
				 * This event is fired when a selection of elements in the graph changes.
				 */
				selectionChange: {
					parameters: {
						/**
						 * A list of elements that changed the state of the selection. To determine the new
						 * state, use the <code>getSelected()</code> method.
						 */
						items: {type: "sap.suite.ui.commons.networkgraph.ElementBase[]"}
					}
				}
			}
		}
	});

	Graph.FAILURE_TYPE = {
		INCONSISTENT_MODEL: "Inconsistent model",
		LAYOUT_FAILURE: "Layout failure"
	};

	Graph.prototype.ZOOM_100_INDEX = DEFAULT_ZOOM_MILESTONE_INDEX;

	/* =========================================================== */
	/* Events */
	/* =========================================================== */
	Graph.prototype.init = function () {
		// indicates zoom state of graph
		this._fZoomRatio = 1;

		// for easier navigation we store index in array of possible zooms
		this._fZoomRatioIndex = DEFAULT_ZOOM_MILESTONE_INDEX;

		// currently selected nodes
		this._mSelectedNodes = {};

		// currently selected lines
		this._mSelectedLines = {};

		// indicates whether the graph is completely rendered
		this._bIsLayedOut = false;

		// flag for fullscreen mode
		this._bIsFullScreen = false;

		// map with nodes parsed by nodes' keys
		this._mNodes = {};

		// some properties are set before rendering (hiding nodes) or before graph aggregation is set
		// in such case we need to reset them after graph is rendered
		// this is needed only for the first time (update aggregation reset this flag)
		this._bNeedNodeProcessing = true;

		// Container for full screen mode, where data is rendered
		this._oFullScreenContainer = null;

		// indicates whether data need to be reprocessed (that is setting parents and child of nodes, groups and lines)
		// set true when aggregation is changed or f.e. line is set to another node
		this._bRequiresDataProcessing = true;

		// information about current state when graph panning
		this._oPanning = {};

		// Custom legend labels
		this._oLegendLabels = {};

		// Number of running layouting algorithms
		this._iRunningLayouts = 0;

		// Last initiated running layouting algorithm.
		this._oLastLayout = null;

		// RTL mode - it's reset in 'onBeforeRendering' in case it changed runtime
		this._bIsRtl = sap.ui.getCore().getConfiguration().getRTL();

		this._oFocus = null;

		this._tooltip = this._createTooltip();

		this._createToolbar();
	};

	Graph.prototype.onBeforeRendering = function () {
		// indicates RTL
		this._bIsRtl = sap.ui.getCore().getConfiguration().getRTL();

		this.setBusy(false);
		this.setBusyIndicatorDelay(0);
		this._loadData();
	};

	Graph.prototype.onAfterRendering = function () {
		var sHtml = "",
			sDirection = this._bIsRtl ? "direction=" + "\"rtl\"" : "",
			sCanvas = "<rect class=\"sapSuiteFlickerFreeRect\" x=\"0\" y=\"0\" height=\"500\" width=\"500\"></rect>";

		this.$scroller = this.$("scroller");
		this.$legend = this.$("legend");

		if (this.getNodes().length > 0) {
			this.setBusy(true);
		} else {
			// empty graph - we fire ready because there is no other action to do
			this.fireGraphReady();
		}

		if (this._isDelayedLayouting()) {
			this.getNodes().forEach(function (oNode) {
				oNode._setupWidthAndHeight();
				oNode.setX(0);
				oNode.setY(0);
				sHtml += oNode._render({
					sizeDetermination: oNode._useAutomaticSize()
				});
			});

			this.$scroller.html("<svg " + sDirection + " class=\"sapSuiteUiCommonsNetworkGraphSvg\">" + sHtml + sCanvas + "</svg>");

			// make sure everything is rendered
			setTimeout(function () {
				this.getNodes().forEach(function (oNode) {
					oNode._applyMaxWidth();
					oNode._createMultilineTitle();
				});

				this._preprocessData();
			}.bind(this), 0);
		}
	};

	/* =========================================================== */
	/* Pseudo events and event triggers */
	/* =========================================================== */
	Graph.prototype._beforeRender = function () {
		this.fireEvent("afterLayouting");
	};

	Graph.prototype._fireFailure = function (oType, sMsg) {
		this.fireFailure([oType.toString(), sMsg]);
		jQuery.sap.log.warning("Graph failure: " + oType + ": " + sMsg);
	};

	/* =========================================================== */
	/* Public API */
	/* =========================================================== */

	/**
	 * This method removes all elements (lines, nodes, groups) without triggering invalidation.
	 * You should use this method when changing graph data that uses data binding, for example with {@link sap.suite.ui.commons.networkgraph.Graph#setModel}.
	 * @public
	 */
	Graph.prototype.destroyAllElements = function () {
		this.destroyAggregation(AGG_NODES, false);
		this.destroyAggregation(AGG_GROUPS, false);
		this.destroyAggregation(AGG_LINES, false);
	};

	/**
	 * Deselects all currently selected items
	 * @param {boolean} bSuppressEvent Indicates whether the <code>selecitonChange</code> event should be fired
	 * @returns {Array} All items that have been deselected
	 * @public
	 */
	Graph.prototype.deselect = function (bSuppressEvent) {
		var aItems = [],
			$this = this.$(),
			fnDeselectElements = function (mElements) {
				Object.keys(mElements).forEach(function (sKey) {
					aItems.push(mElements[sKey]);
					mElements[sKey].setSelected(false);
				}, this);
			}.bind(this);

		$this.find("." + this.HIGHLIGHT_CLASS).removeClass(this.HIGHLIGHT_CLASS);
		$this.find("." + this.SELECT_CLASS).removeClass(this.SELECT_CLASS);
		$this.find("." + this.VISIBLE_ACTIONS_BUTTONS_CLASS).removeClass(this.VISIBLE_ACTIONS_BUTTONS_CLASS);

		fnDeselectElements(this._mSelectedNodes);
		fnDeselectElements(this._mSelectedLines);

		if (!bSuppressEvent && aItems.length) {
			this.fireSelectionChange({
				items: aItems
			});
		}

		return aItems;
	};

	Graph.prototype.getFocus = function () {
		return this._oFocus;
	};

	/**
	 * Returns a toolbar instance to allow its customization
	 * @returns {OverflowToolbar} Toolbar instance
	 * @public
	 */
	Graph.prototype.getToolbar = function () {
		return this._toolbar;
	};

	/**
	 * Returns a node by its key
	 * @param {string} sKey Node's key
	 * @returns {Node} The node, if such a node exists, or undefined
	 * @public
	 */
	Graph.prototype.getNodeByKey = function (sKey) {
		if (this._bRequiresDataProcessing) {
			this._processData();
		}

		return this._mNodes[sKey];
	};

	/**
	 * Sets a custom label for the legend
	 * @param {ElementStatus} sStatus Status the custom text will be assigned to. Works only for the default legend,
	 * not when the Legend aggregation is used
	 * @param {string} sLabel New text for the legend label
	 */

	/**
	 * Sets a custom label for the legend
	 * @param {object} mArguments Parameters for this method
	 * @param {string} mArguments.label New text for the legend label
	 * @param {ElementStatus} mArguments.status Status the custom text will be assigned to. Works only for the default legend,
	 * not when the Legend aggregation is used
	 * @param {boolean} mArguments.isNode True for a legend describing nodes. Otherwise, this label is used for lines. True by default.
	 * @public
	 */
	Graph.prototype.setCustomLegendLabel = function (mArguments) {
		var sPrefix = mArguments.isNode !== false ? StatusType.Node : StatusType.Line;
		if (mArguments.status) {
			this._oLegendLabels[sPrefix + mArguments.status] = mArguments.label;
			this._createLegend();
		}
	};

	/* =========================================================== */
	/* Private methods */
	/* =========================================================== */
	/**
	 *
	 * @param {{x: Number, y: Number}} oPoint Original coordinates to check
	 * @returns {{x: Number, y: Number}} Position of the mouse
	 * @private
	 */
	Graph.prototype.getCorrectMousePosition = function (oPoint) {
		var oPosition = this.$svg.offset(),
			iRatioX = 1,
			iRatioY = 1;

		if (this._iWidth !== this.$svg.width() || this._iHeight !== this.$svg.height()) {
			iRatioX = this._iWidth / this.$svg.width();
			iRatioY = this._iHeight / this.$svg.height();
		}

		return {
			x: parseInt((oPoint.x - oPosition.left) * iRatioX, 10),
			y: parseInt((oPoint.y - oPosition.top) * iRatioY, 10)
		};
	};

	Graph.prototype._createTooltip = function () {
		var oTooltip = new Tooltip(this.getId() + "-tooltip");
		this.addDependent(oTooltip);
		oTooltip.create(this);
		oTooltip.attachEvent("afterClose", function () {
			this.setFocus(this.getFocus());
		}.bind(this));

		return oTooltip;
	};

	/**
	 * @private
	 */
	Graph.prototype.defocus = function () {
		this.$().find("." + this.FOCUS_CLASS).removeClass(this.FOCUS_CLASS);
	};

	/**
	 * @param {object} oFocus Item to focus
	 * @private
	 */
	Graph.prototype.setFocus = function (oFocus) {
		var i;

		this.defocus();

		if (oFocus && oFocus.item instanceof Line) { // Line has no button correction
			oFocus.button = null;
		}

		if (oFocus) {
			if (oFocus.button) {
				if (oFocus.item instanceof Node) {
					i = oFocus.item._aActionButtons.indexOf(oFocus.button);
					if (i > -1) {
						oFocus.item._setActionButtonFocus(oFocus.button, true);
					}
				} else if (oFocus.item instanceof Group) {
					if (oFocus.button === Group.BUTTONS.MENU) {
						oFocus.item._setMenuButtonFocus(true);
					} else if (oFocus.button === Group.BUTTONS.COLLAPSE) {
						oFocus.item._setCollapseButtonFocus(true);
					}
				}
			} else if (oFocus.item) {
				oFocus.item._setFocus(true);
			}
		}

		this._oFocus = oFocus;
		this._updateAccessibility(oFocus);
	};

	Graph.prototype._updateAccessibility = function (oFocus) {
		var i,
			fnSetDefaultAccessibilityTitle = function () {
				this._setAccessibilityTitle(oResourceBundle.getText("NETWORK_GRAPH_ACCESSIBILITY_CONTENT"));
			}.bind(this),
			fnBuildTitleForButton = function (sLabel) {
				return oResourceBundle.getText("NETWORK_GRAPH_ACCESSIBILITY_ACTION_BUTTON") + " " + sLabel;
			};

		if (oFocus) {
			if (oFocus.button) {
				if (oFocus.item instanceof Node) {
					i = oFocus.item._aActionButtons.indexOf(oFocus.button);
					if (i > -1) {
						this._setAccessibilityTitle(oFocus.item._getActionButtonTitle(oFocus.button));
					} else {
						fnSetDefaultAccessibilityTitle();
					}
				} else if (oFocus.item instanceof Group) {
					if (oFocus.button === Group.BUTTONS.MENU) {
						this._setAccessibilityTitle(fnBuildTitleForButton(oResourceBundle.getText("NETWORK_GRAPH_GROUP_DETAIL")));
					} else if (oFocus.button === Group.BUTTONS.COLLAPSE) {
						this._setAccessibilityTitle(fnBuildTitleForButton(oResourceBundle.getText("NETWORK_GRAPH_EXPAND_COLLAPSE")));
					} else {
						fnSetDefaultAccessibilityTitle();
					}
				} else {
					fnSetDefaultAccessibilityTitle();
				}
			} else if (oFocus.item) {
				this._setAccessibilityTitle(oFocus.item._getAccessibilityLabel());
			}
		} else {
			fnSetDefaultAccessibilityTitle();
		}
	};

	Graph.prototype._processProperties = function () {
		if (this._bNeedNodeProcessing) {
			this._mSelectedNodes = {};
			this._mSelectedLines = {};

			this.getNodes().forEach(function (oNode) {
				if (oNode.getSelected()) {
					this._mSelectedNodes[oNode.getKey()] = oNode;
				}
				if (oNode.getCollapsed()) {
					oNode.setCollapsed(true);
				}
			}, this);

			this.getLines().forEach(function (oLine) {
				if (oLine.getSelected()) {
					this._mSelectedLines[oLine._getLineId()] = oLine;
				}
			}, this);
			this._bNeedNodeProcessing = false;
		}
	};

	Graph.prototype._loadData = function () {
		if (this.getNodes().length > 0) {
			// this.fireBeforeLayouting();
			if (!this._isDelayedLayouting()) {
				// postpone processing to finish render routine and allow render busy indicator
				jQuery.sap.delayedCall(0, this, this._preprocessData);
			}
		}
	};

	Graph.prototype._preprocessData = function () {
		this._bIsLayedOut = false;
		this._bImageLoaded = false;

		this.fireBeforeLayouting();

		if (!this._processData()) {
			return;
		}

		this._applyLayout()
			.then(this._render.bind(this))
			.catch(function (error) {
				jQuery.sap.log.error("Error when processing data.", error);
			});
	};

	Graph.prototype._getAllElements = function () {
		return this.getNodes().concat(this.getGroups());
	};

	Graph.prototype._render = function () {
		this._beforeRender();

		this._iRunningLayouts--;

		if (this._iRunningLayouts > 0) {
			return;
		}
		this._oLastLayout = null;

		this._createSearchSuggestItems();
		this._innerRender();
		this._createLegend();

		this._processProperties();

		// fix different zoom ratio
		if (this._fZoomRatio !== 1) {
			this.$svg[0].setAttribute("viewBox", "0 0 " + this.$svg.width() + " " + this.$svg.height());

			this.$svg.width(this.$svg.width() * this._fZoomRatio);
			this.$svg.height(this.$svg.height() * this._fZoomRatio);
		}

		// scrollTo
		if (this._selectElementAfterScroll) {
			this._scrollToElement(this._selectElementAfterScroll);
			this._selectElementAfterScroll = null;
		}

		this._bIsLayedOut = true;
		this._setupEvents();
		this._setupKeyboardNavigation();

		// when there is background image, busy is set false after image is loaded (own event)
		// in case image was already loaded continue as usual
		if (!this.getBackgroundImage() || this._bImageLoaded) {
			this.setBusy(false);
			this.fireGraphReady();
		}
	};

	Graph.prototype._innerRender = function (mParams) {
		var fnRenderItems = function (aItems) {
			var sHtml = "";
			aItems.forEach(function (oItem) {
				sHtml += oItem._render();
				oItem.bOutput = true;
			});
			return sHtml;
		};

		var fnImageLoaded = function () {
			this.$svg.find(".sapSuiteFlickerFreeRect").remove();
			this._bImageLoaded = true;

			if (this._bIsLayedOut) {
				this.setBusy(false);
				this.fireGraphReady();
			}
		}.bind(this);

		var SIZE_OFFSET = 120,
			fnSetLimits = function () {
				var iMaxX = 0,
					iMaxY = 0;

				this._iWidth = 0;
				this._iHeight = 0;

				this._getAllElements().forEach(function (oNode) {
					if (iMaxY < oNode._iHeight + oNode.getY()) {
						iMaxY = oNode._iHeight + oNode.getY();
					}
					if (iMaxX < oNode._iWidth + oNode.getX()) {
						iMaxX = oNode._iWidth + oNode.getX();
					}
				}, this);

				if (this.getBackgroundImage()) {
					var oImg = new Image();
					// this ensures image is not cropped by svg size
					oImg.onload = function () {
						this._iWidth = Math.max(this._iWidth, oImg.width);
						this._iHeight = Math.max(this._iHeight, oImg.height);

						this.$svg.width(this._iWidth);
						this.$svg.height(this._iHeight);

						this.$svg.css("background-image", "url(" + this.getBackgroundImage() + ")");
						this.$svg.css("background-size", "cover");

						fnImageLoaded();
					}.bind(this);
					oImg.onerror = function () {
						jQuery.sap.log.warning("Unable to load background image.");
						fnImageLoaded();
					};
					oImg.src = this.getBackgroundImage();
				}

				this._iWidth = iMaxX + SIZE_OFFSET;
				this._iHeight = iMaxY + SIZE_OFFSET;

				this.$svg.width(this._iWidth);
				this.$svg.height(this._iHeight);
			}.bind(this);

		var fnAfterRendering = function (aItems) {
			aItems.forEach(function (aItemsInner) {
				aItemsInner.forEach(function (oItem) {
					oItem._afterRendering();
				});
			});
		};

		var aNodes = this.getNodes(), aLines = this.getLines(), aGroups = this.getGroups();

		jQuery.sap.measure.start(this.getId(), "Rendering of a network graph");

		this.$scroller.html(this._renderSvg(fnRenderItems(aNodes), fnRenderItems(aLines), fnRenderItems(aGroups)));
		this.$svg = this.$("networkGraphSvg");

		fnSetLimits();

		fnAfterRendering([aNodes, aLines, aGroups]);
		jQuery.sap.measure.end(this.getId());
	};

	Graph.prototype._renderSvg = function (sNodes, sLines, sGroups) {
		var sHtml = "",
			sClass = "sapSuiteUiCommonsNetworkGraphSvg sapSuiteUiCommonsNetworkGraphNoSelect " +
				(this._fZoomRatio < ZOOM_OUT_RATING ? " sapSuiteUiCommonsNetworkGraphZoomedOut " : "");

		sHtml += "<svg id=\"" + this.getId() + "-networkGraphSvg\"";

		if (this._bIsRtl) {
			sHtml += "direction=" + "\"rtl\"";
		}

		sHtml += " class=\"" + sClass + "\" preserveAspectRatio=\"none\" ";
		sHtml += ">";

		sHtml += "<g id=\"" + this.getId() + "-eventwrapper\"><rect class=\"sapSuiteUiCommonsNetworkGraphEventWrapper\" width=\"100%\" height=\"100%\"/></g>";
		sHtml += "<g id=\"" + this.getId() + "-svgbody\">";

		sHtml += "<g class=\"sapSuiteUiCommonsNetworkGroupEventWrapper\"></g>";
		sHtml += "<g id=\"" + this._getDomId("groups") + "\">";
		sHtml += sGroups ? sGroups : "";
		sHtml += "</g>";

		sHtml += "<g id=\"" + this._getDomId("lines") + "\" class=\"sapSuiteUiCommonsNetworkLines\">";
		sHtml += sLines ? sLines : "";
		sHtml += "</g>";

		sHtml += "<g id=\"" + this._getDomId("nodes") + "\" class=\"sapSuiteUiCommonsNetworkNodes\">";
		sHtml += sNodes ? sNodes : "";
		sHtml += "</g>";

		sHtml += "</g>";

		if (this.getBackgroundImage()) {
			sHtml += "<rect class=\"sapSuiteFlickerFreeRect\" x=\"0\" y=\"0\" height=\"100%\" width=\"100%\"></rect>";
		}

		sHtml += "</svg>";

		return sHtml;
	};

	Graph.prototype._isProperKey = function (sKey) {
		return sKey || (sKey === "0");
	};

	Graph.prototype._processData = function () {
		var fnProcessGroups = function () {
			var iIndex = 0;
			this.mGroups = {};

			return this.getGroups().some(function (oGroup) {
				var sGroupKey = oGroup.getKey();
				if (!this._isProperKey(sGroupKey)) {
					this._fireFailure(
						Graph.FAILURE_TYPE.INCONSISTENT_MODEL,
						"Group without a proper key [index: " + iIndex + "] found.");
					return true;
				}

				oGroup._resetSize();
				oGroup._clearChildren();
				if (this.mGroups[sGroupKey]) {
					this._fireFailure(
						Graph.FAILURE_TYPE.INCONSISTENT_MODEL,
						"Group with a duplicit key " + sGroupKey + " found.");
					return true;
				}
				this.mGroups[sGroupKey] = oGroup;
				iIndex++;

				return false;
			}, this);
		}.bind(this);

		var fnProcessNodes = function () {
			var iIndex = 0;
			this._mNodes = {};

			return this.getNodes().some(function (oNode) {
				if (!this._isProperKey(oNode.getKey())) {
					this._fireFailure(
						Graph.FAILURE_TYPE.INCONSISTENT_MODEL,
						"Node without a proper ID [index: " + iIndex + "] found.");
					return true;
				}

				// group handling
				var sGroup = oNode.getGroup(),
					oGroup;
				oNode._oGroup = null;
				if (sGroup) {
					oGroup = this.mGroups[sGroup];
					if (oGroup) {
						oNode._oGroup = oGroup;
						oGroup.aNodes.push(oNode);
					} else {
						this._fireFailure(
							Graph.FAILURE_TYPE.INCONSISTENT_MODEL,
							"Node belonging to a nonexistent group with key " + sGroup + " found.");
						return true;
					}
				}

				oNode._setupWidthAndHeight();
				oNode._clearChildren();
				oNode._rendered = false;

				if (this._mNodes[oNode.getKey()]) {
					this._fireFailure(
						Graph.FAILURE_TYPE.INCONSISTENT_MODEL,
						"Node with a duplicit key " + oNode.getKey() + " found.");
					return true;
				}
				this._mNodes[oNode.getKey()] = oNode;
				iIndex++;

				return false;
			}, this);
		}.bind(this);

		var fnProcessLines = function () {
			return this.getLines().some(function (oLine, iIndex) {
				var oFrom = this.getNodeByKey(oLine.getFrom()),
					oTo = this.getNodeByKey(oLine.getTo());

				if (!oFrom) {
					this._fireFailure(
						Graph.FAILURE_TYPE.INCONSISTENT_MODEL,
						"Line going from a nonexistent node with key " + oLine.getFrom() + " found.");
					return true;
				}
				if (!oTo) {
					this._fireFailure(
						Graph.FAILURE_TYPE.INCONSISTENT_MODEL,
						"Line going to a nonexistent node with key " + oLine.getTo() + " found.");
					return true;
				}

				oLine._rendered = false;
				oLine._initialized = false;

				if (oFrom && oTo) {
					oFrom.aChildren.push(oTo);
					oFrom.aLines.push(oLine);
					oTo.aParents.push(oFrom);
					oTo.aParentLines.push(oLine);

					oLine._oFrom = oFrom;
					oLine._oTo = oTo;

					oLine._sKey = "line_" + oFrom.getKey() + "-" + oTo.getKey() + "[" + iIndex + "]";
				}

				if (oFrom._oGroup) {
					oFrom._oGroup.aLines.push(oLine);
					oFrom._oGroup.aChildren.push(oTo);
				}
				if (oTo._oGroup) {
					oTo._oGroup.aParentLines.push(oLine);
					oTo._oGroup.aParents.push(oFrom);
				}

				return false;
			}, this);
		}.bind(this);

		this._bRequiresDataProcessing = false;

		if (fnProcessGroups() || fnProcessNodes() || fnProcessLines()) {
			return false;
		}

		return true;
	};

	Graph.prototype._validateLayout = function () {
		var bWrongNodeCoordinate,
			bWrongGroupCoordinate,
			bWrongLineCoordinate;

		bWrongNodeCoordinate = this.getNodes().some(function (oNode) {
			return !((oNode._oGroup && oNode._oGroup.getCollapsed()) || (isFinite(oNode.getX()) && isFinite(oNode.getY())));
		});
		if (bWrongNodeCoordinate) {
			this._fireFailure(Graph.FAILURE_TYPE.LAYOUT_FAILURE, "Some nodes are missing coordinates.");
			return false;
		}

		if (this._isLayered()) {
			bWrongGroupCoordinate = this.getGroups().some(function (oGroup) {
				return !oGroup._isEmpty() && (!isFinite(oGroup.getX()) || !isFinite(oGroup.getY()));
			});
			if (bWrongGroupCoordinate) {
				this._fireFailure(Graph.FAILURE_TYPE.LAYOUT_FAILURE, "Some groups are missing coordinates.");
				return false;
			}
		}

		bWrongLineCoordinate = this.getLines().some(function (oLine) {
			if (oLine._isIgnored()) {
				return false;
			}
			return !oLine._validateLayout();
		});
		if (bWrongLineCoordinate) {
			this._fireFailure(Graph.FAILURE_TYPE.LAYOUT_FAILURE, "Some lines are missing coordinates.");
			return false;
		}

		return true;
	};

	Graph.prototype._suggest = function (sTerm) {
		var fnAppendCustomData = function (oItem) {
			oItem.addCustomData(new CustomData({
				key: SUGGESTIONS.IsLastKey,
				value: "true",
				writeToDom: true
			}));
		};

		var fnRemoveCustomData = function (oItem) {
			var oCustomItem = Utils.find(oItem.getCustomData(), function (oCustomData) {
				return oCustomData.getKey() === SUGGESTIONS.IsLastKey;
			});

			if (oCustomItem) {
				oItem.removeCustomData(oCustomItem);
			}
		};

		var fnGetCustomData = function (oItem) {
			var oCustomItem = Utils.find(oItem.getCustomData(), function (oCustomData) {
				return oCustomData.getKey() === SUGGESTIONS.TypeKey;
			});

			return oCustomItem && oCustomItem.getValue();
		};

		var fnCreateDelimiters = function () {
			// last node and last line has special flag to draw delimiter
			var aItems = this._searchField.getSuggestionItems(),
				oItem, sType, sNextType;

			for (var i = 0; i < aItems.length; i++) {
				oItem = aItems[i];

				// remove "islast" flag (if there is any) from last suggestions
				fnRemoveCustomData(oItem);
				if (i < aItems.length - 1) {
					// find suggestion type of current and next item to see if this item is last of its type
					sType = fnGetCustomData(oItem);
					sNextType = fnGetCustomData(aItems[i + 1]);

					if (sType && sNextType) {
						// if the item is last of its type, add custom data (which will be rendered as special attribute and
						// so it can be styled properly

						if ((sType === SUGGESTIONS.Node && sNextType === SUGGESTIONS.Line) ||
							(sType === SUGGESTIONS.Line && sNextType === SUGGESTIONS.Group)) {
							fnAppendCustomData(oItem);
						}
					}
				}
			}
		}.bind(this);

		var aFilters = [];

		iSuggestItemCount = 0;

		if (sTerm) {
			aFilters = [
				new Filter([
					new Filter("text", function (sText) {
						return (sText.toLowerCase() || "").indexOf(sTerm.toLowerCase()) > -1;
					}),
					new Filter("description", function (sDesc) {
						return (sDesc.toLowerCase() || "").indexOf(sTerm.toLowerCase()) > -1;
					})
				], false)
			];
		}

		this._searchField.getBinding("suggestionItems").filter(aFilters);
		fnCreateDelimiters();
		this._searchField.suggest();
	};

	Graph.prototype._search = function (sSearchTerm, sKey) {
		var sSelectFunction = "_selectNode",
			oItem;

		if (sSearchTerm) {
			oItem = Utils.find(this.getNodes(), function (oItem) {
				return sKey ? oItem.getKey() === sKey : oItem.getTitle() === sSearchTerm;
			});

			if (!oItem) {
				oItem = Utils.find(this.getLines(), function (oLine) {
					if (oLine._isLoop()) {
						return false;
					}
					return sKey ? oLine._getLineId() === sKey : oLine._createSuggestionHelpText() === sSearchTerm;
				});
				sSelectFunction = "_selectLine";
			}

			if (!oItem) {
				oItem = Utils.find(this.getGroups(), function (oGroup) {
					return oGroup.aNodes.length > 0 && (sKey ? oGroup.getKey() === sKey : oGroup.getTitle() === sSearchTerm);
				});
				sSelectFunction = "_selectGroup";
			}

			if (oItem) {
				if (sSelectFunction) {
					this[sSelectFunction]({
						element: oItem,
						scroll: true,
						alwaysSelect: true
					});
				}
			}
		} else {
			this.deselect(false);
			this.setFocus(null);
		}
	};

	Graph.prototype._createToolbar = function () {
		var that = this;
		this._toolbar = new OverflowToolbar(this.getId() + "-toolbar", {
			content: [new ToolbarSpacer()]
		}).addStyleClass("sapSuiteUiCommonsNetworkGraphToolbar");
		this.addDependent(this._toolbar);

		// search
		this._searchField = new SearchField({
			width: "220px",
			enableSuggestions: true,
			suggest: function (oEvent) {
				that._suggest(oEvent.getParameter("suggestValue"));
			},
			search: function (oEvent) {
				var sTerm = oEvent.getParameter("query"),
					oSuggestionItem = oEvent.getParameter("suggestionItem"),
					sKey;

				if (oSuggestionItem) {
					sKey = oSuggestionItem.getProperty("key");
				}

				that._search(sTerm, sKey);
			}
		});
		this._toolbar.addContent(this._searchField);

		// show hide legend
		this._toolbar.addContent(new OverflowToolbarButton({
			type: ButtonType.Transparent,
			icon: "sap-icon://legend",
			press: function (oEvent) {
				if (that.$legend.is(":visible")) {
					that.$legend.hide();
				} else {
					that.$legend.show();
				}
			}
		}).setTooltip(oResourceBundle.getText("NETWORK_GRAPH_LEGEND")));

		// zoom
		this._toolbar.addContent(new OverflowToolbarButton({
			type: ButtonType.Transparent,
			icon: "sap-icon://zoom-in",
			press: function (oEvent) {
				that._zoom({
					deltaY: 1
				});
			}
		}));

		this._zoomLabel = new Label({
			text: "100%"
		});

		this._toolbar.addContent(this._zoomLabel);

		this._toolbar.addContent(new OverflowToolbarButton({
			type: ButtonType.Transparent,
			icon: "sap-icon://zoom-out",
			press: function (oEvent) {
				that._zoom({
					deltaY: -1
				});
			}
		}));

		// fit to viewport
		this._toolbar.addContent(new OverflowToolbarButton({
			type: ButtonType.Transparent,
			icon: "sap-icon://sys-monitor",
			press: this._fitToScreen.bind(this)
		}).setTooltip(oResourceBundle.getText("NETWORK_GRAPH_ZOOMTOFIT")));

		// toggle full screen
		this._toolbar.addContent(new OverflowToolbarButton({
			type: ButtonType.Transparent,
			icon: "sap-icon://full-screen",
			press: this._toggleFullScreen.bind(this)
		}));

		//Popup for chart content
		this._oPopup = new Popup({
			modal: true,
			shadow: false,
			autoClose: false
		});
	};

	Graph.prototype._fitToScreen = function () {
		var iHeightRatio = this.$scroller.height() / this._iHeight,
			iWidthRatio = this.$scroller.width() / this._iWidth,
			iFinalRatio = Math.min(iHeightRatio, iWidthRatio),
			iZoomRatioIndex = ZOOM_MILESTONES.length - 1;

		for (var i = 1; i < ZOOM_MILESTONES.length; i++) {
			if (iFinalRatio < ZOOM_MILESTONES[i]) {
				iZoomRatioIndex = i - 1;
				break;
			}
		}

		this._zoom({
			newIndex: iZoomRatioIndex
		});
	};

	Graph.prototype._getZoomText = function () {
		return Math.floor((this._fZoomRatio * 100)) + "%";
	};

	Graph.prototype._toggleFullScreen = function () {
		var fnOpen = function () {
				this._oFullScreenContainer = {};

				this._oFullScreenContainer.$content = this.$();
				if (this._oFullScreenContainer.$content) {
					this._oFullScreenContainer.$tempNode = jQuery("<div></div>");
					this._oFullScreenContainer.$content.before(this._oFullScreenContainer.$tempNode);
					this._oFullScreenContainer.$overlay = jQuery("<div id='" + jQuery.sap.uid() + "'></div>");
					this._oFullScreenContainer.$overlay.addClass("sapSuiteUiCommonsNetworkGraphContainerOverlay");
					this._oFullScreenContainer.$overlay.append(this._oFullScreenContainer.$content);
					this._oPopup.setContent(this._oFullScreenContainer.$overlay);
				}
				this._oPopup.open(200, Popup.Dock.BeginTop, Popup.Dock.BeginTop, jQuery("body"));
			}.bind(this),
			fnClose = function () {
				this._oFullScreenContainer.$tempNode.replaceWith(this._oFullScreenContainer.$content);
				this._oPopup.close();
				this._oFullScreenContainer.$overlay.remove();
			}.bind(this);

		if (this._bIsFullScreen) {
			fnClose();
		} else {
			fnOpen();
		}
		this._bIsFullScreen = !this._bIsFullScreen;
	};

	Graph.prototype._setupKeyboardNavigation = function () {
		if (!this._isLayedOut()) {
			return;
		}
		var aItems = [],
			aGrid = [[]],
			oLastItem,
			aLastRow;
		if (!this._oKeyboardNavigator) {
			this._oKeyboardNavigator = new KeyboardNavigator(this);
			this.addDelegate(this._oKeyboardNavigator);
		}
		this.getNodes().forEach(function (oNode) {
			if (oNode.isHidden() || oNode._isIgnored()) {
				return;
			}
			aItems.push({
				item: oNode,
				x: oNode.getX(),
				y: oNode.getY()
			});
		});
		this.getLines().forEach(function (oLine) {
			if (oLine.isHidden() || oLine._isIgnored()) {
				return;
			}
			var oBend = oLine.getCoordinates()[0],
				iX = oBend.getX(),
				iY = oBend.getY();
			oLine.getCoordinates().forEach(function (oBend) {
				if (iX > oBend.getX()) {
					iX = oBend.getX();
				}
				if (iY > oBend.getY()) {
					iY = oBend.getY();
				}
			});
			aItems.push({
				item: oLine,
				x: iX,
				y: iY
			});
		});
		this.getGroups().forEach(function (oGroup) {
			if (oGroup.isHidden()) {
				return;
			}
			aItems.push({
				item: oGroup,
				x: oGroup.getX(),
				y: oGroup.getY()
			});
		});
		aItems.sort(function (a, b) {
			if (a.y < b.y) {
				return -1;
			} else if (a.y > b.y) {
				return 1;
			} else if (a.x < b.x) {
				return -1;
			} else if (a.x > b.x) {
				return 1;
			} else {
				return 0;
			}
		});
		if (aItems.length > 0) {
			aLastRow = [aItems[0]];
			aGrid = [aLastRow];
			oLastItem = aItems[0];
			aItems.forEach(function (oItem, i) {
				if (i === 0) {
					return;
				}
				if (oItem.y === oLastItem.y) {
					aLastRow.push(oItem);
				} else {
					aLastRow = [oItem];
					aGrid.push(aLastRow);
				}
				oLastItem = oItem;
			});
		}
		aGrid = this._normalizeGrid(aGrid, aItems);
		this._oKeyboardNavigator.setItems(aGrid);
		this._oKeyboardNavigator.setWrapperDom(this.getFocusDomRef());
	};

	Graph.prototype._normalizeGrid = function (aGrid, aItems) {
		if (aItems.length === 0) {
			return aGrid;
		}
		var oFirstItem = aItems[0],
			iMinX = oFirstItem.x,
			iMaxX = oFirstItem.x,
			iCols = 1,
			iBoundaryStep,
			iLastBoundary,
			aBoundaries = [],
			i;

		aItems.forEach(function (oItem) {
			if (oItem.x < iMinX) {
				iMinX = oItem.x;
			}
			if (oItem.x > iMaxX) {
				iMaxX = oItem.x;
			}
		});
		aGrid.forEach(function (aRow) {
			if (aRow.length > iCols) {
				iCols = aRow.length;
			}
		});
		iBoundaryStep = Math.abs(iMaxX - iMinX) / iCols;
		iLastBoundary = iMinX;
		for (i = 0; i < iCols; i++) {
			iLastBoundary += iBoundaryStep;
			aBoundaries.push(iLastBoundary);
		}
		return aGrid.map(function (aRow) {
			var aNewRow,
				iPos;
			if (aRow.length === iCols) {
				aNewRow = aRow;
			} else {
				aNewRow = [];
				iPos = 0;
				while (iPos < (iCols - aRow.length) && aBoundaries[iPos] < aRow[0].x) {
					iPos++;
					aNewRow.push(null);
				}
				aRow.forEach(function (oItem) {
					aNewRow.push(oItem);
					iPos++;
				});
				while (iPos < iCols) {
					aNewRow.push(null);
					iPos++;
				}
			}
			return aNewRow.map(function (oItem) {
				return oItem ? oItem.item : null;
			});
		});
	};

	Graph.prototype.getFocusDomRef = function () {
		return this.getDomRef("wrapper");
	};

	Graph.prototype._setupEvents = function () {
		// how many touchmove events are triggered before zoom is performed.
		// this prevents zooming to fast
		var TOUCH_ZOOM_RATING = 5;

		var iState = 0,
			oTouchCoord = {},
			$eventWrapper = this.$("eventwrapper"),
			$wrapper = this.$scroller;

		var fnDiff = function (o1, o2) {
			return Math.sqrt(Math.pow(o1.clientX - o2.clientX, 2) + Math.pow(o1.clientY - o2.clientY, 2));
		};

		var fnTouchStart = function (oOriginalEvent) {
			if (oOriginalEvent.touches && oOriginalEvent.touches.length === 2) {
				oTouchCoord = {
					t1: oOriginalEvent.touches[0],
					t2: oOriginalEvent.touches[1],
					diff: fnDiff(oOriginalEvent.touches[0], oOriginalEvent.touches[1])
				};
			}
		};

		var fnTouchMove = function (oOriginalEvent) {
			if (oOriginalEvent.touches && oOriginalEvent.touches.length === 2) {
				// trigger zoom every five events
				if (++iState === TOUCH_ZOOM_RATING) {
					var oT1 = oOriginalEvent.touches[0],
						oT2 = oOriginalEvent.touches[1],
						nDiff = fnDiff(oT1, oT2);

					this._zoom({
						point: {
							x: (oT1.clientX + oT2.clientX) / 2,
							y: (oT1.clientY + oT2.clientY) / 2
						},
						deltaY: nDiff - oTouchCoord.diff
					});
					iState = 0;

					oTouchCoord = {
						t1: oT1,
						t2: oT2,
						diff: nDiff
					};
				}
			}
		}.bind(this);

		$wrapper.mousemove(function (oEvent) {
			this._mouseMove(oEvent.clientX, oEvent.clientY);
		}.bind(this));

		$eventWrapper.mousedown(function (oEvent) {
			this._mouseDown(oEvent.clientX, oEvent.clientY);
			oEvent.preventDefault();
		}.bind(this));

		$wrapper.mouseleave(this._endDragging.bind(this));

		$wrapper.mouseup(this._mouseUp.bind(this));

		$wrapper.bind("wheel", function (oEvent) {
			this._wheel({
				x: oEvent.originalEvent.clientX,
				y: oEvent.originalEvent.clientY,
				deltaY: oEvent.originalEvent.deltaY
			});
			oEvent.preventDefault();
		}.bind(this));

		// touch zoom
		$wrapper.bind("touchstart", function (oEvent) {
			fnTouchStart(oEvent);
		});

		$wrapper.bind("touchmove", function (oEvent) {
			fnTouchMove(oEvent);
		});
	};

	Graph.prototype._wheel = function (mArguments) {
		this._zoom({
			point: {
				x: mArguments.x,
				y: mArguments.y
			},
			deltaY: -mArguments.deltaY
		});

		this._zoomLabel.setText(this._getZoomText());
	};

	Graph.prototype._endDragging = function () {
		this._oPanning.dragging = false;
		this.$scroller.removeClass("sapSuiteUiCommonsNetworkGraphPanning");
	};

	Graph.prototype._mouseMove = function (iX, iY) {
		var oScroller = this.$scroller[0];

		if (this._oPanning.dragging) {
			if (!this.$scroller.hasClass("sapSuiteUiCommonsNetworkGraphPanning")) {
				this.$scroller.addClass("sapSuiteUiCommonsNetworkGraphPanning");
			}

			oScroller.scrollTop = oScroller.scrollTop - (iY - this._oPanning.lastY);
			oScroller.scrollLeft = oScroller.scrollLeft - (iX - this._oPanning.lastX);

			this._oPanning.lastX = iX;
			this._oPanning.lastY = iY;
		}
	};

	Graph.prototype._mouseDown = function (iX, iY) {
		this.deselect(false);
		this.setFocus(null);

		this._oPanning.lastX = iX;
		this._oPanning.lastY = iY;
		this._oPanning.dragging = true;

		this._tooltip.instantClose();
	};

	Graph.prototype._mouseUp = function () {
		this._endDragging();
	};

	Graph.prototype._zoom = function (mParameters) {
		var sBox = this.$svg[0].getAttribute("viewBox"),
			iRatio = mParameters.deltaY < 0 ? -1 : 1,
			oOldPoint, oNewPoint, newIndex,
			sNewBox;

		if (!mParameters.point) {
			mParameters.point = {
				x: this.$scroller.width() / 2,
				y: this.$scroller.height() / 2
			};
		}

		oOldPoint = this.getCorrectMousePosition({
			x: mParameters.point.x,
			y: mParameters.point.y
		});

		newIndex = mParameters.newIndex || mParameters.newIndex === 0 ? mParameters.newIndex : this._fZoomRatioIndex + iRatio;
		if ((newIndex < 0) || (newIndex > ZOOM_MILESTONES.length - 1)) {
			return;
		}

		this._fZoomRatioIndex = newIndex;
		this._fZoomRatio = ZOOM_MILESTONES[this._fZoomRatioIndex];

		if (!sBox) {
			sNewBox = "0 0 " + this.$svg.width() + " " + this.$svg.height();
			this.$svg[0].setAttribute("viewBox", sNewBox);
		}

		this.$svg.width(this._iWidth * this._fZoomRatio);
		this.$svg.height(this._iHeight * this._fZoomRatio);

		oNewPoint = this.getCorrectMousePosition({
			x: mParameters.point.x,
			y: mParameters.point.y
		});

		this.$scroller[0].scrollLeft += (oOldPoint.x - oNewPoint.x) * this._fZoomRatio;
		this.$scroller[0].scrollTop += (oOldPoint.y - oNewPoint.y) * this._fZoomRatio;

		this._zoomLabel.setText(this._getZoomText());

		if (this._fZoomRatio < ZOOM_OUT_RATING) {
			this.$svg.addClass("sapSuiteUiCommonsNetworkGraphZoomedOut");
		} else {
			this.$svg.removeClass("sapSuiteUiCommonsNetworkGraphZoomedOut");
		}

		this.fireEvent("zoomChanged");
	};

	Graph.prototype._createSearchSuggestItems = function () {
		var TITLE_LENGTH = 50;

		var oData = {
			items: []
		}, aNodes = this.getNodes().sort(function (oNode1, oNode2) {
			return oNode1.getTitle().localeCompare(oNode2.getTitle());
		}), aLines = this.getLines().sort(function (oLine1, oLine2) {
			var sLine1Title = oLine1.getTitle(),
				sLine2Title = oLine2.getTitle();

			// for lines with same (usually no) title use title of from node to compare
			if (sLine1Title === sLine2Title) {
				return oLine1.getFromNode().getTitle().localeCompare(oLine2.getFromNode().getTitle());
			}
			return sLine1Title.localeCompare(sLine2Title);
		}), aGroups = this.getGroups().sort(function (oGroup1, oGroup2) {
			return oGroup1.getTitle().localeCompare(oGroup2.getTitle());
		});

		var oSearchSuggestionItems = new JSONModel();
		oSearchSuggestionItems.setSizeLimit(SUGGESTION_ITEMS_LIMIT);

		aNodes.forEach(function (oNode) {
			var sTitle = Utils.trimText(oNode.getTitle(), TITLE_LENGTH);
			oData.items.push({
				text: sTitle ? sTitle : oNode.getKey(),
				type: SUGGESTIONS.Node,
				icon: oNode.getIcon(),
				key: oNode.getKey(),
				description: "(" + oResourceBundle.getText("NETWORK_GRAPH_NODE") + ")"
			});
		});

		aLines.forEach(function (oLine) {
			if (oLine._isLoop()) {
				return;
			}
			if (oLine.getTitle() || oLine.getFromNode().getTitle() || oLine.getToNode().getTitle()) {
				oData.items.push({
					text: oLine._createSuggestionHelpText(),
					type: SUGGESTIONS.Line,
					key: oLine._getLineId(),
					description: "(" + oResourceBundle.getText("NETWORK_GRAPH_LINE") + ")"
				});
			}
		});

		aGroups.forEach(function (oGroup) {
			var sTitle = Utils.trimText(oGroup.getTitle(), TITLE_LENGTH);
			if (oGroup.aNodes.length > 0) {
				oData.items.push({
					text: sTitle ? sTitle : oGroup.getKey(),
					key: oGroup.getKey(),
					type: SUGGESTIONS.Group,
					description: "(" + oResourceBundle.getText("NETWORK_GRAPH_GROUP") + ")"
				});
			}
		});

		oSearchSuggestionItems.setData(oData);
		this._searchField.setModel(oSearchSuggestionItems);
		this._searchField.bindAggregation("suggestionItems", {
			path: "/items",
			template: new LimitedSuggestionItem({
				text: "{text}",
				icon: "{icon}",
				key: "{key}",
				description: "{description}",
				customData: new CustomData({
					key: "type",
					value: "{type}"
				})
			})
		});
	};

	Graph.prototype._scrollToElement = function (oItem) {
		var bIsInCollapsedGroup = oItem._oGroup && oItem._oGroup.getCollapsed(),
			oSource = oItem instanceof Line ? oItem.getSource() : oItem;

		if (bIsInCollapsedGroup) {
			oSource = oItem._oGroup;
		}

		this.$scroller.get(0).scrollLeft = ((oSource.getX() + (oSource._iWidth ? oSource._iWidth : 0) / 2) * this._fZoomRatio) - (this.$scroller.width() / 2);
		this.$scroller.get(0).scrollTop = ((oSource.getY() + (oSource._iHeight ? oSource._iHeight : 0) / 2) * this._fZoomRatio) - (this.$scroller.height() / 2);
	};

	Graph.prototype._createLegend = function () {
		var $legend = this.$("legend"),
			sHtml = "",
			that = this,
			oNodeStatuses = {}, oLineStatuses = {};

		var fnAddElement = function (oElement, oItemStatuses) {
			var sStatus = oElement.getStatus();
			if (sStatus) {
				if (oItemStatuses[sStatus]) {
					oItemStatuses[sStatus].push(oElement);
				} else {
					oItemStatuses[sStatus] = [oElement];
				}
			}
		};

		var fnHasStatus = function (oItemStatuses) {
			return Object.keys(oItemStatuses).length > 0;
		};

		var fnAppendLine = function (sStatus, sType) {
			sHtml += this._renderControl("div", {
				status: sStatus,
				elementtype: sType,
				"class": "sapSuiteUiCommonsNetworkGraphLegendLine"
			}, false);

			sHtml += this._renderControl("div", {
				"class": "sapSuiteUiCommonsNetworkGraphLegendColorLine " + this._getStatusClass(sStatus)
			});

			sHtml += this._renderControl("label", {
				"class": "sapSuiteUiCommonsNetworkGraphLegendLineLabel"
			}, false);
			sHtml += this._oLegendLabels[sType + sStatus] ? this._oLegendLabels[sType + sStatus] : sStatus;
			sHtml += "</label>";
			sHtml += "</div>";
		}.bind(this);

		if (this.getLegend()) {
			// legend is already rendered in renderer with render control over aggregation
			return;
		}

		if (!$legend[0]) {
			return;
		}

		// nodes
		this.getNodes().forEach(function (oNode) {
			fnAddElement(oNode, oNodeStatuses);
		});

		if (fnHasStatus(oNodeStatuses)) {
			sHtml += "<div class=\"sapSuiteUiCommonsNetworkGraphLegendTitleNode\"><label class=\"sapSuiteUiCommonsNetworkGraphLegendTitle\">" + jQuery.sap.encodeHTML(oResourceBundle.getText("NETWORK_GRAPH_NODES")) + "</label></div>";
			Object.keys(oNodeStatuses).forEach(function (sKey) {
				fnAppendLine(sKey, StatusType.Node);
			});
		}

		this.getLines().forEach(function (oLine) {
			fnAddElement(oLine, oLineStatuses);
		});

		if (fnHasStatus(oLineStatuses)) {
			sHtml += "<div class=\"sapSuiteUiCommonsNetworkGraphLegendTitleLine\"><label class=\"sapSuiteUiCommonsNetworkGraphLegendTitle\">" + jQuery.sap.encodeHTML(oResourceBundle.getText("NETWORK_GRAPH_LINES")) + "</label></div>";
			Object.keys(oLineStatuses).forEach(function (sKey) {
				fnAppendLine(sKey, StatusType.Line);
			});
		}

		$legend.html(sHtml);

		// events
		this.$().find(".sapSuiteUiCommonsNetworkGraphLegendLine").click(function (oEvent) {
			var sStatus = jQuery(this).attr("status"),
				sType = jQuery(this).attr("elementtype"),
				oCollection = sType === StatusType.Node ? oNodeStatuses : oLineStatuses;

			if (!oEvent.ctrlKey) {
				that.deselect(false);
				that.setFocus(null);
			}
			if (oCollection[sStatus]) {
				oCollection[sStatus].forEach(function (oElement) {
					oElement.$().addClass(that.SELECT_CLASS);
				});
			}
		});
	};

	Graph.prototype._selectElement = function (mArguments) {
		var bIsToBeSelected = mArguments.element && !mArguments.element.getSelected(),
			aItems = [];

		var fnSetElementData = function (bValue) {
			mArguments.element.setSelected(bValue);
			if (mArguments.setFocus !== false) {
				// selecting element have always focus (only in cases) when we don't want to manipulate focus at all
				this.setFocus({item: mArguments.element});
			}
		}.bind(this);

		// remove last item action button class
		this.$().find("." + this.VISIBLE_ACTIONS_BUTTONS_CLASS).removeClass(this.VISIBLE_ACTIONS_BUTTONS_CLASS);

		if (!mArguments.preventDeselect) {
			aItems = this.deselect(true);
			if (mArguments.setFocus) {
				this.setFocus(null);
			}
			if (bIsToBeSelected || mArguments.alwaysSelect) {
				fnSetElementData(true);
			}
		} else {
			fnSetElementData(bIsToBeSelected);
		}

		if (!aItems.some(function (oL) {
				return oL === mArguments.element;
			})) {
			aItems.push(mArguments.element);
		}

		this.fireSelectionChange({items: aItems});
	};

	Graph.prototype._selectLine = function (mArguments) {
		var oFrom = mArguments.element.getFromNode(),
			oTo = mArguments.element.getToNode(),
			oGroup = (oFrom._isInCollapsedGroup() && (oFrom._oGroup === oTo._oGroup)) ? oTo._oGroup : null;
		if (mArguments.scroll) {
			this._scrollToElement(oGroup || mArguments.element);
		}
		if (!oGroup) {
			this._selectElement(mArguments);
		}
	};

	Graph.prototype._selectNode = function (mArguments) {
		var oGroup = mArguments.element._isInCollapsedGroup() ? mArguments.element._oGroup : null;
		if (mArguments.scroll) {
			this._scrollToElement(oGroup || mArguments.element);
		}
		if (!oGroup) {
			this._selectElement(mArguments);
			if (mArguments.renderActionButtons !== false) {
				mArguments.element.showActionButtons(true);
			}
		}
	};

	Graph.prototype._selectGroup = function (mArguments) {
		if (mArguments.scroll) {
			this._scrollToElement(mArguments.element);
		}
		this.setFocus({item: mArguments.element});
	};

	Graph.prototype._applyLayout = function () {
		var oLayoutTask;

		this._iRunningLayouts++;
		oLayoutTask = this._getLayoutAlgorithm().layout().catch(function (oError) {
			jQuery.sap.log.error("Error in layouting algorithm.", oError);
		}).then(function () {
			return new Promise(function (resolve, reject) {
				if (oLayoutTask.isTerminated()) {
					resolve();
					return;
				}
				if (this._validateLayout()) {
					resolve();
				} else {
					reject();
				}
			}.bind(this), function (oError) {
				this._fireFailure(Graph.FAILURE_TYPE.LAYOUT_FAILURE, oError.type + ": " + oError.text);
				return Promise.reject();
			}.bind(this));
		}.bind(this));

		if (this._oLastLayout && this._iRunningLayouts > 1) {
			this._oLastLayout.terminate();
		}
		this._oLastLayout = oLayoutTask;

		return oLayoutTask;
	};

	/**
	 * Set accessibility title for given graph item.
	 * @param {sap.suite.ui.commons.networkgraph.SvgBase} oItem Item to set title for or null, if default title to be set.
	 * @private
	 */
	Graph.prototype._setAccessibilityTitle = function (oItem) {
		var sLabel,
			oWrapper = this.$("accessibility");
		if (oItem === null) {
			sLabel = oResourceBundle.getText("NETWORK_GRAPH_ACCESSIBILITY_CONTENT");
		} else if (typeof oItem === "string") {
			sLabel = oItem;
		} else {
			sLabel = oItem._getAccessibilityLabel();
		}
		if (oWrapper) {
			oWrapper.html(jQuery.sap.encodeHTML(sLabel));
		}
	};

	/* =========================================================== */
	/* Setters & Private helper methods*/
	/* =========================================================== */

	/**
	 * Returns the layouting algorithm to use. It's either getLayoutAlgorithm or a default algorithm.
	 * @returns {LayoutAlgorithm} Algorithm that is set to compute layout of the graph
	 * @private
	 */
	Graph.prototype._getLayoutAlgorithm = function () {
		return this.getLayoutAlgorithm() || this._getDefalutLayout();
	};

	Graph.prototype._getDefalutLayout = function () {
		if (!this._oDefalutLayout) {
			this._oDefaultLayout = new LayeredLayout();
			this._oDefaultLayout.setParent(this, null, true);
		}
		return this._oDefaultLayout;
	};

	Graph.prototype._isLayered = function () {
		return this._getLayoutAlgorithm().isLayered();
	};

	Graph.prototype._isDelayedLayouting = function () {
		return this.getNodes().some(function (oNode) {
			return oNode._useAutomaticSize() || oNode.getTitleLineSize() !== 1;
		});
	};

	Graph.prototype._isLayedOut = function () {
		return this._bIsLayedOut;
	};

	/**
	 * @param {string} sAggregationName Name of the aggregation to destroy
	 * @param {boolean} bSuppressInvalidate Whether to suppress resulting invalidation
	 * @private
	 */
	Graph.prototype.destroyAggregation = function (sAggregationName, bSuppressInvalidate) {
		this._bRequiresDataProcessing = true;
		Control.prototype.destroyAggregation.call(this, sAggregationName, bSuppressInvalidate);
	};

	/**
	 * @param {string} sAggregationName Name of the aggregation to insert the object into
	 * @param {object} oObject Object to insert into the aggregation
	 * @param {number} iIndex Index at which insert the object
	 * @param {boolean} bSuppressInvalidate Whether to suppress resulting invalidation
	 * @private
	 */
	Graph.prototype.insertAggregation = function (sAggregationName, oObject, iIndex, bSuppressInvalidate) {
		this._bRequiresDataProcessing = true;
		Control.prototype.insertAggregation.call(this, sAggregationName, oObject, iIndex, bSuppressInvalidate);
	};

	/**
	 * @param {string} sAggregationName Name of the aggregation to remove the object from
	 * @param {object} oObject Object to remove from the aggregation
	 * @param {boolean} bSuppressInvalidate Whether to suppress resulting invalidation
	 * @private
	 */
	Graph.prototype.removeAggregation = function (sAggregationName, oObject, bSuppressInvalidate) {
		this._bRequiresDataProcessing = true;
		Control.prototype.removeAggregation.call(this, sAggregationName, oObject, bSuppressInvalidate);
	};

	/**
	 * @param {string} sAggregationName Name of the aggregation to add the object into
	 * @param {object} oObject Object to add into the aggregation
	 * @param {boolean} bSuppressInvalidate Whether to suppress resulting invalidation
	 * @private
	 */
	Graph.prototype.addAggregation = function (sAggregationName, oObject, bSuppressInvalidate) {
		this._bRequiresDataProcessing = true;
		Control.prototype.addAggregation.call(this, sAggregationName, oObject, bSuppressInvalidate);
	};

	/**
	 * @param {string} sAggregationName Name of the aggregation to remove all objects from
	 * @param {boolean} bSuppressInvalidate Whether to suppress resulting invalidation
	 * @private
	 */
	Graph.prototype.removeAllAggregation = function (sAggregationName, bSuppressInvalidate) {
		this._bRequiresDataProcessing = true;
		Control.prototype.removeAllAggregation.call(this, sAggregationName, bSuppressInvalidate);
	};

	/**
	 * @param {string} sName Name of the aggregation being updated
	 * @private
	 */
	Graph.prototype.updateAggregation = function (sName) {
		this._bNeedNodeProcessing = true;
		Control.prototype.updateAggregation.call(this, sName);
	};

	return Graph;
});
