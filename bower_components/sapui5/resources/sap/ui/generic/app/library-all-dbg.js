// This file has been generated by the SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.generic.app.library-all');
if ( !jQuery.sap.isDeclared('sap.ui.generic.app.AppComponent') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

// ------------------------------------------------------------------------------------------
// Provides class sap.ui.generic.app.AppComponent for all generic app components
//
// This class is used by Component.js of all generated SmartTemplates Apps
// Therefore we need this empty stub because there is no central way to adapt the
// Component.js file of all generated SmartTemplate Apps.
// The implementation of the class is done in sap.suite.ui.generic.template.lib.AppComponent
// ------------------------------------------------------------------------------------------

// Cross-Dependency needed to effect a correct preloading of the library
sap.ui.getCore().loadLibrary("sap.suite.ui.generic.template");

jQuery.sap.declare('sap.ui.generic.app.AppComponent'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.suite.ui.generic.template.lib.AppComponent'); // unlisted dependency retained
sap.ui.define("sap/ui/generic/app/AppComponent",[
	"sap/suite/ui/generic/template/lib/AppComponent"
], function(AppComponent) {
	"use strict";

	return AppComponent;

},true);

}; // end of sap/ui/generic/app/AppComponent.js
if ( !jQuery.sap.isDeclared('sap.ui.generic.app.library') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

/**
 * Initialization Code and shared classes of library sap.ui.generic.app.
 */
jQuery.sap.declare('sap.ui.generic.app.library'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('jquery.sap.global'); // unlisted dependency retained
jQuery.sap.require('sap.ui.core.library'); // unlisted dependency retained
sap.ui.define("sap/ui/generic/app/library",['jquery.sap.global', 'sap/ui/core/library'],
	function(jQuery, library1) {
	"use strict";


	/**
	 * SAPUI5 library that provides generic reuse functionality which can be used by Applications.
	 *
	 * @namespace 
	 * @name sap.ui.generic.app
	 * @author SAP SE
	 * @version 1.50.6
	 * @public
	 */
	
	// delegate further initialization of this library to the Core
	sap.ui.getCore().initLibrary({
		name : "sap.ui.generic.app",
		version: "1.50.6",
		dependencies : ["sap.ui.core"],
		types: 	[
				"sap.ui.generic.app.navigation.service.NavType",
				"sap.ui.generic.app.navigation.service.ParamHandlingMode",
				"sap.ui.generic.app.navigation.service.SuppressionBehavior"
				],
		interfaces: [],
		controls: [],
		elements: [],
		noLibraryCSS: true
	});

	/**
	 * A static enumeration type which indicates the conflict resolution method when merging URL parameters into select options
	 * @enum {string}
	 * @name sap.ui.generic.app.navigation.service.ParamHandlingMode
	 * @readonly
	 * @public
	 */
	sap.ui.generic.app.navigation.service.ParamHandlingMode = {

		/**
		 * The conflict resolution favors the SelectionVariant over URL parameters
		 * @public
		 */
		SelVarWins : "SelVarWins",

		/**
		 * The conflict resolution favors the URL parameters over the SelectionVariant. Caution: In case of cross-app navigation
		 * a navigation parameter value from the source app is overwritten by a default, if a default is maintained in the launchpad
		 * designer for this parameter in the target app!
		 * @public
		 */
		URLParamWins : "URLParamWins",

		/**
		 * The conflict resolution adds URL parameters to the SelectionVariant
		 * @public
		 */
		InsertInSelOpt : "InsertInSelOpt"
	};

	/**
	 * A static enumeration type which indicates the type of inbound navigation
	 * @enum {string}
	 * @readonly
	 * @public
	 */
	sap.ui.generic.app.navigation.service.NavType = {
		/** 
		 * Initial startup without any navigation or default parameters
		 * @public
		 */
		initial : "initial",

		/**
		 * Basic cross-app navigation with URL parameters only (without sap-xapp-state) or initial start with default parameters
		 * @public
		 */
		URLParams : "URLParams",

		/**
		 * Cross-app navigation with sap-xapp-state parameter (and URL parameters), defaulted parameters may be added
		 * @public
		 */
		xAppState : "xAppState",

		/**
		 * Back navigation with sap-iapp-state parameter
		 * @public
		 */
		iAppState : "iAppState"
	};

	/**
	 * A static enumeration type which indicates whether semantic attributes with values <code>null</code>,
	 * <code>undefined</code> or <code>""</code> (empty string) shall be suppressed, before they are mixed in to the selection variant in the
	 * method {@link sap.ui.generic.app.navigation.service.NavigationHandler.mixAttributesAndSelectionVariant mixAttributesAndSelectionVariant}
	 * of the {@link sap.ui.generic.app.navigation.service.NavigationHandler NavigationHandler}
	 * @enum {int}
	 * @name sap.ui.generic.app.navigation.service.SuppressionBehavior
	 * @readonly
	 * @public
	 */
	sap.ui.generic.app.navigation.service.SuppressionBehavior = {

		/**
		 * Standard suppression behavior: semantic attributes with a <code>null</code> or an <code>undefined</code> value are ignored,
		 * the remaining attributes are mixed in to the selection variant
		 * @public
		 */
		standard : 0,

		/**
		 * Semantic attributes with an empty string are ignored, the remaining attributes are mixed in to the selection variant.
		 * Warning! Consider the impact on Boolean variable values!
		 * @public
		 */
		ignoreEmptyString : 1,

		/**
		 * Semantic attributes with a <code>null</code> value lead to an {@link sap.fin.central.lib.error.Error error} of type NavigationHandler.INVALID_INPUT
		 * @public
		 */
		raiseErrorOnNull : 2,

		/**
		 * Semantic attributes with an <code>undefined</code> value lead to an {@link sap.fin.central.lib.error.Error error} of type NavigationHandler.INVALID_INPUT
		 * @public
		 */
		raiseErrorOnUndefined : 4

	};

	sap.ui.lazyRequire("sap.ui.generic.app.AppComponent", "new extend getMetadata");

	return sap.ui.generic.app;

}, /* bExport= */ false);

}; // end of sap/ui/generic/app/library.js
if ( !jQuery.sap.isDeclared('sap.ui.generic.app.navigation.service.NavError') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.ui.generic.app.navigation.service.NavError'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('jquery.sap.global'); // unlisted dependency retained
jQuery.sap.require('sap.ui.base.Object'); // unlisted dependency retained
sap.ui.define("sap/ui/generic/app/navigation/service/NavError",[
	"jquery.sap.global", "sap/ui/base/Object"
], function(jQuery, BaseObject) {

	"use strict";
	
	/**
	 * @class
	 * An object that provides error handling information during runtime.
	 * @extends sap.ui.base.Object
	 * @constructor
	 * @public
	 * @alias sap.ui.generic.app.navigation.service.NavError
	 * @param {string} sErrorCode The code for an internal error of a consumer that allows you to track the source locations
	 */
	var NavError = BaseObject.extend("sap.ui.generic.app.navigation.service.NavError", /** @lends sap.ui.generic.app.navigation.service.NavError */
	{

		metadata: {
			publicMethods: [
				// getter methods of properties
				"getErrorCode"
			],
			properties: [],
			library: "sap.ui.generic.app"
		},

		constructor: function(sErrorCode) {
			BaseObject.apply(this);

			this._sErrorCode = sErrorCode;
		}

	});

	/**
	 * Returns the error code with which the instance has been created.
	 * @public
	 * @returns {string} The error code of the error
	 * 
	 */
	NavError.prototype.getErrorCode = function() {
		return this._sErrorCode;
	};

	// final step for library
	return NavError;
});

}; // end of sap/ui/generic/app/navigation/service/NavError.js
if ( !jQuery.sap.isDeclared('sap.ui.generic.app.navigation.service.PresentationVariant') ) {
/*!
 * @copyright@
 */
jQuery.sap.declare('sap.ui.generic.app.navigation.service.PresentationVariant'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.base.Object'); // unlisted dependency retained
jQuery.sap.require('jquery.sap.global'); // unlisted dependency retained
sap.ui.define("sap/ui/generic/app/navigation/service/PresentationVariant",["./NavError",  "sap/ui/base/Object", "jquery.sap.global"],
	function(Error, BaseObject, jQuery) {	
	"use strict";
 
	/**
	 * @class
	 * Creates a new instance of a PresentationVariant class. If no parameter is passed, 
	 * an new empty instance is created whose ID has been set to <code>""</code>.
	 * Passing a JSON-serialized string complying to the Selection Variant Specification will parse it,
	 * and the newly created instance will contain the same information. 
	 * @extends sap.ui.base.Object
	 * @constructor
	 * @public
	 * @alias sap.ui.generic.app.navigation.service.PresentationVariant
	 * @param {string|object} [vPresentationVariant] If of type <code>string</code>, the selection variant is JSON-formatted;
	 * if of type <code>object</code>, the object represents a selection variant
	 * @throws An instance of {@link sap.ui.generic.app.navigation.service.NavError} in case of input errors. Valid error codes are:
	 * <table>
	 * <tr><th>Error code</th><th>Description</th></tr>
	 * <tr><td>PresentationVariant.INVALID_INPUT_TYPE</td><td>Indicates that the data format of the selection variant provided is inconsistent</td></tr>
	 * <tr><td>PresentationVariant.UNABLE_TO_PARSE_INPUT</td><td>Indicates that the provided string is not a JSON-formatted string</td></tr>
	 * <tr><td>PresentationVariant.INPUT_DOES_NOT_CONTAIN_SELECTIONVARIANT_ID</td><td>Indicates that the PresentationVariantID cannot be retrieved</td></tr>
	 * <tr><td>PresentationVariant.PARAMETER_WITHOUT_VALUE</td><td>Indicates that there was an attempt to specify a parameter, but without providing any value (not even an empty value)</td></tr>
	 * <tr><td>PresentationVariant.SELECT_OPTION_WITHOUT_PROPERTY_NAME</td><td>Indicates that a selection option has been defined, but the Ranges definition is missing</td></tr>
	 * <tr><td>PresentationVariant.SELECT_OPTION_RANGES_NOT_ARRAY</td><td>Indicates that the Ranges definition is not an array</td></tr>
	 * </table>
	 * These exceptions can only be thrown if the parameter <code>vPresentationVariant</code> has been provided. 
	 */
	var PresentationVariant = BaseObject.extend("sap.ui.generic.app.navigation.service.PresentationVariant",  /** @lends sap.ui.generic.app.navigation.service.PresentationVariant */ {
	
		constructor : function(vPresentationVariant) {
			
			this._sId = "";
		
			if (vPresentationVariant !== undefined) {
				if (typeof vPresentationVariant === "string") {
					this._parseFromString(vPresentationVariant);
				} else if (typeof vPresentationVariant === "object") {
					this._parseFromObject(vPresentationVariant);
				} else {
					throw new Error("PresentationVariant.INVALID_INPUT_TYPE");
				}
			}
		},
	
		/**
		 * Returns the identification of the selection variant.
		 * @returns {string} The identification of the selection variant as made available during construction
		 * @public
		 */
		getID : function() {
			return this._sId;
		},
	
		/**
		 * Sets the identification of the selection variant.
		 * @param {string} sId The new identification of the selection variant 
		 * @public
		 */
		setID : function(sId) {
			this._sId = sId;
		},
	
		/**
		 * Sets the text / description of the selection variant.
		 * @param {string} sNewText The new description to be used
		 * @public
		 * @throws An instance of {@link sap.ui.generic.app.navigation.service.NavError} in case of input errors. Valid error codes are:
		 * <table>
		 * <tr><th>Error code</th><th>Description</th></tr>
		 * <tr><td>PresentationVariant.INVALID_INPUT_TYPE</td><td>Indicates that an input parameter has an invalid type</td></tr>
		 * </table>
		 */
		setText : function(sNewText) {
			if (typeof sNewText !== "string") {
				throw new Error("PresentationVariant.INVALID_INPUT_TYPE");
			}
			this._sText = sNewText;
		},
	
		/**
		 * Returns the current text / description of this selection variant.
		 * @returns {string} the current description of this selection variant.
		 * @public
		 */
		getText : function() {
			return this._sText;
		},
	
		/**
		 * Sets the context URL.
		 * @param {string} sURL The URL of the context
		 * @public
		 * @throws An instance of {@link sap.ui.generic.app.navigation.service.NavError} in case of input errors. Valid error codes are:
		 * <table>
		 * <tr><th>Error code</th><th>Description</th></tr>
		 * <tr><td>PresentationVariant.INVALID_INPUT_TYPE</td><td>Indicates that an input parameter has an invalid type</td></tr>
		 * </table>
		 */
		setContextUrl : function(sURL) {
			if (typeof sURL !== "string") {
				throw new Error("PresentationVariant.INVALID_INPUT_TYPE");
			}
			this._sCtxUrl = sURL;
		},
	
		/**
		 * Gets the current context URL intended for the query.
		 * @returns {string} The current context URL for the query
		 * @public
		 */
		getContextUrl : function() {
			return this._sCtxUrl;
		},	
		
		/**
		 * Returns <code>true</code> if the presentation variant does not contain any properties.
		 * nor ranges.
		 * @return {boolean} If set to <code>true</code> there are no current properties set; <code>false</code> otherwise.
		 * @public
		 */
		isEmpty : function() {
			return ((Object.keys(this.getTableVisualization()).length === 0) && (Object.keys(this.getChartVisualization()).length === 0) && (Object.keys(this.getProperties()).length === 0));			                
		},
	


		/**
		 * Sets the more trivial properties. Basically all properties with the exception of the Visualization.
		 * 
		 * @param {map} mProperties properties to be used. 
		 * @public
		 */
		setProperties : function(mProperties) {
			this._mProperties = jQuery.extend(true, {}, mProperties);
		},		
		
		/**
		 * Gets the more trivial properties. Basically all properties with the exception of the Visualization.
		 * @returns {map} The current properties. 
		 * @public
		 */		
		getProperties : function() {

			return this._mProperties;
		},	
		
		/**
		 * Sets the table visualization property. 
		 * 
		 * @param {map} mProperties to be used for the table visualization. 
		 * @public
		 */
		setTableVisualization : function(mProperties) {
			this._mVisTable = jQuery.extend(true, {}, mProperties);
		},	
		
		/**
		 * Gets the table visualization property. 
		 * 
		 * @returns {map} mProperties to be used for the table visualization. 
		 * @public
		 */
		getTableVisualization : function() {
			return this._mVisTable;
		},			
		
		/**
		 * Sets the chart visualization property. 
		 * 
		 * @param {map} mProperties to be used for the chart visualization. 
		 * @public
		 */
		setChartVisualization : function(mProperties) {
			this._mVisChart = jQuery.extend(true, {}, mProperties);
		},	
		
		/**
		 * Gets the chart visualization property. 
		 * 
		 * @returns {map} mProperties to be used for the chart visualization. 
		 * @public
		 */
		getChartVisualization : function() {
			return this._mVisChart;
		},		
		
		
		/**
		 * Returns the external representation of the selection variant as JSON object.
		 * @return {object} The external representation of this instance as a JSON object
		 * @public
		 */
		toJSONObject : function() {
			var oExternalPresentationVariant = {
				Version : { // Version attributes are not part of the official specification, 
					Major : "1", // but could be helpful later for implementing a proper lifecycle/interoperability
					Minor : "0",
					Patch : "0"
				},
				PresentationVariantID : this._sId
			};
		
			if (this._sCtxUrl) {
				oExternalPresentationVariant.ContextUrl = this._sCtxUrl;
			}
		
			if (this._sText) {
				oExternalPresentationVariant.Text = this._sText;
			} else {
				oExternalPresentationVariant.Text = "Presentation Variant with ID " + this._sId;
			}
	
		
			this._serializeProperties(oExternalPresentationVariant);
			this._serializeVisualizations(oExternalPresentationVariant);
			
			return oExternalPresentationVariant;
		},
		
		/**
		 * Serializes this instance into a JSON-formatted string.
		 * @return {string} The JSON-formatted representation of this instance in stringified format
		 * @public
		 */
		toJSONString : function() {
			return JSON.stringify(this.toJSONObject());
		},
				
		_serializeProperties : function(oExternalPresentationVariant) {			
			
			if (!this.getProperties()) {
				return;
			}
		
			jQuery.extend(true, oExternalPresentationVariant, this.getProperties());
		},
	
		_serializeVisualizations : function(oExternalPresentationVariant) {
		
			if (this.getTableVisualization()) {
				if (!oExternalPresentationVariant.Visualizations) {
					oExternalPresentationVariant.Visualizations = [];
				}
				oExternalPresentationVariant.Visualizations.push(this.getTableVisualization());
			}

			if (this.getChartVisualization()) {
				if (!oExternalPresentationVariant.Visualizations) {
					oExternalPresentationVariant.Visualizations = [];
				}
				oExternalPresentationVariant.Visualizations.push(this.getChartVisualization());
			}			

		},

		_parseFromString : function(sJSONString) {
			if (sJSONString === undefined) {
				throw new Error("PresentationVariant.UNABLE_TO_PARSE_INPUT");
			}
		
			if (typeof sJSONString !== "string") {
				throw new Error("PresentationVariant.INVALID_INPUT_TYPE");
			}
		
			var oInput = JSON.parse(sJSONString);
			// the input needs to be an JSON string by specification
			
			this._parseFromObject(oInput);
		}, 
		
		_parseFromObject : function(oInput) {
		
			if (oInput.PresentationVariantID === undefined) {
				// Do not throw an error, but only write a warning into the log.
				// The PresentationVariantID is mandatory according to the specification document version 1.0, 
				// but this document is not a universally valid standard.
				// It is said that the "implementation of the SmartFilterBar" may supersede the specification.
				// Thus, also allow an initial PresentationVariantID.
	//		throw new sap.ui.generic.app.navigation.service.NavError("PresentationVariant.INPUT_DOES_NOT_CONTAIN_SELECTIONVARIANT_ID");
				jQuery.sap.log.warning("PresentationVariantID is not defined");
				oInput.PresentationVariantID = "";
			}
			
			
			var oInputCopy = jQuery.extend(true, {}, oInput);
			delete oInputCopy.Version;
		
			this.setID(oInput.PresentationVariantID);
			delete oInputCopy.PresentationVariantID;
		
			if (oInput.ContextUrl !== undefined && oInput.ContextUrl !== "") {
				this.setContextUrl(oInput.ContextUrl);
				delete oInputCopy.ContextUrl;				
			}
		
			if (oInput.Text !== undefined) {
				this.setText(oInput.Text);
				delete oInputCopy.Text;
			}		
	
			if (oInput.Visualizations) {
				this._parseVisualizations(oInput.Visualizations);
				delete oInputCopy.Visualizations;				
			}	
			
			this._parseProperties(oInputCopy);
			
		},
	
		_parseProperties : function(oInput) {
			
			var mProperties = {};
			
			
			
			jQuery.each(oInput, function(sKey, vValue) {
				mProperties[sKey] = vValue;
			});

			this.setProperties(mProperties);
		},
	
		_parseVisualizations: function(aVisualizations) {
			
			if (!Array.isArray(aVisualizations)) {
				throw new Error("PresentationVariant.INVALID_INPUT_TYPE");
			}
			if (typeof aVisualizations.length > 2) {
				throw new Error("PresentationVariant.TOO_MANY_VISUALIZATIONS");
			}

			for (var i = 0; i < aVisualizations.length; i++) {
				if (aVisualizations[i].Type && (aVisualizations[i].Type.indexOf("Chart") >= 0)) {
					this.setChartVisualization(aVisualizations[i]);
				} else {
					this.setTableVisualization(aVisualizations[i]);
				}
			}

		}
	});

	return PresentationVariant;

});

}; // end of sap/ui/generic/app/navigation/service/PresentationVariant.js
if ( !jQuery.sap.isDeclared('sap.ui.generic.app.navigation.service.SelectionVariant') ) {
/*!
 * @copyright@
 */
jQuery.sap.declare('sap.ui.generic.app.navigation.service.SelectionVariant'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.base.Object'); // unlisted dependency retained
jQuery.sap.require('jquery.sap.global'); // unlisted dependency retained
sap.ui.define("sap/ui/generic/app/navigation/service/SelectionVariant",["./NavError",  "sap/ui/base/Object", "jquery.sap.global"],
	function(Error, BaseObject, jQuery) {	
	"use strict";
 
	/**
	 * @class
	 * Creates a new instance of a SelectionVariant class. If no parameter is passed, 
	 * an new empty instance is created whose ID has been set to <code>""</code>.
	 * Passing a JSON-serialized string complying to the Selection Variant Specification will parse it,
	 * and the newly created instance will contain the same information. 
	 * @extends sap.ui.base.Object
	 * @constructor
	 * @public
	 * @alias sap.ui.generic.app.navigation.service.SelectionVariant
	 * @param {string|object} [vSelectionVariant] If of type <code>string</code>, the selection variant is JSON-formatted;
	 * if of type <code>object</code>, the object represents a selection variant
	 * @throws An instance of {@link sap.ui.generic.app.navigation.service.NavError} in case of input errors. Valid error codes are:
	 * <table>
	 * <tr><th>Error code</th><th>Description</th></tr>
	 * <tr><td>SelectionVariant.INVALID_INPUT_TYPE</td><td>Indicates that the data format of the selection variant provided is inconsistent</td></tr>
	 * <tr><td>SelectionVariant.UNABLE_TO_PARSE_INPUT</td><td>Indicates that the provided string is not a JSON-formatted string</td></tr>
	 * <tr><td>SelectionVariant.INPUT_DOES_NOT_CONTAIN_SELECTIONVARIANT_ID</td><td>Indicates that the SelectionVariantID cannot be retrieved</td></tr>
	 * <tr><td>SelectionVariant.PARAMETER_WITHOUT_VALUE</td><td>Indicates that there was an attempt to specify a parameter, but without providing any value (not even an empty value)</td></tr>
	 * <tr><td>SelectionVariant.SELECT_OPTION_WITHOUT_PROPERTY_NAME</td><td>Indicates that a selection option has been defined, but the Ranges definition is missing</td></tr>
	 * <tr><td>SelectionVariant.SELECT_OPTION_RANGES_NOT_ARRAY</td><td>Indicates that the Ranges definition is not an array</td></tr>
	 * </table>
	 * These exceptions can only be thrown if the parameter <code>vSelectionVariant</code> has been provided. 
	 */
	var SelectionVariant = BaseObject.extend("sap.ui.generic.app.navigation.service.SelectionVariant",  /** @lends sap.ui.generic.app.navigation.service.SelectionVariant */ {
		_rVALIDATE_SIGN : new RegExp("[E|I]"),
		_rVALIDATE_OPTION : new RegExp("EQ|NE|LE|GE|LT|GT|BT|CP"),
	
		constructor : function(vSelectionVariant) {
			this._mParameters = {};
			this._mSelectOptions = {};
		
			this._sId = "";
		
			if (vSelectionVariant !== undefined) {
				if (typeof vSelectionVariant === "string") {
					this._parseFromString(vSelectionVariant);
				} else if (typeof vSelectionVariant === "object") {
					this._parseFromObject(vSelectionVariant);
				} else {
					throw new Error("SelectionVariant.INVALID_INPUT_TYPE");
				}
			}
		},
	
		/**
		 * Returns the identification of the selection variant.
		 * @returns {string} The identification of the selection variant as made available during construction
		 * @public
		 */
		getID : function() {
			return this._sId;
		},
	
		/**
		 * Sets the identification of the selection variant.
		 * @param {string} sId The new identification of the selection variant 
		 * @public
		 */
		setID : function(sId) {
			this._sId = sId;
		},
	
		/**
		 * Sets the text / description of the selection variant.
		 * @param {string} sNewText The new description to be used
		 * @public
		 * @throws An instance of {@link sap.ui.generic.app.navigation.service.NavError} in case of input errors. Valid error codes are:
		 * <table>
		 * <tr><th>Error code</th><th>Description</th></tr>
		 * <tr><td>SelectionVariant.INVALID_INPUT_TYPE</td><td>Indicates that an input parameter has an invalid type</td></tr>
		 * </table>
		 */
		setText : function(sNewText) {
			if (typeof sNewText !== "string") {
				throw new Error("SelectionVariant.INVALID_INPUT_TYPE");
			}
			this._sText = sNewText;
		},
	
		/**
		 * Returns the current text / description of this selection variant.
		 * @returns {string} the current description of this selection variant.
		 * @public
		 */
		getText : function() {
			return this._sText;
		},
	
		/**
		 * Sets the context URL intended for the parameters.
		 * @param {string} sURL The URL of the parameter context
		 * @public
		 * @throws An instance of {@link sap.ui.generic.app.navigation.service.NavError} in case of input errors. Valid error codes are:
		 * <table>
		 * <tr><th>Error code</th><th>Description</th></tr>
		 * <tr><td>SelectionVariant.INVALID_INPUT_TYPE</td><td>Indicates that an input parameter has an invalid type</td></tr>
		 * </table>
		 */
		setParameterContextUrl : function(sURL) {
			if (typeof sURL !== "string") {
				throw new Error("SelectionVariant.INVALID_INPUT_TYPE");
			}
			this._sParameterCtxUrl = sURL;
		},
	
		/**
		 * Gets the current context URL intended for the parameters.
		 * @returns {string} The current context URL for the parameters
		 * @public
		 */
		getParameterContextUrl : function() {
			return this._sParameterCtxUrl;
		},
	
		/**
		 * Gets the current context URL intended for the filters.
		 * @returns {string} The current context URL for the filters
		 * @public
		 */
		getFilterContextUrl : function() {
			return this._sFilterCtxUrl;
		},
	
		/**
		 * Sets the context URL intended for the filters.
		 * @param {string} sURL The URL of the filters
		 * @public
		 * @throws An instance of {@link sap.ui.generic.app.navigation.service.NavError} in case of input errors. Valid error codes are:
		 * <table>
		 * <tr><th>Error code</th><th>Description</th></tr>
		 * <tr><td>SelectionVariant.INVALID_INPUT_TYPE</td><td>Indicates that an input parameter has an invalid type</td></tr>
		 * </table>
		 */
		setFilterContextUrl : function(sURL) {
			if (typeof sURL !== "string") {
				throw new Error("SelectionVariant.INVALID_INPUT_TYPE");
			}
			this._sFilterCtxUrl = sURL;
		},
	
		/**
		 * Sets the value of a parameter called <code>sName</code> to the new value <code>sValue</code>.
		 * If the parameter has already been set before, its value is overwritten.
		 * @param {string} sName The name of the parameter to be set; the <code>null</code> value is not allowed 
		 * @param {string} sValue The value of the parameter to be set
		 * @returns {object} This instance to allow method chaining
		 * @public
		 * @throws An instance of {@link sap.ui.generic.app.navigation.service.NavError} in case of input errors. Valid error codes are:
		 * <table>
		 * <tr><th>Error code</th><th>Description</th></tr>
		 * <tr><td>SelectionVariant.PARAMETER_WITHOUT_NAME</td><td>Indicates that the name of the parameter has not been specified</td></tr>
		 * <tr><td>SelectionVariant.INVALID_INPUT_TYPE</td><td>Indicates that an input parameter has an invalid type or the value is set to <code>null</code></td></tr>
		 * <tr><td>SelectionVariant.PARAMETER_SELOPT_COLLISION</td><td>Indicates that another SelectOption with the same name as the parameter already exists</td></tr>
		 * </table>
		 */
		addParameter : function(sName, sValue) {
			/*
			 *  {string} sName The name of the parameter to be set; the <code>null</code> value is not allowed 
			 * (see specification "Selection Variants for UI Navigation in Fiori", section 2.4.2.1)
			 */			
			if (typeof sName !== "string") {
				throw new Error("SelectionVariant.INVALID_INPUT_TYPE");
			}
			if (typeof sValue !== "string") {
				throw new Error("SelectionVariant.INVALID_INPUT_TYPE");
			}
			if (sName === "") {
				throw new Error("SelectionVariant.PARAMETER_WITHOUT_NAME");
			}
		
			if (this._mSelectOptions[sName]) {
				throw new Error("SelectionVariant.PARAMETER_SELOPT_COLLISION");
			}

			this._mParameters[sName] = sValue;
		
			return this;
		},
	
		/**
		 * Removes a parameter called <code>sName</code> from the selection variant.
		 * @param {string} sName The name of the parameter to be removed
		 * @returns {object} This instance to allow method chaining
		 * @public
		 * @throws An instance of {@link sap.ui.generic.app.navigation.service.NavError} in case of input errors. Valid error codes are:
		 * <table>
		 * <tr><th>Error code</th><th>Description</th></tr>
		 * <tr><td>SelectionVariant.PARAMETER_WITHOUT_NAME</td><td>Indicates that name of the parameter has not been specified</td></tr>
		 * <tr><td>SelectionVariant.INVALID_INPUT_TYPE</td><td>Indicates that an input parameter has an invalid type</td></tr>
		 * </table>
		 */
		removeParameter : function(sName) {
			if (typeof sName !== "string") {
				throw new Error("SelectionVariant.INVALID_INPUT_TYPE");
			}
			if (sName === "") {
				throw new Error("SelectionVariant.PARAMETER_WITHOUT_NAME");
			}
		
			delete this._mParameters[sName];
		
			return this;
		},
	
		/**
		 * Renames a parameter called <code>sNameOld</code> to <code>sNameNew</code>. If a parameter or a select option with
		 * the name <code>sNameNew</code> already exist, an error is thrown. If a parameter with the name <code>sNameOld</code>
		 * does not exist, nothing is changed.
		 * @param {string} sNameOld The current name of the parameter to be renamed
		 * @param {string} sNameNew The new name of the parameter
		 * @returns {object} This instance to allow method chaining
		 * @public
		 * @throws An instance of {@link sap.ui.generic.app.navigation.service.NavError} in case of input errors. Valid error codes are:
		 * <table>
		 * <tr><th>Error code</th><th>Description</th></tr>
		 * <tr><td>SelectionVariant.PARAMETER_WITHOUT_NAME</td><td>Indicates that the name of a parameter has not been specified</td></tr>
		 * <tr><td>SelectionVariant.INVALID_INPUT_TYPE</td><td>Indicates that an input parameter has an invalid type</td></tr>
		 * <tr><td>SelectionVariant.PARAMETER_SELOPT_COLLISION</td><td>Indicates that another select option with the same new name already exists</td></tr>
		 * <tr><td>SelectionVariant.PARAMETER_COLLISION</td><td>Indicates that another parameter with the same new name already exists</td></tr>
		 * </table>
		 */	
		renameParameter : function(sNameOld, sNameNew) {
			if (typeof sNameOld !== "string" || typeof sNameNew !== "string") {
				throw new Error("SelectionVariant.INVALID_INPUT_TYPE");
			}
			if (sNameOld === "" || sNameNew === "") {
				throw new Error("SelectionVariant.PARAMETER_WITHOUT_NAME");
			}
			if (this._mParameters[sNameOld] !== undefined) {
				if (this._mSelectOptions[sNameNew]) {
					throw new Error("SelectionVariant.PARAMETER_SELOPT_COLLISION");
				}
				if (this._mParameters[sNameNew]) {
					throw new Error("SelectionVariant.PARAMETER_COLLISION");
				}
				this._mParameters[sNameNew] = this._mParameters[sNameOld];
				delete this._mParameters[sNameOld];
			}
			return this;
		},
	
		/**
		 * Returns the value of the parameter called <code>sName</code> if it has been set.
		 * If the parameter has never been set or has been removed, <code>undefined</code> is returned.
		 * @param {string} sName The name of the parameter to be returned
		 * @returns {string} The value of parameter <code>sName</code>; returning the value <code>null</code> not possible 
		 * @public
		 * @throws An instance of {@link sap.ui.generic.app.navigation.service.NavError} in case of input errors. Valid error codes are:
		 * <table>
		 * <tr><th>Error code</th><th>Description</th></tr>
		 * <tr><td>SelectionVariant.INVALID_INPUT_TYPE</td><td>Indicates that an input parameter has an invalid type</td></tr>
		 * </table>
		 */
		getParameter : function(sName) {
			if (typeof sName !== "string") {
				throw new Error("SelectionVariant.INVALID_INPUT_TYPE");
			}
			return this._mParameters[sName];
		},
	
		/**
		 * Returns the set of parameter names available in this selection variant
		 * @returns {array} the list of parameter names which are valid
		 * @public
		 */
		getParameterNames : function() {
			return Object.keys(this._mParameters);
		},
	
		/**
		 * Adds a new range to the list of select options for a given parameter.
		 * @param {string} sPropertyName The name of the property for which the selection range is added
		 * @param {string} sSign The sign of the range (<b>I</b>nclude or <b>E</b>xclude)
		 * @param {string} sOption The option of the range (<b>EQ</b> for "equals", <b>NE</b> for "not equals",
		 * <b>LE</b> for "less or equals", <b>GE</b> for "greater or equals", <b>LT</b> for "less than" (and not equals),
		 * <b>GT</b> for "greater than" (and not equals), <b>BT</b> for "between", or <b>CP</b> for "contains pattern"
		 * (ABAP-styled pattern matching with the asterisk as wildcard)
		 * @param {string} sLow The single value or the lower boundary of the interval; the <code>null</code> value is not allowed 
		 * @param {string} [sHigh] Set only if sOption is <b>BT</b>: the upper boundary of the interval;
		 * must be <code>undefined</code> or <code>null</code> in all other cases
		 * @return {object} This instance to allow method chaining.
		 * @public
		 * @throws An instance of {@link sap.ui.generic.app.navigation.service.NavError} in case of input errors. Valid error codes are:
		 * <table>
		 * <tr><th>Error code</th><th>Description</th></tr>
		 * <tr><td>SelectionVariant.INVALID_SIGN</td><td>Indicates that the sign is an invalid expression</td></tr>
		 * <tr><td>SelectionVariant.INVALID_OPTION</td><td>Indicates that the option is an invalid expression</td></tr>
		 * <tr><td>SelectionVariant.HIGH_PROVIDED_THOUGH_NOT_ALLOWED</td><td>Indicates that the upper boundary has been specified, even though the option is not 'BT'</td></tr>
		 * <tr><td>SelectionVariant.INVALID_INPUT_TYPE</td><td>Indicates that an input parameter has an invalid type or the value is set to <code>null</code></td></tr>
		 * <tr><td>SelectionVariant.INVALID_PROPERTY_NAME</td><td>Indicates that the property name is invalid, for example, it has not been specified</td></tr>
		 * <tr><td>SelectionVariant.PARAMETER_SELOPT_COLLISION</td><td>Indicates that another parameter with the same name as the property name already exists</td></tr>
		 * </table>
		 */
		addSelectOption : function(sPropertyName, sSign, sOption, sLow, sHigh) {
			 /* {string} sLow The single value or the lower boundary of the interval; the <code>null</code> value is not allowed 
			 * (see specification "Selection Variants for UI Navigation in Fiori", section 2.4.2.1)
			 */
			if (typeof sPropertyName !== "string") {
				throw new Error("SelectionVariant.INVALID_INPUT_TYPE");
			}
			if (sPropertyName === "") {
				throw new Error("SelectionVariant.INVALID_PROPERTY_NAME");
			}
			if (typeof sSign !== "string") {
				throw new Error("SelectionVariant.INVALID_INPUT_TYPE");
			}
			if (typeof sOption !== "string") {
				throw new Error("SelectionVariant.INVALID_INPUT_TYPE");
			}
			if (typeof sLow !== "string") {
				throw new Error("SelectionVariant.INVALID_INPUT_TYPE");
			}
			if (sOption === "BT" && typeof sHigh !== "string") {
				throw new Error("SelectionVariant.INVALID_INPUT_TYPE");
			}
			if (!this._rVALIDATE_SIGN.test(sSign.toUpperCase())) {
				throw new Error("SelectionVariant.INVALID_SIGN");
			}
		
			if (!this._rVALIDATE_OPTION.test(sOption.toUpperCase())) {
				throw new Error("SelectionVariant.INVALID_OPTION");
			}
		
			if (this._mParameters[sPropertyName]) {
				throw new Error("SelectionVariant.PARAMETER_SELOPT_COLLISION");
			}
		
			if (sOption !== "BT") {
				// only "Between" has two parameters; for all others, sHigh may not be filled
				if ( (sHigh !== undefined) && (sHigh !== "") && (sHigh !== null)) {
					throw new Error("SelectionVariant.HIGH_PROVIDED_THOUGH_NOT_ALLOWED");
				}
			}
		
			// check, if there's already an entry for this property
			if (this._mSelectOptions[sPropertyName] === undefined) {
				// if not, create a new set of entries
				this._mSelectOptions[sPropertyName] = [];
			}
		
			var oEntry = {
				Sign : sSign.toUpperCase(),
				Option : sOption.toUpperCase(),
				Low : sLow
			};
		
			if (sOption === "BT") {
				oEntry.High = sHigh;
			} else {
				oEntry.High = null;	// Note this special case in the specification!
				// The specification requires that the "High" attribute is always 
				// available. In case that no high value is necessary, yet the value
				// may not be empty, but needs to be set to "null"
			}
		
			//check if it is necessary to add select option
			for (var i = 0; i < this._mSelectOptions[sPropertyName].length; i++) {
				var oExistingEntry = this._mSelectOptions[sPropertyName][i];
				if (oExistingEntry.Sign === oEntry.Sign && oExistingEntry.Option === oEntry.Option && oExistingEntry.Low === oEntry.Low && oExistingEntry.High === oEntry.High) {
					return this;
				}
			}
			this._mSelectOptions[sPropertyName].push(oEntry);

			return this;
		},

		/**
		 * Removes a select option called <code>sName</code> from the selection variant.
		 * @param {string} sName The name of the select option to be removed
		 * @returns {object} This instance to allow method chaining.
		 * @public
		 * @throws An instance of {@link sap.ui.generic.app.navigation.service.NavError} in case of input errors. Valid error codes are:
		 * <table>
		 * <tr><th>Error code</th><th>Description</th></tr>
		 * <tr><td>SelectionVariant.SELOPT_WITHOUT_NAME</td><td>Indicates that name of the select option has not been specified</td></tr>
		 * <tr><td>SelectionVariant.SELOPT_WRONG_TYPE</td><td>Indicates that the name of the parameter <code>sName</code> has an invalid type</td></tr>
		 * </table>
		 */
		removeSelectOption : function(sName) {
			if (typeof sName !== "string") {
				throw new Error("SelectionVariant.SELOPT_WRONG_TYPE");
			}
		
			if (sName === "") {
				throw new Error("SelectionVariant.SELOPT_WITHOUT_NAME");
			}
		
			delete this._mSelectOptions[sName];
		
			return this;
		},
	
		/**
		 * Renames a select option called <code>sNameOld</code> to <code>sNameNew</code>. If a select option or a parameter
		 * with the name <code>sNameNew</code> already exist, an error is thrown. If a select option with the name <code>sNameOld</code>
		 * does not exist, nothing is changed.
		 * @param {string} sNameOld The current name of the select option property to be renamed
		 * @param {string} sNameNew The new name of the select option property
		 * @returns {object} This instance to allow method chaining
		 * @public
		 * @throws An instance of {@link sap.ui.generic.app.navigation.service.NavError} in case of input errors. Valid error codes are:
		 * <table>
		 * <tr><th>Error code</th><th>Description</th></tr>
		 * <tr><td>SelectionVariant.SELOPT_WITHOUT_NAME</td><td>Indicates that the name of a select option has not been specified</td></tr>
		 * <tr><td>SelectionVariant.SELOPT_WRONG_TYPE</td><td>Indicates that a select option has an invalid type</td></tr>
		 * <tr><td>SelectionVariant.PARAMETER_SELOPT_COLLISION</td><td>Indicates that another parameter with the same new name already exists</td></tr>
		 * <tr><td>SelectionVariant.SELOPT_COLLISION</td><td>Indicates that another select option with the same new name already exists</td></tr>
		 * </table>
		 */	
		renameSelectOption : function(sNameOld, sNameNew) {
			if (typeof sNameOld !== "string" || typeof sNameNew !== "string") {
				throw new Error("SelectionVariant.SELOPT_WRONG_TYPE");
			}
			if (sNameOld === "" || sNameNew === "") {
				throw new Error("SelectionVariant.SELOPT_WITHOUT_NAME");
			}
			if (this._mSelectOptions[sNameOld] !== undefined) {
				if (this._mSelectOptions[sNameNew]) {
					throw new Error("SelectionVariant.SELOPT_COLLISION");
				}
				if (this._mParameters[sNameNew]) {
					throw new Error("SelectionVariant.PARAMETER_SELOPT_COLLISION");
				}
				this._mSelectOptions[sNameNew] = this._mSelectOptions[sNameOld];
				delete this._mSelectOptions[sNameOld];
			}
			return this;
		},
	
		/**
		 * Returns the set of select options/ranges available for a given property name.
		 * @param {string} sPropertyName The name of the property for which the set of select options/ranges is returned
		 * @returns {array} If <code>sPropertyName</code> is an invalid name of a property or no range exists, <code>undefined</code>
		 * is returned; otherwise, an immutable array of ranges is returned. Each entry of the array is an object with the 
		 * following properties:
		 * <ul>
		 * <li><code>Sign</code>: The sign of the range</li>
		 * <li><code>Option</code>: The option of the range</li>
		 * <li><code>Low</code>: The low value of the range; returning value <code>null</code> is not possible</li>
		 * <li><code>High</code>: The high value of the range; if this value is not necessary, <code>null</code> is used</li>
		 * </ul>
		 * For further information about the meaning of the attributes, refer to method <code>addSelectOption</code>.
		 * @public
		 * @throws An instance of {@link sap.ui.generic.app.navigation.service.NavError} in case of input errors. Valid error codes are:
		 * <table>
		 * <tr><th>Error code</th><th>Description</th></tr>
		 * <tr><td>SelectionVariant.INVALID_INPUT_TYPE</td><td>Indicates that an input parameter has an invalid type</td></tr>
		 * <tr><td>SelectionVariant.INVALID_PROPERTY_NAME</td><td>Indicates that the property name is invalid, for example, it has not been specified</td></tr>
		 * </table>
		 */
		getSelectOption : function(sPropertyName) {
			if (typeof sPropertyName !== "string") {
				throw new Error("SelectionVariant.INVALID_INPUT_TYPE");
			}
			if (sPropertyName === "") {
				throw new Error("SelectionVariant.INVALID_PROPERTY_NAME");
			}
		
			var oEntries = this._mSelectOptions[sPropertyName];
			if (!oEntries) {
				return undefined;
			}
		
			return JSON.parse(JSON.stringify(oEntries)); // create an immutable clone of data to prevent obfuscation by caller.
		},
	
		/**
		 * Returns the names of the properties available for this instance.
		 * @returns {array} The list of property names available for this instance
		 * @public
		 */
		getSelectOptionsPropertyNames : function() {
			return Object.keys(this._mSelectOptions);
		},
		
		/**
		 * Returns the names of the parameter and select option properties available for this instance.
		 * @returns {array} The list of parameter and select option property names available for this instance
		 * @public
		 */
		getPropertyNames : function() {
			return this.getParameterNames().concat(this.getSelectOptionsPropertyNames());
		},
		
		/**
		 * Adds a set of select options to the list of select options for a given parameter.
		 * @param {string} sPropertyName The name of the property for which the set of select options is added
		 * @param {array} aSelectOptions Set of select options to be added
		 * @return {object} This instance to allow method chaining
		 * @throws An instance of {@link sap.ui.generic.app.navigation.service.NavError} in case of input errors. Valid error codes are:
		 * <table>
		 * <tr><th>Error code</th><th>Description</th></tr>
		 * <tr><td>SelectionVariant.INVALID_INPUT_TYPE</td><td>Indicates that an input parameter has an invalid type</td></tr>
		 * </table>
		 * @public
		 */
		massAddSelectOption : function(sPropertyName, aSelectOptions){
			
			if (!jQuery.isArray(aSelectOptions)) {
				throw new Error("SelectionVariant.INVALID_INPUT_TYPE");
			}
			
			for (var i = 0; i < aSelectOptions.length; i++){
				var oSelectOption = aSelectOptions[i];
				this.addSelectOption(sPropertyName, oSelectOption.Sign, oSelectOption.Option, oSelectOption.Low, oSelectOption.High);
			}
			
			return this;
		},
		
		/**
		 * First tries to retrieve the set of select options/ranges available for <code>sName</code> as property name. If successful, 
		 * this array of selections is being returned. If it fails, an attempt to find a parameter, whose name is <code>sName</code>, is
		 * made. If the latter succeeds, the single value is converted to fit into an array of selections to make it 
		 * type compatible with ranges. This array is then returned. <br />
		 * If neither a select option nor a parameter could be found, <code>undefined</code> is returned.
		 * @param {string} sName The name of the attribute for which the value is retrieved
		 * @returns {array} The ranges in the select options for the specified property or a range-converted representation of a parameter is returned.
		 * If both lookups fail, <code>undefined</code> is returned. <br />
		 * The returned ranges have the format:
		 * <ul>
		 * <li><code>Sign</code>: The sign of the range</li>
		 * <li><code>Option</code>: The option of the range</li>
		 * <li><code>Low</code>: The low value of the range; returning the value <code>null</code> is not possible</li>
		 * <li><code>High</code>: The high value of the range; if this value is not necessary, <code>null</code> (but does exist)</li>
		 * </ul>
		 * For further information on the meaning of the attributes, refer to method {@link #.addSelectOption addSelectOption}.
		 * @public
		 * @throws An instance of {@link sap.ui.generic.app.navigation.service.NavError} in case of input errors. Valid error codes are:
		 * <table>
		 * <tr><th>Error code</th><th>Description</th></tr>
		 * <tr><td>SelectionVariant.INVALID_INPUT_TYPE</td><td>Indicates that an input parameter has an invalid type</td></tr>
		 * <tr><td>SelectionVariant.INVALID_PROPERTY_NAME</td><td>Indicates that the property name is invalid, for example, it has not been specified</td></tr>
		 * </table>
		 */
		getValue : function(sName) {
			var aValue = this.getSelectOption(sName);
			if (aValue !== undefined) {
				// a range for the selection option is provided; so this is the leading one
				return aValue;
			}
		
			var sParamValue = this.getParameter(sName);
			if (sParamValue !== undefined) {
				// a parameter value has been provided; we need to convert it to the range format
				aValue = [
					{
						Sign : "I",
						Option : "EQ",
						Low : sParamValue,
						High : null
					}
				];
				return aValue;
			}
		
			return undefined;
		},
	
		
		/**
		 * Returns <code>true</code> if the selection variant does neither contain parameters
		 * nor ranges.
		 * @return {boolean} If set to <code>true</code>  there are no parameters and no select options available in
		 * the selection variant; <code>false</code> otherwise.
		 * @public
		 */
		isEmpty : function() {
			return this.getParameterNames().length === 0 && this.getSelectOptionsPropertyNames().length === 0;
		},
	
		/**
		 * Returns the external representation of the selection variant as JSON object.
		 * @return {object} The external representation of this instance as a JSON object
		 * @public
		 */
		toJSONObject : function() {
			var oExternalSelectionVariant = {
				Version : { // Version attributes are not part of the official specification, 
					Major : "1", // but could be helpful later for implementing a proper lifecycle/interoperability
					Minor : "0",
					Patch : "0"
				},
				SelectionVariantID : this._sId
			};
		
			if (this._sParameterCtxUrl) {
				oExternalSelectionVariant.ParameterContextUrl = this._sParameterCtxUrl;
			}
		
			if (this._sFilterCtxUrl) {
				oExternalSelectionVariant.FilterContextUrl = this._sFilterCtxUrl;
			}
		
			if (this._sText) {
				oExternalSelectionVariant.Text = this._sText;
			} else {
				oExternalSelectionVariant.Text = "Selection Variant with ID " + this._sId;
			}
		
			this._determineODataFilterExpression(oExternalSelectionVariant);
		
			this._serializeParameters(oExternalSelectionVariant);
			this._serializeSelectOptions(oExternalSelectionVariant);
			
			return oExternalSelectionVariant;
		},
		
		/**
		 * Serializes this instance into a JSON-formatted string.
		 * @return {string} The JSON-formatted representation of this instance in stringified format
		 * @public
		 */
		toJSONString : function() {
			return JSON.stringify(this.toJSONObject());
		},
	
		_determineODataFilterExpression : function(oExternalSelectionVariant) {
			// TODO - specification does not indicate what is expected here in detail
			oExternalSelectionVariant.ODataFilterExpression = ""; // not supported yet - it's allowed to be optional
		},
	
		_serializeParameters : function(oExternalSelectionVariant) {
		
			if (this._mParameters.length === 0) {
				return;
			}
		
			// Note: Parameters section is optional (see specification section 2.4.2.1)
			oExternalSelectionVariant.Parameters = [];
		
			jQuery.each(this._mParameters, function(sParameterName, sParameterValue) {
				var oParObject = {
					PropertyName : sParameterName,
					PropertyValue : sParameterValue
				};
				oExternalSelectionVariant.Parameters.push(oParObject);
			});
		},
	
		_serializeSelectOptions : function(oExternalSelectionVariant) {
		
			if (this._mSelectOptions.length === 0) {
				return;
			}
		
			oExternalSelectionVariant.SelectOptions = [];
		
			jQuery.each(this._mSelectOptions, function(sPropertyName, aEntries) {
				var oSelectOption = {
					PropertyName : sPropertyName,
					Ranges : aEntries
				};
			
				oExternalSelectionVariant.SelectOptions.push(oSelectOption);
			});
		},

		_parseFromString : function(sJSONString) {
			if (sJSONString === undefined) {
				throw new Error("SelectionVariant.UNABLE_TO_PARSE_INPUT");
			}
		
			if (typeof sJSONString !== "string") {
				throw new Error("SelectionVariant.INVALID_INPUT_TYPE");
			}
		
			var oInput = JSON.parse(sJSONString);
			// the input needs to be an JSON string by specification
			
			this._parseFromObject(oInput);
		}, 
		
		_parseFromObject : function(oInput) {
		
			if (oInput.SelectionVariantID === undefined) {
				// Do not throw an error, but only write a warning into the log.
				// The SelectionVariantID is mandatory according to the specification document version 1.0, 
				// but this document is not a universally valid standard.
				// It is said that the "implementation of the SmartFilterBar" may supersede the specification.
				// Thus, also allow an initial SelectionVariantID.
	//		throw new sap.ui.generic.app.navigation.service.NavError("SelectionVariant.INPUT_DOES_NOT_CONTAIN_SELECTIONVARIANT_ID");
				jQuery.sap.log.warning("SelectionVariantID is not defined");
				oInput.SelectionVariantID = "";
			}

			this.setID(oInput.SelectionVariantID);
		
			if (oInput.ParameterContextUrl !== undefined && oInput.ParameterContextUrl !== "") {
				this.setParameterContextUrl(oInput.ParameterContextUrl);
			}
		
			if (oInput.FilterContextUrl !== undefined && oInput.FilterContextUrl !== "") {
				this.setFilterContextUrl(oInput.FilterContextUrl);
			}
		
			if (oInput.Text !== undefined) {
				this.setText(oInput.Text);
			}
		
			// note that ODataFilterExpression is ignored right now - not supported yet!
		
			if (oInput.Parameters) {
				this._parseFromStringParameters(oInput.Parameters);
			}
		
			if (oInput.SelectOptions) {
				this._parseFromStringSelectOptions(oInput.SelectOptions);
			}
		},
	
		_parseFromStringParameters : function(aParameters) {
			jQuery.each(aParameters, jQuery.proxy(function(iIdx, oEntry) {
				this.addParameter(oEntry.PropertyName, oEntry.PropertyValue);
			}, this));
		},
	
		_parseFromStringSelectOptions: function(aSelectOptions) {
			jQuery.each(aSelectOptions, jQuery.proxy(function(iIdx, oSelectOption) {
			
				if (!oSelectOption.Ranges) {
					jQuery.sap.log.warning("Select Option object does not contain a Ranges entry; ignoring entry");
					return true; // "continue"
				}
			
				if (!jQuery.isArray(oSelectOption.Ranges)) {
					throw new Error("SelectionVariant.SELECT_OPTION_RANGES_NOT_ARRAY");
				}
			
				jQuery.each(oSelectOption.Ranges, jQuery.proxy(function(iIdx2, oRange) {
					this.addSelectOption(oSelectOption.PropertyName, oRange.Sign, oRange.Option, oRange.Low, oRange.High);
				}, this));
			}, this));
		}
	});

	return SelectionVariant;

});

}; // end of sap/ui/generic/app/navigation/service/SelectionVariant.js
if ( !jQuery.sap.isDeclared('sap.ui.generic.app.util.DraftUtil') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.ui.generic.app.util.DraftUtil'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('jquery.sap.global'); // unlisted dependency retained
sap.ui.define("sap/ui/generic/app/util/DraftUtil",[	"jquery.sap.global" ], function(jQuery) {
	"use strict";

	/**
	 * Constructor for generic utility for draft instance handling.
	 * @author SAP SE
	 * @version 1.50.6
	 * @since 1.30.0
	 * @alias sap.ui.generic.app.util.DraftUtil
	 * @private
	 */
	var DraftUtil = function() {

	};
	
	/**
	 * Checks if the current entity is an active instance or not.
	 * 
	 * @param {object} oEntity The given entity 
	 * @returns {boolean} <code>true</code> if the given entity is active, <code>false</code> otherwise
	 * @public
	 */
	DraftUtil.prototype.isActiveEntity = function(oEntity) {
		return oEntity.IsActiveEntity;
	};
	
	/**
	 * Checks if the current entity has a corresponding draft entity.
	 * 
	 * @param {object} oEntity The given entity 
	 * @returns {boolean} <code>true</code> if the given entity has a corresponding draft entity, <code>false</code> otherwise
	 * @public
	 */
	DraftUtil.prototype.hasDraftEntity = function(oEntity) {
		return oEntity.HasDraftEntity;
	};
	
	/**
	 * Checks if the current entity has a corresponding active entity.
	 * 
	 * @param {object} oEntity The given entity
	 * @returns {boolean} <code>true</code> if the given entity a corresponding active entity, <code>false</code> otherwise 
	 * @public
	 */
	DraftUtil.prototype.hasActiveEntity = function(oEntity) {
		return oEntity.HasActiveEntity;
	};	

	/**
	 * Frees all resources claimed during the life-time of this instance.
	 * 
	 * @private
	 */
	DraftUtil.prototype.destroy = function() {
		
	};
	
	return DraftUtil;

}, /* bExport= */true);

}; // end of sap/ui/generic/app/util/DraftUtil.js
if ( !jQuery.sap.isDeclared('sap.ui.generic.app.util.MessageUtil') ) {
jQuery.sap.declare('sap.ui.generic.app.util.MessageUtil'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.core.ValueState'); // unlisted dependency retained
jQuery.sap.require('sap.ui.model.Filter'); // unlisted dependency retained
jQuery.sap.require('sap.ui.model.FilterOperator'); // unlisted dependency retained
jQuery.sap.require('sap.m.MessageToast'); // unlisted dependency retained
jQuery.sap.require('sap.m.MessageBox'); // unlisted dependency retained
sap.ui.define("sap/ui/generic/app/util/MessageUtil",["sap/ui/core/ValueState", "sap/ui/model/Filter", "sap/ui/model/FilterOperator", "sap/m/MessageToast", "sap/m/MessageBox"],
	function (ValueState, Filter, FilterOperator, MessageToast, MessageBox) {
		"use strict";

		/**
		 * static Message Util class.
		 * @private
		 * @class This static class contains messages related to transient messages and error handling. There is a
		 * transformation from "transient" to "persistent" in the stack: in the backend messages that are only fired
		 * and returned once are called transient (opposite are state messages that are returned as long as the problem
		 * is not resolved). As the UI needs to take care that those messages are explicitly shown to the user a dialog
		 * is used, once the user closes the dialog the transient messages are removed.
		 * As there's no transient flag yet in the OData message container the target is misused, it's set to
		 * /#TRANSIENT/(target) while (target) contains the real target. The UI5 Message Parser knows this workaround,
		 * removes the /#TRANSIENT/ string, sets/calculates the target correctly and sets this message to persistent.
		 * In the message model this property is not called transient but persistent because the meaning of this
		 * property is that the messages are not automatically be removed from the Message Model (although further data/
		 * messages are read for the same entity type). The messages stay in the model as long as the client removes
		 * them. The methods in this Message connect the term "transient" with the term "persistent" - due to the fact
		 * that the purpose of them is to handle the transient messages from the backend they are still have the term
		 * transient in their names
		 * @author SAP SE
		 * @version 1.50.6
		 * @since 1.30.0
		 * @alias sap.ui.generic.app.util.MessageUtil
		 */

		var httpStatusCodes = {
			badRequest: "400",
			unauthorized: "401",
			forbidden: "403",
			notFound: "404",
			methodNotAllowed: "405",
			preconditionFailed: "428",
			internalServerError: "500",
			notImplemented: "501",
			badGateway: "502",
			serviceUnavailable: "503",
			gatewayTimeout: "504",
			httpVersionNotSupported: "505"
		};

		var operations = {
			callAction: "callAction",
			addEntry: "addEntry",
			saveEntity: "saveEntity",
			deleteEntity: "deleteEntity",
			editEntity: "editEntity",
			modifyEntity: "modifyEntity",
			activateDraftEntity: "activateDraftEntity",
			saveAndPrepareDraftEntity: "saveAndPrepareDraftEntity",
			getCollection: "getCollection"
		};
		var sMessageErrorPath;

		function fnGetTransientMessages(oResponse) {
			var aTransientMessages = [], oMessage;
			var oMessageManager = sap.ui.getCore().getMessageManager();
			var aMessages = oMessageManager.getMessageModel().getData();

			for (var i = 0; i < aMessages.length; i++) {
				oMessage = aMessages[i];
				if (oMessage.getPersistent()) {
					aTransientMessages.push(oMessage);
				}
			}

			// in future we want to return only the transient messages that are returned by the given response
			// this does not work yet due to missing core functionality
			jQuery.noop(oResponse);

			return aTransientMessages;
		}


		/**
			 * Default/example implementation for a dialog fragment provider needed for example in function <code>handleTransientMessages</code>
			 *
			 * @param {sap.ui.core.Control} oParentView The view on which the message dialog depends
			 * @param {string} [sContentDensityClass] The name of the style class
			 *
			 * @return {function} Provider function which requires two input parameters: the name of the fragment and the fragment controller.
			 *
			 * @since 1.40
			 * @private
			 */
		function createDialogFragmentProvider(oParentView, sContentDensityClass) {
			var fnDialogFragmentProvider;

			fnDialogFragmentProvider = function (sName, oFragmentController) {
				var oFragment;
				var oDialogFragmentControllerWrapper = {
					onMessageDialogClose: function () {
						oFragmentController.onMessageDialogClose();
						oFragment.destroy();
					}
				};

				oFragment = sap.ui.xmlfragment(sName, oDialogFragmentControllerWrapper);
				if (sContentDensityClass) {
					jQuery.sap.syncStyleClass(sContentDensityClass, oParentView, oFragment);
				}
				oParentView.addDependent(oParentView);
				return oFragment;
			};

			return fnDialogFragmentProvider;
		}

		/**
		 * Grouping of transient messages belonging to the same object under the same key
		 *
		 * @param {object} [oMetaModel] The used OData Metamodel 
		 *
		 * @return {object} Key value object of targets and keys
		 *
		 * @private
		 */
		function groupTransientMessages(oMetaModel) {
			var aTransientMessages = fnGetTransientMessages();
			var sEntitySet, targetPattern, regexPattern, sTransientMessageType, sMessageTarget, isValidEntitySet;
			var key = 1;
			var oGroupingData = {};
			var oGroupRank = {};
			for (var i = 0; i < aTransientMessages.length; i++) {
				sMessageTarget = aTransientMessages[i].target || "";
				sEntitySet = sMessageTarget.substring(1, sMessageTarget.indexOf('('));
				isValidEntitySet = oMetaModel.getODataEntitySet(sEntitySet);
				if (isValidEntitySet) {
					targetPattern = sEntitySet + "\\((.*?)\\)";
					regexPattern = new RegExp(targetPattern);
					sTransientMessageType = aTransientMessages[i].target.match(regexPattern);
					if (sTransientMessageType) {
						if (sTransientMessageType[0].lastIndexOf("/") > 0) {
							sTransientMessageType[0] = sTransientMessageType[0].substring(0, sTransientMessageType[0].lastIndexOf("/"));
						}
						sTransientMessageType[0] = '/' + sTransientMessageType[0];
						if (!oGroupRank[sTransientMessageType[0]]) {
							oGroupRank[sTransientMessageType[0]] = key;
							key++;
						}
					}
				}
			}
			oGroupingData['groups'] = oGroupRank;
			oGroupingData['lastKey'] = key;
			return oGroupingData;
		}

		/**
		 * With this function, all transient messages are taken over from the MessageManager and
		 * displayed. After displaying them, the transient messages are removed automatically from the MessageManager.
		 *
		 * To show the messages, a custom <code>sap.ui.xmlfragment</code> can be provided via a callback function.
		 *
		 * @param {function|map} vMessageDialogData Either a callback <code>function</code> that returns a message dialog fragment or a
		 * property bag that contains the two parameters <code>owner</code> and <code>contentDensityClass</code>
		 * @param {sap.ui.core.Control} [vMessageDialogData.owner] The owner control on which the message dialog depends
		 * @param {string} [vMessageDialogData.contentDensityClass] The density class which controls the display mode
		 * @param {string} sActionLabel A label for the action
		 *
		 * @since 1.38
		 *
		 * @experimental
		 * @public
		 */
		function handleTransientMessages(vMessageDialogData, sActionLabel) {
			var sState, sTitle, oDialog, oGroupingData, oGroupRank, oMetaModel;
			var oLibraryResourceBundle = sap.ui.getCore().getLibraryResourceBundle("sap.ui.generic.app");
			var oDialogFragmentController = {
				onMessageDialogClose: function () {
					oDialog.close();
					removeTransientMessages();
				},
				grouper: function (oGroup) {
					var sMessageGroupRank, sLastGroupRank;
					oGroupingData = groupTransientMessages(oMetaModel);
					oGroupRank = oGroupingData.groups;
					sLastGroupRank = oGroupingData.lastKey;
					var sMessageTarget = oGroup.getObject().target || "";
					if (sMessageTarget.lastIndexOf("/") > 0) {
						sMessageTarget = sMessageTarget.substring(0, sMessageTarget.lastIndexOf("/"));
					}

					if (oGroupRank[sMessageTarget]) {
						sMessageGroupRank = oGroupRank[sMessageTarget];
					} else {// For general messages assign the maximum key so that it comes at the bottom
						sMessageGroupRank = sLastGroupRank;
					}

					return sMessageGroupRank;
				},
				getGroupHeader: function (oGroup) {
					var sMessageGroupRank, sMessageTarget, oValueTitleContext, sEntitySet;
					sMessageGroupRank = oGroup.key;
					//set sMessageTarget '' for general messages
					sMessageTarget = '';
					for (var key in oGroupRank) {
						if (oGroupRank[key] == sMessageGroupRank) {
							sMessageTarget = key;
							if (sMessageErrorPath && (key == sMessageErrorPath)) {
								sMessageTarget = '';
							}
							break;
						}
					}

					sEntitySet = sMessageTarget.substring(1, sMessageTarget.indexOf('('));
					if (sEntitySet) {
						oValueTitleContext = oMetaModel.createBindingContext("com.sap.vocabularies.UI.v1.HeaderInfo/Title/Value", oMetaModel.getMetaContext('/' + sEntitySet));
					}
					var sGroupTitle = (sEntitySet == '' || (!oValueTitleContext)) ? (oLibraryResourceBundle.getText("GENERAL_TITLE")) : sap.ui.model.odata.AnnotationHelper.format(oValueTitleContext);
					var oHeader = new sap.m.GroupHeaderListItem({
						title: sGroupTitle,
						upperCase: false
					});
					oHeader.bindElement(sMessageTarget);
					return oHeader;
				},

				//Called after the list is updated. CSS classes are added to list items to add Colors based on icon type
				onUpdate: function (oContent) {
					var sMessageType;
					var oMessageListItems = oContent.getSource().getItems();
					for (var i = 0; i < oMessageListItems.length; i++) {
						if (oMessageListItems[i].getMetadata().getElementName() == "sap.m.StandardListItem") {
							sMessageType = oMessageListItems[i].getInfoState();
							switch (sMessageType) {
								case sap.ui.core.ValueState.Error:
									oMessageListItems[i].addStyleClass("sapSmartTemplatesListReportSLINegative");
									break;
								case sap.ui.core.ValueState.Warning:
									oMessageListItems[i].addStyleClass("sapSmartTemplatesListReportSLICritical");
									break;
								case sap.ui.core.ValueState.Success:
									oMessageListItems[i].addStyleClass("sapSmartTemplatesListReportSLIPositive");
									break;
								default:
									oMessageListItems[i].addStyleClass("sapSmartTemplatesListReportSLINeutral");
									break;
							}
						}
					}

				}
			};

			var aTransientMessages = fnGetTransientMessages();

			if (aTransientMessages.length === 0) {
				return false;
			} else if (aTransientMessages.length === 1 && aTransientMessages[0].type === ValueState.Success) {
				// show Message in dialog only
				MessageToast.show(aTransientMessages[0].message, {
					onClose: removeTransientMessages
				});
			} else {
				if (typeof vMessageDialogData == "function") {
					oDialog = vMessageDialogData("sap.ui.generic.app.fragments.MessageDialog", oDialogFragmentController);

				} else if (typeof vMessageDialogData == "object") {
					oDialog = createDialogFragmentProvider(vMessageDialogData.owner, vMessageDialogData.contentDensityClass)(
						"sap.ui.generic.app.fragments.MessageDialog", oDialogFragmentController);

				} else {
					//assert
					return undefined;
				}

				var oMessageModel = sap.ui.getCore().getMessageManager().getMessageModel();

				oMetaModel = oDialog.getParent().getParent().getModel().getMetaModel();

				oDialog.setModel(oMessageModel, "message");

				var oSettingModel = new sap.ui.model.json.JSONModel();
				oDialog.setModel(oSettingModel, "settings");

				var oMessageTable = oDialog.getContent()[0];

				// set close button text, don't use i18n model as the resources would then be loaded every time
				oSettingModel.setProperty("/closeButtonText", oLibraryResourceBundle.getText("DIALOG_CLOSE"));

				var oBinding = oMessageTable.getBinding("items");
				oBinding.filter(new Filter("persistent", FilterOperator.EQ, true));

				// set title according to the severity
				for (var i = 0; i < aTransientMessages.length; i++) {
					var oMessage = aTransientMessages[i];

					if (oMessage.type === sap.ui.core.MessageType.Error) {
						// Error
						sState = sap.ui.core.ValueState.Error;
						break;
					}

					if (oMessage.type === sap.ui.core.MessageType.Warning) {
						// Warning
						sState = sap.ui.core.ValueState.Warning;
						continue;
					}

					if (oMessage.type === sap.ui.core.MessageType.Information || oMessage.type === sap.ui.core.MessageType.None) {
						// information
						sState = sap.ui.core.ValueState.None;
						continue;
					}

					sState = sap.ui.core.ValueState.Success;
				}
				//If Action Name is available it will mw shown as Dialog Title.
				if (sActionLabel) {
					sTitle = sActionLabel;
				} else { //Show "Messages" as the dialog title
					sTitle = oLibraryResourceBundle.getText("DIALOG_TITLE");
				}

				oSettingModel.setProperty("/state", sState);
				oSettingModel.setProperty("/title", sTitle);
				oDialog.open();
			}
		}

		/**
		 * Remove all transient messages that are currently available in the MessageManager.
		 *
		 * @since 1.38
		 *
		 * @experimental
		 * @public
		 */
		function removeTransientMessages() {
			var oMessageManager = sap.ui.getCore().getMessageManager();
			var aTransientMessages = fnGetTransientMessages();

			if (aTransientMessages.length > 0) {
				oMessageManager.removeMessages(aTransientMessages);
			}
		}

		/**
		 * add a transient error messages to the MessageManager
		 *
		 * @param {string} sMessage Text of the message to add
		 * @param {string} sDescription Long text of the transient message added
		 * 
		 * @since 1.40
		 * @experimental
		 * @public
		 */
		function addTransientErrorMessage(sMessage, sDescription, oModel) {
			// currently still use /#TRANSIENT target, to be replaced with persistent flag
			var oTransientMessage = new sap.ui.core.message.Message({
				message: sMessage,
				description: sDescription,
				type: sap.ui.core.MessageType.Error,
				processor: oModel,
				target: '',
				persistent: true
			});
			sap.ui.getCore().getMessageManager().addMessages(oTransientMessage);
		}

		/**
		 * This function parses an error response and returns information like the status code, leading error text,
		 * description (not yet) and if already transient message exist
		 *
		 * @param {object} oError The error response object
		 *
		 * @since 1.40
		 *
		 * @experimental
		 * @public
		 */
		function parseErrorResponse(oError) {
			var oReturn;

			// BCP 1770144015
			sMessageErrorPath = oError && oError.url;
			if (sMessageErrorPath) {
				sMessageErrorPath = "/" + sMessageErrorPath.substring(0,sMessageErrorPath.indexOf(")") + 1);
			}

			var sMessage = sap.ui.getCore().getLibraryResourceBundle("sap.ui.generic.app").getText("ERROR_UNKNOWN");
			var sHttpStatusCode;

			if (oError instanceof Error) {
				// promise rejection
				if (oError.message) {
					// TODO differentiate between technical errors and business errors in case of promise rejections
					sMessage = oError.message;
				}
			} else if (oError.response) { // odata error
				if (oError.response.message) {
					// TODO differentiate between technical errors and business errors in case of promise rejections
					sMessage = oError.response.message;
				}

				// check http status code
				if (oError.response.statusCode) {
					sHttpStatusCode = oError.response.statusCode;
				}

				// check for content type of response - in case of a runtime error on the backend it is xml
				if (oError.response.headers) {
					for (var sHeader in oError.response.headers) {
						if (sHeader.toLowerCase() === "content-type") {
							var sHeaderValue = oError.response.headers[sHeader];
							if (sHeaderValue.toLowerCase().indexOf("application/json") === 0) {
								if (oError.response.responseText) {
									var oODataError = JSON.parse(oError.response.responseText);
									if (oODataError && oODataError.error && oODataError.error.message && oODataError.error.message.value) {
										sMessage = oODataError.error.message.value;
									}
								}
							} else if (oError.message) {
								sMessage = oError.message;
							}
							break;
						} // if content-type is not application/json it is usually an internal server error (status code 500)
					}
				}
			}

			var aTransientMessages = fnGetTransientMessages(oError);

			oReturn = {
				httpStatusCode: sHttpStatusCode,
				messageText: sMessage,
				description: null, // TODO: get description
				containsTransientMessage: (aTransientMessages.length === 0) ? false : true
			};

			return oReturn;
		}

		return {
			operations: operations,
			httpStatusCodes: httpStatusCodes,
			handleTransientMessages: handleTransientMessages,
			removeTransientMessages: removeTransientMessages,
			addTransientErrorMessage: addTransientErrorMessage,
			parseErrorResponse: parseErrorResponse
		};
	}, true);
}; // end of sap/ui/generic/app/util/MessageUtil.js
if ( !jQuery.sap.isDeclared('sap.ui.generic.app.util.ModelUtil') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.ui.generic.app.util.ModelUtil'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('jquery.sap.global'); // unlisted dependency retained
sap.ui.define("sap/ui/generic/app/util/ModelUtil",[	"jquery.sap.global" ], function(jQuery) {
	"use strict";

	/**
	 * Constructor for generic utility for model access.
	 * 
	 * @private
	 * @class 
	 * @classdesc
	 * Generic utility for model access.
	 * @author SAP SE
	 * @version 1.50.6
	 * @since 1.30.0
	 * @alias sap.ui.generic.app.util.ModelUtil
	 * @param {sap.ui.model.odata.ODataModel} oModel The OData model currently used
	 */
	var ModelUtil = function(oModel) {
		this._oModel = oModel;
	};
	
	/**
	 * Converts response data into a binding context.
	 * 
	 * @param {object} oResponseData Response data.
	 * @returns {sap.ui.model.Context} Binding context, can be <code>null</code>.
	 * @public
	 */
	ModelUtil.prototype.getContextFromResponse = function(oResponseData) {
		var sPath = "/" + this._oModel.getKey(oResponseData);
		return this._oModel.getContext(sPath);
	};
	
	/**
	 * Calculates the name of an OData entity set from the given binding context.
	 * 
	 * @param {sap.ui.model.Context} oContext The given binding context
	 * @returns {string} The name of the entity set, can be <code>null</code>
	 * @throws {Error} If no context is handed over as input parameter
	 * @public
	 */
	ModelUtil.getEntitySetFromContext = function(oContext) {
		var sPath, sEntitySet;

		if (!oContext) {
			throw new Error("No context");
		}
		
		if (oContext && oContext.getPath) {
			sPath = oContext.getPath().split("(")[0];
			sEntitySet = sPath.substring(1);
		}

		if (sEntitySet == null) {
			return null;
		} else {
			return oContext.getModel().getMetaModel().getODataEntitySet(sEntitySet) 
				&& oContext.getModel().getMetaModel().getODataEntitySet(sEntitySet).name;
		}
	};
	
	/**
	 * Checks for client-side messages, e.g. validation errors.
	 * 
	 * @returns {boolean} <code>true</code>, if client-side messages exist, <code>false</code> otherwise
	 * @public
	 */
	ModelUtil.prototype.hasClientMessages = function() {
		var oManager, oModel, aMessages, oMessage, i = 0, len = 0;
		
		oManager = sap.ui.getCore().getMessageManager();
		oModel = oManager.getMessageModel();
		aMessages = oModel.getData();
		
		if (aMessages) {
			len = aMessages.length;
		}
		
		for (i = 0; i < len; i++) {
			oMessage = aMessages[i];
			
			if (oMessage.processor.getMetadata()._sClassName === "sap.ui.core.message.ControlMessageProcessor") {
				return true;
			}
		}
		
		return false;
	};
	
	/**
	 * Frees all resources claimed during the life-time of this instance.
	 * 
	 * @public
	 */
	ModelUtil.prototype.destroy = function() {
		this._oModel = null;
	};
	
	return ModelUtil;

}, /* bExport= */true);

}; // end of sap/ui/generic/app/util/ModelUtil.js
if ( !jQuery.sap.isDeclared('sap.ui.generic.app.util.Queue') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.ui.generic.app.util.Queue'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('jquery.sap.global'); // unlisted dependency retained
sap.ui.define("sap/ui/generic/app/util/Queue",[	"jquery.sap.global" ], function(jQuery) {
	"use strict";

	/* global Promise */

	/**
	 * @class
	 * @classdesc Asynchronous queue for JavaScript functions.
	 *
	 * Creates a new queue instance.
	 *
	 * @param {int} [iMaxLength] Maximum queue length
	 *
	 * @alias sap.ui.generic.app.util.Queue
	 * @private
	 *
	 * @since 1.30.0
	 * @author SAP SE
	 * @version 1.50.6
	 */
	var Queue = function(iMaxLength) {
		this._iMaxLength = iMaxLength;
		this._aQueue = [];
		this._aEventHandlerRegistry = [];
	};

	/* Internal functions for attaching, detaching and firing events */
	Queue.prototype._attachEvent = function(sEvent, fnFunction) {
		if (typeof fnFunction !== "function") {
			throw new Error("Event handler must be a function");
		}
		this._aEventHandlerRegistry.push({
			event: sEvent,
			handler: fnFunction
		});
	};
	Queue.prototype._detachEvent = function(sEvent, fnFunction) {
		for (var i = this._aEventHandlerRegistry.length; i--;) {
			if (this._aEventHandlerRegistry[i].handler === fnFunction && this._aEventHandlerRegistry[i].event === sEvent) {
				this._aEventHandlerRegistry.splice(i, 1);
			}
		}
	};
	Queue.prototype._fireEvent = function(sEvent, oEvent) {
		for (var i = 0; i < this._aEventHandlerRegistry.length; i++) {
			if (this._aEventHandlerRegistry[i].event === sEvent) {
				this._aEventHandlerRegistry[i].handler(oEvent);
			}
		}
	};

	/**
	 * Removes the first item from the queue and executes the next item on the queue.
	 *
	 * @private
	 */
	Queue.prototype._execNext = function() {
		var oNext, that = this;

		// the method  is invoked by the OData model at a point in time, when the OData model does not have
		// cleaned up its internal data structures, especially the one to track pending changes.
		// therefore place a timeout to make sure that when the check for the next request is invoked in our queue
		// that the internal data structures are up to date.
		setTimeout(function() {
			that._aQueue.shift();
			oNext = that._aQueue[0];

			if (oNext) {
				that._exec(oNext);
			} else {
				that._fireEvent('onQueueCompleted');
			}
		});
	};

	/**
	 * Executes the given item and defers execution of the next item, if it exists.
	 *
	 * @param {object} oItem The item to be executed
	 * @private
	 */
	Queue.prototype._exec = function(oItem) {
		var that = this, fSuccess = function() {
			that._execNext();
		};

		this._fireEvent('beforeQueueItemProcess', oItem.eventParameters);

		oItem.jqdeferred.resolve();
		oItem.wait.then(function() {
			// wait until other handlers have executed.
			oItem.wait.then(fSuccess);
		}, jQuery.proxy(that._cancel, that));
	};

	/**
	 * Enqueues a function. If the queue has reached its maximum capacity, the function is rejected.
	 *
	 * @param {function} fFunc The function to be enqueued
	 * @returns {Promise} A <code>Promise</code> for asynchronous execution of the enqueued item
	 * @public
	 */
	Queue.prototype.enqueue = function(fFunc, mEventParameters) {
		var oItem = {
			fn: fFunc,
			eventParameters : mEventParameters
		};

		// build up the item:
		// use jQuery.Deferred to create a pending promise.
		oItem.jqdeferred = jQuery.Deferred();
		oItem.defer = new Promise(function (fulfill, reject) {
			oItem.jqdeferred.then(fulfill, reject);
		});

		// enable consumers to chain to the executed function:
		// function also returns a promise:
		// so implicitly consumers chain to the resolved or rejected promise
		// returned by the function.
		oItem.wait = oItem.defer.then(fFunc);

		if (!(this._iMaxLength === undefined) && this._aQueue.length >= this._iMaxLength) {
			oItem.jqdeferred.reject(new Error("Queue overflow: " + this._aQueue.length));
		} else {
			this._aQueue.push(oItem);

			// if only one item is on the queue, execute it immediately.
			if (this._aQueue.length === 1) {
				this._exec(oItem);
			}
		}

		return oItem.wait.then();
	};

	/**
	 * Cancels the execution of the current queue by rejecting each enqueued item. Additionally all existing items are removed from the queue.
	 *
	 * @private
	 */
	Queue.prototype._cancel = function() {
		var oItem, i, len = this._aQueue.length;

		for (i = 0; i < len; i++) {
			oItem = this._aQueue[i];
			oItem.jqdeferred.reject(new Error("Queue cancellation"));
		}

		this._fireEvent('onQueueFailed');

		this._aQueue = [];
	};

	/**
	 * Frees all resources claimed during the life-time of this instance.
	 *
	 * @public
	 */
	Queue.prototype.destroy = function() {
		this._aQueue = [];
	};

	return Queue;

}, true);

}; // end of sap/ui/generic/app/util/Queue.js
if ( !jQuery.sap.isDeclared('sap.ui.generic.app.navigation.service.NavigationHandler') ) {
/*!
 * @copyright@
 */
jQuery.sap.declare('sap.ui.generic.app.navigation.service.NavigationHandler'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.base.Object'); // unlisted dependency retained
jQuery.sap.require('sap.ui.model.resource.ResourceModel'); // unlisted dependency retained
jQuery.sap.require('sap.ui.core.UIComponent'); // unlisted dependency retained
jQuery.sap.require('sap.ui.core.routing.HashChanger'); // unlisted dependency retained
jQuery.sap.require('jquery.sap.global'); // unlisted dependency retained
sap.ui.define("sap/ui/generic/app/navigation/service/NavigationHandler",["./NavError","./SelectionVariant",  "sap/ui/generic/app/library", "sap/ui/base/Object", "sap/ui/model/resource/ResourceModel", "sap/ui/core/UIComponent", "sap/ui/core/routing/HashChanger", "jquery.sap.global"],
	function(Error, SelectionVariant, NavLibrary, BaseObject, ResourceModel, UIComponent, HashChanger, jQuery) {
	"use strict";

	/**
	 * @class
	 * Creates a new NavigationHandler class by providing the required environment.
	 *
	 * <b>Note:</b> This class requires that the UShell Navigation Service API CrossApplicationNavigation is available and initialized.
	 * @extends sap.ui.base.Object
	 * @constructor
	 * @public
	 * @param {object} oController UI5 controller that contains a router and a component; typically the main controller of your application,
	 * for example, a subclass of the sap.ca.scfld.md.controller.BaseFullscreenController if scaffolding is used
	 * @param {string} [sParamHandlingMode=SelVarWins] Mode to be used to handle conflicts when merging URL parameters and the SelectionVariant class, see {@link sap.ui.generic.app.navigation.service.ParamHandlingMode}
	 * @throws An instance of {@link sap.ui.generic.app.navigation.service.NavError} in case of input errors. Valid error codes are:
	 * <table>
	 * <tr><th align="left">Error code</th><th align="left">Description</th></tr>
	 * <tr><td>NavigationHandler.INVALID_INPUT</td><td>Indicates that the input parameter is invalid</td></tr>
	 * </table>
	 * @alias sap.ui.generic.app.navigation.service.NavigationHandler
	 */
	var NavigationHandler = BaseObject.extend("sap.ui.generic.app.navigation.service.NavigationHandler", /** @lends sap.ui.generic.app.navigation.service.NavigationHandler */ {
		metadata : {
			publicMethods : ["navigate","parseNavigation","storeInnerAppState","openSmartLinkPopover","mixAttributesAndSelectionVariant"]
		},

		constructor: function(oController, sParamHandlingMode){

			if (!oController) {
				throw new Error("NavigationHandler.INVALID_INPUT");
			}

			if (oController instanceof UIComponent) {
				this.oRouter = oController.getRouter();
				this.oComponent = oController;

			} else {

				if (typeof oController.getOwnerComponent !== "function") {
					throw new Error("NavigationHandler.INVALID_INPUT");
				}

				this.oRouter = this._getRouter(oController);
				this.oComponent = oController.getOwnerComponent();
			}

			//special handling for SmartTemplates
			if (this.oComponent && this.oComponent.getAppComponent) {
				this.oComponent = this.oComponent.getAppComponent();
			}

			if (typeof this.oRouter === "undefined" || typeof this.oComponent === "undefined" || typeof this.oComponent.getComponentData !== "function" ) {
				throw new Error("NavigationHandler.INVALID_INPUT");
			}

			try {
				this.oCrossAppNavService = this._getAppNavigationService();
			} catch (ex) {
				jQuery.sap.log.error("NavigationHandler: UShell service API for CrossApplicationNavigation is not available.");
			}
			this.IAPP_STATE = "sap-iapp-state";
			this.sDefaultedParamProp = "sap-ushell-defaultedParameterNames";
			this.sSAPSystemProp = "sap-system";

			//list of technical parameters
			this._aTechnicalParamaters = ["hcpApplicationId" ];


			this._oLastSavedInnerAppData = { sAppStateKey: "" , oAppData: {}, iCacheHit: 0, iCacheMiss: 0 };

			/*
			 * There exists a generation of "old" sap-iapp-states which are based on the following
			 * URL schema:
			 *
			 * #SemObj-action&/route/sap-iapp-state=ABC12345678
			 *
			 * The new URL schema is:
			 *
			 * #SemObj-action&/route?sap-iapp-state=ABC12345678
			 *
			 * (mind the difference between / and ? above), i.e. the sap-iapp-state has become a
			 * parameter of the query parameter section in the AppHash string.
			 * Yet, this tool shall be able to deal even with old sap-iapp-states. Therefore, we
			 * use two Regular Expressions (rIAppStateOld and rIAppStateOldAtStart) as defined below
			 * to scan for these old variants.
			 * The new variant is being scanned using rIAppStateNew as Regular Expression search string.
			 *
			 * Compatibility is centrally ensured by the two methods
			 *    _getInnerAppStateKey
			 * and
			 *    _replaceInnerAppStateKey
			 * (see below). Never use these RegExp in a method on your own, as it typically indicates that
			 * you will fall into the compatibility trap!
			 */
			// Warning! Do not use GLOBAL flags here; RegExp in GLOBAL mode store the lastIndex value
			// Therefore, repeated calls to the RegExp will then only start beginning with that stored
			// lastIndex. Thus, multiple calls therefore could yield strange results.
			// Moreover, there shall only be exactly one IAPP_STATE per RegExp in an AppHash.
			// Therefore, GLOBAL search should be superfluous.
			this._rIAppStateOld = new RegExp("/" + this.IAPP_STATE + "=([^/?]+)");
			this._rIAppStateOldAtStart = new RegExp("^" + this.IAPP_STATE + "=([^/?]+)");

			this._rIAppStateNew = new RegExp("[\?&]" + this.IAPP_STATE + "=([^&]+)");
			/*
			 * Regular Expression in words:
			 * Search for something that either stars with ? or &, followed by the term
			 * "sap-iapp-state". That one is followed by an equal sign (=).
			 * The stuff that is after the equal sign forms the first regexp group.
			 * This group consists of at least one (or arbitrary many) characters, as long
			 * as it is not an ampersand sign (&).
			 * Characters after such an ampersand would be ignored and do not belong to the group.
			 * Alternatively, the string also may end.
			 */

			if (sParamHandlingMode === sap.ui.generic.app.navigation.service.ParamHandlingMode.URLParamWins || sParamHandlingMode === sap.ui.generic.app.navigation.service.ParamHandlingMode.InsertInSelOpt) {
				this.sParamHandlingMode = sParamHandlingMode;
			} else {
				this.sParamHandlingMode = sap.ui.generic.app.navigation.service.ParamHandlingMode.SelVarWins; //default
			}
		},

		/**
		 * Retrieves the shell navigation service.
		 * @returns {object} the Navigation service
		 * @private
		 */
		_getAppNavigationService : function() {
			return sap.ushell.Container.getService("CrossApplicationNavigation");
		},


		/**
		 * Retrieves the reference to the router object for navigation for this given Controller
		 * @param {object} oController the reference to the Controller for which the Router instance shall be determined.
		 * @returns {object} the Router for the given Controller
		 * @private
		 */
		_getRouter : function(oController) {
			return UIComponent.getRouterFor(oController);
		},

		/**
		 * Triggers a cross-app navigation after saving the inner and the cross-app states.
		 * @param {string} sSemanticObject Name of the semantic object of the target app
		 * @param {string} sActionName Name of the action of the target app
		 * @param {object | string } [vNavigationParameters] Navigation parameters as an object with key/value pairs or as a stringified JSON object
		 * @param {object} [oInnerAppData] Object for storing current state of the app
		 * @param {string} [oInnerAppData.selectionVariant] Stringified JSON object as returned, for example, from getDataSuiteFormat() of the SmartFilterBar control
		 * @param {string} [oInnerAppData.tableVariantId] ID of the SmartTable variant
		 * @param {object} [oInnerAppData.customData] Object that can be used to store arbitrary data
		 * @param {object} [mInnerAppData.presentationVariant] Object containing the current ui state of the app
		 * @param {function} [fnOnError] Callback that is called if an error occurs during navigation <br>
		 * <b>Parameters:</b>
		 * <table>
		 * <tr><td align="center">{object}</td><td><b>oError</b></td><td>Error object (instance of {@link sap.ui.generic.app.navigation.service.NavError}) that describes
		 * which kind of error occurred</td>
		 * <tr><td align="center">{string}</td><td><b>oError.errorCode</b></td><td>Code to identify the error</td>
		 * <tr><td align="center">{string}</td><td><b>oError.type</b></td><td>Severity of the error (info/warning/error)</td>
		 * <tr><td align="center">{array}</td><td><b>oError.params</b></td><td>An array of objects (typically strings) that describe additional value parameters
		 * required for generating the message</td>
		 * </table>
		 * @public
		 * @example
		 * <code>
		 * var oNavigationHandler = new sap.ui.generic.app.navigation.service.NavigationHandler(oController);
		 * var sSemanticObject = "SalesOrder";
		 * var sActionName = "create";
		 *
		 * //simple parameters as Object
		 * var vNavigationParameters = {
		 * 		CompanyCode : "0001",
		 * 		Customer : "C0001"
		 * };
		 *
		 * //or as selection variant
		 * var oSelectionVariant = new sap.ui.generic.app.navigation.service.SelectionVariant();
		 * oSelectionVariant.addSelectOption("CompanyCode", "I", "EQ", "0001");
		 * oSelectionVariant.addSelectOption("Customer", "I", "EQ", "C0001");
		 * vNavigationParameters = oSelectionVariant.toJSONString();
		 *
		 * //or directly from SmartFilterBar
		 * vNavigationParameters = oSmartFilterBar.getDataSuiteFormat();
		 *
		 * //app state for back navigation
		 * var oInnerAppData = {
		 * 		selectionVariant : oSmartFilterBar.getDataSuiteFormat(),
		 * 		tableVariantId : oSmartTable.getCurrentVariantId(),
		 * 		customData : oMyCustomData
		 * };
		 *
		 * // callback function in case of errors
		 * var fnOnError = function(oError){
		 * 		var oi18n = oController.getView().getModel("i18n").getResourceBundle();
		 * 		oError.setUIText({oi18n : oi18n, sTextKey : "OUTBOUND_NAV_ERROR"});
		 * 		oError.showMessageBox();
		 * };
		 *
		 * oNavigationHandler.navigate(sSemanticObject, sActionName, vNavigationParameters, oInnerAppData, fnOnError);
		 * </code>
		 */
		navigate : function(sSemanticObject, sActionName, vNavigationParameters, oInnerAppData, fnOnError) {

		var sSelectionVariant, mParameters, oObj = {}, oPresentationVariant = null;

			if (oInnerAppData && oInnerAppData.presentationVariant) {
				oPresentationVariant = oInnerAppData.presentationVariant;
			}

			//for navigation we need URL parameters (legacy navigation) and sap-xapp-state, therefore we need to create the missing one from the passed one
			if (typeof vNavigationParameters === "string") {
				sSelectionVariant = vNavigationParameters;
				mParameters = this._getURLParametersFromSelectionVariant(sSelectionVariant);
			} else if (typeof vNavigationParameters === "object") {
				mParameters = vNavigationParameters;
				var oEnrichedSelVar = this._splitInboundNavigationParameters(new SelectionVariant(), mParameters, []).oNavigationSelVar;
				sSelectionVariant = oEnrichedSelVar.toJSONString();
			} else {
				throw new Error("NavigationHandler.INVALID_INPUT");
			}

			var oNavHandler = this;
			var oNavArguments = {
					target: {
						semanticObject: sSemanticObject,
						action: sActionName
					},
					params: mParameters || {}
			};
			var oSupportedPromise = oNavHandler.oCrossAppNavService.isNavigationSupported([oNavArguments], oNavHandler.oComponent);
			oSupportedPromise.done(function(oTargets){
				if (oTargets[0].supported){
					var oStorePromise = oNavHandler.storeInnerAppState(oInnerAppData);
					oStorePromise.done(function(){
						var fnOnContainerSave = function(sAppStateKey){
							//set the app state key in addition to the navigation arguments
							oNavArguments.appStateKey = sAppStateKey;
							// Remark:
							// The Cross App Service takes care of encoding parameter keys and values. Example:
							// mParams = { "$@%" : "&/=" } results in the URL parameter %2524%2540%2525=%2526%252F%253D
							// Note the double encoding, this is correct.

							// toExternal sets sap-xapp-state in the URL if appStateKey is provided in oNavArguments
							oNavHandler.oCrossAppNavService.toExternal(oNavArguments, oNavHandler.oComponent); //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OUT
						};

						oObj.selectionVariant = sSelectionVariant;
						if (oPresentationVariant) {
							oObj.presentationVariant = oPresentationVariant;
						}
						oNavHandler._saveAppState(oObj, fnOnContainerSave, fnOnError);
					});

					if (fnOnError) {
						oStorePromise.fail(function(oError){
							fnOnError(oError);
						});
					}

				} else {
					// intent is not supported
					if (fnOnError) {
						var oError = new Error("NavigationHandler.isIntentSupported.notSupported");
						fnOnError(oError);
					}
				}
			});

			if (fnOnError) {
				oSupportedPromise.fail(function(){
					// technical error: could not determine if intent is supported
					var oError = oNavHandler._createTechnicalError("NavigationHandler.isIntentSupported.failed");
					fnOnError(oError);
				});
			}
		},

		/**
		 * Parses the incoming URL and returns a Promise. If this method detects a back navigation, the inner app state is returned
		 * in the resolved Promise. Otherwise startup parameters will be merged into the app state provided by cross app navigation, and a combined
		 * app state will be returned. The conflict resolution can be influenced with sParamHandlingMode defined in the constructor.
		 * @returns {object} A Promise object to monitor when all the actions of the function have been executed. If the execution is successful, the extracted app state,
		 * the startup parameters, and the type of navigation are returned, see also the example above. The app state is an object that contains
		 * the following information:
		 * <ul>
		 * <li><code>oAppData.oSelectionVariant</code>: An instance of {@link sap.ui.generic.app.navigation.service.SelectionVariant} containing only
		 * parameters/select options that are related to navigation</li>
		 * <li><code>oAppData.selectionVariant</code>: The navigation-related selection variant as a JSON-formatted string</li>
		 * <li><code>oAppData.oDefaultedSelectionVariant</code>: An instance of {@link sap.ui.generic.app.navigation.service.SelectionVariant} containing
		 * only the parameters/select options that are set by user default data</li>
		 * <li><code>oAppData.bNavSelVarHasDefaultsOnly</code>: A Boolean flag that indicates whether only defaulted parameters and
		 * no navigation parameters are present (<b>Note:</b> If no navigation parameters are available, bNavSelVarHasDefaultsOnly
		 * is<code>true</code>, even also no defaulted parameters may be available)</li>
		 * </ul>
		 * If the navigation-related selection variant is empty, it is replaced by a copy of the defaulted selection variant.<br>
		 * The navigation type is an enumeration type of type {@link sap.ui.generic.app.navigation.service.NavType} (possible values are initial,
		 * URLParams, xAppState, and iAppState).<br>
		 * <b>Note:</b> If the navigation type is {@link sap.ui.generic.app.navigation.service.NavType.iAppState} oAppData has two additional properties
		 * <ul>
		 * <li><code>oAppData.tableVariantId</code></li>
		 * <li><code>oAppData.customData</code></li>
		 * </ul>
		 * which return the inner app data as stored in {@link #.navigate navigate} or {@link #.storeInnerAppState storeInnerAppState}.
		 * <code>oAppData.oDefaultedSelectionVariant</code> is an empty selection variant and <code>oAppData.bNavSelVarHasDefaultsOnly</code>
		 * is <code>false</code> in this case.<br>
		 * <b>Note:</b> If the navigation type is {@link sap.ui.generic.app.navigation.service.NavType.initial} oAppData is an empty object!<br>
		 * If an error occurs, an error object of type {@link sap.ui.generic.app.navigation.service.NavError}, URL parameters (if available) and the type of
		 * navigation are returned.
		 * @public
		 * @example
		 * <code>
		 * var oNavigationHandler = new sap.ui.generic.app.navigation.service.NavigationHandler(oController);
		 * var oParseNavigationPromise = oNavigationHandler.parseNavigation();
		 *
		 * oParseNavigationPromise.done(function(oAppData, oStartupParameters, sNavType){
		 * 		oSmartFilterBar.setDataSuiteFormat(oAppData.selectionVariant);
		 * 		// oAppData.oSelectionVariant can be used to manipulate the selection variant
		 * 		// oAppData.oDefaultedSelectionVariant contains the parameters which are set by user defaults
		 * 		// oAppData.bNavSelVarHasDefaultsOnly indicates whether only defaulted parameters and no navigation parameters are present
		 * });
		 * oParseNavigationPromise.fail(function(oError, oURLParameters, sNavType){
		 * 		// if e.g. the xapp state could not be loaded, nevertheless there may be URL parameters available
		 * 		//some error handling
		 * });
		 * </code>
		 */
		parseNavigation: function(){

			var sAppHash = HashChanger.getInstance().getHash();
			/* use .getHash() here instead of .getAppHash() to also be able dealing with
			 * environments where only SAPUI5 is loaded and the UShell is not initialized properly.
			 */
			var sIAppState = this._getInnerAppStateKey(sAppHash);

			var oComponentData = this.oComponent.getComponentData();
			/*
			 * There are some race conditions where the oComponentData may not be set,
			 * for example in case the UShell was not initialized properly.
			 * To make sure that we do not dump here with an exception, we
			 * take this special error handling behavior:
			 */
			if (oComponentData === undefined) {
				jQuery.sap.log.warning("The navigation Component's data was not set properly; assuming instead that no parameters are provided.");
				oComponentData = {};
			}

			// Remark:
			// The startup parameters are already decoded. Example:
			// The original URL parameter %2524%2540%2525=%2526%252F%253D results in oStartupParameters = { "$@%" : "&/=" }
			// Note the double encoding in the URL, this is correct. An URL parameter like xyz=%25 causes an "URI malformed" error.
			// If the decoded value should be e.g. "%25", the parameter in the URL needs to be: xyz=%252525
			var oStartupParameters = oComponentData.startupParameters;

			var aDefaultedParameters = [];
			if (oStartupParameters && oStartupParameters[this.sDefaultedParamProp] && oStartupParameters[this.sDefaultedParamProp].length > 0) {
				aDefaultedParameters = JSON.parse(oStartupParameters[this.sDefaultedParamProp][0]);
			}

			var oMyDeferred = jQuery.Deferred();
			var oNavHandler = this;

			if (sIAppState) {
				// inner app state is available in the AppHash (back navigation); extract the parameter value
				this._loadAppState(sIAppState,oMyDeferred);

			} else {

				// no back navigation
				var bIsXappStateNavigation = oComponentData["sap-xapp-state"] !== undefined;
				if (bIsXappStateNavigation) {
					// inner app state was not found in the AppHash, but xapp state => try to read the xapp state
					var oStartupPromise = this.oCrossAppNavService.getStartupAppState(this.oComponent);

					oStartupPromise.done(
						function(oAppState) {
							//get app state from sap-xapp-state,
							//create a copy, not only a reference, because we want to modify the object
							var oAppStateData = oAppState.getData();
							if (oAppStateData){
								try {
									oAppStateData = JSON.parse(JSON.stringify(oAppStateData));
								} catch (x) {
									var oError = oNavHandler._createTechnicalError("NavigationHandler.AppStateData.parseError");
									oMyDeferred.reject(oError, oStartupParameters, sap.ui.generic.app.navigation.service.NavType.xAppState);
									return oMyDeferred.promise();
								}
							}

							if (oAppStateData) {
									var oSelVar = new SelectionVariant(oAppStateData.selectionVariant);

									var oSelVars = oNavHandler._splitInboundNavigationParameters(oSelVar, oStartupParameters, aDefaultedParameters);
									oAppStateData.selectionVariant = oSelVars.oNavigationSelVar.toJSONString();
									oAppStateData.oSelectionVariant = oSelVars.oNavigationSelVar;
									oAppStateData.oDefaultedSelectionVariant = oSelVars.oDefaultedSelVar;
									oAppStateData.bNavSelVarHasDefaultsOnly = oSelVars.bNavSelVarHasDefaultsOnly;
									oMyDeferred.resolve(oAppStateData, oStartupParameters, sap.ui.generic.app.navigation.service.NavType.xAppState);
							} else {
									// sap-xapp-state navigation, but ID has already expired, but URL parameters available
									oError = oNavHandler._createTechnicalError("NavigationHandler.getDataFromAppState.failed");
									oMyDeferred.reject(oError, oStartupParameters || {}, sap.ui.generic.app.navigation.service.NavType.xAppState);
							}
						}
					);
					oStartupPromise.fail(function(){
						var oError = oNavHandler._createTechnicalError("NavigationHandler.getStartupState.failed");
						oMyDeferred.reject(oError, {}, sap.ui.generic.app.navigation.service.NavType.xAppState);
						}
					);

				} else {
					// no sap-xapp-state
					if (oStartupParameters) {
						// standard URL navigation
						var oSelVars = oNavHandler._splitInboundNavigationParameters(new SelectionVariant(), oStartupParameters, aDefaultedParameters);
						if (oSelVars.oNavigationSelVar.isEmpty() && oSelVars.oDefaultedSelVar.isEmpty()){
							// Startup parameters contain only technical parameters (SAP system) which were filtered out.
							// oNavigationSelVar and oDefaultedSelVar are empty.
							// Thus, consider this type of navigation as an initial navigation.
							oMyDeferred.resolve( {}, oStartupParameters, sap.ui.generic.app.navigation.service.NavType.initial);
						} else {
							var oAppStateData = {};
							oAppStateData.selectionVariant = oSelVars.oNavigationSelVar.toJSONString();
							oAppStateData.oSelectionVariant = oSelVars.oNavigationSelVar;
							oAppStateData.oDefaultedSelectionVariant = oSelVars.oDefaultedSelVar;
							oAppStateData.bNavSelVarHasDefaultsOnly = oSelVars.bNavSelVarHasDefaultsOnly;
							oMyDeferred.resolve(oAppStateData, oStartupParameters, sap.ui.generic.app.navigation.service.NavType.URLParams);
						}
					} else {
						// initial navigation
						oMyDeferred.resolve( {}, {}, sap.ui.generic.app.navigation.service.NavType.initial);
					}
				}
			}

			return oMyDeferred.promise();
		},

		/**
		 * Sets the application specific technical parameters. Technical parameters will not be added to the selection variant passed to the application.
		 * As a default the following values are considered as technical parameters:
		 * <ul>
		 * <li><code>sap-system</code></li>
		 * <li><code>sap-ushell-defaultedParameterNames</code></li>
		 * <li><code>"hcpApplicationId"</code></li>
		 * </ul>
		 * @param {array} aTechnicalParameters list of parameter names to be considered as technical parameters. <code>null</code> or <code>undefined</code> may be used to reset the complete list.
		 * @public
		 */
		setTechnicalParameters : function(aTechnicalParameters) {

			if (!aTechnicalParameters) {
				aTechnicalParameters = [];
			}

			if (!jQuery.isArray(aTechnicalParameters)) {
				jQuery.sap.log.error("NavigationHandler: parameter incorrect, array of strings expected");
				throw new Error("NavigationHandler.INVALID_INPUT");
			}

			this._aTechnicalParamaters = aTechnicalParameters;
		},

		/**
		 * Gets the application specific technical parameters. Technical parameters will not be added to the selection variant passed to the application.
		 * As a default the following values are considered as technical parameters:
		 * <ul>
		 * <li><code>sap-system</code></li>
		 * <li><code>sap-ushell-defaultedParameterNames</code></li>
		 * <li><code>"hcpApplicationId"</code></li>
		 * </ul>
		 * @returns {array} Containing the technical parameters.
		 * @public
		 */
		getTechnicalParameters : function() {
			return this._aTechnicalParamaters.concat([]);
		},

		/**
		 * Checks if the passed parameter is considered as technical parameter.
		 * @param {string} sParameterName Name of a request parameter, considered as technical parameter.
		 * @returns {boolean} indicates if the parameter is considered as technical parameter or not.
		 * @private
		 */
		_isTechnicalParameter : function(sParameterName) {

			if (sParameterName) {
				if  (sParameterName.toLowerCase().indexOf("sap-") === 0) {
					return true;
				} else if (this._aTechnicalParamaters.indexOf(sParameterName) >= 0) {
					return true;
				}
			}

			return false;
		},

		/**
		 * Splits the parameters provided during inbound navigation and separates the contextual information
		 * between defaulted parameter values and navigation parameters
		 * @param {object} oSelectionVariant Instance of {@link sap.ui.generic.app.navigation.service.SelectionVariant} containing
		 * navigation data of the app
		 * @param {object} oStartupParameters Object containing startup parameters of the app (derived from the component)
		 * @param {array} aDefaultedParameters Array containing defaulted parameter names
		 *
		 * @returns {object} Object containing two SelectionVariants, one for navigation (oNavigationSelVar) and one for
		 * defaulted startup parameters (oDefaultedSelVar), and a flag (bNavSelVarHasDefaultsOnly) indicating whether all
		 * parameters were defaulted.
		 *
		 * The function is handed two objects containing parameters (names and their corresponding values),
		 * oSelectionVariant and oStartupParameters. A parameter could be stored in just one of these two
		 * objects or in both of them simultaneously. Because of the latter case a parameter could be associated
		 * with conflicting values and it is the job of this function to resolve any such conflict.
		 *
		 * Parameters are assigned to the two returned SelectionVariants, oNavigationSelVar and oDefaultedSelVar, as
		 * follows:
		 *
		 *                    | parameter NOT in  | parameter in
		 *                    | oSelectionVariant | oSelectionVariant
		 * ---------------------------------------|------------------
		 * parameter NOT in   | nothing to do     | Add parameter
		 * oStartupParameters | here              | (see below)
		 * ----------------------------------------------------------
		 * parameter in       | Add parameter     | Conflict resolution
		 * oStartupParameters | (see below)       | (see below)
		 *
		 * Add parameter:
		 *     if parameter in aDefaultedParameters:
		 *         add parameter to oDefaultedSelVar
		 *     else:
		 *         add parameter to oNavigationSelVar
		 *
		 * Conflict resolution:
		 *     if parameter in aDefaultedParameters:
		 *         add parameter value from oSelectionVariant to oNavigationSelVar
		 *         add parameter value from oStartupParameters to oDefaultedSelVar
		 *         Note: This case only occurs in UI5 1.32. In later versions UShell stores any defaulted parameter
		 *         either in oSelectionVariant or oStartupParameters but never simultaneously in both.
		 *     else:
		 *         Choose 1 of the following options based on given handling mode (this.sParamHandlingMode).
		 *              -> add parameter value from oStartupParameters to oNavigationSelVar
		 *|             -> add parameter value from oAppState.selectionVariant to oNavigationSelVar
		 *              -> add both parameter values to navigationSelVar
		 *
		 * If navigationSelVar is still empty at the end of execution, navigationSelVar is replaced by a copy of
		 * oDefaultedSelVar and the flag bNavSelVarHasDefaultsOnly is set to true. The selection variant
		 * oDefaultedSelVar itself is always returned as is.
		 *
		 * @private
		 *
		 */
		_splitInboundNavigationParameters : function(oSelectionVariant, oStartupParameters, aDefaultedParameters) {

			if (!jQuery.isArray(aDefaultedParameters)) {
				throw new Error("NavigationHandler.INVALID_INPUT");
			}

			var sPropName, i;
			// First we do some parsing of the StartUp Parameters.
			var oStartupParametersAdjusted = {};
			for (sPropName in oStartupParameters){
				if (!oStartupParameters.hasOwnProperty(sPropName)) {
					continue;
				}

				//if (sPropName === this.sSAPSystemProp || sPropName === this.sDefaultedParamProp) {
				if (this._isTechnicalParameter(sPropName)) {
					// Do not add the SAP system parameter to the selection variant as it is a technical parameter
					// not relevant for the selection variant.
					// Do not add the startup parameter for default values to the selection variant. The information, which parameters
					// are defaulted, is available in the defaulted selection variant.
					continue;
				}

				// We support parameters as a map with strings and as a map with value arrays
				if (typeof oStartupParameters[sPropName] === "string") {
					oStartupParametersAdjusted[sPropName] = oStartupParameters[sPropName];
				} else if (jQuery.type(oStartupParameters[sPropName]) === "array" && oStartupParameters[sPropName].length === 1) {
					oStartupParametersAdjusted[sPropName] = oStartupParameters[sPropName][0]; //single-valued parameters
				} else if (jQuery.type(oStartupParameters[sPropName]) === "array" && oStartupParameters[sPropName].length > 1) {
					oStartupParametersAdjusted[sPropName] = oStartupParameters[sPropName]; //multi-valued parameters
				} else {
					throw new Error("NavigationHandler.INVALID_INPUT");
				}
			}

			// Construct two selection variants for defaults and navigation to be returned by the function.
			var oDefaultedSelVar = new SelectionVariant();
			var oNavigationSelVar = new SelectionVariant();

			var aSelVarPropNames = oSelectionVariant.getParameterNames().concat(oSelectionVariant.getSelectOptionsPropertyNames());
			for (i = 0; i < aSelVarPropNames.length; i++) {
				sPropName = aSelVarPropNames[i];
				if (sPropName in oStartupParametersAdjusted) {

					// Resolve conflict.
					if (jQuery.inArray(sPropName, aDefaultedParameters) > -1) {
						oNavigationSelVar.massAddSelectOption(sPropName, oSelectionVariant.getValue(sPropName));
						this._addParameterValues(oDefaultedSelVar, sPropName, "I", "EQ", oStartupParametersAdjusted[sPropName]);
					} else {
						switch (this.sParamHandlingMode) {
							case sap.ui.generic.app.navigation.service.ParamHandlingMode.SelVarWins:
								oNavigationSelVar.massAddSelectOption(sPropName, oSelectionVariant.getValue(sPropName));
								break;
							case sap.ui.generic.app.navigation.service.ParamHandlingMode.URLParamWins:
								this._addParameterValues(oNavigationSelVar, sPropName, "I", "EQ", oStartupParametersAdjusted[sPropName]);
								break;
							case sap.ui.generic.app.navigation.service.ParamHandlingMode.InsertInSelOpt:
								oNavigationSelVar.massAddSelectOption(sPropName, oSelectionVariant.getValue(sPropName));
								this._addParameterValues(oNavigationSelVar, sPropName, "I", "EQ", oStartupParametersAdjusted[sPropName]);
								break;
							default:
								throw new Error("NavigationHandler.INVALID_INPUT");
						}
					}
				} else { // parameter only in SelVar
					if (jQuery.inArray(sPropName, aDefaultedParameters) > -1) {
						oDefaultedSelVar.massAddSelectOption(sPropName, oSelectionVariant.getValue(sPropName));
					} else {
						oNavigationSelVar.massAddSelectOption(sPropName, oSelectionVariant.getValue(sPropName));
					}
				}
			}

			for (sPropName in oStartupParametersAdjusted) {
				// The case where the parameter appears twice has already been taken care of above so we skip it here.
				if (jQuery.inArray(sPropName, aSelVarPropNames) > -1) {
					continue;
				}

				if ((jQuery.inArray(sPropName, aDefaultedParameters) > -1)) {
					this._addParameterValues(oDefaultedSelVar, sPropName, "I", "EQ", oStartupParametersAdjusted[sPropName]);
				} else {
					this._addParameterValues(oNavigationSelVar, sPropName, "I", "EQ", oStartupParametersAdjusted[sPropName]);
				}
			}

			// the selection variant used for navigation should be filled with defaults in case that only defaults exist
			var bNavSelVarHasDefaultsOnly = false;
			if (oNavigationSelVar.isEmpty()) {
				bNavSelVarHasDefaultsOnly = true;
				var aPropNames = oDefaultedSelVar.getSelectOptionsPropertyNames();
				for (i = 0; i < aPropNames.length; i++) {
					oNavigationSelVar.massAddSelectOption(aPropNames[i], oDefaultedSelVar.getValue(aPropNames[i]));
				}
			}

			return {
				oNavigationSelVar : oNavigationSelVar,
				oDefaultedSelVar : oDefaultedSelVar,
				bNavSelVarHasDefaultsOnly : bNavSelVarHasDefaultsOnly
			};
		},

		_addParameterValues : function(oSelVariant, sPropName, sSign, sOption, oValues) {
			if (jQuery.isArray(oValues)){
				for (var i = 0; i < oValues.length; i++) {
					oSelVariant.addSelectOption(sPropName, sSign, sOption, oValues[i]);
				}
			} else {
				oSelVariant.addSelectOption(sPropName, sSign, sOption, oValues);
			}
		},


		/**
		 * Changes the URL according to the current sAppStateKey.
		 * As an reaction route change event will be triggered.
		 * @param {string} sAppStateKey the new app state key.
		 * @public
		 **/
		replaceHash:  function(sAppStateKey) {
			var oHashChanger = this.oRouter.oHashChanger ? this.oRouter.oHashChanger : HashChanger.getInstance();
			var sAppHashOld = oHashChanger.getHash();
			/* use .getHash() here instead of .getAppHash() to also be able dealing with
			 * environments where only SAPUI5 is loaded and the UShell is not initialized properly.
			 */
			var sAppHashNew = this._replaceInnerAppStateKey(sAppHashOld, sAppStateKey);
			oHashChanger.replaceHash(sAppHashNew);
		},

		/**
		 * Changes the URL according to the current app state and stores the app state for later retrieval.
		 * @param {object} mInnerAppData Object containing the current state of the app
		 * @param {string} mInnerAppData.selectionVariant Stringified JSON object as returned, for example, from getDataSuiteFormat() of the SmartFilterBar control
		 * @param {string} [mInnerAppData.tableVariantId] ID of the SmartTable variant
		 * @param {object} [mInnerAppData.customData] Object that can be used to store additional app-specific data
		 * @param {object} [mInnerAppData.presentationVariant] Object containing the current ui state of the app
		 * @param {boolean} [bImmediateHashReplace=true] If set to false, the inner app hash will not be replaced until storing is successful;
		 * do not set to false if you cannot react to the resolution of the Promise, for example, when calling the beforeLinkPressed event
		 * @returns {object} A Promise object to monitor when all the actions of the function have been executed; if the execution is successful, the app state key is returned;
		 * if an error occurs, an object of type {@link sap.ui.generic.app.navigation.service.NavError} is returned
		 * @public
		 * @example
		 * <code>
		 * var oNavigationHandler = new sap.ui.generic.app.navigation.service.NavigationHandler(oController);
		 * var mInnerAppData = {
		 * 		selectionVariant : oSmartFilterBar.getDataSuiteFormat(),
		 * 		tableVariantId : oSmartTable.getCurrentVariantId(),
		 * 		customData : oMyCustomData
		 * };
		 *
		 * var oStoreInnerAppStatePromise = oNavigationHandler.storeInnerAppState(mInnerAppData);
		 *
		 * oStoreInnerAppStatePromise.done(function(sAppStateKey){
		 * 	//your inner app state is saved now, sAppStateKey was added to URL
		 * 	//perform actions that must run after save
		 * });
		 *
		 * oStoreInnerAppStatePromise.fail(function(oError){
		 * 		//some error handling
		 * });
		 * </code>
		 */
		storeInnerAppState: function(mInnerAppData, bImmediateHashReplace){

			if (typeof bImmediateHashReplace !== "boolean") {
				bImmediateHashReplace = true; //default
			}
			var oNavHandler = this;
			var oMyDeferred = jQuery.Deferred();

			var fnReplaceHash = function(sAppStateKey){
				var oHashChanger = oNavHandler.oRouter.oHashChanger ? oNavHandler.oRouter.oHashChanger : HashChanger.getInstance();
				var sAppHashOld = oHashChanger.getHash();
				/* use .getHash() here instead of .getAppHash() to also be able dealing with
				 * environments where only SAPUI5 is loaded and the UShell is not initialized properly.
				 */
				var sAppHashNew = oNavHandler._replaceInnerAppStateKey(sAppHashOld,sAppStateKey);
				oHashChanger.replaceHash(sAppHashNew);
			};

			// in case mInnerAppState is null, do not overwrite the last saved state
			if (mInnerAppData === null) {
				oMyDeferred.resolve("");
				return oMyDeferred.promise();
			}


			//check if we already saved the same data
			var sAppStateKeyCached = this._oLastSavedInnerAppData.sAppStateKey;

			//check if empty and first save
			if ( jQuery.isEmptyObject(mInnerAppData) && !sAppStateKeyCached) {
				oMyDeferred.resolve("");
				return oMyDeferred.promise();
			}

			var bInnerAppDataEqual = (JSON.stringify(mInnerAppData) === JSON.stringify(this._oLastSavedInnerAppData.oAppData));
			if (bInnerAppDataEqual && sAppStateKeyCached) {
				// passed inner app state found in cache
				this._oLastSavedInnerAppData.iCacheHit++;

				//replace inner app hash with cached appStateKey in url (just in case the app has changed the hash in meantime)
				fnReplaceHash(sAppStateKeyCached);
				oMyDeferred.resolve(sAppStateKeyCached);
				return oMyDeferred.promise();
			}

			// passed inner app state not found in cache
			this._oLastSavedInnerAppData.iCacheMiss++;

			var fnOnAfterSave = function(sAppStateKey){

				//replace inner app hash with new appStateKey in url
				if (!bImmediateHashReplace) {
					fnReplaceHash(sAppStateKey);
				}

				//remember last saved state
				oNavHandler._oLastSavedInnerAppData.oAppData = mInnerAppData;
				oNavHandler._oLastSavedInnerAppData.sAppStateKey = sAppStateKey;
				oMyDeferred.resolve(sAppStateKey);
			};

			var fnOnError = function(oError){
				oMyDeferred.reject(oError);
			};

			var sAppStateKey = this._saveAppState(mInnerAppData, fnOnAfterSave, fnOnError);
			/* Note that _sapAppState may return 'undefined' in case that the parsing
			 * has failed. In this case, we should not trigger the replacement of the App Hash
			 * with the generated key, as the container was not written before.
			 * Note as well that the error handling has already happened before by
			 * making the oMyDeferred promise fail (see fnOnError above).
			 */
			if (sAppStateKey !== undefined) {
				//replace inner app hash with new appStateKey in url
				//note: we do not wait for the save to be completed: this asynchronously behaviour is necessary if
				//this method is called e.g. in a onLinkPressed event with no possibility to wait for the promise resolution
				if (bImmediateHashReplace) {
					fnReplaceHash(sAppStateKey);
				}
			}

			return oMyDeferred.promise();
		},


		/**
		 * Changes the URL according to the current app state and stores the app state for later retrieval.
		 *
		 * @param {object} mInnerAppData Object containing the current state of the app
		 * @param {string} mInnerAppData.selectionVariant Stringified JSON object as returned, for example, from getDataSuiteFormat() of the SmartFilterBar control
		 * @param {string} [mInnerAppData.tableVariantId] ID of the SmartTable variant
		 * @param {object} [mInnerAppData.customData] Object that can be used to store additional app-specific data
		 * @param {object} [mInnerAppData.presentationVariant] Object containing the current ui state of the app
		 * @param {boolean} [bImmediateHashReplace=false] If set to false, the inner app hash will not be replaced until storing is successful;
		 * do not set to false if you cannot react to the resolution of the Promise, for example, when calling the beforeLinkPressed event.
		 * <b>Note:</b>If not provided it will be treated as set to false.
		 * <b>Note:</b>If set to true, the calling instance has to ensure that a follow-on call to <code>replaceHash</code> will take place!
		 *
		 * @returns {Object} An object containing the appStateId and a promise object to monitor when all the actions of the function have been executed; Please note that the appStateKey may be undefined or empty.
		 * if an error occurs, an object of type {@link sap.ui.generic.app.navigation.service.NavError} is returned
		 *
		 * @example
		 * <code>
		 * var oNavigationHandler = new sap.ui.generic.app.navigation.service.NavigationHandler(oController);
		 * var mInnerAppData = {
		 * 		selectionVariant : oSmartFilterBar.getDataSuiteFormat(),
		 * 		tableVariantId : oSmartTable.getCurrentVariantId(),
		 * 		customData : oMyCustomData
		 * };
		 *
		 * var oStoreInnerAppState = storeInnerAppStateWithNonDelayedReturn(mInnerAppData);
		 * var sAppStateKey = oStoreInnerAppState.appStateKey;
		 * if (!sAppStateKey) {
		 *    // no appStateKey obtained...
		 * };
		 * var oStoreInnerAppStatePromise = oStoreInnerAppState.promise;
		 *
		 * oStoreInnerAppStatePromise.done(function(sAppStateKey){
		 * 	//your inner app state is saved now, sAppStateKey was added to URL
		 * 	//perform actions that must run after save
		 * });
		 *
		 * oStoreInnerAppStatePromise.fail(function(oError){
		 * 		//some error handling
		 * });
		 * </code>
		 *
		 *  @public
		 */
		storeInnerAppStateWithImmediateReturn: function(mInnerAppData, bImmediateHashReplace){

			if (typeof bImmediateHashReplace !== "boolean") {
				bImmediateHashReplace = false; //default
			}

			var that = this;
			var oAppStatePromise = jQuery.Deferred();


			// in case mInnerAppState is null, do not overwrite the last saved state
			if (mInnerAppData === null) {
				return {
					appStateKey: "",
					promise: oAppStatePromise.resolve("")
				};
			}


			//check if we already saved the same data
			var sAppStateKeyCached = this._oLastSavedInnerAppData.sAppStateKey;

			//check if empty and first save
			if ( jQuery.isEmptyObject(mInnerAppData) && !sAppStateKeyCached) {
				return {
					appStateKey: "",
					promise: oAppStatePromise.resolve("")
				};
			}

			var bInnerAppDataEqual = (JSON.stringify(mInnerAppData) === JSON.stringify(this._oLastSavedInnerAppData.oAppData));
			if (bInnerAppDataEqual && sAppStateKeyCached) {
				// passed inner app state found in cache
				this._oLastSavedInnerAppData.iCacheHit++;

				//replace inner app hash with cached appStateKey in url (just in case the app has changed the hash in meantime)
				if (bImmediateHashReplace) {
					setTimeout(function() {that.replaceHash(sAppStateKeyCached);}, 70);
				}
				//this.replaceHash(sAppStateKeyCached);
				return {
					appStateKey: sAppStateKeyCached,
					promise: oAppStatePromise.resolve(sAppStateKeyCached)
				};
			}

			// passed inner app state not found in cache
			this._oLastSavedInnerAppData.iCacheMiss++;

			var fnOnAfterSave = function(sAppStateKey){

				//replace inner app hash with new appStateKey in url
				if (!bImmediateHashReplace) {
					that.replaceHash(sAppStateKey);
				}

				//remember last saved state
				that._oLastSavedInnerAppData.oAppData = mInnerAppData;
				that._oLastSavedInnerAppData.sAppStateKey = sAppStateKey;
				oAppStatePromise.resolve(sAppStateKey);
			};

			var fnOnError = function(oError){
				oAppStatePromise.reject(oError);
			};

			var sAppStateKey = this._saveAppState(mInnerAppData, fnOnAfterSave, fnOnError);
			/* Note that _sapAppState may return 'undefined' in case that the parsing
			 * has failed. In this case, we should not trigger the replacement of the App Hash
			 * with the generated key, as the container was not written before.
			 * Note as well that the error handling has already happened before by
			 * making the oMyDeferred promise fail (see fnOnError above).
			 */
//			if (sAppStateKey !== undefined) {
//				//replace inner app hash with new appStateKey in url
//				//note: we do not wait for the save to be completed: this asynchronously behaviour is necessary if
//				//this method is called e.g. in a onLinkPressed event with no possibility to wait for the promise resolution
//				if (bImmediateHashReplace) {
//					fnReplaceHash(sAppStateKey);
//				}
//			}

			return {
				appStateKey: sAppStateKey,
				promise: oAppStatePromise.promise()
			};
		},



		/**
		 * Processes navigation-related tasks related to beforePopoverOpens event handling for the SmartLink control and returns a Promise object.
		 * In particular, the following tasks are performed before the SmartLink popover can be opened:
		 * <ul>
		 * 	<li>If <code>mInnerAppData</code> is provided, this inner app state is saved for back navigation at a later time.</li>
		 * 	<li>The table event parameters (semantic attributes) and the selection variant data are combined by calling the
		 * 			method {@link #.mixAttributesAndSelectionVariant mixAttributesAndSelectionVariant}.</li>
		 * 	<li>The combined data is saved as the cross app state to be handed over to the target app, and the corresponding sap-xapp-state key is set in the URL.</li>
		 * 	<li>All single selections ("including equal") of the combined selection data are passed to the SmartLink popover as semantic attributes.</li>
		 * 	<li>The method <code>oTableEventParameters.open()</code> is called. Note that this does not really open the popover, but the SmartLink control proceeds
		 *			with firing the event <code>navigationTargetsObtained</code>.</li>
		 * </ul>
		 * @param {object} oTableEventParameters The parameters made available by the SmartTable control when the SmartLink control has been clicked, an instance of a PopOver object
		 * @param {string} sSelectionVariant Stringified JSON object as returned, for example, from getDataSuiteFormat() of the SmartFilterBar control
		 * @param {object} [mInnerAppData] Object containing the current state of the app. If provided, opening the Popover is deferred until the inner app data is saved in a consistent way.
		 * @param {string} [mInnerAppData.selectionVariant] Stringified JSON object as returned, for example, from getDataSuiteFormat() of the the SmartFilterBar control; if provided, the selection
		 * is merged into the semantic attributes
		 * @param {string} [mInnerAppData.tableVariantId] ID of the SmartTable variant
		 * @param {object} [mInnerAppData.customData] Object that can be used to store additional app-specific data
		 * @param {object} [mInnerAppData.presentationVariant] Object containing the current ui state of the app
		 * @returns {object} A Promise object to monitor when all actions of the function have been executed; if the execution is successful, the modified oTableEventParameters is returned;
		 * if an error occurs, an error object of type {@link sap.ui.generic.app.navigation.service.NavError} is returned
		 * @public
		 * @example
		 * <code>
		 * //event handler for the smart link event "beforePopoverOpens"
		 * 	onBeforePopoverOpens: function(oEvent) {
		 * 		var oTableEventParameters = oEvent.getParameters();
		 *
		 * 		var mInnerAppData = {
		 * 			selectionVariant : oSmartFilterBar.getDataSuiteFormat(),
		 * 			tableVariantId : oSmartTable.getCurrentVariantId(),
		 * 			customData : oMyCustomData
		 * 		};
		 *
		 * 		var oSelectionVariant = new sap.ui.generic.app.navigation.service.SelectionVariant();
		 * 		oSelectionVariant.addSelectOption("CompanyCode", "I", "EQ", "0001");
		 * 		oSelectionVariant.addSelectOption("Customer", "I", "EQ", "C0001");
		 * 		var sSelectionVariant= oSelectionVariant.toJSONString();
		 *
		 * 		var oNavigationHandler = new sap.ui.generic.app.navigation.service.NavigationHandler(oController);
		 * 		var oSmartLinkPromise = oNavigationHandler.processBeforeSmartLinkPopoverOpens(oTableEventParameters, sSelectionVariant, mInnerAppData);
		 *
		 * 		oSmartLinkPromise.done(function(oTableEventParameters){
		 * 			// here you can add coding that should run after all app states are saved and the semantic attributes are set
		 * 		});
		 *
		 * 		oSmartLinkPromise.fail(function(oError){
		 * 		//some error handling
		 * 		});
		 * };
		 * </code>
		 */
		processBeforeSmartLinkPopoverOpens: function(oTableEventParameters, sSelectionVariant, mInnerAppData){
			var oMyDeferred = jQuery.Deferred();
			var mSemanticAttributes = oTableEventParameters.semanticAttributes;
			var oObj = {}, oPresentationVariant = null, oNavHandler = this;

			if (mInnerAppData && mInnerAppData.presentationVariant) {
				oPresentationVariant = mInnerAppData.presentationVariant;
			}

			var fnStoreXappAndCallOpen = function(mSemanticAttributes, sSelectionVariant){

				//mix the semantic attributes (e.g. from the row line) with the selection variant (e.g. from the filter bar)
				sSelectionVariant = sSelectionVariant || "{}";

				var iSuppressionBehavior = sap.ui.generic.app.navigation.service.SuppressionBehavior.raiseErrorOnNull | sap.ui.generic.app.navigation.service.SuppressionBehavior.raiseErrorOnUndefined;
				/* compatiblity: Until SAPUI5 1.28.5 (or even later) the Smart Link in a Smart Table is
				 * filtering all null- and undefined values. Therefore, mSemanticAttributes are already
				 * reduced appropriately -- this does not need to be done by mixAttributesAndSelectionVariant
				 * again. To ensure that we still have the old behaviour (i.e. an Error is raised in case
				 * that behaviour of the Smart Link control has changed), the "old" Suppression Behaviour is
				 * retained.
				 */

				var oMixedSelVar = oNavHandler.mixAttributesAndSelectionVariant(mSemanticAttributes, sSelectionVariant, iSuppressionBehavior);
				sSelectionVariant = oMixedSelVar.toJSONString();

				//enrich the semantic attributes with single selections from the selection variant
				mSemanticAttributes = oNavHandler._getURLParametersFromSelectionVariant(oMixedSelVar);

				var fnOnContainerSave = function(sAppStateKey){
					//set the stored data in popover and call open()
					oTableEventParameters.setSemanticAttributes(mSemanticAttributes);
					oTableEventParameters.setAppStateKey(sAppStateKey);
					oTableEventParameters.open(); //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Note that "open" does not open the popover, but proceeds
					//                                                               with firing the onNavTargetsObtained event.
					oMyDeferred.resolve(oTableEventParameters);
				};

				var fnOnError = function(oError){
					oMyDeferred.reject(oError);
				};

				//store the sap-xapp-state
				oObj.selectionVariant = sSelectionVariant;
				if (oPresentationVariant) {
					oObj.presentationVariant = oPresentationVariant;
				}
				oNavHandler._saveAppState(oObj, fnOnContainerSave, fnOnError);
			};

			if (mInnerAppData) {

				var oStoreInnerAppStatePromise = this.storeInnerAppState(mInnerAppData, true);

				//if the inner app state was successfully stored, store also the xapp-state
				oStoreInnerAppStatePromise.done(function(){
					fnStoreXappAndCallOpen(mSemanticAttributes, sSelectionVariant);
				});

				oStoreInnerAppStatePromise.fail(function(oError){
					oMyDeferred.reject(oError);
				});

			} else {
				//there is no inner app state to save, just put the parameters into xapp-state
				fnStoreXappAndCallOpen(mSemanticAttributes, sSelectionVariant);
			}

			return oMyDeferred.promise();
		},


		/** Combines the given parameters and selection variant into a new selection variant containing properties from both, with the parameters
		 * overriding existing properties in the selection variant. The new selection variant does not contain any parameters. All parameters are merged into select options.
		 * The output of this function, converted to a JSON string, can be used for the {@link #.navigate NavigationHandler.navigate} method.
		 * @param {object} mSemanticAttributes Object containing key/value pairs
		 * @param {string} sSelectionVariant The selection variant in string format as provided by the SmartFilterBar control
		 * @param {int} [iSuppressionBehavior=sap.ui.generic.app.navigation.service.SuppressionBehavior.standard] Indicates whether semantic attributes with special values
		 *(see {@link sap.ui.generic.app.navigation.service.SuppressionBehavior suppression behavior}) must be suppressed before they are combined with the selection variant;
		 * several {@link sap.ui.generic.app.navigation.service.SuppressionBehavior suppression behaviors} can be combined with the bitwise OR operator (|)
		 * @returns {object} Instance of {@link sap.ui.generic.app.navigation.service.SelectionVariant}
		 * @public
		 * @example
		 * <code>
		 * var mSemanticAttributes = { "Customer" : "C0001" };
		 * var sSelectionVariant = oSmartFilterBar.getDataSuiteFormat();
		 * var oNavigationHandler = new sap.ui.generic.app.navigation.service.NavigationHandler(oController);
		 * var sNavigationSelectionVariant = oNavigationHandler.mixAttributesAndSelectionVariant(mSemanticAttributes, sSelectionVariant).toJSONString();
		 * // Optionally, you can specify one or several suppression behaviors. Several suppression behaviors are combined with the bitwise OR operator, e.g.
		 * // var iSuppressionBehavior = sap.ui.generic.app.navigation.service.SuppressionBehavior.raiseErrorOnNull | sap.ui.generic.app.navigation.service.SuppressionBehavior.raiseErrorOnUndefined;
		 * // var sNavigationSelectionVariant = oNavigationHandler.mixAttributesAndSelectionVariant(mSemanticAttributes, sSelectionVariant, iSuppressionBehavior).toJSONString();
		 *
		 * oNavigationHandler.navigate("SalesOrder", "create", sNavigationSelectionVariant);
		 * </code>
		 */
		mixAttributesAndSelectionVariant: function(mSemanticAttributes, sSelectionVariant, iSuppressionBehavior){

			if (iSuppressionBehavior === undefined) {
				iSuppressionBehavior = sap.ui.generic.app.navigation.service.SuppressionBehavior.standard;
			}
			var oSelectionVariant = new SelectionVariant(sSelectionVariant);
			var oNewSelVariant = new SelectionVariant();

			//add all semantic attributes to the mixed selection variant
			for (var sPropertyName in mSemanticAttributes){
				if (mSemanticAttributes.hasOwnProperty(sPropertyName)) {
					// A value of a semantic attribute may not be a string, but can be e.g. a date.
					// Since the selection variant accepts only a string, we have to convert it in dependence of the type.
					var vSemanticAttributeValue = mSemanticAttributes[sPropertyName];

					if (jQuery.type(vSemanticAttributeValue) === "array" || jQuery.type(vSemanticAttributeValue) === "object") {
						vSemanticAttributeValue = JSON.stringify(vSemanticAttributeValue);
					} else if ( jQuery.type(vSemanticAttributeValue) === "date"){
						// use the same conversion method for dates as the SmartFilterBar: toJSON()
						vSemanticAttributeValue = vSemanticAttributeValue.toJSON();
					} else if ( jQuery.type(vSemanticAttributeValue) === "number" || jQuery.type(vSemanticAttributeValue) === "boolean") {
						vSemanticAttributeValue = vSemanticAttributeValue.toString();
					}

					if (vSemanticAttributeValue === "") {
						if (iSuppressionBehavior & sap.ui.generic.app.navigation.service.SuppressionBehavior.ignoreEmptyString) {
							jQuery.sap.log.info("Semantic attribute " + sPropertyName + " is an empty string and due to the chosen Suppression Behiavour is being ignored.");
							continue;
						}
					}

					if (vSemanticAttributeValue === null) {
						if (iSuppressionBehavior & sap.ui.generic.app.navigation.service.SuppressionBehavior.raiseErrorOnNull) {
							throw new Error("NavigationHandler.INVALID_INPUT");
						} else {
							jQuery.sap.log.warning("Semantic attribute " + sPropertyName + " is null and ignored for mix in to selection variant");
							continue; // ignore!
						}
					}

					if (vSemanticAttributeValue === undefined) {
						if (iSuppressionBehavior & sap.ui.generic.app.navigation.service.SuppressionBehavior.raiseErrorOnUndefined) {
							throw new Error("NavigationHandler.INVALID_INPUT");
						} else {
							jQuery.sap.log.warning("Semantic attribute " + sPropertyName + " is undefined and ignored for mix in to selection variant");
							continue;
						}
					}

					if (jQuery.type(vSemanticAttributeValue) === "string" ) {
						oNewSelVariant.addSelectOption(sPropertyName, "I", "EQ", vSemanticAttributeValue);
					} else {
						throw new Error("NavigationHandler.INVALID_INPUT");
					}

				}
			}

			//add parameters that are not part of the oNewSelVariant yet
			var aParameters = oSelectionVariant.getParameterNames();
			for (var i = 0; i < aParameters.length; i++) {
				if (!oNewSelVariant.getSelectOption(aParameters[i])) {
					oNewSelVariant.addSelectOption(aParameters[i], "I", "EQ", oSelectionVariant.getParameter(aParameters[i]));
				}
			}

			//add selOptions that are not part of the oNewSelVariant yet
			var aSelOptionNames =  oSelectionVariant.getSelectOptionsPropertyNames();
			for (i = 0; i < aSelOptionNames.length; i++) {
				if (!oNewSelVariant.getSelectOption(aSelOptionNames[i])) {
					var aSelectOption = oSelectionVariant.getSelectOption(aSelOptionNames[i]);
					//add every range in the current select option
					for (var j = 0; j < aSelectOption.length; j++) {
						oNewSelVariant.addSelectOption( aSelOptionNames[i], aSelectOption[j].Sign, aSelectOption[j].Option, aSelectOption[j].Low, aSelectOption[j].High);
					}
				}
			}

			return oNewSelVariant;
		},

		_ensureSelectionVariantFormatString : function(vSelectionVariant) {
			/* There are legacy AppStates where the SelectionVariant is being stored
			 * as a string. However, that is not compliant to the specification, which
			 * states that a standard JS object shall be provided.
			 * Internally, however, the selectionVariant is always of type string.
			 *
			 * Situation           Persistency         internal API
			 * ----------------    ------------------  ---------------------
			 * legacy              string              string
			 * new approach        (JSON) object       string
			 *
			 */

			if (vSelectionVariant === undefined) {
				return undefined;
			}

			var vConvertedSelectionVariant = vSelectionVariant;

			if (typeof vSelectionVariant === "object") {
				vConvertedSelectionVariant = JSON.stringify(vSelectionVariant);
			}

			return vConvertedSelectionVariant;
		},

		_saveAppState: function(oAppData, fnOnAfterSave, fnOnError){

			var oAppState = this.oCrossAppNavService.createEmptyAppState(this.oComponent);
			var sAppStateKey = oAppState.getKey();

			var oAppDataForSave = { selectionVariant: {}, tableVariantId: "", customData: {}};

			if (oAppData.selectionVariant) {

				/*
				 * The specification states that Selection Variants need to be JSON objects.
				 * However, internally, we work with strings for "selectionVariant". Therefore,
				 * in case that this is a string, we need to JSON-parse the data.
				 */
				if (typeof oAppData.selectionVariant === "string") {
					try {
						oAppDataForSave.selectionVariant = JSON.parse(oAppData.selectionVariant);
					} catch (x) {
						var oError = this._createTechnicalError("NavigationHandler.AppStateSave.parseError");
						if (fnOnError) {
							fnOnError(oError);
						}
						return undefined;
					}
				} else {
					oAppDataForSave.selectionVariant = oAppData.selectionVariant;
				}
			}
			if (oAppData.tableVariantId) {
				oAppDataForSave.tableVariantId = oAppData.tableVariantId;
			}
			if (oAppData.customData) {
				oAppDataForSave.customData = oAppData.customData;
			}
			if (oAppData.presentationVariant) {
				oAppDataForSave.presentationVariant = oAppData.presentationVariant;
			}

			oAppState.setData(oAppDataForSave);
			var oSavePromise = oAppState.save();

			if (fnOnAfterSave) {
				oSavePromise.done(function(){
					fnOnAfterSave(sAppStateKey);
				});
			}

			if (fnOnError) {
				var oNavHandler = this;
				oSavePromise.fail(function(){
					oError = oNavHandler._createTechnicalError("NavigationHandler.AppStateSave.failed");
					fnOnError(oError);
				});
			}
			return sAppStateKey;
		},

		_loadAppState: function(sAppStateKey,oDeferred){

			var oAppStatePromise = this.oCrossAppNavService.getAppState(this.oComponent, sAppStateKey);
			var oNavHandler = this;

			oAppStatePromise.done(function(oAppState){
				var oAppData = { selectionVariant: "{}",
				                 oSelectionVariant: new SelectionVariant(),
				                 oDefaultedSelectionVariant: new SelectionVariant(),
				                 bNavSelVarHasDefaultsOnly: false,
				                 tableVariantId: "",
				                 customData: {},
				                 appStateKey: sAppStateKey,
				                 presentationVariant: {}
				                 };
				var oAppDataLoaded = oAppState.getData();

				if (typeof oAppDataLoaded === "undefined") {
					var oError = oNavHandler._createTechnicalError("NavigationHandler.getDataFromAppState.failed");
					oDeferred.reject(oError, {}, sap.ui.generic.app.navigation.service.NavType.iAppState);
				} else {
					if (oAppDataLoaded.selectionVariant) {
						/* In case that we get an object from the stored AppData (=persistency), we need
						 * to stringify the JSON object.
						 */
						oAppData.selectionVariant = oNavHandler._ensureSelectionVariantFormatString(oAppDataLoaded.selectionVariant);
						oAppData.oSelectionVariant = new SelectionVariant(oAppData.selectionVariant);
					}
					if (oAppDataLoaded.tableVariantId) {
						oAppData.tableVariantId = oAppDataLoaded.tableVariantId;
					}
					if (oAppDataLoaded.customData){
						oAppData.customData = oAppDataLoaded.customData;
					}
					if (oAppDataLoaded.presentationVariant){
						oAppData.presentationVariant = oAppDataLoaded.presentationVariant;
					}
				}

				//resolve is called on passed Deferred object to trigger a call of the done method, if implemented
				//the done method will receive the loaded appState and the navigation type as parameters
				oDeferred.resolve(oAppData, {}, sap.ui.generic.app.navigation.service.NavType.iAppState);
			});
			oAppStatePromise.fail(function(){
				var oError = oNavHandler._createTechnicalError("NavigationHandler.getAppState.failed");
				oDeferred.reject(oError, {}, sap.ui.generic.app.navigation.service.NavType.iAppState);
			});
		},

		/**
		 * Retrieves the parameter value of the sap-iapp-state (the internal apps) from the AppHash string.
		 * It automatically takes care about compatibility between the old and the new approach of
		 * the sap-iapp-state. Precedence is that the new approach is favoured against the old approach.
		 * @param {string} sAppHash the AppHash, which may contain a sap-iapp-state parameter (both old and/or new approach)
		 * @return {string} the value of sap-iapp-state (i.e. the name of the container to retrieve the parameters),
		 * or <code>undefined</code> in case that no sap-iapp-state was found in <code>sAppHash</code>.
		 * @private
		 */
		_getInnerAppStateKey : function(sAppHash) {

			// trivial case: no app hash available at all.
			if (!sAppHash) {
				return undefined;
			}

			/* new approach: separated via question mark / part of the query parameter of the AppHash */
			var aMatches = this._rIAppStateNew.exec(sAppHash);

			/* old approach: spearated via slashes / i.e. part of the route itself */
			if (aMatches === null) {
				aMatches = this._rIAppStateOld.exec(sAppHash);
			}

			/* old approach: special case: if there is no deep route/key defined, the sap-iapp-state may be at the beginning
			 * of the string, without any separation with the slashes
			 */
			if (aMatches === null) {
				aMatches = this._rIAppStateOldAtStart.exec(sAppHash);
			}

			if (aMatches === null) {
				// there is no (valid) sap-iapp-state in the App Hash
				return undefined;
			}

			return aMatches[1];
		},


		/**
		 * Replaces (or inserts) a parameter value (an AppStateKey) for the sap-iapp-state into an existing
		 * AppHash string. Other routes/parameters are ignored and returned without modification ("environmental
		 * agnostic" property).
		 * Only the new approach (sap-iapp-state as query parameter in the AppHash) is being issued.
		 * @param {string} sAppHash the AppHash into which the sap-iapp-state parameter shall be made available
		 * @param {string} sAppStateKey the key value of the AppState which shall be stored as parameter value of
		 * the sap-iapp-state property.
		 * @return {string} the modified sAppHash string, such that the sap-iapp-state has been set based on the
		 * new (query option-based) sap-iapp-state. If a sap-iapp-state has been specified before, the key is replaced.
		 * If <code>sAppHash</code> was of the old format (sap-iapp-state as part of the keys/route), the format is
		 * converted to the new format before the result is returned.
		 * @private
		 */
		_replaceInnerAppStateKey: function(sAppHash,sAppStateKey){
			var sNewIAppState = this.IAPP_STATE + "=" + sAppStateKey;

			/*
			 * generate sap-iapp-states with the new way
			 */
			if (!sAppHash) {
				// there's no sAppHash key yet
				return "?" + sNewIAppState;
			}

			var fnAppendToQueryParameter = function(sAppHash) {
				// there is an AppHash available, but it does not contain a sap-iapp-state parameter yet - we need to append one

				// new approach: we need to check, if a set of query parameters is already available
				if (sAppHash.indexOf("?") !== -1) {
					// there are already query parameters available - append it as another parameter
					return sAppHash + "&" + sNewIAppState;
				}
				// there are no a query parameters available yet; create a set with a single parameter
				return sAppHash + "?" + sNewIAppState;
			};

			if (!this._getInnerAppStateKey(sAppHash)) {
				return fnAppendToQueryParameter(sAppHash);
			}
			// There is an AppHash available and there is already an sap-iapp-state in the AppHash

			if (this._rIAppStateNew.test(sAppHash)) {
				// the new approach is being used
				return sAppHash.replace(this._rIAppStateNew, function(sNeedle) {
					return sNeedle.replace(/\=.*/ig, "=" + sAppStateKey);
				});
			}

			// we need to remove the old AppHash entirely and replace it with a new one.

			var fnReplaceOldApproach = function(rOldApproach, sAppHash) {
				sAppHash = sAppHash.replace(rOldApproach, "");
				return fnAppendToQueryParameter(sAppHash);
			};

			if (this._rIAppStateOld.test(sAppHash)) {
				return fnReplaceOldApproach(this._rIAppStateOld, sAppHash);
			}

			if (this._rIAppStateOldAtStart.test(sAppHash)) {
				return fnReplaceOldApproach(this._rIAppStateOldAtStart, sAppHash);
			}

			jQuery.sap.assert(false, "internal inconsistency: Approach of sap-iapp-state not known, but _getInnerAppStateKey returned it");
			return undefined;
		},

		_getURLParametersFromSelectionVariant : function(vSelectionVariant){
			var mURLParameters = {};
			var i = 0;

			if (typeof vSelectionVariant === "string") {
				var oSelectionVariant = new SelectionVariant(vSelectionVariant);
			} else if (typeof vSelectionVariant === "object") {
				oSelectionVariant = vSelectionVariant;
			} else {
				throw new Error("NavigationHandler.INVALID_INPUT");
			}

			//add URLs parameters from SelectionVariant.SelectOptions (if single value)
			var aSelectProperties = oSelectionVariant.getSelectOptionsPropertyNames();
			for (i = 0; i < aSelectProperties.length; i++) {
				var aSelectOptions = oSelectionVariant.getSelectOption(aSelectProperties[i]);
				if (aSelectOptions.length === 1 && aSelectOptions[0].Sign === "I" && aSelectOptions[0].Option === "EQ") {
						mURLParameters[aSelectProperties[i]] = aSelectOptions[0].Low;
				}
			}

			//add parameters from SelectionVariant.Parameters
			var aParameterNames = oSelectionVariant.getParameterNames();
			for (i = 0; i < aParameterNames.length; i++) {
				var sParameterValue = oSelectionVariant.getParameter(aParameterNames[i]);

				mURLParameters[aParameterNames[i]] = sParameterValue;
			}
			return mURLParameters;
		},

		_createTechnicalError: function(sErrorCode){
			return new Error(sErrorCode);
		}
	});


	return NavigationHandler;

});
}; // end of sap/ui/generic/app/navigation/service/NavigationHandler.js
if ( !jQuery.sap.isDeclared('sap.ui.generic.app.transaction.BaseController') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.ui.generic.app.transaction.BaseController'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('jquery.sap.global'); // unlisted dependency retained
jQuery.sap.require('sap.ui.base.EventProvider'); // unlisted dependency retained
sap.ui.define("sap/ui/generic/app/transaction/BaseController",["jquery.sap.global", "sap/ui/base/EventProvider", "sap/ui/generic/app/util/ModelUtil", "sap/ui/generic/app/util/DraftUtil", "sap/ui/generic/app/util/Queue"],
	function (jQuery, EventProvider, ModelUtil, DraftUtil, Queue) {
		"use strict";

		/*global Promise */

		/**
		 * Constructor for base class for controller instances.
		 *
		 * @param {sap.ui.model.odata.ODataModel} oModel The OData model currently used
		 * @param {sap.ui.generic.app.util.Queue} oQueue Optional HTTP request queue
		 *
		 * @throws {Error} If no model is handed over as input parameter
		 *
		 * @class Common base class for <code>sap.ui.generic.app.transaction.TransactionController</code> and
		 *        <code>sap.ui.generic.app.transaction.DraftController</code>, which offers basic functionality to invoke OData functions and
		 *        actions as well as OData CRUD functions in general.
		 *
		 * @author SAP SE
		 * @version 1.50.6
		 *
		 * @since 1.30.0
		 * @alias sap.ui.generic.app.transaction.BaseController
		 * @private
		 */
		var BaseController = EventProvider.extend("sap.ui.generic.app.transaction.BaseController", {
			metadata: {
				publicMethods: [
					"hasClientMessages", "triggerSubmitChanges", "attachFatalError", "detachFatalError", "destroy"
				]
			},

			constructor: function (oModel, oQueue) {
				// model is a mandatory parameter.
				if (!oModel) {
					throw new Error("No model");
				}

				// inherit from event provider.
				EventProvider.apply(this, arguments);

				this.sName = "sap.ui.generic.app.transaction.BaseController";
				this._oModel = oModel;
				this._oMeta = oModel.getMetaModel();
				this._oDraftUtil = new DraftUtil();
				this._oModelUtil = new ModelUtil(oModel);

				if (oQueue) {
					this._oQueue = oQueue;
				} else {
					this._oQueue = new Queue();
					this._bOwnsQueue = true;
				}

				this._initCounts();
			}
		});

		/**
		 * Attaches event handler <code>fnFunction</code> to the <code>fatalError</code> event.
		 *
		 * @param {function} fnFunction The function to call when the event occurs
		 * @param {object} [oListener] Object on which to call the given function
		 * @public
		 */
		BaseController.prototype.attachFatalError = function (fnFunction, oListener) {
			this.attachEvent("fatalError", fnFunction, oListener);
		};

		/**
		 * Detaches event handler <code>fnFunction</code> from the <code>fatalError</code> event.
		 *
		 * @param {function} fnFunction The function to call when the event occurs
		 * @param {object} [oListener] Object on which to call the given function
		 * @public
		 */
		BaseController.prototype.detachFatalError = function (fnFunction, oListener) {
			this.detachEvent("fatalError", fnFunction, oListener);
		};

		/**
		 * Prepares an action invocation, as it checks the existence of the function import and correctness of function import parameters.
		 *
		 * @param {string} sFunctionImportName The name of the function or action
		 * @param {sap.ui.model.Context} oContext The given binding context
		 * @param {map} mParameters Parameters to control the behavior of the action invocation
		 * @returns {map} The parameters used to invoke the action
		 * @throws {Error} Throws an error if the function import does not exist or the action input parameters are invalid
		 * @private
		 */
		BaseController.prototype._prepareCallAction = function (sFunctionImportName, oContext, mParameters) {
			var oEntitySet, oEntityType, oEntity, sEntitySet, aKeyProperties;

			// check the input.
			if (!sFunctionImportName) {
				throw new Error("Invalid Function Import");
			}

			mParameters.urlParameters = mParameters.urlParameters || {};
			mParameters.functionImport = this._oMeta.getODataFunctionImport(sFunctionImportName.split("/")[1]);

			if (!mParameters.functionImport) {
				throw new Error("Unknown Function Import " + sFunctionImportName);
			}

			// retrieve current entity set from binding context
			if (oContext) {
				sEntitySet = ModelUtil.getEntitySetFromContext(oContext);
				oEntitySet = this._oMeta.getODataEntitySet(sEntitySet, false);
				oEntityType = this._oMeta.getODataEntityType(oEntitySet.entityType, false);
				aKeyProperties = oEntityType.key.propertyRef;
				oEntity = oContext.getObject();
			}
			if (oEntity) {
				this._getActionParameters(oEntity, mParameters, aKeyProperties);
				this._getAdditionalActionParameters(oEntity, mParameters, aKeyProperties);
				// etag handling for bound actions
				this._getActionRequestHeaders(oContext, oEntity, mParameters);
			}

			return mParameters;
		};

		/**
		 * Invokes an action with the given name.
		 *
		 * @param {string} sFunctionImportName The name of the function or action
		 * @param {sap.ui.model.Context} oContext The given binding context
		 * @param {map} mParameters Parameters to control the behavior of the action invocation
		 * @param {map} mParameters.urlParameters An optional map containing the parameters that will be passed as query strings
		 * @param {string} mParameters.batchGroupId BatchGroupId for this request
		 * @param {string} mParameters.changeSetId ChangeSetId for this request
		 * @returns {Promise} A <code>Promise</code> for asynchronous execution of the action
		 * @throws {Error} Throws an error if the function import does not exist or the action input parameters are invalid
		 * @private
		 */
		BaseController.prototype._callAction = function (sFunctionImportName, oContext, mParameters) {
			var that = this;

			if (!mParameters.urlParameters || !mParameters.functionImport) {
				mParameters = this._prepareCallAction(sFunctionImportName, oContext, mParameters);
			}

			return new Promise(function (resolve, reject) {
				var sFunctionImport, mCallBacks;

				sFunctionImport = "/" + mParameters.functionImport.name;
				mCallBacks = that._getRequestCallbacks(resolve, reject);

				that._oModel.callFunction(sFunctionImport, {
					method: mParameters.functionImport.httpMethod,
					urlParameters: mParameters.urlParameters,
					success: mCallBacks.success,
					error: mCallBacks.error,
					batchGroupId: mParameters.batchGroupId,
					changeSetId: mParameters.changeSetId,
					headers: mParameters.headers
				});
			});
		};


		/**
		 * Prepares an action call and returns a handle that grants access to a action-specific model
		 * context.
		 *
		 * @param {sap.ui.model.Context} oContext The given binding context.
		 * @param {map} mParameters Parameters to control the behavior of the action invocation.
		 * @param {map} mParameters.urlParameters An optional map containing the parameters that will be passed as query strings.
		 * @param {string} mParameters.batchGroupId BatchGroupId for this request.
		 * @param {string} mParameters.changeSetId ChangeSetId for this request.
		 * @param {string} mParameters.functionImport <code>Map</code> with information about the function import.
		 * @param {string} mParameters.headers Header fields that shall be sent with the function import.
		 *
		 * @returns {map} A <code>map</code> that contains two Promises:
		 *                <code>context</code> which provides the action-specific model context to the resolve function.
		 *                <code>result</code> which resolves when the success handler is called and rejects when the error handler is called.
		 *
		 *
		 * @throws {Error} Throws an error if the function import does not exist or the action input parameters are invalid
		 *
		 * @private
		 */
		BaseController.prototype._createFunctionContext = function (oContext, mParameters) {
			var mActionHandles = {};
			var mCallbacks;
			var that = this;

			mActionHandles.result = new Promise(function (fnResolve, fnReject) {
				mCallbacks = that._getRequestCallbacks(fnResolve, fnReject);
			});

			mActionHandles.context = this._oModel.callFunction(
				"/" + mParameters.functionImport.name,
				{
					method: mParameters.functionImport.httpMethod,
					urlParameters: mParameters.urlParameters,
					success: mCallbacks.success,
					error: mCallbacks.error,
					batchGroupId: mParameters.batchGroupId,
					changeSetId: mParameters.changeSetId,
					headers: mParameters.headers
				}
			).contextCreated();

			return mActionHandles;
		};


		/**
		 * Calculates the action header parameters - only for ETag so far.
		 *
		 * @param {sap.ui.model.Context} oContext The given binding context
		 * @param {object} oEntity The given entity.
		 * @param {map} mParameters Parameters to control the behavior of the action invocation.
		 * @throws {Error} Throws an error if the function import does not exist or the action input parameters are invalid
		 * @private
		 */
		BaseController.prototype._getActionRequestHeaders = function (oContext, oEntity, mParameters) {
			// bound actions have OData v2 annotation action-for and work on entity level: ETags only for bound actions
			var sETag;

			if (!mParameters.headers) {
				mParameters.headers = {};
			}

			// set ETag only, if it hasn't been set before, e.g. due to an overwrite action on UI -> value = '*'
			if (!mParameters.headers["If-Match"] && mParameters.functionImport["sap:action-for"]) {
				sETag = this._oModel.getETag(null, oContext, oEntity);

				if (sETag) {
					mParameters.headers["If-Match"] = sETag;
				}
			}
		};

		/**
		 * Calculates the action parameters.
		 *
		 * @param {object} oEntity The given entity
		 * @param {map} mParameters Parameters to control the behavior of the action invocation
		 * @param {array} aKeyProperties The key properties
		 * @returns {map} The action parameters
		 * @throws {Error} Throws an error if the function import does not exist or the action input parameters are invalid
		 * @private
		 */
		BaseController.prototype._getActionParameters = function (oEntity, mParameters, aKeyProperties) {
			var i, isFunctionImportParameter, length = aKeyProperties.length, mActionParameters = {}, sActionFor;

			// Bound actions have OData v2 annotation "sap:action-for" and work on entity level -> parameter of function import
			// need to contain all key properties of the corresponding entity type, except the draft properties (IsActiveEntity and DraftUUID).
			// Instance level actions without "sap:action-for" do not need to fulfill the requirement to have all keys of the entity
			// types as parameters -> therefore no hard check for completeness of key parameters.
			sActionFor = mParameters.functionImport["sap:action-for"];

			isFunctionImportParameter = function (sPropertyName) {
				if (mParameters.functionImport.parameter) {
					var j, len = mParameters.functionImport.parameter.length;

					for (j = 0; j < len; j++) {
						if (mParameters.functionImport.parameter[j].name === sPropertyName) {
							return true;
						}
					}
				}

				return false;
			};

			if (!mParameters.functionImport.parameter && sActionFor) {
				jQuery.sap.log.error("Action doesn't have any parameters");
				throw new Error("Action doesn't have any parameters");
			}

			// Map action parameters and check whether every key field of the entitytype is represented as action parameter (execption: draft parameters).
			// (based on the assumption that entitytype property and action parameter are named equal)
			for (i = 0; i < length; i++) {
				if (isFunctionImportParameter(aKeyProperties[i].name)) {
					mParameters.urlParameters[aKeyProperties[i].name] = oEntity[aKeyProperties[i].name];
				} else if (sActionFor && (aKeyProperties[i].name != "IsActiveEntity" || aKeyProperties[i].name != "DraftUUID")) {
					// only raise errors for bound actions if key is not part of function import parameters AND key is not technical draft parameter
					jQuery.sap.log.error("Action does not contain a equally-named parameter for key property: " + aKeyProperties[i].name);
					throw new Error("Action does not contain a equally-named parameter for key property: " + aKeyProperties[i].name);
				}
			}
			return mActionParameters;
		};

		/**
		 * Calculates the action parameters.
		 *
		 * @param {object} oEntity The given entity
		 * @param {map} mParameters Parameters to control the behavior of the action invocation
		 * @param {array} aKeyProperties The key properties
		 * @throws {Error} Throws an error if the function import does not exist or the action input parameters are invalid
		 * @private
		 */
		BaseController.prototype._getAdditionalActionParameters = function (oEntity, mParameters, aKeyProperties) {
			var j, length = 0, oParameterName, isKeyProperty = function (sParameterName) {
				var i = 0, len = aKeyProperties.length;

				for (i = 0; i < len; i++) {
					if (aKeyProperties[i].name === sParameterName) {
						return true;
					}
				}
				return false;
			};

			if (mParameters.functionImport.parameter) {
				length = mParameters.functionImport.parameter.length;
			}

			if (length > aKeyProperties.length) {
				// additional parameters have to be passed although part of entity
				for (j = 0; j < length; j++) {
					oParameterName = mParameters.functionImport.parameter[j];

					if (!isKeyProperty(oParameterName.name)) {
						// accept also empty parameters e.g. empty string or optional parameters (nullable=true)
						// if nullable is not set -> default is currently false on client - ideally be true
						// reason ->  Gateway rejects requests which do not contain parameters which don't have the nullable attribute at all
						var bNullable = (oParameterName.nullable === "true") ? true : false;
						if (!mParameters.urlParameters.hasOwnProperty(oParameterName.name) && !bNullable) {
							jQuery.sap.log.error("Unknown parameter " + oParameterName.name);
							throw new Error("Unknown parameter " + oParameterName.name);
						}
					}
				}
			}
		};

		/**
		 * Triggers a GET request to the OData service that has been specified in the model constructor. The data will be stored in the model. The requested data is returned with the response.
		 *
		 * @param {string} sPath The path to the data that is retrieved
		 * @param {map} mParameters Parameters to control the behavior of the request
		 * @returns {Promise} A <code>Promise</code> for asynchronous execution of the request
		 * @private
		 */
		BaseController.prototype._read = function (sPath, mParameters) {
			var that = this;

			return new Promise(function (resolve, reject) {
				var mCallBacks, urlParams;

				if (mParameters.readParameters) {
					urlParams = mParameters.readParameters;
				} else if (mParameters.urlParameters) {
					urlParams = mParameters.urlParameters;
				}

				mCallBacks = that._getRequestCallbacks(resolve, reject);

				that._oModel.read(sPath, {
					success: mCallBacks.success,
					error: mCallBacks.error,
					batchGroupId: mParameters.batchGroupId,
					changeSetId: mParameters.changeSetId,
					urlParameters: urlParams
				});
			});
		};

		/**
		 * Triggers a delete request.
		 *
		 * @param {string} sPath The path identifying the entity to be removed
		 * @param {map} mParameters Parameters to control the behavior
		 * @returns {Promise} A <code>Promise</code> for asynchronous execution
		 * @private
		 */
		BaseController.prototype._remove = function (sPath, mParameters) {
			var that = this;

			return new Promise(function (resolve, reject) {
				var mCallBacks = that._getRequestCallbacks(resolve, reject);

				that._oModel.remove(sPath, {
					success: mCallBacks.success,
					error: mCallBacks.error,
					eTag: "*",
					batchGroupId: mParameters.batchGroupId,
					changeSetId: mParameters.changeSetId
				});
			});
		};

		/**
		 * Triggers a synchronous delete request and calls the given success or error callback function afterwards.
		 *
		 * @param {string} sPath The path identifying the entity to be removed
		 * @param {map} mParameters Parameters that control the behavior
		 * @param {function} fnSuccess A callback function that is called in case of success
		 * @param {function} fnError A callback function that is called in case of error
		 * @returns {object} an object which has an <code>abort</code> function to abort the current request
		 *
		 * @private
		 * @experimental
		 */
		BaseController.prototype._syncRemove = function (sPath, mParameters, fnSuccess, fnError) {
			var mCallBacks = this._getRequestCallbacks(fnSuccess, fnError);

			return this._oModel.remove(sPath, {
				success: mCallBacks.success,
				error: mCallBacks.error,
				eTag: "*",
				batchGroupId: mParameters.batchGroupId,
				changeSetId: mParameters.changeSetId
			});
		};

		/**
		 * Submits all changes that were collected by the currently used model or does nothing,
		 * when submit is not allowed at the moment.
		 *
		 * @param {map} mParameters Parameters to control the submit behavior
		 * @param {string} mParameters.batchGroupId The ID of the batch group to use for the submit
		 * @param {string} mParameters.eTag The ETag to use for the submit
		 * @param {boolean} [mParameters.forceSubmit] Forces a submit to the back-end
		 * @returns {Promise} A <code>Promise</code> for asynchronous execution which resolves either
		 *                      with responseData and httpRequest or empty (when nothing is done)
		 *
		 * @private
		 */
		BaseController.prototype._submitChanges = function (mParameters) {
			var that = this;

			// Just resolve the promise when nothing is done (it's not an error...)
			if (!this._checkSubmit(mParameters)) {
				return Promise.resolve({ context: mParameters && mParameters.context });
			}

			return new Promise(function (resolve, reject) {
				var mCallbacks = that._getRequestCallbacks(resolve, reject);
				that._oModel.submitChanges({
					batchGroupId: mParameters.batchGroupId,
					success: mCallbacks.success,
					error: mCallbacks.error,
					eTag: mParameters.eTag
				});

			});
		};

		/**
		 * Checks whether a request has to be submitted to the back-end.
		 *
		 * @param {map} mParameters parameters to control the submit behavior
		 * @param {string} mParameters.batchGroupId the ID of the batch group to use for the submit
		 * @param {string} mParameters.eTag the eTag to use for the submit
		 * @param {boolean} [mParameters.forceSubmit] forces a submit to the back-end
		 * @returns {boolean} <code>true</code>, if a submit has to be triggered, <code>false</code> otherwise.
		 * @private
		 */
		BaseController.prototype._checkSubmit = function(mParameters) {
			// Take into consideration that no pending changes might exist and that some
			// client just might want to execute some action => forceSubmit.
			// without forceSubmit, interaction would be pending.
			if (this._oModel.hasPendingChanges()) {
				mParameters.pendingChanges = true;
				return true;
			}

			if (mParameters.forceSubmit && mParameters.forceSubmit == true) {
				// This is to avoid blocked Smart Template UIs:
				// Currently multiple logically separate requests can potentially be triggered in one
				// batch. so the result can be that we attempt to submit "empty" batch groups, which
				// will not trigger the success and error handler of the OData model's submitChanges()
				// and therefore ends in blocked UIs, as for example the busy animation is not removed.
				// Here this situation is identified for both, property changes and changing function
				// imports ("changes" array) and read requests and reading function imports
				// ("requests" array):
				if (mParameters.batchGroupId
					&& this._oModel.mDeferredRequests
					&& this._oModel.mDeferredRequests[mParameters.batchGroupId]
					&& this._oModel.mDeferredRequests[mParameters.batchGroupId].changes) { // .changes contains POSTed values
					// It is not enough to check if deferred requests exist for the given BatchGrouId, as the corresponding requests are maybe already
					// aborted. Therefore, an additional check has to be done:
					// Is there at least one entry in the request section that doesn't have a "_aborted" flag or where this is set to false?
					var aChanges = this._oModel.mDeferredRequests[mParameters.batchGroupId].changes[mParameters.changeSetId]  || [];
					for (var i = 0; i < aChanges.length; i++) {
						if (aChanges[i].request._aborted == undefined || aChanges[i].request._aborted == false) {
							return true;
						}
					}
				}
				if (mParameters.batchGroupId
					&& this._oModel.mDeferredRequests
					&& this._oModel.mDeferredRequests[mParameters.batchGroupId]
					&& this._oModel.mDeferredRequests[mParameters.batchGroupId].requests) { // .requests contains an array GET requests
					// It is not enough to check if deferred requests exist for the given BatchGrouId, as the corresponding requests are maybe already
					// aborted. Therefore, an additional check has to be done:

					var aRequests = this._oModel.mDeferredRequests[mParameters.batchGroupId].requests;

					if (aRequests.length == 0) {
						//in case there are no requests also submit
						return true;
					}

					for (var i = 0; i < aRequests.length; i++) {
						if (aRequests[i].request._aborted == undefined || aRequests[i].request._aborted == false ) {
							return true;
						}
					}
				}
			}
			// Nothing found for submission (although forceSubmit was set nothing will be submitted)
			return false;
		};

		/**
		 * Triggers submitting the currently tracked changes to the back-end.
		 *
		 * @param {map} mParameters Parameters to control the submit behavior
		 * @param {boolean} mParameters.noBlockUI If set to <code>true</code>, the current user interface is not blocked by a busy animation
		 * @param {boolean} mParameters.noShowResponse If set to <code>true</code>, no success and error messages are shown
		 * @param {boolean} mParameters.noShowSuccessToast If set to <code>true</code>, the success message is not shown in a toast
		 * @param {string} mParameters.successMsg An optional success message
		 * @param {string} mParameters.failedMsg An optional error message
		 * @returns {Promise} A <code>Promise</code> for asynchronous execution of the submit
		 * @public
		 */
		BaseController.prototype.triggerSubmitChanges = function (mParameters) {
			var that = this, fFunc,fRaiseError;

			// check and default the input.
			mParameters = mParameters || {};
			mParameters.successMsg = mParameters.successMsg || "Action succeeded";
			mParameters.failedMsg = mParameters.failedMsg || "Action failed";

			fRaiseError = function(oError) {
				// notify possible listeners of the fatal error situation.
				that.fireEvent("fatalError", {
					response: oError
				});

				throw oError;
			};


			fFunc = function() {
			return that._submitChanges(mParameters).then(function(oResponse) {
				// check for "implicitly" triggered merge requests that failed.
				try {
					that._checkImplicitError(oResponse, mParameters);

					// mind nesting of promises.
					return that._normalizeResponse(oResponse, true);

				} catch (oError) {
					fRaiseError(oError);
				}
			}, function(oResponse) {
				var oResponseOut = that._normalizeError(oResponse);

				// this call back is only invoked, if the complete request fails.
				// so if an operation in a change set fails, this is technically considered a success;
				// especially failure of individual requests does not lead to invocation of this call back.

				fRaiseError(oResponseOut);
			});
		};

			// enqueue the item to process HTTP requests in sequence.
			return this._oQueue.enqueue(fFunc, {
				draftSave: mParameters.draftSave
			});
		};

		/**
		 * Adds an operation to the Queue
		 * @param {function} fnFunction function that needs to return a <code>Promise</code>.
		 * @param {map} mEventParameters <code>Map</code> with parameters.
		 *
		 * @experimental
		 *
		 * @private
		 */
		BaseController.prototype.addOperationToQueue = function (fnFunction, mEventParameters) {
			this._oQueue.enqueue(fnFunction, mEventParameters);
		};

		/**
		 * Attach to queue event that is fired whenever an item is going to be executed
		 * @param {function} fnFunction event handler function
		 * @experimental
		 */
		BaseController.prototype.attachBeforeQueueItemProcess = function (fnFunction) {
			this._oQueue._attachEvent('beforeQueueItemProcess', fnFunction);
		};
		/**
		 * Detach to queue event that is fired whenever an item is going to be executed
		 * @param {function} fnFunction event handler function
		 * @experimental
		 */
		BaseController.prototype.detachBeforeQueueItemProcess = function (fnFunction) {
			this._oQueue._detachEvent('beforeQueueItemProcess', fnFunction);
		};
		/**
		 * Attach to queue event that is fired once the last item in the queue was processed
		 * @param {function} fnFunction event handler function
		 * @experimental
		 */
		BaseController.prototype.attachOnQueueCompleted = function (fnFunction) {
			this._oQueue._attachEvent('onQueueCompleted', fnFunction);
		};
		/**
		 * Detach to queue event that is fired once the last item in the queue was processed
		 * @param {function} fnFunction event handler function
		 * @experimental
		 */
		BaseController.prototype.detachOnQueueCompleted = function (fnFunction) {
			this._oQueue._detachEvent('onQueueCompleted', fnFunction);
		};
		/**
		 * Attach to queue event that is fired once one item in the queue fails
		 * @param {function} fnFunction event handler function
		 * @experimental
		 */
		BaseController.prototype.attachOnQueueFailed = function (fnFunction) {
			this._oQueue._attachEvent('onQueueFailed', fnFunction);
		};
		/**
		 * Detach to queue event that is fired once one item in the queue fails
		 * @param {function} fnFunction event handler function
		 * @experimental
		 */
		BaseController.prototype.detachOnQueueFailed = function (fnFunction) {
			this._oQueue._detachEvent('onQueueFailed', fnFunction);
		};


		/**
		 * Checks for client messages.
		 *
		 * @returns {Promise} If client-side messages exist a rejected promise is returned, <code>null</code> otherwise
		 * @public
		 */
		BaseController.prototype.hasClientMessages = function () {
			if (this._oModelUtil.hasClientMessages()) {
				return Promise.reject(new Error("Client messages detected"));
			}

			return null;
		};

		/**
		 * Converts the response into an object with two properties, <code>response</code> that represents the response of the HTTP request and
		 * <code>context</code> that is the binding context.
		 *
		 * @param {object} oResponse The given response
		 * @param {boolean} bContext Flag indicating whether context has to be added
		 * @returns {object} The response object
		 * @private
		 */
		BaseController.prototype._normalizeResponse = function (oResponse, bContext) {
			if (oResponse && (oResponse.httpResponse || oResponse.responseData)) {
				return {
					data: oResponse.responseData,
					response: oResponse.httpResponse || null,
					context: bContext ? this._oModelUtil.getContextFromResponse(oResponse.responseData) : null
				};
			}

			return oResponse;
		};

		/**
		 * Converts the error response into an object with one property, <code>response</code>, which represents the response of the failed HTTP
		 * request.
		 *
		 * @param {object} oResponse The given response
		 * @returns {object} The response object
		 * @private
		 */
		BaseController.prototype._normalizeError = function (oResponse) {
			if (oResponse && oResponse.message) {
				return {
					response: oResponse
				};
			}

			return oResponse;
		};

		/**
		 * Creates a sync point for using multiple promises and returns a promise to use for chaining.
		 *
		 * @param {array} aPromises The promises
		 * @returns {Promise} A promise for chaining
		 * @private
		 */
		BaseController.prototype._returnPromiseAll = function (aPromises) {
			return Promise.all(aPromises).then(function (oResponse) {
				// on successful execution an array of the collected responses for all sub-ordinate promises is created by Promise.all and returned.
				// so take the first response, as it has a context object.
				if (oResponse.length) {
					return oResponse[0];
				}

				return oResponse;
			});
		};

		/**
		 * Returns a promise which resolves if the given promises have been executed with at least one successfully. It rejects if all given promises were rejected.
		 *
		 * @param {array} aPromises Array containing promises and a flag if the result should be included in the response
		 * @param {boolean} bDropLastResult When set to <code>true</code>, the result of the last <code>Promise</code> is not returned
		 *
		 * @returns {object} A promise which will wait for all given promises to finish.
		 *
		 * @since 1.40
		 * @private
		 */
		BaseController.prototype._atLeastOnePromiseResolved = function (aPromises, bDropLastResult) {
			var aResponses = [];
			var oReadyPromise = Promise.resolve(null);
			var bAtLeastOneSuccess = false;

			var aPromisesLength = aPromises.length;
			var fnResolve = function (oResponse) {
				if (!bDropLastResult) {
					aResponses.push(oResponse);
					bAtLeastOneSuccess = true;
				} else if (aPromisesLength - 1 > aResponses.length && bDropLastResult) {
					aResponses.push(oResponse);
					bAtLeastOneSuccess = true;
				}
			};

			aPromises.forEach(function (oPromise, iIndex) {
				oReadyPromise = oReadyPromise.then(function () {
					return oPromise;
				}).then(fnResolve, function (oError) {
					aResponses.push(oError);
				}, this);
			});

			return oReadyPromise.then(function () {

				if (bAtLeastOneSuccess) {
					return Promise.resolve(aResponses);
				} else {
					return Promise.reject(aResponses);
				}

			});
		};

		/**
		 * Checks a batch response for implicitly triggered patch or merge requests.
		 *
		 * @param {object} oResponse The response of the HTTP request
		 * @param {map} mParameters Parameters to control the submit behavior
		 * @param {boolean} mParameters.noBlockUI If set to <code>true</code> the current user interface is not blocked by a busy animation
		 * @param {boolean} mParameters.noShowResponse If set to <code>true</code> no success and error messages are shown
		 * @param {boolean} mParameters.noShowSuccessToast If set to <code>true</code> the success message is not shown in a toast
		 * @param {string} mParameters.successMsg An optional success message
		 * @param {string} mParameters.failedMsg An optional error message
		 * @throws {object} Error object, if a requests was triggered that submits implicitly changes to the back-end.
		 * @private
		 */
		BaseController.prototype._checkImplicitError = function (oResponse, mParameters) {
			var oPart, oParsed, iStatus, bCounts = false;

			// check the counters
			if (this._mCounts.requestSent === 1 && this._mCounts.requestCompleted === 1) {
				bCounts = true;
			}

			this._initCounts();

			// if a batch request with one batch containing only changes has been sent to the back-end
			// and fails, the "success" call-back is invoked.
			// so we check for error in such situations.
			if (mParameters.pendingChanges && bCounts) {
				if (oResponse && oResponse.responseData && oResponse.responseData.__batchResponses && (oResponse.responseData.__batchResponses.length === 1)) {
					oPart = oResponse.responseData.__batchResponses[0];
				}

				if (oPart && oPart.response && oPart.response.statusCode) {
					iStatus = parseInt(oPart.response.statusCode, 10);

					// check whether the request failed and throw in this case an exception.
					if (iStatus < 200 || iStatus > 299) {
						oParsed = this._parseError(oPart);
						throw this._normalizeError(oParsed);
					}
				}
			}
		};

		/**
		 * Converts a batch response part to an error message.
		 *
		 * @param {object} oPart The response part
		 * @returns {object} Error message
		 * @private
		 */
		BaseController.prototype._parseError = function (oPart) {
			var oResult = {};

			if (oPart.message) {
				oResult.message = oPart.message;
			}

			if (oPart.response) {
				oResult.statusCode = oPart.response.statusCode;
				oResult.statusText = oPart.response.statusText;
				oResult.headers = oPart.response.headers;
				oResult.responseText = oPart.response.body;
			}

			return oResult;
		};

		/**
		 * Sets the request counters to their initial state.
		 *
		 * @private
		 */
		BaseController.prototype._initCounts = function () {
			this._mCounts = {
				requestSent: 0,
				requestCompleted: 0
			};
		};

		/**
		 * Returns the call-backs for HTTP response handling.
		 *
		 * @param {function} resolve Callback from <code>Promise</code>
		 * @param {function} reject Callback from <code>Promise</code>
		 * @returns {map} Callback functions for success and error handling of HTTP responses
		 * @private
		 */
		BaseController.prototype._getRequestCallbacks = function (resolve, reject) {
			var that = this;

			// increment request count.
			this._mCounts.requestSent++;

			return {
				success: function (oData, oResponse) {
					// increment request completed count.
					that._mCounts.requestCompleted++;

					// resolve the promise.
					resolve({
						responseData: oData,
						httpResponse: oResponse
					});
				},
				error: function (oResponse) {
					// increment request completed count.
					that._mCounts.requestCompleted++;

					// reject the promise.
					reject(oResponse);
				}
			};
		};

		/**
		 * Frees all resources claimed during the life-time of this instance.
		 *
		 * @public
		 */
		BaseController.prototype.destroy = function () {
			if (this._oModelUtil) {
				this._oModelUtil.destroy();
			}

			if (this._oQueue && this._bOwnsQueue) {
				this._oQueue.destroy();
			}

			this._oModel = null;
			this._oMeta = null;
			this._oDraftUtil = null;
			this._oModelUtil = null;
		};

		return BaseController;

	}, true);

}; // end of sap/ui/generic/app/transaction/BaseController.js
if ( !jQuery.sap.isDeclared('sap.ui.generic.app.transaction.DraftContext') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.ui.generic.app.transaction.DraftContext'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('jquery.sap.global'); // unlisted dependency retained
jQuery.sap.require('sap.ui.base.Object'); // unlisted dependency retained
sap.ui.define("sap/ui/generic/app/transaction/DraftContext",[	"jquery.sap.global", "sap/ui/base/Object", "sap/ui/generic/app/util/ModelUtil" ], function(jQuery, BaseObject, ModelUtil) {
	"use strict";

	/**
	 * Constructor for meta-model access class.
	 * 
	 * @public
	 * @class The class provides access to information on draft handling that is available in the
	 *        OData service's metadata as it interprets draft-specific annotations.
	 * @author SAP SE
	 * @version 1.50.6
	 * @since 1.30.0
	 * @alias sap.ui.generic.app.transaction.DraftContext
	 * @param {sap.ui.model.odata.ODataModel} oModel The OData model currently used
	 * @throws {Error} If no model is handed over as input parameter
	 */
	var DraftContext = BaseObject.extend("sap.ui.generic.app.transaction.DraftContext", {
		metadata: {
			publicMethods: [
				"isDraftEnabled", "isDraftRoot", "hasDraft", "hasDraftRoot", "hasDraftValidationFunction", "hasDraftPreparationAction", "isTechnicalKey", "isSemanticKey", "getSemanticKey", "checkUpdateOnChange", 
				"getODataDraftFunctionImportName", "hasDraftAdministrativeData", "hasSiblingEntity", "destroy", "hasPreserveChanges"
			]
		},

		constructor: function(oModel) {
			// model is a mandatory parameter.
			if (!oModel) {
				throw new Error("No model");
			}

			this._oModel = oModel;
			this._oMeta = oModel.getMetaModel();
			this._oModelUtil = new ModelUtil(oModel);

			return this.getInterface();
		}
	});

	/**
	 * Checks whether a given entity set is draft-enabled.
	 *
	 * @param {string} sEntitySet The name of the entity set
	 * @returns {boolean} <code>true</code>, if a given entity set is draft-enabled, <code>false</code> otherwise
	 * @throws {Error} If no entity set is handed over as input parameter
	 * @public
	 */
	DraftContext.prototype.isDraftEnabled = function(sEntitySet) {
		var oDraftEntitySet = this._getODataDraftEntitySet(sEntitySet);
		return !!(oDraftEntitySet && oDraftEntitySet.isDraft);
	};

	/**
	 * Checks whether a given entity set is a draft root.
	 *
	 * @param {string} sEntitySet The name of the entity set
	 * @returns {boolean} <code>true</code>, if a given entity set is draft root, <code>false</code> otherwise
	 * @throws {Error} If no entity set is handed over as input parameter
	 * @public
	 */
	DraftContext.prototype.isDraftRoot = function(sEntitySet) {
		var oDraftEntitySet = this._getODataDraftEntitySet(sEntitySet);
		return !!(oDraftEntitySet && oDraftEntitySet.isRoot);
	};

	/**
	 * Checks whether an entity set is draft-enabled. The entity set name is derived from the given binding context
	 *
	 * @param {sap.ui.model.Context} oContext The given binding context
	 * @returns {boolean} <code>true</code>, if a given entity set is draft-enabled, <code>false</code> otherwise
	 * @throws {Error} If no context is handed over as input parameter
	 * @public
	 */
	DraftContext.prototype.hasDraft = function(oContext) {
		var sEntitySet = ModelUtil.getEntitySetFromContext(oContext);
		if (sEntitySet == null) {
			return false;
		}
		return this.isDraftEnabled(sEntitySet);
	};

	/**
	 * Checks whether an entity set is draft root. The entity set name is derived from the given binding context.
	 *
	 * @param {sap.ui.model.Context} oContext The given binding context
	 * @returns {boolean} <code>true</code>, if a given entity set is draft root, <code>false</code> otherwise
	 * @throws {Error} If no context is handed over as input parameter
	 * @public
	 */
	DraftContext.prototype.hasDraftRoot = function(oContext) {
		var sEntitySet = ModelUtil.getEntitySetFromContext(oContext);
		return this.isDraftRoot(sEntitySet);
	};

	/**
	 * Checks whether an entity set has a draft validation function. The entity set name is derived from the given binding context.
	 *
	 * @param {sap.ui.model.Context} oContext The given binding context
	 * @returns {boolean} <code>true</code>, if a given entity set has a draft validation function, <code>false</code> otherwise
	 * @throws {Error} If no context is handed over as input parameter
	 * @public
	 */
	DraftContext.prototype.hasDraftValidationFunction = function(oContext) {
		return !!this.getODataDraftFunctionImportName(oContext, "ValidationFunction");
	};

	/**
	 * Checks whether an entity set has a draft preparation action. The entity set name is derived from the given binding context.
	 *
	 * @param {sap.ui.model.Context} oContext The given binding context
	 * @returns {boolean} <code>true</code>, if a given entity set has a draft preparation action, <code>false</code> otherwise
	 * @throws {Error} If no context is handed over as input parameter
	 * @public
	 */
	DraftContext.prototype.hasDraftPreparationAction = function(oContext) {
		return !!this.getODataDraftFunctionImportName(oContext, "PreparationAction");
	};

	/**
	 * Checks whether a given key is a technical key.
	 *
	 * @param {string} sEntitySet The name of the entity set
	 * @param {object} oKeys The given key
	 * @returns {boolean} <code>true</code>, if a given key is a technical key, <code>false</code> otherwise
	 * @throws {Error} If no entity set is handed over as input parameter
	 * @public
	 */
	DraftContext.prototype.isTechnicalKey = function(sEntitySet, oKeys) {
		var oEntitySet, oEntityType, iKeys, i, sKey;

		if (!sEntitySet) {
			throw new Error("No entity set");
		}

		oEntitySet = this._oMeta.getODataEntitySet(sEntitySet);
		oEntityType = this._oMeta.getODataEntityType(oEntitySet.entityType);
		iKeys = oEntityType.key.propertyRef.length;

		// different amount of keys
		if (Object.keys(oKeys).length !== iKeys) {
			return false;
		}

		for (i = 0; i < iKeys; i++) {
			sKey = oEntityType.key.propertyRef[i].name;

			if (!oKeys[sKey]) {
				return false;
			}
		}

		return true;
	};

	/**
	 * Checks whether a given key is a semantic key.
	 *
	 * @param {string} sEntitySet The name of the entity set
	 * @param {object} oKeys The given key
	 * @returns {boolean} <code>true</code>, if a given key is a semantic key, <code>false</code> otherwise
	 * @throws {Error} If no entity set is handed over as input parameter
	 * @public
	 */
	DraftContext.prototype.isSemanticKey = function(sEntitySet, oKeys) {
		var aSemanticKeyProperties, i, len;

		if (this.isDraftEnabled(sEntitySet)) {
			aSemanticKeyProperties = this.getSemanticKey(sEntitySet);
			len = aSemanticKeyProperties.length;

			for (i = 0; i < len; i++) {
				if (!oKeys[aSemanticKeyProperties[i].name]) {
					return false;
				}
			}

			return true;
		}

		return false;
	};

	/**
	 * Returns the semantic keys for a given entity set.
	 *
	 * @param {string} sEntitySet The given entity set
	 * @returns {array} The semantic keys
	 * @throws {Error} If no entity set is handed over as input parameter
	 * @public
	 */
	DraftContext.prototype.getSemanticKey = function(sEntitySet) {
		var oEntitySet, oEntityType, aSemanticKeys, aSemanticKey = [], i, len;

		if (!sEntitySet) {
			throw new Error("No entity set");
		}

		oEntitySet = this._oMeta.getODataEntitySet(sEntitySet);
		oEntityType = this._oMeta.getODataEntityType(oEntitySet.entityType);
		aSemanticKeys = oEntityType["com.sap.vocabularies.Common.v1.SemanticKey"];

		if (aSemanticKeys) {
			len = aSemanticKeys.length;

			for (i = 0; i < len; i++) {
				// to be conform to property-reference of keys -> name : value
				aSemanticKey.push({name : aSemanticKeys[i].PropertyPath});
			}
		}

		return aSemanticKey;
	};

	/**
	 * Returns the name of the function import to be used.
	 *
	 * @param {sap.ui.model.Context} oContext The given binding context
	 * @param {string} sDraftFunctionImport The draft function import
	 * @returns {string} The name of the function import to be used
	 * @throws {Error} If no context is handed over as input parameter
	 * @public
	 */
	DraftContext.prototype.getODataDraftFunctionImportName = function(oContext, sDraftFunctionImport) {
		var sEntitySet, oDraftEntitySet;

		sEntitySet = ModelUtil.getEntitySetFromContext(oContext);
		oDraftEntitySet = this._getODataDraftEntitySet(sEntitySet);

		if (oDraftEntitySet.oDraft[sDraftFunctionImport] && oDraftEntitySet.oDraft[sDraftFunctionImport].String) {
			return oDraftEntitySet.oDraft[sDraftFunctionImport].String;
		}

		return null;
	};

	/**
	 * Calculates the description of an entity set with regards to draft enablement.
	 *
	 * @param {string} sEntitySet The name of the entity set
	 * @returns {object} The description of an entity set
	 * @throws {Error} If no entity set is handed over as input parameter
	 * @private
	 */
	DraftContext.prototype._getODataDraftEntitySet = function(sEntitySet) {
		var oODataDraftEntitySet = {}, oEntitySet;

		if (!sEntitySet) {
			throw new Error("No entity set");
		}

		oEntitySet = this._oMeta.getODataEntitySet(sEntitySet);
		oODataDraftEntitySet.ODataEntitySet = oEntitySet;

		if (oEntitySet["com.sap.vocabularies.Common.v1.DraftRoot"]) {
			oODataDraftEntitySet.isDraft = true;
			oODataDraftEntitySet.isRoot = true;
			oODataDraftEntitySet.oDraft = oEntitySet["com.sap.vocabularies.Common.v1.DraftRoot"];
		} else if (oEntitySet["com.sap.vocabularies.Common.v1.DraftNode"]) {
			oODataDraftEntitySet.isDraft = true;
			oODataDraftEntitySet.isRoot = false;
			oODataDraftEntitySet.oDraft = oEntitySet["com.sap.vocabularies.Common.v1.DraftNode"];
		}

		return oODataDraftEntitySet;
	};

	/**
	 * Checks whether administrative data for a given draft is available.
	 *
	 * @param {string} sEntitySet The name of the entity set
	 * @returns {boolean} <code>true</code>, if administrative data is available, <code>false</code> otherwise 
	 * @public
	 */
	DraftContext.prototype.hasDraftAdministrativeData = function(sEntitySet) {
		return this._hasNavigationProperty(sEntitySet, "DraftAdministrativeData");
	};

	/**
	 * Checks whether a sibling entity for a given entity set is available.
	 *
	 * @param {string} sEntitySet The name of the entity set
	 * @returns {boolean} <code>true</code>, if sibling entity is available, <code>false</code> otherwise 
	 * @public
	 */
	DraftContext.prototype.hasSiblingEntity = function(sEntitySet) {
		return this._hasNavigationProperty(sEntitySet, "SiblingEntity");
	};

	/**
	 * Checks whether entity type of given entity set has the navigation property.
	 *
	 * @param {string} sEntitySet The name of the entity set
	 * @param {string} sNavigationProperty The name of the navigation property 
	 * @returns {boolean} <code>true</code>, if navigation property exists, <code>false</code> otherwise
	 * @private
	 */
	DraftContext.prototype._hasNavigationProperty = function(sEntitySet, sNavigationProperty) {
		var oEntitySet, oEntityType, i, len;

		oEntitySet = this._oMeta.getODataEntitySet(sEntitySet);
		oEntityType = this._oMeta.getODataEntityType(oEntitySet.entityType);

		if (oEntityType.navigationProperty) {
			len = oEntityType.navigationProperty.length;

			for (i = 0; i < len; i++) {
				if (oEntityType.navigationProperty[i].name === sNavigationProperty) {
					return true;
				}
			}
		}

		return false;
	};

	/**
	 * Checks whether an OData property is annotated with UpdateOnChange. The method is used in context of a validation success event.
	 *
	 * @param {string} sEntitySet The name of the entity set
	 * @param {string} sProperty The name of the property
	 * @return {boolean} <code>true</code>, if the property is annotated with UpdateOnChange, <code>false</code> otherwise
	 * @throws {Error} If no entity set is handed over as input parameter
	 * @public
	 * @deprecated Since 1.32.0
	 */
	DraftContext.prototype.checkUpdateOnChange = function(sEntitySet, sProperty) {
		var sProp, oEntitySet, oSideEffect;

		if (!sEntitySet) {
			throw new Error("No entity set");
		}

		oEntitySet = this._oMeta.getODataEntitySet(sEntitySet);

		for (sProp in oEntitySet) {
			if (sProp.indexOf && sProp.indexOf("com.sap.vocabularies.Common.v1.SideEffects") === 0) {
				oSideEffect = oEntitySet[sProp];

				if (oSideEffect.SourceProperties && oSideEffect.SourceProperties.length) {
					if (oSideEffect.SourceProperties.length === 1 && oSideEffect.SourceProperties[0].PropertyPath) {
						if (oSideEffect.SourceProperties[0].PropertyPath === sProperty) {
							return true;
						}
					}
				}
			}
		}
		return false;
	};

	/**
	 * Checks if the parameter "PreserveChanges" is supported by the edit function.
	 * If the edit action is triggered with the parameter set to <code>true</code> the
	 * ABAP application infrastructure will respond with HTTP response code 409 if unsaved 
	 * changes (from another user) exist.
	 *
	 * @returns {boolean} <code>true</code>, if "PreserveChanges" is supported
	 *
	 * @throws {Error} If no context is handed over as input parameter
	 *
	 * @since 1.38
	 * @public
	 */
	DraftContext.prototype.hasPreserveChanges = function(oContext) {
		var oEditFunction = this._oMeta.getODataFunctionImport(this.getODataDraftFunctionImportName(oContext, "EditAction"));
		if (oEditFunction && oEditFunction.parameter) {
			for (var i = 0; i < oEditFunction.parameter.length; i++) {
				var oParameter = oEditFunction.parameter[i];
				if (oParameter.mode === 'In' && oParameter.name === "PreserveChanges") {
					return true;
				}
			}
		}
		return false;
	};

	/**
	 * Frees all resources claimed during the life-time of this instance.
	 *
	 * @public
	 */
	DraftContext.prototype.destroy = function() {
		if (this._oModelUtil) {
			this._oModelUtil.destroy();
		}

		this._oModelUtil = null;
		this._oModel = null;
		this._oMeta = null;
	};

	return DraftContext;

}, true);

}; // end of sap/ui/generic/app/transaction/DraftContext.js
if ( !jQuery.sap.isDeclared('sap.ui.generic.app.transaction.DraftController') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.ui.generic.app.transaction.DraftController'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('jquery.sap.global'); // unlisted dependency retained
sap.ui.define("sap/ui/generic/app/transaction/DraftController",[	"jquery.sap.global", "./BaseController", "./DraftContext" ], function(jQuery, BaseController, DraftContext) {
	"use strict";

	/* global Promise */

	/**
	 * Constructor for a new draft controller instance.
	 *
	 * @public
	 * @class Gives access to runtime draft handling for applications. Assuming state-less communication, each single data modification request (or
	 *        change set in an OData $batch request) is a "mini-transaction", which saves data to the database. The class implements the transactional
	 *        interaction patterns specified for OData services that support draft documents and provides methods for draft-specific actions, for
	 *        example validate, prepare, activate.
	 *
	 *        Additionally, it handles transactional request processing, ensures concurrency control and correct
	 *        ETag handling. It provides access to the simple interaction patterns of runtime handling for drafts according to the draft
	 *        specification. These can be combined as required by client applications. Additionally, error handling is provided to notify client
	 *        implementations of error situations. The event <code>fatalError</code> is thrown, if fatal errors occur during execution of OData
	 *        requests.
	 * @author SAP SE
	 * @version 1.50.6
	 * @since 1.30.0
	 * @alias sap.ui.generic.app.transaction.DraftController
	 * @param {sap.ui.model.odata.ODataModel} oModel The OData model currently used
	 * @param {sap.ui.generic.app.util.Queue} oQueue Optional HTTP request queue
	 * @throws {Error} Throws an error if no model is handed over as input parameter
	 */
	var DraftController = BaseController.extend("sap.ui.generic.app.transaction.DraftController", {
		metadata: {
			publicMethods: [
				"getDraftContext", "getDraftForActiveEntity", "createNewDraftEntity", "createEditDraftEntity", "validateDraftEntity", "validateDraft", "prepareDraft", "prepareDraftEntity", "saveAndPrepareDraftEntity", "activateDraftEntity", "isActiveEntity", "hasActiveEntity", "destroy"
			]
		},

		constructor: function(oModel, oQueue) {
			BaseController.apply(this, [
				oModel, oQueue
			]);
			this.sName = "sap.ui.generic.app.transaction.DraftController";
			this._oContext = null;
		}
	});

	/**
	 * Returns the current draft context instance. If no instance exists, it is created lazily.
	 *
	 * @returns {sap.ui.generic.app.transaction.DraftContext} The current draft context instance
	 * @public
	 */
	DraftController.prototype.getDraftContext = function() {
		if (!this._oContext) {
			this._oContext = new DraftContext(this._oModel);
		}

		return this._oContext;
	};

	/**
	 * Creates a new draft instance.
	 *
	 * @param {string} sEntitySet The name of the entity set
	 * @param {string} sPath Path identifying the new entity instance
	 * @param {map} mParameters Parameters to control the behavior of the request
	 * @param {string} mParameters.batchGroupId The ID of the batch group to use
	 * @param {string} mParameters.changeSetId The ID of the change set to use
	 * @returns {Promise} A <code>Promise</code> for asynchronous execution
	 * @throws {Error} Throws an error if no entity set is handed over as input parameter
	 * @private
	 */
	DraftController.prototype.createDraft = function(sEntitySet, sPath, mParameters) {
		var that = this;

		if (!sEntitySet) {
			throw new Error("No entity set");
		}

		mParameters = mParameters || {};

		return new Promise(function(resolve, reject) {
			var fnSuccess = function(oData, oResponse) {
				resolve({
					responseData: oData,
					httpResponse: oResponse
				});
			};

			var createdContext;
			var fnError = function(oError){
				that._oModel.deleteCreatedEntry(createdContext);
				reject(oError);
			};

			createdContext = that._oModel.createEntry(sPath, {
				success: fnSuccess,
				error: fnError,
				batchGroupId: mParameters.batchGroupId,
				changeSetId: mParameters.changeSetId
			});
		});
	};

	/**
	 * Validates a draft in the back-end.
	 *
	 * @param {sap.ui.model.Context} oContext The given binding context
	 * @param {map} mParameters Parameters to control the behavior
	 * @returns {Promise} A <code>Promise</code> for asynchronous execution
	 * @throws {Error} Throws an error if no context is handed over as input parameter or if the function import does not exist or the action input
	 *         parameters are invalid
	 * @private
	 */
	DraftController.prototype.validateDraft = function(oContext, mParameters) {
		if (!oContext.getModel().getObject(oContext.getPath()).IsActiveEntity) {
			var oImport = this.getDraftContext().getODataDraftFunctionImportName(oContext, "ValidationFunction");
			return this._callAction(oImport, oContext, mParameters);
		} else {
			return Promise.resolve();
		}
	};

	/**
	 * Prepares a draft in the back-end.
	 *
	 * @param {sap.ui.model.Context} oContext The given binding context
	 * @param {map} mParameters Parameters to control the behavior
	 * @returns {Promise} A <code>Promise</code> for asynchronous execution
	 * @throws {Error} Throws an error if no context is handed over as input parameter or if the function import does not exist or the action input
	 *         parameters are invalid
	 * @private
	 */
	DraftController.prototype.prepareDraft = function(oContext, mParameters) {
		if (!oContext.getModel().getObject(oContext.getPath()).IsActiveEntity) {
			var oImport;
	
			mParameters = mParameters || {};
			mParameters.urlParameters = mParameters.urlParameters || {};
	
			oImport = this.getDraftContext().getODataDraftFunctionImportName(oContext, "PreparationAction");
			return this._callAction(oImport, oContext, mParameters);
		} else {
			return Promise.resolve();
		}

	};

	/**
	 * Activates a draft in the back-end.
	 *
	 * @param {sap.ui.model.Context} oContext The given binding context
	 * @param {map} mParameters Parameters to control the behavior
	 * @returns {Promise} A <code>Promise</code> for asynchronous execution
	 * @throws {Error} Throws an error if no context is handed over as input parameter or if the function import does not exist or the action input
	 *         parameters are invalid
	 * @private
	 */
	DraftController.prototype.activateDraft = function(oContext, mParameters) {
		var oImport = this.getDraftContext().getODataDraftFunctionImportName(oContext, "ActivationAction");
		return this._callAction(oImport, oContext, mParameters);
	};

	/**
	 * Creates an edit draft in the back-end.
	 *
	 * @param {sap.ui.model.Context} oContext The given binding context
	 * @param {map} mParameters Parameters to control the behavior
	 * @returns {Promise} A <code>Promise</code> for asynchronous execution
	 * @throws {Error} Throws an error if no context is handed over as input parameter or if the function import does not exist or the action input
	 *         parameters are invalid
	 * @private
	 */
	DraftController.prototype.editDraft = function(oContext, mParameters) {
		var oImport = this.getDraftContext().getODataDraftFunctionImportName(oContext, "EditAction");
		return this._callAction(oImport, oContext, mParameters);
	};

	/**
	 * Removes a draft in the back-end.
	 *
	 * @param {sap.ui.model.Context} oContext The given binding context
	 * @param {map} mParameters Parameters to control the behavior
	 * @returns {Promise} A <code>Promise</code> for asynchronous execution
	 * @throws {Error} Throws an error if no context is handed over as input parameter
	 * @private
	 */
	DraftController.prototype.discardDraft = function(oContext, mParameters) {
		if (!oContext) {
			throw new Error("No context");
		}

		return this._remove(oContext.getPath(), mParameters);
	};

	/**
	 * Retrieves a possibly existing draft entity for the given active entity using the binding context of the active entity from the back-end.
	 *
	 * @param {sap.ui.model.Context} oContext The binding context of the active entity
	 * @param {map} mParameters Parameters to control the behavior
	 * @returns {Promise} A <code>Promise</code> for asynchronous execution
	 * @throws {Error} Throws an error if no context is handed over as input parameter
	 * @private
	 * @since 1.32.0
	 */
	DraftController.prototype.getDraftForActive = function(oContext, mParameters) {
		var that = this;

		if (!oContext) {
			throw new Error("No context");
		}

		mParameters = mParameters || {};
		mParameters.urlParameters = {
			"$expand": "SiblingEntity"
		};

		return this._read(oContext.getPath(), mParameters).then(function(oResponse) {
			if (oResponse.responseData && oResponse.responseData.hasOwnProperty("SiblingEntity")) {
				oResponse.context = that._oModel.getContext("/" + that._oModel.getKey(oResponse.responseData.SiblingEntity));
				return oResponse;
			}

			throw new Error("No draft entity could be found");
		});
	};

	/**
	 * Retrieves a possibly existing draft entity for the given active entity using the binding context of the active entity from the back-end.
	 *
	 * @param {sap.ui.model.Context} oContext The binding context of the active entity
	 * @returns {Promise} A <code>Promise</code> for asynchronous execution
	 * @throws {Error} Throws an error if no context is handed over as input parameter
	 * @public
	 * @since 1.32.0
	 */
	DraftController.prototype.getDraftForActiveEntity = function(oContext) {
		var oPromise, oPromise2, that = this, mParameters = {
			batchGroupId: "Changes",
			changeSetId: "Changes",
			noShowSuccessToast: true,
			forceSubmit: true
		};

		oPromise = this.getDraftForActive(oContext, mParameters).then(function(oResponse) {
			return oResponse;
		}, function(oResponse) {
			throw that._normalizeError(oResponse);
		});
		oPromise2 = this.triggerSubmitChanges(mParameters);

		// continue, if all "sub-ordinate" promises have been resolved.
		return this._returnPromiseAll([
			oPromise, oPromise2
		]);
	};

	/**
	 * Creates a new edit draft on the client and sends it to the back-end. Additionally, possible changes that have been collected on the client are
	 * sent to the back-end.
	 *
	 * @param {string} sEntitySet The name of the entity set
	 * @param {string} sPath Path identifying the new entity instance
	 * @returns {Promise} A <code>Promise</code> for asynchronous execution of the request
	 * @public
	 */
	DraftController.prototype.createNewDraftEntity = function(sEntitySet, sPath) {
		var oPromise, oPromise2, that = this, mParameters = {
			batchGroupId: "Changes",
			changeSetId: "Changes",
			noShowSuccessToast: true,
			forceSubmit: true,
			failedMsg: "New draft document could not be created"
		};

		oPromise = this.createDraft(sEntitySet, sPath, mParameters).then(function(oResponse) {
			return that._normalizeResponse(oResponse, true);
		}, function(oResponse) {
			var oResponseOut = that._normalizeError(oResponse);
			throw oResponseOut;
		});
		oPromise2 = this.triggerSubmitChanges(mParameters).then(function() {
			return oPromise.then(function(oResponse) {
				var bIsActiveEntity, bHasDraftEntity, oResponseEntity, oResponseOut = that._normalizeResponse(oResponse, true);

				// mind nesting of promises and error situation.
				if (oResponseOut.context) {
					oResponseEntity = oResponseOut.context.getObject();
				}

				if (!oResponseEntity) {
					jQuery.sap.log.error("Activate function returned no entity");
					return Promise.reject(new Error("Activate function returned no entity"));
				}
				bIsActiveEntity = that._oDraftUtil.isActiveEntity(oResponseEntity);
				if (bIsActiveEntity) {
					jQuery.sap.log.error("New draft entity is not marked as draft - isActiveEntity = " + bIsActiveEntity);
					return Promise.reject("New draft entity is not marked as draft - isActiveEntity = " + bIsActiveEntity);
				}
				bHasDraftEntity = that._oDraftUtil.hasDraftEntity(oResponseEntity);
				if (bHasDraftEntity) {
					jQuery.sap.log.error("Wrong value for HasTwin of new draft entity - HasDraftEntity = " + bHasDraftEntity);
					return Promise.reject(new Error("Wrong value for HasTwin of new draft entity - HasDraftEntity = " + bHasDraftEntity));
				}

				return oResponseOut;
			});
		});

		// continue, if all "sub-ordinate" promises have been resolved.
		return this._returnPromiseAll([
			oPromise, oPromise2
		]);
	};

	/**
	 * Creates an edit draft in the back-end. Additionally, possible changes that have been collected on the client are sent to the back-end.
	 *
	 * @param {sap.ui.model.Context} oContext The given binding context
	 * @param {boolean} [bPreserveChanges] Set to <code>true</code> to avoid the creation of a new draft when unsaved changes exist in the back-end
	 * @returns {Promise} A <code>Promise</code> for asynchronous execution
	 * @public
	 */
	DraftController.prototype.createEditDraftEntity = function(oContext, bPreserveChanges) {
		var oPromise, oPromise2, that = this, mParameters = {
			batchGroupId: "Changes",
			changeSetId: "Changes",
			successMsg: "Draft for document was created",
			failedMsg: "Could not create draft for document",
			forceSubmit: true,
			context: oContext
		};
		if (bPreserveChanges) {
			mParameters.urlParameters = { PreserveChanges: true };
		}

		oPromise = this.editDraft(oContext, mParameters).then(function(oResponse) {
			var bIsActiveEntity, oResponseEntity, oResponseOut;

			oResponseOut = that._normalizeResponse(oResponse, true);

			// mind nesting of promises and error situation.
			if (oResponseOut.context) {
				oResponseEntity = oResponseOut.context.getObject();
			}

			if (!oResponseEntity) {
				jQuery.sap.log.error("Activate function returned no entity");
				return Promise.reject(new Error("Activate function returned no entity"));
			}

			bIsActiveEntity = that._oDraftUtil.isActiveEntity(oResponseEntity);
			if (bIsActiveEntity) {
				jQuery.sap.log.error("Edit function returned an entity which is not a draft instance - IsActiveEntity = " + bIsActiveEntity);
				return Promise.reject(new Error("Returned entity ist not a draft instance - IsActiveEntity = " + bIsActiveEntity));
			}

			return oResponseOut;
		}, function(oResponse) {
			var oResponseOut = that._normalizeError(oResponse);
			throw oResponseOut;
		});
		oPromise2 = this.triggerSubmitChanges(mParameters);

		// continue, if all "sub-ordinate" promises have been resolved.
		return this._returnPromiseAll([
			oPromise, oPromise2
		]);
	};

	/**
	 * Submits changes to the back-end and prepares an existing draft entity in the back-end for later activation by invoking the validation action.
	 * 
	 * @param {sap.ui.model.Context} oContext The given binding context
	 * @returns {Promise} A <code>Promise</code> for asynchronous execution
	 * @public
	 */
	DraftController.prototype.validateDraftEntity = function(oContext) {
		var oPromise, oPromise2, that = this, mParameters = {
			batchGroupId: "Changes",
			changeSetId: "Changes",
			context: oContext,
			forceSubmit: true
		};

		oPromise = this.validateDraft(oContext, mParameters).then(function(oResponse) {
			return that._normalizeResponse(oResponse, true);
		}, function(oResponse) {
			var oResponseOut = that._normalizeError(oResponse);
			throw oResponseOut;
		});
		oPromise2 = this.triggerSubmitChanges(mParameters);

		// continue, if all "sub-ordinate" promises have been resolved.
		return this._returnPromiseAll([
			oPromise, oPromise2
		]);
	};

	/**
	 * Submits changes to the back-end and prepares a draft entity in the back-end for later activation by invoking the preparation action.
	 * 
	 * @param {sap.ui.model.Context} oContext The given binding context
	 * @param {map} mParameters Parameters to control the behavior of the request
	 * @returns {Promise} A <code>Promise</code> for asynchronous execution
	 * @public
	 */
	DraftController.prototype.saveAndPrepareDraftEntity = function(oContext, mParameters) {
		var oPromise, oPromise2, that = this;

		mParameters = mParameters || {};
		mParameters.batchGroupId = "Changes";
		mParameters.changeSetId = "Changes";
		mParameters.successMsg = "Saved";
		mParameters.failedMsg = "Save failed";
		mParameters.context = oContext;
		mParameters.forceSubmit = true;

		oPromise = this.prepareDraft(oContext, mParameters).then(function(oResponse) {
			var bIsActiveEntity, oResponseEntity, oResponseOut;

			// mind nesting of promises and error situation.
			oResponseOut = that._normalizeResponse(oResponse, true);

			if (oResponseOut.context) {
				oResponseEntity = oResponseOut.context.getObject();
			}

			if (!oResponseEntity) {
				jQuery.sap.log.error("Activate function returned no entity");
				return Promise.reject(new Error("Activate function returned no entity"));
			}

			bIsActiveEntity = that._oDraftUtil.isActiveEntity(oResponseEntity);
			if (bIsActiveEntity) {
				jQuery.sap.log.error("Prepare function returned an entity which is not a draft instance - IsActiveEntity = " + bIsActiveEntity);
				return Promise.reject(new Error("Returned entity ist not a draft instance - IsActiveEntity = " + bIsActiveEntity));
			}

			return oResponseOut;
		}, function(oResponse) {
			var oResponseOut = that._normalizeError(oResponse);
			throw oResponseOut;
		});

		// to make sure that read operations and the prepare action are processed in the same OData request hand in the batch group.
		if (mParameters.binding) {
			mParameters.binding.refresh(true, "Changes");
		}

		oPromise2 = this.triggerSubmitChanges(mParameters);

		// continue, if all "sub-ordinate" promises have been resolved.
		return this._returnPromiseAll([
			oPromise, oPromise2
		]);
	};

	/**
	 * Submits changes to the back-end and prepares an existing draft entity in the back-end for later activation by invoking the preparation action.
	 * 
	 * @param {sap.ui.model.Context} oContext The given binding context
	 * @returns {Promise} A <code>Promise</code> for asynchronous execution
	 * @public
	 */
	DraftController.prototype.prepareDraftEntity = function(oContext) {
		var that = this;

		return this.prepareDraft(oContext).then(function(oResponse) {
			var oResponseOut, oResponseEntity;

			oResponseOut = that._normalizeResponse(oResponse, true);
			oResponseEntity = oResponseOut.context.getObject();

			if (that._oDraftUtil.isActiveEntity(oResponseEntity)) {
				jQuery.sap.log.error("Prepare function returned an entity which is not a draft instance - IsActiveEntity = " + true);
				return Promise.reject(new Error("Returned entity ist not a draft instance - IsActiveEntity = " + true));
			}

			return oResponseOut;
		}, function(oResponse) {
			var oResponseOut = that._normalizeError(oResponse);
			throw oResponseOut;
		});
	};

	/**
	 * Submits changes to the back-end and activates a draft entity in the back-end.
	 * 
	 * @param {sap.ui.model.Context} oContext The given binding context
	 * @returns {Promise} A <code>Promise</code> for asynchronous execution
	 * @public
	 */
	DraftController.prototype.activateDraftEntity = function(oContext) {
		var oPromise, oPromise2, that = this, mParameters = {
			batchGroupId: "Changes",
			changeSetId: "Changes",
			successMsg: "Document activated",
			failedMsg: "Activation of document failed",
			forceSubmit: true,
			context: oContext
		};

		oPromise = this.activateDraft(oContext, mParameters).then(function(oResponse) {
			var bIsActiveEntity, oResponseEntity, oResponseOut;

			// mind nesting of promises and error situation.
			oResponseOut = that._normalizeResponse(oResponse, true);

			if (oResponseOut.context) {
				oResponseEntity = oResponseOut.context.getObject();
			}

			if (!oResponseEntity) {
				jQuery.sap.log.error("Activate function returned no entity");
				return Promise.reject(new Error("Activate function returned no entity"));
			}

			bIsActiveEntity = that._oDraftUtil.isActiveEntity(oResponseEntity);
			if (!bIsActiveEntity) {
				jQuery.sap.log.error("Activate function returned an entity which is still a draft instance - IsActiveEntity = " + bIsActiveEntity);
				return Promise.reject(new Error("Returned entity is still a draft instance - IsActiveEntity = " + bIsActiveEntity));
			}

			return oResponseOut;
		}, function(oResponse) {
			var oResponseOut = that._normalizeError(oResponse);
			throw oResponseOut;
		});
		oPromise2 = this.triggerSubmitChanges(mParameters);

		// continue, if all "sub-ordinate" promises have been resolved.
		return this._returnPromiseAll([
			oPromise, oPromise2
		]);
	};

	/**
	 * Checks whether an entity set is active. The entity set name is derived from the given binding context
	 * 
	 * @param {sap.ui.model.Context} oContext The given binding context
	 * @returns {boolean} <code>true</code>, if a given entity set is active, <code>false</code> otherwise
	 * @throws {Error} Throws an error if no context is handed over as input parameter
	 * @public
	 */
	DraftController.prototype.isActiveEntity = function(oContext) {
		if (this.getDraftContext().hasDraft(oContext)) {
			return this._oDraftUtil.isActiveEntity(oContext.getObject());
		}

		return true;
	};

	/**
	 * Checks whether an entity has an active entity associated.
	 * 
	 * @param {sap.ui.model.Context} oContext The given binding context
	 * @returns {boolean} <code>true</code>, if an active entity exists, <code>false</code> otherwise
	 * @public
	 * @since 1.32.0
	 */
	DraftController.prototype.hasActiveEntity = function(oContext) {
		return this._oDraftUtil.hasActiveEntity(oContext.getObject());
	};

	/**
	 * Frees all resources claimed during the life-time of this instance.
	 * 
	 * @public
	 */
	DraftController.prototype.destroy = function() {
		if (this._oContext) {
			this._oContext.destroy();
		}

		this._oContext = null;
		this._oModel = null;

		BaseController.prototype.destroy.apply(this, []);
	};

	return DraftController;

}, true);

}; // end of sap/ui/generic/app/transaction/DraftController.js
if ( !jQuery.sap.isDeclared('sap.ui.generic.app.transaction.TransactionController') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.ui.generic.app.transaction.TransactionController'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('jquery.sap.global'); // unlisted dependency retained
sap.ui.define("sap/ui/generic/app/transaction/TransactionController",[	"jquery.sap.global", "./BaseController", "./DraftController", "sap/ui/generic/app/util/ModelUtil" ], function(jQuery, BaseController, DraftController, ModelUtil) {
	"use strict";

	/* global Promise */

	/**
	 * Constructor for a new transaction controller instance.
	 *
	 * @public
	 * @class Assuming state-less communication, each single data modification request (or change set in an OData $batch request) is a
	 *        "mini-transaction", which saves data to the database. The class allows you to submit changes, invoke actions, OData CRUD operations in general,
	 *        and trigger client-side validations. It ensures concurrency control and correct ETag handling.
	 *
	 *        The class gives access to runtime draft handling for applications. Additionally error handling capabilities are provided to notify client 
	 *        implementations of error situations. The event <code>fatalError</code> is thrown, if fatal errors occur during execution of OData requests.
	 * @author SAP SE
	 * @version 1.50.6
	 * @since 1.30.0
	 * @alias sap.ui.generic.app.transaction.TransactionController
	 * @param {sap.ui.model.odata.ODataModel} oModel The OData model currently used
	 * @param {sap.ui.generic.app.util.Queue} oQueue Optional HTTP request queue
	 * @param {map} mParams Optional configuration parameters
	 * @param {boolean} mParams.noBatchGroups Suppresses creation of batch groups
	 * @throws {Error} Throws an error if no model is handed over as input parameter
	 */
	var TransactionController = BaseController.extend("sap.ui.generic.app.transaction.TransactionController", {
		metadata: {
			publicMethods: [
				"destroy", "setBatchStrategy", "getDraftController", "invokeAction", "editEntity", "deleteEntity", "deleteEntities", "propertyChanged", "hasClientValidationErrors", "resetChanges"
			]
		},

		constructor: function(oModel, oQueue, mParams) {
			BaseController.apply(this, [ oModel, oQueue ]);
			this.sName = "sap.ui.generic.app.transaction.TransactionController";
			this._oDraft = null;

			// make sure changes are sent by submitChanges only.
			mParams = mParams || {};

			if (!mParams.noBatchGroups) {
				oModel.setDeferredGroups([
					"Changes"
				]);
	
				// make sure one change set is used by default for every change.
				oModel.setChangeGroups({
					"*": {
						groupId: "Changes",
						changeSetId: "Changes",
						single: false
					}
				});
			}

			return this.getInterface();
		}
	});

	/**
	 * Sets the strategy for batch handling. Currently all batch operations are sent in one batch group, but alternatively one can
	 * trigger sending all operations in their own batch group.
	 * 
	 * @param {boolean} bSingle If set to <code>true</code>, all batch operations are sent in their own batch group, otherwise all operations are
	 *        sent in one batch group
	 * @private
	 * @deprecated Since 1.32.0
	 */
	TransactionController.prototype.setBatchStrategy = function(bSingle) {
		var n, mChangeBatchGroups = this._oModel.getChangeGroups();

		for (n in mChangeBatchGroups) {
			mChangeBatchGroups[n].single = bSingle;
		}

		this._oModel.setChangeGroups(mChangeBatchGroups);
	};

	/**
	 * Returns the current draft controller instance.
	 * 
	 * @returns {sap.ui.generic.app.transaction.DraftController} The draft controller instance
	 * @public
	 */
	TransactionController.prototype.getDraftController = function() {
		// create the draft controller lazily.
		if (!this._oDraft) {
			this._oDraft = new DraftController(this._oModel, this._oQueue);
		}

		return this._oDraft;
	};

	/**
	 * Prepares an entity for editing. If the entity is active and draft enabled, a new draft document is created. If not, the control is
	 * automatically returned to the caller of the method by returning a resolved promise.
	 * 
	 * @param {sap.ui.model.Context} oContext The given binding context
	 * @param {boolean} [bPreserveChanges] Set to <code>true</code> to avoid the creation of a new draft when unsaved changes exist in the back-end
	 * @returns {Promise} A <code>Promise</code> for asynchronous execution
	 * @public
	 */
	TransactionController.prototype.editEntity = function(oContext, bPreserveChanges) {
		var that = this;

		return new Promise(function(resolve) {
			var oDraftContext, sEntitySet;

			oDraftContext = that.getDraftController().getDraftContext();
			sEntitySet = ModelUtil.getEntitySetFromContext(oContext);

			if (oDraftContext.isDraftEnabled(sEntitySet) && that._oDraftUtil.isActiveEntity(oContext.getObject())) {
				return resolve(that.getDraftController().createEditDraftEntity(oContext, bPreserveChanges));
			}

			return resolve({
				context: oContext
			});
		});
	};

	/**
	 * Submits changes to the backend system and deletes an entity in the backend system.
	 * This entity can be either a draft or an active entity.
	 *
	 * @param {sap.ui.model.Context | string} vEntity Binding context or path of the entity
	 * @param {map} mParameters Parameters that control the behavior of the request
	 * @returns {Promise} A <code>Promise</code> for asynchronous execution
	 * @public
	 */
	TransactionController.prototype.deleteEntity = function(vEntity, mParameters) {
		var oPromise, oPromise2, that = this, sPath, oContext; 

		if (typeof vEntity == "string") {
			sPath = vEntity;
		} else if (typeof vEntity == "object" && vEntity instanceof sap.ui.model.Context){
			oContext = vEntity;
			sPath = oContext.getPath();
		}

		mParameters = mParameters || {};
		jQuery.extend(mParameters, {
			batchGroupId: "Changes",
			changeSetId: "Changes",
			successMsg: "Changes were discarded",
			failedMsg: "Discarding of changes failed",
			forceSubmit: true,
			context: oContext
		});

		oPromise = this._remove(sPath, mParameters).then(function(oResponse) {
			return that._normalizeResponse(oResponse, true);
		}, function(oResponse) {
			var oResponseOut = that._normalizeError(oResponse);
			throw oResponseOut;
		});
		oPromise2 = this.triggerSubmitChanges(mParameters);

		// continue, if all "sub-ordinate" promises have been resolved.
		return this._returnPromiseAll([
			oPromise, oPromise2
		]);
	};


	/**
	 * Submits changes to the backend system and deletes a group of entities in the backend system.
	 * These entities can be both draft or active entities.
	 *
	 * @param {array} aEntities Binding contexts or paths (strings) which identify the entities
	 * @param {map} mParameters Parameters that control the behavior of the request
	 * @returns {Promise} A <code>Promise</code> that receives an array with the responses of the delete requests.
	 *          The <code>Promise</code> resolves when at least one request was successful and rejects when all 
	 *          delete requests have been rejected/aborted.
	 *
	 * @since 1.38
	 * @experimental
	 * @public
	 */
	TransactionController.prototype.deleteEntities = function(aEntities, mParameters) {
		var oPromise, aPromises = [], that = this, sPath, oContext; 

		mParameters = mParameters || {};
		jQuery.extend(mParameters, {
			batchGroupId: "Changes",
			changeSetId: "Changes",
			successMsg: "Changes were discarded",
			failedMsg: "Discarding of changes failed",
			forceSubmit: true
		});

		var fnResolve = function(oResponse) {
			return that._normalizeResponse(oResponse, true);
		};

		var fnReject = function(oResponse) {
			var oResponseOut = that._normalizeError(oResponse);
			throw oResponseOut;
		};

		for (var i = 0; i < aEntities.length; i++) {
			if (typeof aEntities[i] == "string") {
				sPath = aEntities[i];
			} else if (typeof aEntities[i] == "object" && aEntities[i] instanceof sap.ui.model.Context) {
				oContext = aEntities[i];
				sPath = oContext.getPath();
			}

			if (that._oModel.getObject(sPath) && !that._oDraftUtil.isActiveEntity(that._oModel.getObject(sPath))) {
				mParameters.changeSetId = "Changes";
			} else {
				mParameters.changeSetId = "ActiveChanges";
			}

			oPromise = this._remove(sPath, mParameters).then(fnResolve,fnReject);
			aPromises.push(oPromise);
		}

		oPromise = this.triggerSubmitChanges(mParameters);
		aPromises.push(oPromise);

		return this._atLeastOnePromiseResolved(aPromises, true);
	};


	/**
	 * Invokes an action with the given name and submits changes to the backend system.
	 * 
	 * @param {string} sFunctionName The name of the function or action
	 * @param {sap.ui.model.Context} oContext The given binding context
	 * @param {map} mParameters Parameters to control the behavior of the request
	 * @returns {Promise} A <code>Promise</code> for asynchronous execution of the action
	 * @throws {Error} Throws an error if the OData function import does not exist or the action input parameters are invalid
	 * @private
	 * @deprecated Since 1.32.0
	 */
	TransactionController.prototype.invokeAction = function(sFunctionName, oContext, mParameters) {
		var that = this, oPromise, oPromise2;

		// check for client message.
		oPromise = this.hasClientMessages();

		if (oPromise) {
			return oPromise;
		}

		mParameters = {
			batchGroupId: "Changes",
			changeSetId: "Changes",
			successMsg: "Call of action succeeded",
			failedMsg: "Call of action failed",
			urlParameters: mParameters.urlParameters,
			forceSubmit: true,
			context: oContext
		};

		oPromise = this._callAction(sFunctionName, oContext, mParameters).then(function(oResponse) {
			return that._normalizeResponse(oResponse, true);
		}, function(oResponse) {
			var oOut = that._normalizeError(oResponse);
			throw oOut;
		});
		
		// TODO: check for side effects
		// if no side effects are annotated refresh the complete model
		this._oModel.refresh(true, false, "Changes");
		
		oPromise2 = this.triggerSubmitChanges(mParameters);

		// continue, if all "sub-ordinate" promises have been resolved.
		return this._returnPromiseAll([
			oPromise, oPromise2
		]);
	};

	/**
	 * Resets changes that have been tracked by the current instance of <code>sap.ui.model.odata.v2.ODatatModel</code>. These changes have been
	 * created by invoking the <code>setProperty</code> method of <code>sap.ui.model.odata.v2.ODatatModel</code>.
	 * 
	 * @param{array} aKeys Optional array of keys that have to be reset. If no array is passed all changes will be reset.
	 * @public
	 */
	TransactionController.prototype.resetChanges = function(aKeys) {
		this._oModel.resetChanges(aKeys);
	};
	
	/**
	 * Notifies the transaction controller of a change of a property. Please note that the method is not meant for public use currently.
	 * It is experimental.
	 * 
	 * @param {string} sEntitySet The name of the entity set
	 * @param {string} sProperty Path identifying the changed property
	 * @param {object} oBinding The binding associated with the changed property
	 * @returns {Promise} A <code>Promise</code> for asynchronous execution of the action
	 * @deprecated
	 * @private
	 */
	TransactionController.prototype.propertyChanged = function(sEntitySet, sProperty, oBinding) {
		var oDraftContext, oContext, mParameters = {
			batchGroupId: "Changes",
			changeSetId: "Changes",
			binding: oBinding
		};

		oDraftContext = this.getDraftController().getDraftContext();

		// if (this.hasClientValidationErrors()) {
		// ask core guys how to check for client validation errors.
		// if (bUpdateOnChange) {
		// // what to do? inform user?
		// }
		// } else {
		if (oDraftContext.checkUpdateOnChange(sEntitySet, sProperty)) {
			oContext = oBinding.getBoundContext();

			if (oDraftContext.hasDraftPreparationAction(oContext)) {
				return this.getDraftController().saveAndPrepareDraftEntity(oContext, mParameters);
			}

			mParameters.onlyIfPending = true;
			return this.triggerSubmitChanges(mParameters);
		}

		mParameters.onlyIfPending = true;
		mParameters.noShowResponse = true;
		mParameters.noBlockUI = true;
		return this.triggerSubmitChanges(mParameters);
		// }
	};
	
	/**
	 * Frees all resources claimed during the life-time of this instance.
	 * 
	 * @public
	 */
	TransactionController.prototype.destroy = function() {
		BaseController.prototype.destroy.apply(this, []);

		if (this._oDraft) {
			this._oDraft.destroy();
		}

		this._oDraft = null;
	};

	return TransactionController;

}, true);

}; // end of sap/ui/generic/app/transaction/TransactionController.js
if ( !jQuery.sap.isDeclared('sap.ui.generic.app.util.ActionUtil') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */
jQuery.sap.declare('sap.ui.generic.app.util.ActionUtil'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('jquery.sap.global'); // unlisted dependency retained
jQuery.sap.require('sap.ui.base.ManagedObject'); // unlisted dependency retained
jQuery.sap.require('sap.m.MessageBox'); // unlisted dependency retained
jQuery.sap.require('sap.ui.layout.form.SimpleForm'); // unlisted dependency retained
jQuery.sap.require('sap.ui.comp.smartfield.SmartField'); // unlisted dependency retained
jQuery.sap.require('sap.ui.comp.smartfield.SmartLabel'); // unlisted dependency retained
jQuery.sap.require('sap.m.Dialog'); // unlisted dependency retained
jQuery.sap.require('sap.m.VBox'); // unlisted dependency retained
jQuery.sap.require('sap.m.Text'); // unlisted dependency retained
sap.ui.define("sap/ui/generic/app/util/ActionUtil",[
	"jquery.sap.global", "sap/ui/base/ManagedObject", "sap/m/MessageBox", "sap/ui/layout/form/SimpleForm", "sap/ui/comp/smartfield/SmartField", "sap/ui/comp/smartfield/SmartLabel", "sap/m/Dialog", "sap/ui/generic/app/util/ModelUtil", "sap/m/VBox", "sap/m/Text"
], function (jQuery, ManagedObject, MessageBox, SimpleForm, SmartField, SmartLabel, Dialog, ModelUtil, VBox, Text) {
	"use strict";

	var ActionUtil = ManagedObject.extend("sap.ui.generic.app.util.ActionUtil", {
		metadata: {
			properties: {
				/**
				 * The used controller.
				 */
				controller: {
					type: "object",
					group: "Misc",
					defaultValue: null
				},
				/**
				 * The used ApplicationController
				 */
				applicationController: {
					type: "object",
					group: "Misc",
					defaultValue: null
				},
				/* TODO Should maybe get an aggregation to reflect that it is an array */
				/**
				 * The contexts in which the action is called.
				 */
				contexts: {
					type: "object",
					group: "Misc",
					defaultValue: null
				},
				/**
				 * The callback that is called after the action has been successfully executed.
				 */
				successCallback: {
					type: "function",
					group: "Misc",
					defaultValue: null
				},
				/**
				 * The callback that is called after the action has been successfully executed.
				 */
				operationGrouping: {
					type: "string",
					group: "Misc",
					defaultValue: null
				}
			}
		}
	});

	/**
	 * Triggers the chain of the action call's preparation, its processing and its result handling.
	 * If there is a critical action, a confirmation dialog is displayed on the UI.
	 * <b>Note</b>: An action is considered as critical if the UI annotation <code>com.sap.vocabularies.Common.v1.IsActionCritical</code> is defined.
	 *
	 * @param {string} sFunctionImportPath The function import that is called
	 * @param {string} [sFunctionImportLabel] Optional parameter for the confirmation popup text
	 *
	 * @returns {Promise} There are two cases:
	 * Case 1: Action is triggered immediately w/o further user interaction (i.e. when no further
	 * parameters are needed or expected for processing).
	 * A <code>Promise</code> is returned that resolves immediately and provides as parameter an
	 * <code>Object</code> that contains another promise in the member <code>executionPromise</code>.
	 * Case 2: Action is triggered with a dialog beforehand that could be cancelled by the user.
	 * Same as above with the exception that the returned <code>Promise</code> is rejected directly
	 * when the user decides to cancel the action processing.
	 *
	 * @protected
	 */
	ActionUtil.prototype.call = function (sFunctionImportPath, sFunctionImportLabel) {
		var that = this;
		return new Promise(function (resolve, reject) {
			var mActionParams;
			that._oActionPromiseCallback = { resolve: resolve, reject: reject };

			that._sFunctionImportPath = sFunctionImportPath;

			var oController = that.getController();
			if (!oController) {
				reject("Controller not provided");
			}

			that._oMetaModel = oController.getView().getModel().getMetaModel();

			var sFunctionName = sFunctionImportPath.split('/')[1];

			//TODO Think about removing "global" variables for better readability / debugging
			that._oFunctionImport = that._oMetaModel.getODataFunctionImport(sFunctionName);
			that._sFunctionImportLabel = sFunctionImportLabel || sFunctionName;

			if (!that._oFunctionImport) {
				reject("Unknown Function Import " + sFunctionName);
			}

			if (that._isActionCritical()) {
				var sCustomMessageKey = "ACTION_CONFIRM|" + sFunctionName; // Key for i18n in application for custom message
				var sMsgBoxText;
				var oResourceBundle = oController.getOwnerComponent().getAppComponent && oController.getOwnerComponent().getAppComponent().getModel("i18n") && oController.getOwnerComponent().getAppComponent().getModel("i18n").getResourceBundle();
				if (oResourceBundle && oResourceBundle.hasText(sCustomMessageKey)) {
					sMsgBoxText = oResourceBundle.getText(sCustomMessageKey);
				} else {
					// Fallback in case key does not exist in i18n file of Application
					sMsgBoxText = sap.ui.getCore().getLibraryResourceBundle("sap.ui.generic.app").getText("ACTION_CONFIRM");
					sMsgBoxText = jQuery.sap.formatMessage(sMsgBoxText, that._sFunctionImportLabel);
				}
				MessageBox.confirm(sMsgBoxText, {
					title: that._sFunctionImportLabel,
					onClose: function (oAction) {
						if (oAction === "OK") {
							mActionParams = that._prepareParameters(that.getContexts());
							that._initiateCall(mActionParams);
						} else if (oAction === "CANCEL") {
							that._oActionPromiseCallback.reject();
						}
					},
					sClass: that._getCompactModeStyleClass()
				});
			} else {
				mActionParams = that._prepareParameters(that.getContexts());
				that._initiateCall(mActionParams);
			}
		});
	};

	ActionUtil.prototype._getCompactModeStyleClass = function () {
		if (this.getController().getView().$().closest(".sapUiSizeCompact").length) {
			return "sapUiSizeCompact";
		}
		return "";
	};

	/**
	 * checks if the action is critical
	 *
	 * @private
	 * @returns {boolean} true if the action is critical otherwise false
	 */
	ActionUtil.prototype._isActionCritical = function () {
		var oCritical = this._oFunctionImport["com.sap.vocabularies.Common.v1.IsActionCritical"];

		if (!oCritical) {
			return false;
		}
		if (oCritical.Bool === undefined) {
			return true;
		}

		return this._toBoolean(oCritical.Bool);
	};

	/**
	 * converts a parameter value to a boolean
	 *
	 * @param {object} oParameterValue The value to be converted
	 * @private
	 * @returns {boolean} Boolean value
	 */
	ActionUtil.prototype._toBoolean = function (oParameterValue) {
		if (typeof oParameterValue === "string") {
			var oValue = oParameterValue.toLowerCase();
			return !(oValue == "false" || oValue == "" || oValue == " ");
		}

		return !!oParameterValue;
	};

	/**
	 * Prepares the parameters which are needed as input for the action
	 *
	 * @param {array} 		aContexts Array of contexts used for action processing
	 *
	 * @returns {object} 	mActionParams Parameters that describe the Function Import:
	 * 						mActionParams.parameterData Array with mandatory parameters
	 *						mActionParams.additionalParameters Array with additional parameters
	 *
	 * @private
	 */
	ActionUtil.prototype._prepareParameters = function (aContexts) {

		var oSingleContext, oEntityType = null;

		// Multi action scenario or "no" scenario? --> If yes we do no preparation sugar
		if (jQuery.isArray(aContexts) && aContexts.length != 1) {
			return undefined;
		} else {
			oSingleContext = aContexts[0];
		}

		var oContextObject = oSingleContext.getObject();
		if (oSingleContext && oSingleContext.getPath()) {
			var sEntitySet = ModelUtil.getEntitySetFromContext(oSingleContext);
			var oEntitySet = this._oMetaModel.getODataEntitySet(sEntitySet, false);
			oEntityType = this._oMetaModel.getODataEntityType(oEntitySet.entityType, false);
		}

		var oKeyProperties = this._getPropertyKeys(oEntityType);
		var oParameterValue;
		var mActionParams = {
			parameterData: {},
			additionalParameters: []
		};

		if (this._oFunctionImport.parameter) {
			for (var i = 0; i < this._oFunctionImport.parameter.length; i++) {
				var oParameter = this._oFunctionImport.parameter[i];

				this._addParameterLabel(oParameter, oEntityType);

				var sParameterName = oParameter.name;
				var bIsKey = !!oKeyProperties[sParameterName];

				oParameterValue = undefined;
				if (oContextObject.hasOwnProperty(sParameterName)) {
					oParameterValue = oContextObject[sParameterName];
				} else if (bIsKey) {
					// parameter is key but not part of the current projection - raise error
					jQuery.sap.log.error("Key parameter of action not found in current context: " + sParameterName);
					throw new Error("Key parameter of action not found in current context: " + sParameterName);
				}

				mActionParams.parameterData[sParameterName] = oParameterValue;

				if (!bIsKey && oParameter.mode.toUpperCase() == "IN") {
					// offer as optional parameter with default value from context
					mActionParams.additionalParameters.push(oParameter);
				}
			}
		}
		return mActionParams;
	};

	/**
	 * returns a map containing all keys retrieved for the given entityType
	 *
	 * @param {object} oEntityType - the entity type for which the keys should be retrieved
	 * @private
	 * @returns {object} map containing the properties keys
	 */
	ActionUtil.prototype._getPropertyKeys = function(oEntityType) {
		var oKeyMap = {};

		if (oEntityType && oEntityType.key && oEntityType.key.propertyRef) {
			for (var i = 0; i < oEntityType.key.propertyRef.length; i++) {
				var sKeyName = oEntityType.key.propertyRef[i].name;
				oKeyMap[sKeyName] = true;
			}
		}
		return oKeyMap;
	};

	/**
	 * Initiate action call.
	 *
	 * @param {object} [mActionParams] Optional map with parameters that are used in action call.
	 *
	 */
	ActionUtil.prototype._initiateCall = function (mActionParams) {
		if (mActionParams != undefined && mActionParams.additionalParameters.length == 0) {
			this._call(mActionParams.parameterData);
		} else if (mActionParams != undefined && mActionParams.additionalParameters.length > 0) {
			var that = this;
			var mParameters = {
				urlParameters: {}
			};

			var oEntityContext = this.getContexts()[0];

			var oFuncHandle = this.getApplicationController().getNewActionContext(this._sFunctionImportPath, oEntityContext, mParameters);

			oFuncHandle.context.then(function (oActionContext) {
				var mParameterForm = that._buildParametersForm(mActionParams, oActionContext);

				for (var sKey in mActionParams.parameterData) {
					oActionContext.oModel.getData(oActionContext.sPath)[sKey] = mActionParams.parameterData[sKey];
				}
				var bActionPromiseDone = false;
				var oParameterDialog = new Dialog({
					title: that._sFunctionImportLabel,
					content: [
						mParameterForm.form
					],
					beginButton: new sap.m.Button({
						text: that._sFunctionImportLabel,
						press: function (oEvent) {
							if (mParameterForm.hasNoClientErrors()) {
								if (mParameterForm.getEmptyMandatoryFields().length == 0) {
									oParameterDialog.close();

									that._oActionPromiseCallback.resolve({
										executionPromise: oFuncHandle.result.then(function (aResults) {
											that._bExecutedSuccessfully = true;
											return aResults;
										}, function (oError) {
											that._bExecutedSuccessfully = false;
											//TODO: Think about throwing errors. Maybe not needed in a failing Promise...?
											throw oError;
										})
									});

									bActionPromiseDone = true;

									var sFunctionImportName = that._sFunctionImportPath.split('/')[1];
									that.getApplicationController().submitActionContext(oActionContext, sFunctionImportName);

								} else {
									var oContent = new VBox();

									var sRootMessage = sap.ui.getCore().getLibraryResourceBundle("sap.ui.generic.app").getText("ACTION_MISSING_MANDATORY");

									for (var i = 0; i < mParameterForm.getEmptyMandatoryFields().length; i++) {
										var sText = jQuery.sap.formatMessage(sRootMessage, mParameterForm.getEmptyMandatoryFields()[i].getTextLabel());
										oContent.addItem(new Text({
											text: sText
										}));
									}

									MessageBox.error(oContent, {
										sClass: that._getCompactModeStyleClass()
									});
								}

							}
						}
					}),
					endButton: new sap.m.Button({
						text: sap.ui.getCore().getLibraryResourceBundle("sap.ui.generic.app").getText("ACTION_CANCEL"),
						press: function () {
							oParameterDialog.close();
							that._oActionPromiseCallback.reject();
							bActionPromiseDone = true;
						}
					}),
					afterClose: function (oControlEvent) {
						oParameterDialog.destroy();
						// Tidy up at the end: if the action hasn't been triggered, do the same as it was cancelled.
						if (!bActionPromiseDone) {
							that._oActionPromiseCallback.reject();
						}
					}
				}).addStyleClass("sapUiNoContentPadding");

				oParameterDialog.addStyleClass(that._getCompactModeStyleClass());

				oParameterDialog.setModel(oActionContext.oModel);
				oParameterDialog.open();
			});

		} else {
			//Take "the old" way -> prepare everything and call then callFunction with complete set of data
			this._call();
		}
	};

	ActionUtil.prototype._call = function (mUrlParameters) {
		var aCurrentContexts = this.getContexts();
		var mParameters = {
			urlParameters: mUrlParameters,
			operationGrouping: this.getOperationGrouping()
		};
		var oController = this.getController();
		var oApplicationController = this.getApplicationController() || oController.getApplicationController();
		var that = this;


		that._oActionPromiseCallback.resolve({
			executionPromise: oApplicationController.invokeActions(this._sFunctionImportPath, aCurrentContexts, mParameters).then(function (oResponse) {
				that._bExecutedSuccessfully = true;
				return oResponse;
			}, function (oError) {
				that._bExecutedSuccessfully = false;
				//TODO: Think about throwing errors. Maybe not needed in a failing Promise...?
				throw oError;
			})

		});
	};

	ActionUtil.prototype._getActionParameterData = function (oParameterModel) {
		var aMissingMandatoryParameters = [];

		// raw parameter list contains all action parameters as key/value - no check required
		var oRawParameterData = oParameterModel.getObject('/');
		var oPreparedParameterData = {};
		for (var i = 0; i < this._oFunctionImport.parameter.length; i++) {
			var oParameter = this._oFunctionImport.parameter[i];
			var sParameterName = oParameter.name;
			if (oRawParameterData.hasOwnProperty(sParameterName)) {
				var oValue = oRawParameterData[sParameterName];
				if (oValue === undefined) {
					// if parameter is nullable=true don't pass it at all to function import call
					// TODO check boolean handling - should undefined boolean value be sent as false to backend or not at all
					if (!this._toBoolean(oParameter.nullable)) {
						// defaulting for boolean - set to false - UI state undefined for checkbox
						// all other not null checks should have already been done by smart field - if not throw error - should not happen at all
						if (oParameter.type === 'Edm.Boolean') {
							oPreparedParameterData[sParameterName] = false;
						} else {
							aMissingMandatoryParameters.push(oParameter);
						}
					}
				} else {
					oPreparedParameterData[sParameterName] = oValue;
				}
			} else {
				throw new Error("Unknown parameter: " + sParameterName);
			}
		}

		return {
			preparedParameterData: oPreparedParameterData,
			missingMandatoryParameters: aMissingMandatoryParameters
		};
	};


	/**
	 * Initiate a form with all needed controls to allow providing missing
	 * parameters which are needed by the triggered action.
	 *
	 * @param {object} mParameters Map that contains the parameters - prefilled and additional
	 * @param {object} oContext Context object of the triggered action
	 *
	 * @returns {object} A map with the two members: "form" and "hasNoClientErrors"
	 *
	 * @private
	 */
	ActionUtil.prototype._buildParametersForm = function (mParameters, oContext) {
		var oForm = new SimpleForm({
			editable: true
		});

		oForm.setBindingContext(oContext);
		// list of all smart fields for input check
		var oField;
		var aFields = [];
		var sLabel;

		for (var i = 0; i < mParameters.additionalParameters.length; i++) {
			var oParameter = mParameters.additionalParameters[i];

			var sValueType = oParameter["com.sap.vocabularies.Common.v1.ValueListWithFixedValues"] ? "fixed-values" : undefined;

			//Create a smartfield with data form outside
			oField = new SmartField({
				value: '{' + oParameter.name + '}',
				textLabel: this._getParameterName(oParameter)
			});
			oField.data("configdata", {
				"configdata": {
					isInnerControl: false,
					path: oParameter.name,
					entitySetObject: {},
					annotations: {
						valuelist: oParameter["com.sap.vocabularies.Common.v1.ValueList"],
						valuelistType: sValueType
					},
					modelObject: oContext.oModel,
					entityType: oParameter.type,
					property: {
						property: oParameter,
						typePath: oParameter.name
					}
				}
			});

			//set mandatory if requested
			if (oParameter.nullable == "false") {
				oField.setMandatory(true);
			}

			aFields.push(oField);

			sLabel = new SmartLabel();
			sLabel.setLabelFor(oField);

			oForm.addContent(sLabel);
			oForm.addContent(oField);
		}

		// for now: always return false, as smart fields currently do not handle JSON models correctly
		var fnHasNoClientErrors = function () {
			var bNoClientErrors = true;
			for (var i = 0; i < aFields.length; i++) {
				if (aFields[i].getValueState() != "None") {
					bNoClientErrors = false;
					break;
				}
			}
			return bNoClientErrors;
		};

		var fnGetEmptyMandatoryFields = function () {
			var aMandatoryFields = jQuery.grep(aFields, function (oField) {
				return (oField.getMandatory() == true
					&& oField.getValue() == ""
					&& oField.getDataType() != "Edm.Boolean"
				);
			});
			return aMandatoryFields;
		};

		return {
			form: oForm,
			hasNoClientErrors: fnHasNoClientErrors,
			getEmptyMandatoryFields: fnGetEmptyMandatoryFields
		};
	};


	ActionUtil.prototype._getParameterName = function (oParameter) {
		// if no label is set for parameter use parameter name as fallback
		return oParameter["com.sap.vocabularies.Common.v1.Label"] ? oParameter["com.sap.vocabularies.Common.v1.Label"].String : oParameter.name;
	};

	ActionUtil.prototype._addParameterLabel = function (oParameter, oEntityType) {
		if (oEntityType && oParameter && !oParameter["com.sap.vocabularies.Common.v1.Label"]) {

			var oProperty = this._oMetaModel.getODataProperty(oEntityType, oParameter.name, false);
			if (oProperty && oProperty["com.sap.vocabularies.Common.v1.Label"]) {
				// copy label from property to parameter with same name as default if no label is set for function import parameter
				oParameter["com.sap.vocabularies.Common.v1.Label"] = oProperty["com.sap.vocabularies.Common.v1.Label"];
			}
		}
	};


	/**
	 * returns the actions function import label
	 *
	 * @protected
	 * @returns {string} the function import label
	 */
	ActionUtil.prototype.getFunctionImportLabel = function () {
		return this._sFunctionImportLabel;
	};


	/**
	 * returns true if the action has executed successfully
	 *
	 * @protected
	 * @returns {boolean} true if the action has executed successfully
	 */
	ActionUtil.prototype.getExecutedSuccessfully = function () {
		return this._bExecutedSuccessfully;
	};

	return ActionUtil;

}, /* bExport= */true);

}; // end of sap/ui/generic/app/util/ActionUtil.js
if ( !jQuery.sap.isDeclared('sap.ui.generic.app.ApplicationController') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.ui.generic.app.ApplicationController'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('jquery.sap.global'); // unlisted dependency retained
sap.ui.define("sap/ui/generic/app/ApplicationController",["jquery.sap.global", "./transaction/BaseController", "./transaction/TransactionController", "sap/ui/generic/app/util/ModelUtil"], function (jQuery, BaseController, TransactionController, ModelUtil) {
	"use strict";

	/* global Promise */

	/**
	 * Constructor for application controller.
	 *
	 * @param {sap.ui.model.odata.v2.ODataModel} oModel The OData model currently used
	 * @param {sap.ui.core.mvc.View} oView The current view
	 *
	 * @throws {Error} If no model is handed over as input parameter
	 *
	 * @class Application Controller.
	 *
	 * @author SAP SE
	 * @version 1.50.6
	 *
	 * @public
	 * @experimental Since 1.32.0
	 * @since 1.32.0
	 * @alias sap.ui.generic.app.ApplicationController
	 */
	var ApplicationController = BaseController.extend("sap.ui.generic.app.ApplicationController", {

		constructor: function (oModel, oView) {
			BaseController.apply(this, [
				oModel
			]);

			this._oGroupChanges = {};
			this.sName = "sap.ui.generic.app.ApplicationController";
			this._initModel(oModel);
			this.registerView(oView);
		}
	});

	/**
	 * Notifies the application controller of a change of a property. Please note that the method is not meant for
	 * productive use currently. It is experimental.
	 *
	 * @param {string} sPath The path to the changed property
	 * @param {object} oContext The binding context in which the change occured
	 * @returns {Promise} A <code>Promise</code> for asynchronous execution of the action
	 * @experimental Since 1.32.0
	 * @public
	 */
	ApplicationController.prototype.propertyChanged = function (sPath, oContext) {
		var that = this, mParameters = {
			batchGroupId: "Changes",
			changeSetId: "Changes",
			onlyIfPending: true,
			noShowResponse: true,
			noBlockUI: true,
			draftSave: true // propertyChanged is currently only called for drafts therefore set this statically
		}, oSideEffect, oEntityType = {};


		// check if this change is part of a side effects group
		if (oContext && oContext instanceof sap.ui.model.Context) {
			var sEntitySet = ModelUtil.getEntitySetFromContext(oContext);
			var oMetaModel = oContext.getModel().getMetaModel();
			var sEntityType = oMetaModel.getODataEntitySet(sEntitySet).entityType;
			oEntityType = oMetaModel.getODataEntityType(sEntityType);
		}

		for (var p in oEntityType) {
			if (jQuery.sap.startsWith(p, "com.sap.vocabularies.Common.v1.SideEffects")) {

				oSideEffect = oEntityType[p];

				if (oSideEffect.SourceProperties && oSideEffect.SourceProperties.length) {
					for (var i = 0; i < oSideEffect.SourceProperties.length; i++) {
						if (oSideEffect.SourceProperties[i].PropertyPath === sPath) {
							that.registerGroupChange(that._getSideEffectsQualifier(p));
						}
					}
				}
			}
		}

		return new Promise(function (resolve, reject) {
			// queue the propertyChanged event in order to synchronize it correctly
			// with the sideEffects validateFieldGroup event
			setTimeout(function () {
				that.triggerSubmitChanges(mParameters).then(function (oResponse) {
					resolve(oResponse);
				}, function (oError) {
					reject(oError);
				});
			});
		});
	};

	/**
	 * Registers a change for the given group id.
	 *
	 * @param {string} sGroupId The group id where changes were done
	 * @experimental Since 1.32.0
	 * @public
	 */
	ApplicationController.prototype.registerGroupChange = function (sGroupId) {
		this._oGroupChanges[sGroupId] = true;
	};

	/**
	 * Registers the given view with the Application Controller.
	 *
	 * @param {sap.ui.core.mvc.View} oView The view to be registered
	 * @experimental Since 1.32.0
	 * @public
	 */
	ApplicationController.prototype.registerView = function (oView) {
		var that = this;

		if (oView) {
			// attach to the field group validation event.
			this._fnAttachValidateFieldGroup = function (oEvent) {
				var sID, oID, len, i, aIDs = [];

				var oBindingContext = this.getBindingContext();
				if (!oBindingContext) {
					return false;
				}

				if (!that.getTransactionController().getDraftController().getDraftContext().hasDraft(oBindingContext)) {
					// in case of non-draft do not immediately execute side effect, detach event
					this.detachValidateFieldGroup(that._fnAttachValidateFieldGroup);
					return false;
				}

				if (oEvent.mParameters.fieldGroupIds) {
					len = oEvent.mParameters.fieldGroupIds.length;
				}

				for (i = 0; i < len; i++) {
					sID = oEvent.mParameters.fieldGroupIds[i];
					oID = oView.data(sID);

					// make sure it is one of our IDs.
					if (oID) {
						aIDs.push({
							uuid: sID,
							objid: oID
						});
					}
				}

				that._onValidateFieldGroup(aIDs, oView);
			};
			oView.attachValidateFieldGroup(this._fnAttachValidateFieldGroup);
		}
	};

	/**
	 * Parameterizes the OData model.
	 *
	 * @param {sap.ui.model.odata.ODataModel} oModel The OData model currently used
	 * @private
	 */
	ApplicationController.prototype._initModel = function (oModel) {
		// set binding mode and refresh after change.
		oModel.setDefaultBindingMode(sap.ui.model.BindingMode.TwoWay);
		oModel.setRefreshAfterChange(false);

		// set the batch groups:
		// it should be deferred, as it is for batching actions
		oModel.setDeferredBatchGroups([
			"Changes"
		]);
		oModel.setChangeBatchGroups({
			"*": {
				batchGroupId: "Changes",
				changeSetId: "Changes",
				single: false
			}
		});
	};

	/**
	 * Event handler for field-group-validation event of the view.
	 *
	 * @param {array} aGroups Field group IDs
	 * @param {object} oView reference to the view
	 * @returns {Promise} A <code>Promise</code> for asynchronous execution of the submit
	 * @private
	 */
	ApplicationController.prototype._onValidateFieldGroup = function (aGroups, oView) {
		var i, len = aGroups.length, fRequest, mRequests = {
			bGlobal: false,
			aRequests: []
		};

		// calculate the requests to be triggered.
		for (i = 0; i < len; i++) {
			this._executeFieldGroup(aGroups[i], mRequests, oView);
		}

		// execute the requests to be triggered.
		len = mRequests.aRequests.length;

		for (i = 0; i < len; i++) {
			fRequest = mRequests.aRequests[i];
			fRequest(mRequests.bGlobal);
		}

		// global side effect: so execute refresh of the complete model.
		if (mRequests.bGlobal) {
			this._oModel.refresh(true, false, "Changes");
		}

		// trigger flush.
		var oPromise = this.triggerSubmitChanges({
			batchGroupId: "Changes",
			noShowSuccessToast: true,
			forceSubmit: true,
			noBlockUI: true,
			urlParameters: {},
			draftSave: this._oModel.hasPendingChanges()
		});

		this.fireEvent("beforeSideEffectExecution", {
			promise: oPromise,
			valueChange: mRequests.bValueChange,
			validationMessage: mRequests.bValidationMessage,
			fieldControl: mRequests.bFieldControl
		});

		return oPromise;
	};

	/**
	 * Executes the side effects for a single field group.
	 *
	 * @param {object} oGroup The given field group
	 * @param {map} mRequests Collection of all requests
	 * @param {object} oView Reference to the view
	 * @returns {boolean} <code>true</code> if the field group action has been executed otherwise <code>false</code>
	 * @private
	 */
	ApplicationController.prototype._executeFieldGroup = function (oGroup, mRequests, oView) {
		var sSideEffectsQualifier, oContext, oSideEffect, mParams = {
			batchGroupId: "Changes",
			changeSetId: "SideEffects",
			noShowSuccessToast: true,
			forceSubmit: true,
			noBlockUI: true,
			urlParameters: {}
		};

		sSideEffectsQualifier = this._getSideEffectsQualifier(oGroup.objid.name);

		// set the side effects qualifier as action input.
		mParams.urlParameters.SideEffectsQualifier = sSideEffectsQualifier;

		// create a new context and get the side effect.
		oContext = this._oModel.getContext(oGroup.objid.context);
		oSideEffect = this._getSideEffect(oGroup.objid);

		// check whether to stop.
		if (this._hasClientErrors(oGroup.uuid, oView)) {
			return false;
		}

		if (!this._oGroupChanges[sSideEffectsQualifier] && !this._oModel.hasPendingChanges()) {
			return false;
		}

		// set changes tracking to false.
		this._oGroupChanges[sSideEffectsQualifier] = false;

		// execute the side effect.
		this._executeSideEffects(oSideEffect, oContext, mParams, mRequests);

		return true;
	};

	/**
	 * Determines the side effect qualifier
	 *
	 * @param {string} sAnnotation The annotation path
	 * @returns {string} the side effect qualifier or empty in case of no qualifier
	 *
	 * @private
	 */
	ApplicationController.prototype._getSideEffectsQualifier = function (sAnnotation) {
		var sSideEffectQualifier = sAnnotation.replace("com.sap.vocabularies.Common.v1.SideEffects", "");
		if (sSideEffectQualifier.indexOf("#") === 0) {
			sSideEffectQualifier = sSideEffectQualifier.replace("#", "");
		}
		return sSideEffectQualifier;
	};


	/**
	 * Executes a side effects for given action contexts
	 *
	 * @param {object} oSideEffect The side effects annotation
	 * @param {sap.ui.model.Context} aContexts The given contexts
	 *
	 * @private
	 */
	ApplicationController.prototype._executeSideEffectsForActions = function (oSideEffect, aContexts) {
		var fnRequest;
		var sConstantForBoundEntity = "_it/";
		var mRequests = {
			bGlobal: false,
			aRequests: []
		};
		var mParams = {
			batchGroupId: "Changes",
			changeSetId: "SideEffects",
			noShowSuccessToast: true,
			forceSubmit: true,
			noBlockUI: true,
			urlParameters: {}
		};
		var i = 0;

		/*
		 As agreed with SAP consumption team in OData V2 we use the constant _it to define that the targets are relative
		 to the instance for which the action is executed for (bound action) - we remove this strings as the internal
		 _executeSideEffect method already requires a context (= the action context) and executes all side effects
		 relative from this context.
		 */

		if (oSideEffect.TargetEntities && oSideEffect.TargetEntities.length) {

			for (i = 0; i < oSideEffect.TargetEntities.length; i++) {
				if (oSideEffect.TargetEntities[i].NavigationPropertyPath.indexOf(sConstantForBoundEntity) === 0) {
					oSideEffect.TargetEntities[i].NavigationPropertyPath = oSideEffect.TargetEntities[i].NavigationPropertyPath.substr(4);
				}
			}
		}
		if (oSideEffect.TargetProperties && oSideEffect.TargetProperties.length) {
			for (i = 0; i < oSideEffect.TargetProperties.length; i++) {
				if (oSideEffect.TargetProperties[i].PropertyPath.indexOf(sConstantForBoundEntity) === 0) {
					oSideEffect.TargetProperties[i].PropertyPath = oSideEffect.TargetProperties[i].PropertyPath.substr(4);
				}
			}
		}

		for (i = 0; i < aContexts.length; i++) {
			this._executeSideEffects(oSideEffect, aContexts[i], mParams, mRequests);

			if (mRequests.aRequests[0]) {
				fnRequest = mRequests.aRequests[0];
				fnRequest(mRequests.bGlobal);
				mRequests.aRequests = [];
			}
		}

		if (mRequests.bGlobal) {
			this._oModel.refresh(true, false, "Changes");
		}
	};


	/**
	 * Executes a side effects annotation.
	 *
	 * @param {object} oSideEffects The side effects annotation
	 * @param {sap.ui.model.Context} oContext The given binding context
	 * @param {map} mParameters Parameters to control the behavior of the request
	 * @param {map} mRequests Collection of all requests
	 *
	 * @private
	 */
	ApplicationController.prototype._executeSideEffects = function (oSideEffects, oContext, mParameters, mRequests) {
		var that = this, fFunction, sMethod, mMethods = {
			"ValidationMessage": "validateDraft",
			"ValueChange": "prepareDraft"
		};

		if (!oSideEffects.EffectTypes || !oSideEffects.EffectTypes.EnumMember) {
			// although effect type is mandatory according to the specification we set value change as fallback
			oSideEffects.EffectTypes = {
				EnumMember: "ValueChange"
			};
		}

		// check whether validate or prepare function has to be executed.
		if (that.getTransactionController().getDraftController().getDraftContext().hasDraft(oContext)) {
			sMethod = mMethods[oSideEffects.EffectTypes.EnumMember];
		}
		mRequests.bValueChange = oSideEffects.EffectTypes.EnumMember === "ValueChange" ? true : mRequests.bValueChange;
		mRequests.bValidationMessage = oSideEffects.EffectTypes.EnumMember === "ValidationMessage" ? true : mRequests.bValidationMessage;
		mRequests.bFieldControl = oSideEffects.EffectTypes.EnumMember === "FieldControlChange" ? true : mRequests.bFieldControl;

		// collect URL parameters and check for global prepare.
		this._setSelect(oSideEffects, mParameters, mRequests, oContext);

		// set the function to be executed to create the request.
		fFunction = function (bGlobal) {
			// for field control no preparation or validation action shall be executed.
			if (sMethod) {
				that.getTransactionController().getDraftController()[sMethod](oContext, mParameters);
			}

			if (!bGlobal) {
				that._read(oContext.getPath(), mParameters);
			}
		};
		mRequests.aRequests.push(fFunction);
	};

	/**
	 * Checks the controls of the given group for client errors.
	 *
	 * @param {string} sGroupId The Id of the group.
	 * @param {object} oView Reference to the view
	 * @returns {boolean} <code>true</code> if client errors exist otherwise <code>false</code>.
	 * @private
	 */
	ApplicationController.prototype._hasClientErrors = function (sGroupId, oView) {
		var i, len, oControl, aControls;

		aControls = oView.getControlsByFieldGroupId(sGroupId);

		if (aControls) {
			len = aControls.length;

			for (i = 0; i < len; i++) {
				oControl = aControls[i];

				if (oControl && oControl.getParent) {
					oControl = oControl.getParent(); // get parental SmartField

					if (oControl && oControl.checkClientError && oControl.checkClientError()) {
						return true;
					}
				}
			}
		}

		return false;
	};

	/**
	 * Creates a $select statement for rereading an entity based upon the side effects annotation.
	 *
	 * @param {object} oSideEffects The side effects annotation
	 * @param {map} mParameters Parameters to control the behavior of the request
	 * @param {map} mRequests Collection of all requests
	 * @param {sap.ui.model.Context} oContext The given binding context
	 *
	 * @private
	 */
	ApplicationController.prototype._setSelect = function (oSideEffects, mParameters, mRequests, oContext) {
		var i, len = 0, oTarget, aSelect = [], aExpand = [], aTargetEntities = [], sNavigationPath;

		if (!mRequests.bGlobal) {
			if ((!oSideEffects.TargetEntities || oSideEffects.TargetEntities.length === 0) && (!oSideEffects.TargetProperties || oSideEffects.TargetProperties.length === 0)) {
				mRequests.bGlobal = true;
				return;
			}

			if (oSideEffects.TargetEntities) {
				len = oSideEffects.TargetEntities.length;

				if (len > 0) {
					for (i = 0; i < len; i++) {
						oTarget = oSideEffects.TargetEntities[i];

						if (oTarget.NavigationPropertyPath === "") {
							aSelect.push('*');
						} else {
							aSelect.push(oTarget.NavigationPropertyPath);
							if (aExpand.indexOf(oTarget.NavigationPropertyPath) === -1) {
								aExpand.push(oTarget.NavigationPropertyPath);
							}
						}
						aTargetEntities.push(oTarget.NavigationPropertyPath);
					}
				}
			}

			if (oSideEffects.TargetProperties) {
				len = oSideEffects.TargetProperties.length;

				if (len > 0) {
					for (i = 0; i < len; i++) {
						oTarget = oSideEffects.TargetProperties[i];
						sNavigationPath = "";

						if (oTarget.PropertyPath.indexOf("/") !== -1) {
							var sEntitySet = ModelUtil.getEntitySetFromContext(oContext);
							var oMetaModel = this._oModel.getMetaModel();
							var sEntityType = oMetaModel.getODataEntitySet(sEntitySet).entityType;
							var oEntityType = oMetaModel.getODataEntityType(sEntityType);
							var aParts = oTarget.PropertyPath.split("/");
							var oAssociationEnd;

							if (aParts.length > 1) {
								for (var j = 0; j < (aParts.length - 1); j++) {
									oAssociationEnd = oMetaModel.getODataAssociationEnd(oEntityType, aParts[j]);
									if (oAssociationEnd) {
										oEntityType = oMetaModel.getODataEntityType(oAssociationEnd.type);
										if (sNavigationPath) {
											sNavigationPath = sNavigationPath + "/";
										}
										sNavigationPath = sNavigationPath + aParts[j];
									} else {
										// we reached a complex type
										break;
									}
								}
							}
						}

						if (aTargetEntities.indexOf(sNavigationPath) === -1) {
							// only in case not complete entity is read use $select for this entity

							if (sNavigationPath && aExpand.indexOf(sNavigationPath) === -1) {
								aExpand.push(sNavigationPath);
							}

							aSelect.push(oTarget.PropertyPath);
						}
					}
				}
			}
		}

		if (aSelect.length > 0) {
			mParameters.readParameters = [
				"$select=" + aSelect.join(",")
			];

			if (aExpand.length > 0) {
				mParameters.readParameters.push("$expand=" + aExpand.join(','));
			}
		}
	};

	/**
	 * Returns the side effect annotation for a given field group ID.
	 *
	 * @param {object} oID Field group ID
	 * @returns {object} The side effect annotation for a given ID
	 * @private
	 */
	ApplicationController.prototype._getSideEffect = function (oID) {
		var oMeta, oResult, sMethod, sFullname;

		oMeta = this._oModel.getMetaModel();
		sMethod = "getOData" + oID.originType.substring(0, 1).toUpperCase() + oID.originType.substring(1);

		if (oID.originNamespace) {
			sFullname = oID.originNamespace + "." + oID.originName;
		} else {
			sFullname = oID.originName;
		}

		if (oMeta[sMethod]) {
			oResult = oMeta[sMethod](sFullname);

			if (oResult) {
				return oResult[oID.name];
			}
		}

		throw "Unknown SideEffect originType: " + oID.originType;
	};

	/**
	 * Returns the current transaction controller instance.
	 *
	 * @returns {sap.ui.generic.app.transaction.TransactionController} The transaction controller instance
	 *
	 * @public
	 */
	ApplicationController.prototype.getTransactionController = function () {
		// create the transaction controller lazily.
		if (!this._oTransaction) {
			this._oTransaction = new TransactionController(this._oModel, this._oQueue, {
				noBatchGroups: true
			});
		}

		return this._oTransaction;
	};

	/**
	 * Invokes an action for every provided context where the properties are taken as input from.
	 * The changes are submitted directly to the back-end.
	 *
	 * @param {string} sFunctionName The name of the function or action that shall be triggered.
	 * @param {array} aContexts The given binding contexts where the parameters of the action shall be filled from.
	 * @param {map} mParameters Parameters to control the behavior of the request.
	 * @param {String} mParameters.operationGrouping if set to "com.sap.vocabularies.UI.v1.OperationGroupingType/ChangeSet" 
	 * 				   for every actition call a new group is used.
	 * @returns {Promise} A <code>Promise</code> for asynchronous execution of the action
	 * @throws {Error} Throws an error if the OData function import does not exist or the action input parameters are invalid
	 *
	 * @public
	 */
	ApplicationController.prototype.invokeActions = function (sFunctionName, aContexts, mParameters) {
		var oContext, i, len, fnChanges, aPromises = [], oSideEffect;
		mParameters = mParameters || {};

		len = aContexts.length;
		fnChanges = this._getChangeSetFunc(sFunctionName, aContexts, mParameters.operationGrouping);

		if (len === 0) {
			aPromises.push(this._invokeAction(sFunctionName, null, null, mParameters.urlParameters));
		} else {
			// Fire all Actions and bring them in order
			for (i = 0; i < len; i++) {
				aPromises.push(this._invokeAction(sFunctionName, aContexts[i], fnChanges(i), mParameters.urlParameters));
			}
		}

		// check if side effect is annotated and if a validate or prepare shall be sent
		var oFunctionImport = this._oModel.getMetaModel().getODataFunctionImport(sFunctionName);
		for (var p in oFunctionImport) {
			if (jQuery.sap.startsWith(p, "com.sap.vocabularies.Common.v1.SideEffects")) {
				oSideEffect = oFunctionImport[p];
				break;
			}
		}

		if (oSideEffect) {
			this._executeSideEffectsForActions(oSideEffect, aContexts);
		}

		// trigger submitting the batch.
		mParameters = {
			batchGroupId: "Changes",
			changeSetId: "Action" + fnChanges(i + 1),
			successMsg: "Call of action succeeded",
			failedMsg: "Call of action failed",
			//urlParameters: mParameters.urlParameters,
			forceSubmit: true,
			context: oContext
		};

		aPromises.push(this.triggerSubmitChanges(mParameters));

		return this._newPromiseAll(aPromises).then(function (aResponses) {
			var i, bAtLeastOneSuccess = false;

			if (aResponses && aResponses.length > aContexts.length) {
				aResponses.pop(); //last response from triggerSubmitChanges, remove to the outside world
			}

			if (aContexts.length <= aResponses.length) {
				for (i = 0; i < aContexts.length; i++) {
					aResponses[i].actionContext = aContexts[i];
					if (!aResponses[i].error) {
						bAtLeastOneSuccess = true;
					}
				}
				if (aContexts.length === 0) {
					for (i = 0; i < aResponses.length; i++) {
						if (!aResponses[i].error) {
							bAtLeastOneSuccess = true;
						}
					}
				}
			}

			if (bAtLeastOneSuccess) {
				return aResponses;
			} else {
				return Promise.reject(aResponses);
			}
		});
	};


	/**
	 * executes annotated side effect for properties/navigation properties or navigation entities. If no properties
	 * or entities are passed the unspecified side effect is executed which reads either the annotated targets of the
	 * unspecified side effect or in case of no available annotation a complete model refresh
	 *
	 * @param {sap.ui.model.Context} oContext The given binding context
	 * @param {array} aSourceProperties An array of properties of the given context or properties in a 1:1 association
	 * 								    for those side effects shall be executed
	 * @param {array} aSourceEntities An array of entities (navigation properties) for those side effects shall be executed.
	 * @param {boolean} bForceGlobalRefresh If not set to <code>false</code> explicitly a global model refresh is triggered.
	 *
	 * @returns {Promise} A <code>Promise</code> for asynchronous execution of the action.
	 *
	 * @public
	 */
	ApplicationController.prototype.executeSideEffects = function (oContext, aSourceProperties, aSourceEntities, bForceGlobalRefresh) {
		var oSideEffect, sNavigationPath, sProperty, bExecuteSideEffect, fnRequest, sQualifier;
		var bGlobal = !aSourceProperties && !aSourceEntities;
		var mRequests = {
			bGlobal: false,
			aRequests: []
		};
		var mParams = {
			batchGroupId: "Changes",
			changeSetId: "SideEffects",
			noShowSuccessToast: true,
			forceSubmit: true,
			noBlockUI: true,
			urlParameters: {}
		};
		var sEntitySet = ModelUtil.getEntitySetFromContext(oContext);
		var oMetaModel = oContext.getModel().getMetaModel();
		var sEntityType = oMetaModel.getODataEntitySet(sEntitySet).entityType;
		var oEntityType = oMetaModel.getODataEntityType(sEntityType);
		var i = 0;

		bForceGlobalRefresh = !(bForceGlobalRefresh === false);

		aSourceEntities = aSourceEntities || [];
		aSourceProperties = aSourceProperties || [];

		var fnExecuteSideEffect = function (oSideEffect) {

			// set the side effects qualifier as action input.
			if (sQualifier) {
				mParams.urlParameters.SideEffectsQualifier = sQualifier;
			} else {
				delete mParams.urlParameters.SideEffectsQualifier;
			}

			this._executeSideEffects(oSideEffect, oContext, mParams, mRequests);
			if (mRequests.aRequests[0]) {
				fnRequest = mRequests.aRequests[0];
				fnRequest(mRequests.bGlobal);
				mRequests.aRequests = [];
			}
		}.bind(this);

		for (var p in oEntityType) {
			if (jQuery.sap.startsWith(p, "com.sap.vocabularies.Common.v1.SideEffects")) {
				oSideEffect = oEntityType[p];
				bExecuteSideEffect = false;

				sQualifier = this._getSideEffectsQualifier(p);

				if (bGlobal) {
					if (!oSideEffect.SourceProperties && !oSideEffect.SourceEntities) {
						fnExecuteSideEffect(oSideEffect);
						bExecuteSideEffect = true;
						break;
					}
				} else {
					if (oSideEffect.SourceEntities && oSideEffect.SourceEntities.length) {
						for (i = 0; i < oSideEffect.SourceEntities.length; i++) {
							sNavigationPath = oSideEffect.SourceEntities[i].NavigationPropertyPath;
							if (aSourceEntities.indexOf(sNavigationPath) !== -1) {
								bExecuteSideEffect = true;
							}
						}
					}
					if (!bExecuteSideEffect && oSideEffect.SourceProperties && oSideEffect.SourceProperties.length) {
						for (i = 0; i < oSideEffect.SourceProperties.length; i++) {
							sProperty = oSideEffect.SourceProperties[i].PropertyPath;
							if (aSourceProperties.indexOf(sProperty) !== -1) {
								bExecuteSideEffect = true;
							}
						}
					}
					if (bExecuteSideEffect) {
						fnExecuteSideEffect(oSideEffect);
					}
				}
			}
		}

		if (mRequests.bGlobal || (bGlobal && !bExecuteSideEffect)) {

			if (bGlobal && bForceGlobalRefresh) {

				// global side effect, no side effect annotated therefore fallback is a prepare
				//if bForceGlobalRefresh is true,then refresh
				fnExecuteSideEffect({});
			}
			// unspecified side effect: so execute refresh of the complete model.
			// if false then do not update model.	
			if (bForceGlobalRefresh) {
				this._oModel.refresh(true, false, "Changes");
			}
		}


		// trigger flush.
		var oPromise = this.triggerSubmitChanges({
			batchGroupId: "Changes",
			noShowSuccessToast: true,
			forceSubmit: true,
			noBlockUI: true,
			urlParameters: {},
			draftSave: this._oModel.hasPendingChanges()
		});

		this.fireEvent("beforeSideEffectExecution", {
			promise: oPromise,
			valueChange: mRequests.bValueChange,
			validationMessage: mRequests.bValidationMessage,
			fieldControl: mRequests.bFieldControl
		});

		return oPromise;
	};

	/**
	 * Returns a promise which resolves if the given promises have been executed with at least one successfully. It rejects if all given promises were rejected.
	 *
	 * @param {array} aPromises Array containing promises and a flag if the result should be included in the response
	 * @returns {object} A promise which will wait for all given promises to finish
	 * @private
	 */
	ApplicationController.prototype._newPromiseAll = function (aPromises) {
		var aResponses = [];
		var oReadyPromise = Promise.resolve(null);

		aPromises.forEach(function (oPromise) {
			oReadyPromise = oReadyPromise.then(function () {
				return oPromise;
			}).then(function (oResponse) {
				aResponses.push({ response: oResponse });
			}, function (oError) {
				aResponses.push({ error: oError });
			});
		});

		return oReadyPromise.then(function () {
			return Promise.resolve(aResponses);
		});
	};

	/**
	 * Returns a function to calculate the changeset ID (used in action processing). If only
	 * one context instance is supplied, only one changeset is created, which contains the action
	 * invocation and possibly existing changes. When two or more contexts are provided there are
	 * two possible ways to handle:
	 * - one changeset for property/entity changes and one changeset per action invocation could be created
	 * or
	 * - possible changes and all the action invocations could be put into the same change set.
	 *
	 * Which way of processing is used depends on the action's annotations.
	 *
	 * @param {string} sFunctionName The name of the function or action.
	 * @param {array} aContexts The given binding contexts.
	 * @param {string} sOperationGrouping If this is set to "com.sap.vocabularies.UI.v1.OperationGroupingType/ChangeSet" single contexts are used.
	 * @returns {function} A function to calculate the change set ID.
	 *
	 * @private
	 */
	ApplicationController.prototype._getChangeSetFunc = function (sFunctionName, aContexts, sOperationGrouping) {
		var len = aContexts.length;
		var fnSingle = function () {
			return "Changes";
		};

		// make sure that always the same change set is used, if the action is executed for one context instance only.
		if (len === 1) {
			return fnSingle;
		}

		// OperationGrouping ChangeSet results that all action calls are put into one changeSet
		if (sOperationGrouping === "com.sap.vocabularies.UI.v1.OperationGroupingType/ChangeSet") {
			return fnSingle;
		}

		// return as default different change set IDs for multiple contexts - at least for the time being.
		return function (i) {
			return "Changes" + i;
		};
	};

	/**
	 * Creates a context for an action call (OData function import)
	 *
	 * @param {string} sFunctionName Name of the function import that shall be triggered.
	 * @param {object} oEntityContext The given binding context of the object on which the action is called.
	 * @param {map} mParameters Parameters to control the behavior of the request.
	 *
	 * @returns {map} A <code>map</code> that contains two Promises:
	 *                <code>context</code> which provides the action-specific model context to the resolve function
	 *                <code>result</code> which resolves when the success handler is called and rejects when the error handler is called;
	 * 				  The result of the promises is noramlized in both cases, error and success.
	 *
	 * @since 1.38
	 * @experimental
	 * @public
	 */
	ApplicationController.prototype.getNewActionContext = function (sFunctionName, oEntityContext, mParameters) {

		var that = this;
		mParameters = jQuery.extend({
			batchGroupId: "Changes",
			changeSetId: "SingleAction",
			successMsg: "Call of action succeeded",
			failedMsg: "Call of action failed",
			forceSubmit: true,
			context: oEntityContext,
			functionImport: this._oMeta.getODataFunctionImport(sFunctionName.split("/")[1])
		}, mParameters);

		var oFuncHandle = this._createFunctionContext(oEntityContext, mParameters);

		// Add "formatters" for error and success messages
		oFuncHandle.result = oFuncHandle.result.then(function (oResponse) {
			return that._normalizeResponse(oResponse, true);
		}, function (oResponse) {
			var oOut = that._normalizeError(oResponse);
			throw oOut;
		});

		return oFuncHandle;
	};

	/**
	 * Builds a consistent chain for all given actions and their implicit dependencies (e.g. side effects)
	 * and submits the changes to the back-end.
	 *
	 * @param {object} oActionContext Either one or an array of action context objects
	 *        created by {@link sap.ui.generic.app.ApplicationController#createActionContext}
	 * @param {string} sFunctionName The name of the function or action
	 *
	 * @since 1.38
	 * @experimental
	 * @private
	 */
	ApplicationController.prototype.submitActionContext = function (oActionContext, sFunctionName) {
		var oSideEffect;

		// check if side effect is annotated and if a validate or prepare shall be sent
		var oFunctionImport = this._oModel.getMetaModel().getODataFunctionImport(sFunctionName);
		for (var p in oFunctionImport) {
			if (jQuery.sap.startsWith(p, "com.sap.vocabularies.Common.v1.SideEffects")) {
				oSideEffect = oFunctionImport[p];
				break;
			}
		}

		if (oSideEffect) {
			this._executeSideEffectsForActions(oSideEffect, [oActionContext]);
		}


		this.triggerSubmitChanges({
			batchGroupId: "Changes",
			successMsg: "Call of action succeeded",
			failedMsg: "Call of action failed",
			//urlParameters: mParameters.urlParameters,
			forceSubmit: true,
			context: oActionContext
		});
	};

	/**
	 * Invokes an action with the given name and submits changes to the back-end.
	 *
	 * @param {string} sFunctionName The name of the function or action.
	 * @param {sap.ui.model.Context} oContext The given binding context.
	 * @param {string} sChangeSetID the ID of the change set to place the action invocation in.
	 * @param {map} mUrlParams Parameter map with additional URL parameters.
	 * @returns {Promise} A <code>Promise</code> for asynchronous execution of the action.
	 * @throws {Error} Throws an error if the OData function import does not exist or the action input parameters are invalid.
	 *
	 * @experimental Since 1.32.0
	 *
	 * @private
	 */
	ApplicationController.prototype._invokeAction = function (sFunctionName, oContext, sChangeSetID, mUrlParams) {
		var that = this;
		var mParameters = {
			batchGroupId: "Changes",
			changeSetId: sChangeSetID,
			successMsg: "Call of action succeeded",
			failedMsg: "Call of action failed",
			urlParameters: mUrlParams,
			forceSubmit: true,
			context: oContext
		};

		return this._callAction(sFunctionName, oContext, mParameters).then(function (oResponse) {
			return that._normalizeResponse(oResponse, true);
		}, function (oResponse) {
			var oOut = that._normalizeError(oResponse);
			throw oOut;
		});
	};

	/**
	 * Frees all resources claimed during the life-time of this instance.
	 *
	 * @experimental Since 1.32.0
	 * @public
	 */
	ApplicationController.prototype.destroy = function () {
		BaseController.prototype.destroy.apply(this, []);

		if (this._oTransaction) {
			this._oTransaction.destroy();
		}

		this._oModel = null;
		this._oTransaction = null;
		this._oGroupChanges = null;
	};

	return ApplicationController;

}, true);

}; // end of sap/ui/generic/app/ApplicationController.js
