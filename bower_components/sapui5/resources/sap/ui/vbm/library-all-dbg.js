// This file has been generated by the SAPUI5 'AllInOne' Builder
// ...........................................................................//
// Actions namespace.........................................................//

// Author: Ulrich Roegelein

// ...........................................................................//
// helper functions..........................................................//

// ...........................................................................//
// actions provider..........................................................//
// ...........................................................................//

VBI.Actions = function() {
	"use strict";
	/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
	var actions = {};
	actions.m_actions = []; // array of actions

	actions.clear = function() {
		// clear the data type provider........................................//
		for (var nJ = 0; nJ < actions.m_actions.length; ++nJ) {
			actions.m_actions[nJ].clear();
		}

		// reset array
		actions.m_actions = [];
	};

	actions.Set = function(dat, id, ctx) {
		if (id) {
			// setting a specifivc action.......................................//
			var action;
			if ((action = actions.findById(id))) {
				action.load(dat, ctx); // load the action...//
			} else {
				// create the new action load and push it........................//
				action = new VBI.Actions.Action();
				action.load(dat, ctx);
				actions.m_actions.push(action);
			}
			return;
		}
	};

	actions.Remove = function(dat, id, ctx) {
		if (id) {
			// remove a specific action.........................................//
			var action;
			if ((action = actions.findById(id))) {
				actions.m_actions.splice(action.m_nArrayIndex, 1);
			}

			return;
		}
	};

	actions.load = function(dat, ctx) {
		var nJ;
		// first process all data removes......................................//
		if (dat.Remove) {
			// check if there are multiple sets.................................//
			if (jQuery.type(dat.Remove) == 'array') {
				// remove an array of actions....................................//
				for (nJ = 0; nJ < dat.Remove.length; ++nJ) {
					actions.Remove(dat.Remove[nJ], dat.Remove[nJ].id, ctx);
				}
			}
		}

		// load the json delta data............................................//
		if (dat.Set) {
			// check if there are multiple sets.................................//
			if (jQuery.type(dat.Set) == 'array') {
				// load an array of actions......................................//
				for (nJ = 0; nJ < dat.Set.length; ++nJ) {
					actions.Set(dat.Set[nJ].Action, dat.Set[nJ].id, ctx);
				}
				return;
			}

			// check if there are multiple sets.................................//
			if (jQuery.type(dat.Set) == '') {
				// load an array of actions......................................//
				for (nJ = 0; nJ < dat.Set.length; ++nJ) {
					actions.Set(dat.Set[nJ].Action, dat.Set[nJ].id, ctx);
				}
				return;
			}

			// clear all actions when this is not a set by id...................//
			if (!dat.Set.id) {
				actions.clear();
			}

			if (jQuery.type(dat.Set.Action) == 'object') {
				actions.Set(dat.Set.Action, dat.Set.Action.id, ctx);
			} else if (jQuery.type(dat.Set.Action) == 'array') {
				// load an array of actions
				for (nJ = 0; nJ < dat.Set.Action.length; ++nJ) {
					actions.Set(dat.Set.Action[nJ], dat.Set.Action[nJ].id, ctx);
				}
			}
		}
	};

	actions.findById = function(id) {
		// find the action.....................................................//
		var aAction = actions.m_actions, len = aAction.length;
		for (var nJ = 0; nJ < len; ++nJ) {
			var a = aAction[nJ];
			if (a && (a.m_id == id)) {
				a.m_nArrayIndex = nJ; // set the array index................//
				return a;
			}
		}
	};

	actions.findAction = function(evtname, scene, vo, actionID) {
		// the vo can be either a string or an object..........................//
		// for map actions the vo is usually a string..........................//

		var id = null;
		if (jQuery.type(vo) == 'object') {
			id = vo.m_ID;
		} else if (jQuery.type(vo) == 'string') {
			id = vo;
		}

		// find the fitting action.............................................//
		var tmp, len = actions.m_actions.length;
		for (var nJ = 0; nJ < len; ++nJ) {
			tmp = actions.m_actions[nJ];
			if ((evtname ? (tmp.m_refEvent == evtname) : true) && (scene ? (tmp.m_refScene == scene.m_ID) : true) && (vo ? (tmp.m_refVO == id) : true) && (actionID ? (tmp.m_id == actionID) : true)) {
				return tmp;
			}
		}
		return null;
	};

	// ........................................................................//
	// action implementation..................................................//

	VBI.Actions.Action = function() {
		var action = {};

		action.m_id = 0;
		action.m_name = null;
		action.m_refScene = null;
		action.m_refVO = null;
		action.m_refEvent = null;

		// additional properties array.........................................//
		action.m_additionalProperties = [];

		action.clear = function() {
			action.m_addProperties = null;
		};

		action.load = function(dat, ctx) {
			// load the attributes
			action.m_id = dat.id;
			action.m_name = dat.name;
			action.m_refScene = dat.refScene;
			action.m_refVO = dat.refVO;
			action.m_refEvent = dat.refEvent;

			// reset additional properties to be able to reload an existing.....//
			// action...........................................................//
			action.m_additionalProperties = [];

			// check if there are additional properties requested...............//
			if (dat.AddActionProperty) {
				if (jQuery.type(dat.AddActionProperty) == 'object') {
					// load additional properties when it is just an object.......//
					action.m_additionalProperties.push(dat.AddActionProperty.name);
				} else if (jQuery.type(dat.AddActionProperty) == 'array') {
					// load additional properties when specified as an array......//
					for (var nJ = 0; nJ < dat.AddActionProperty.length; ++nJ) {
						action.m_additionalProperties.push(dat.AddActionProperty[nJ].name);
					}
				}
			}
		};

		return action;
	};

	return actions;
};
// ...........................................................................//
// Automations namespace.........................................................//

// Author: Juergen Gatter

// ...........................................................................//
// helper functions..........................................................//

// ...........................................................................//
// automations provider......................................................//
// ...........................................................................//

VBI.Automations = function() {
	"use strict";
	/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
	var automations = {};
	automations.m_automations = []; // array of automations

	automations.clear = function() {
		// clear the data type provider........................................//
		for (var nJ = 0; nJ < automations.m_automations.length; ++nJ) {
			automations.m_automations[nJ].clear();
		}

		// reset array
		automations.m_automations = [];
	};

	automations.load = function(dat, ctx) {
		// load the json delta data............................................//
		if (dat.Call) {
			var automation = {};
			if (jQuery.type(dat.Call) == 'object') {
				automation = new VBI.Automations.Automation();
				automation.load(dat.Call, ctx); // load the automation...//

				automations.m_automations.push(automation);
				/*
				 * TO DO:
				 * load when there is only one object
				 */
			} else if (jQuery.type(dat.Call) == 'array') {
				// load an array of automations
				for (var nJ = 0; nJ < dat.Call.length; ++nJ) {
					automation = new VBI.Automations.Automation();
					automation.load(dat.Call[nJ], ctx); // load the automation...//

					automations.m_automations.push(automation);
				}
			}
		}
	};

	// ........................................................................//
	// automation implementation..............................................//

	VBI.Automations.Automation = function() {
		var automation = {};

		// additional properties array.........................................//
		automation.m_additionalProperties = [];

		automation.clear = function() {
			automation.m_addProperties = null;
		};

		automation.createHandler = function(dat, handler) {
			switch (handler) {
				case "CONTEXTMENUHANDLER":
					return new VBI.ContextMenuHandler(dat);
				case "FLYTOHANDLER":
					return new VBI.FlyToHandler(dat);
				case "OBJECTCREATIONHANDLER":
					return new VBI.ObjectCreationHandler(dat);
				case "LOOPBACKHANDLER":
					return new VBI.LoopBackHandler(dat);
				default:
					return undefined;
			}
		};

		automation.getMainScene = function(ctx) { // in case there is anyway only one scene we use this scene
			if (ctx.m_SceneManager.m_SceneArray.length == 1) {
				return ctx.m_SceneManager.m_SceneArray[0].m_ID;
			}
			return undefined;
		};

		automation.load = function(dat, ctx) {
			automation.m_handlerName = dat.handler;
			automation.m_handler = automation.createHandler(dat.Param, dat.handler);
			if (!automation.m_handler) {
				return;
			}
			automation.m_handler.m_Ctx = ctx;
			automation.m_name = dat.name;
			if (automation.m_handler.m_scene == undefined) {
				automation.m_handler.m_scene = (dat.scene == undefined ? automation.getMainScene(ctx) : dat.scene);
			}
			automation.m_delay = (dat.delay == undefined ? 1 : dat.delay);
			automation.m_earliest = (dat.earliest == undefined ? 1 : dat.earliest);
			automation.m_retryAfterMS = (dat.retryAfterMS == undefined ? 0 : dat.retryAfterMS);
			automation.m_reattempts = (dat.reattempts == undefined ? -1 : dat.reattempts);
			automation.m_handler.m_refID = (dat.refID == undefined ? "" : dat.refID);
			automation.m_handler.m_refObj = (dat.object == undefined ? "" : dat.object);
			automation.m_handler.m_refInstance = (dat.object == undefined ? "" : dat.instance);
			automation.m_handler.m_Name = dat.name; // set the function name to be called
			automation.m_nAttempts = 0;
			var now = new Date();
			var runningTime = now.getTime() - ctx.m_StartupTime;
			var nCurrentDelay = automation.m_delay;
			if (runningTime < automation.m_earliest) {
				nCurrentDelay = Math.max(nCurrentDelay, automation.m_earliest - runningTime);
			}
			automation.m_AnimZoomTimer = window.setInterval(automation.startAutomation, nCurrentDelay);
		};

		automation.startAutomation = function() {
			window.clearInterval(automation.m_AnimZoomTimer);

			if (!automation.m_handler.start() && automation.m_retryAfterMS) {
				automation.m_nAttempts++;
				if ((automation.m_reattempts == -1) || (automation.m_nAttempts < automation.m_reattempts)) {
					automation.m_AnimZoomTimer = window.setInterval(automation.startAutomation, automation.m_retryAfterMS);
				}
			}
		};

		return automation;
	};

	return automations;
};

VBI.FlyToHandler = function(dat) {
	"use strict";
	var flyToHandler = {};
	flyToHandler.cnt = 0;
	for (var i = 0; i < dat.length; ++i) {
		if (dat[i].name === "x") {
			flyToHandler.m_x = dat[i]["#"];
		}
		if (dat[i].name === "y") {
			flyToHandler.m_y = dat[i]["#"];
		}
		if (dat[i].name === "lod") {
			flyToHandler.m_lod = dat[i]["#"];
		}
		if (dat[i].name === "mode") {
			flyToHandler.m_mode = dat[i]["#"];
		}
		if (dat[i].name === "velocity") {
			flyToHandler.m_velocity = dat[i]["#"];
		}
		if (dat[i].name === "basetime") {
			flyToHandler.m_basetime = dat[i]["#"];
		}
		if (dat[i].name === "scene") {
			flyToHandler.m_scene = dat[i]["#"];
		}
		if (dat[i].name === "zoomToAll") {
			flyToHandler.m_zoomToAll = dat[i]["#"];
		}
	}

	flyToHandler.start = function() {
		if (VBI.m_bTrace) {
			VBI.m_bTrace && VBI.Trace("FlyTo triggered to " + flyToHandler.m_x + "," + flyToHandler.m_y + "," + flyToHandler.m_lod + " on scene " + flyToHandler.m_scene);
		}
		if (flyToHandler.m_scene == undefined || flyToHandler.m_x == undefined || flyToHandler.m_y == undefined || flyToHandler.m_lod == undefined) {
			return true; // unsuccessful but repeating makes no sense either
		}
		var scene = flyToHandler.m_Ctx.m_SceneManager.GetSceneByName(flyToHandler.m_scene);

		if (scene) {
			if (flyToHandler.m_zoomToAll) {
				scene.ZoomToAll();
			} else {
				var lod = flyToHandler.m_lod;
				var lonlat = VBI.MathLib.DegToRad([parseFloat(flyToHandler.m_x), parseFloat(flyToHandler.m_y)]);
				scene.ZoomToGeoPosition(lonlat, lod);
			}
		}
		return true;
	};

	return flyToHandler;
};

VBI.ContextMenuHandler = function(dat) {
	"use strict";
	var contextMenuHandler = {};
	contextMenuHandler.cnt = 0;
	for (var i = 0; i < dat.length; ++i) {
		if (dat[i].name === "x") {
			contextMenuHandler.m_x = parseInt(dat[i]["#"], 10);
		}
		if (dat[i].name === "y") {
			contextMenuHandler.m_y = parseInt(dat[i]["#"], 10);
		}
		if (dat[i].name === "scene") {
			contextMenuHandler.m_scene = dat[i]["#"];
		}
	}

	contextMenuHandler.start = function() {
		var scene = contextMenuHandler.m_Ctx.m_SceneManager.GetSceneByName(contextMenuHandler.m_scene);
		var ctx = contextMenuHandler.m_Ctx;
		var oMenuObject = ctx.m_Menus.findMenuByID(contextMenuHandler.m_refID);
		if (!scene) {
			return true;
		}

		oMenuObject.vbi_data.scene = contextMenuHandler.m_scene;
		oMenuObject.vbi_data.object = contextMenuHandler.m_refObj;
		oMenuObject.vbi_data.instance = contextMenuHandler.m_refInstance;

		// remember open menu to be able to close it & close open menus before
		if (ctx.m_strOpenMenu) {
			var oMenuObjectOld = ctx.m_Menus.findMenuByID(ctx.m_strOpenMenu);
			oMenuObjectOld.close();
		}
		ctx.m_strOpenMenu = contextMenuHandler.m_refID;

		oMenuObject.open(true, 0, "begin top", "begin top", scene.m_Div, "" + contextMenuHandler.m_x + " " + contextMenuHandler.m_y + "", "fit");
	};

	return contextMenuHandler;
};

// ...........................................................................//
// handler for triggering object creations...................................//

VBI.ObjectCreationHandler = function(dat) {
	"use strict";
	var handler = {};
	handler.cnt = 0;
	handler.m_Ctx = null;
	handler.m_Name = null;

	if (jQuery.type(dat) == 'object') {
		// expect the id of the action that should be raised...................//
		if (dat.name === "data") {
			handler.m_data = dat["#"];
		}
	} else if (jQuery.type(dat) == 'array') {
		// expect the id of the action that should be raised...................//
		for (var i = 0, len = dat.length; i < len; ++i) {
			if (dat[i].name === "data") {
				handler.m_data = dat[i]["#"];
			}
		}
	}

	handler.start = function() {
		var scene = null;
		if ((scene = handler.m_Ctx.m_SceneManager.GetSceneByName(handler.m_scene))) {
			if (handler.m_Name == "CreateObject") {
				// check if there is CreateeComplete action subscribed...........//
				var action = null, actions = scene.m_Ctx.m_Actions;
				if (actions) {
					action = scene.m_Ctx.m_Actions.findAction("CreateComplete", scene, "General");
				}

				// determine the right callback function for the handler.........//
				var func = null;
				if (action) {
					// bind to a callback that raises the event...................//
					func = function(data) {
						var params = {
							data: data
						};
						scene.m_Ctx.FireAction(action, scene, "General", null, params);
					};
				} else {
					// by default we bind the loader function of the vbi instance.//
					func = scene.m_Ctx.m_Control.load.bind(scene.m_Ctx.m_Control);
				}

				scene.DesignCreateObject(handler.m_data, null, func);
			}
		}
	};

	return handler;
};

// ...........................................................................//
// handler for triggering a roundtrip by raising an action...................//

VBI.LoopBackHandler = function(dat) {
	"use strict";
	var handler = {};
	handler.cnt = 0;
	handler.m_Ctx = null;
	handler.m_Name = null;

	if (jQuery.type(dat) == 'object') {
		// expect the id of the action that should be raised...................//
		if (dat.name === "ActionID") {
			handler.m_ActionID = dat["#"];
		}
	} else if (jQuery.type(dat) == 'array') {
		// expect the id of the action that should be raised....................//
		for (var i = 0, len = dat.length; i < len; ++i) {
			if (dat[i].name === "ActionID") {
				handler.m_ActionID = dat[i]["#"];
			}
		}
	}

	handler.start = function() {
		if (handler.m_Name == "TriggerAction") {
			var actions;
			if ((actions = handler.m_Ctx.m_Actions)) {
				// check if action is subscribed....................................//
				var action;
				if ((action = actions.findAction(null, null, null, handler.m_ActionID))) {
					var scene;
					if ((scene = handler.m_Ctx.m_SceneManager.GetSceneByName(action.m_refScene))) {
						var vo = scene.BaseGetVO(action.m_refVO);
						handler.m_Ctx.FireAction(action, scene, vo ? vo : action.m_refVO, null, null);
					}
				}
			}
		}

	};

	return handler;
};
﻿// ...........................................................................//
// configuration object......................................................//

// Author: Martina Gozlinski

VBI.Configurations = function() {
	"use strict";
	/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
	var configurations = {};

	configurations.m_configdata = [];

	configurations.clear = function() {
		// clear instances and data............................................//
		configurations.m_configdata = [];
	};

	// load the configuraionts specified in the application area...............//

	configurations.load = function(dat, ctx) {
		// load the json delta data............................................//
		if (dat.Set) {

			configurations.clear();

			var res = dat.Set.P;
			if (jQuery.type(res) == 'object') {
				configurations.m_configdata[res.name] = res.value;
			} else if (jQuery.type(res) == 'array') {
				// load from array...............................................//
				for (var nJ = 0, len = res.length; nJ < len; ++nJ) {
					configurations.m_configdata[res[nJ].name] = res[nJ].value;
				}
			}
		}
	};

	configurations.GetData = function(name) {
		return configurations.m_configdata[name];
	};

	return configurations;
};
// ...........................................................................//
// DataProvider and DataType namespace.......................................//

// Author: Ulrich Roegelein

// ...........................................................................//
// helper functions..........................................................//
VBI.isInt = function(input) {
	"use strict";
	/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
	return ((input - 0) == input && input % 1 == 0);
};

VBI.IndexOf = function(array, ele) {
	"use strict";
	// to not use indexof in an array, we do this function here...............//
	var len = array.length;
	for (var nJ = 0; nJ < len; ++nJ) {
		if (ele == array[nJ]) {
			return nJ;
		}
	}
	return -1;
};

// data type enumerator......................................................//
VBI.Types = {
	// type enumeration.......................................................//
	st_unknown: 0,
	st_vector: 1,
	st_string: 2,
	st_vectorarray: 3,
	st_float: 4,
	st_color: 5,
	st_long: 6,
	st_bool: 7,
	st_vectorarraymulti: 8,

	// type conversions.......................................................//

	// ........................................................................//
	// from string conversions................................................//

	string2bool: function(a) {
		"use strict";
		if (typeof a == "boolean") {
			return a;
		}
		if (typeof a == "number") {
			return a ? true : false;
		}

		var tmp = a.slice(0, 1); // check first character only
		return (tmp == 't' || tmp == '1' || tmp == 'X') ? true : false;
	},

	string2vector: function(a) {
		"use strict";
		var error = false;
		var array = a.split(';');
		for (var nJ = 0, len = array.length; nJ < len; ++nJ) {
			array[nJ] = parseFloat(array[nJ]);
			if (!error && (isNaN(array[nJ]) || !isFinite(array[nJ]))) {
				error = true;
				jQuery.sap.log.error("The string contains invalid numbers");
			}
		}
		return array;
	},

	stringarray2vectorarray: function(a) {
		"use strict";
		var result = [];
		// we expect an array of string arrays
		for (var nI = 0, len = a.length; nI < len; ++nI) {
			var polygon = [];
			for (var nJ = 0, len2 = a[nI].length; nJ < len2; ++nJ) {
				polygon.push(this.string2vector(a[nI][nJ]));
			}
			result.push(polygon);
		}
		return result;
	},

	string2rgba: function(a) {
		"use strict";
		// return an rgba array [r,g,b,a,x] plus a 5ths component that defines that an alpha was set
		var cache, rgb;
		// CSS color formats
		if ((cache = /^rgba\(([\d]+)[,;]\s*([\d]+)[,;]\s*([\d]+)[,;]\s*([\d]+|[\d]*.[\d]+)\)/.exec(a))) {
			return [
				+cache[1], +cache[2], +cache[3], +cache[4], 1
			];
		} else if ((cache = /^rgba\(([\d]+)\%[,;]\s*([\d]+)\%[,;]\s*([\d]+)\%[,;]\s*([\d]+|[\d]*.[\d]+)\)/.exec(a))) {
			return [
				+Math.round(cache[1] * 2.55), +Math.round(cache[2] * 2.55), +Math.round(cache[3] * 2.55), +cache[4], 1
			];
		} else if ((cache = /^rgb\(([\d]+)[,;]\s*([\d]+)[,;]\s*([\d]+)\)/.exec(a))) {
			return [
				+cache[1], +cache[2], +cache[3], 1.0, 0
			];
		} else if ((cache = /^rgb\(([\d]+)\%[,;]\s*([\d]+)\%[,;]\s*([\d]+)\%\)/.exec(a))) {
			return [
				+Math.round(cache[1] * 2.55), +Math.round(cache[2] * 2.55), +Math.round(cache[3] * 2.55), 1.0, 0
			];
		} else if (a.charAt(0) === "#") {
			var sColor;
			if (a.length < 7) {
				// 3-digit hex color -> extend to 6-digit format
				sColor = a.substring(0, 2) + a.substring(1, 2) + a.substring(2, 3) + a.substring(2, 3) + a.substring(3, 4) + a.substring(3, 4);
			} else {
				sColor = a;
				return [
					parseInt(sColor.substring(1, 3), 16), parseInt(sColor.substring(3, 5), 16), parseInt(sColor.substring(5, 7), 16), 1.0, 1
				];
			}
		} else if ((cache = /^hsla\(([\d]+)[,]\s*([\d]+)\%[,]\s*([\d]+)\%[,]\s*([\d]+|[\d]*.[\d]+)\)/.exec(a))) {
			// hsla( 0-360, 0-100%, 0-100%, 0-1)
			cache = [
				+cache[1], +cache[2], +cache[3], +cache[4]
			];
			rgb = VBI.Utilities.HLS2RGB(cache[0] / 360.0, cache[2] / 100.0, cache[1] / 100.0); // Note: hsl -> HLS
			return [
				rgb[0], rgb[1], rgb[2], cache[3], 1
			];
		} else if ((cache = /^hsl\(([\d]+)[,]\s*([\d]+)\%[,]\s*([\d]+)\%\)/.exec(a))) {
			// hsl( 0-360, 0-100%, 0-100%)
			cache = [
				+cache[1], +cache[2], +cache[3]
			];
			rgb = VBI.Utilities.HLS2RGB(cache[0] / 360.0, cache[2] / 100.0, cache[1] / 100.0); // Note: hsl -> HLS
			return [
				rgb[0], rgb[1], rgb[2], 1.0, 0
			];
		} else
		// VBI internal color formats
		if ((cache = /^RGBA\(([\d]+)[,;]([\d]+)[,;]([\d]+)[,;]([\d]+|[\d]*.[\d]+)\)/.exec(a))) {
			return [
				+cache[1], +cache[2], +cache[3], parseFloat(+cache[4]) / 255.0, 1
			];
		} else if ((cache = /^RGB\(([\d]+)[,;]([\d]+)[,;]([\d]+)\)/.exec(a))) {
			return [
				+cache[1], +cache[2], +cache[3], 1.0, 0
			];
		} else if ((cache = /^ARGB\((0[xX][0-9A-Fa-f]+)[,;](0[xX][0-9A-Fa-f]+)[,;](0[xX][0-9A-Fa-f]+)[,;](0[xX][0-9A-Fa-f]+)\)/.exec(a))) {
			return [
				parseInt(cache[2], 16), parseInt(cache[3], 16), parseInt(cache[4], 16), parseFloat(+cache[1]) / 255.0, 1
			];
		} else if ((cache = /^ARGB\(([\d]+)[,;]([\d]+)[,;]([\d]+)[,;]([\d]+)\)/.exec(a))) {
			return [
				+cache[2], +cache[3], +cache[4], parseFloat(+cache[1]) / 255.0, 1
			];
		} else if ((cache = /^HLSA\(([\d]+)[,;]([\d]+)[,;]([\d]+)[,;]([\d]+)\)/.exec(a))) {
			// HLSA( 0-600, 0-600, 0-600, 0-255 )
			cache = [
				+cache[1], +cache[2], +cache[3], +cache[4]
			];
			rgb = VBI.Utilities.HLS2RGB(cache[0] / 600.0, cache[1] / 600.0, cache[2] / 600.0);
			return [
				rgb[0], rgb[1], rgb[2], cache[3] / 255, 1
			];
		} else if ((cache = /^HLS\(([\d]+)[,;]([\d]+)[,;]([\d]+)\)/.exec(a))) {
			// HLS( 0-600, 0-600, 0-600 )
			cache = [
				+cache[1], +cache[2], +cache[3]
			];
			rgb = VBI.Utilities.HLS2RGB(cache[0] / 600.0, cache[1] / 600.0, cache[2] / 600.0);
			return [
				rgb[0], rgb[1], rgb[2], 1.0, 0
			];
		}

		return [
			255, 0, 0, 1.0, 0
		];
	},

	string2color: function(a) {
		"use strict";
		var rgba = this.string2rgba(a);
		return "rgba(" + rgba[0] + "," + rgba[1] + "," + rgba[2] + "," + rgba[3] + ")";
	},

	string2rhls: function(a) {
		"use strict";
		// input: RHLS(270;0.6;0.8)
		// input: RHLSA(270;0.6;0.8;0.5)

		// return vector items:
		// 0: hue shift in degrees/360 [0,1]
		// 1: saturation factor (float) [0,1]
		// 2: luminance factor (float) [0,1]
		// 3: alpha factor ( float ) [0,1]

		var cache;
		if ((cache = /^RHLS\(([\d]+|[\d]*.[\d]+)[,;]([\d]+|[\d]*.[\d]+)[,;]([\d]+|[\d]*.[\d]+)\)/.exec(a))) {
			return [
				parseFloat(+cache[1]) / 360.0, parseFloat(+cache[2]), parseFloat(+cache[3]), 1.0
			];
		} else if ((cache = /^RHLSA\(([\d]+|[\d]*.[\d]+)[,;]([\d]+|[\d]*.[\d]+)[,;]([\d]+|[\d]*.[\d]+)[,;]([\d]+|[\d]*.[\d]+)\)/.exec(a))) {
			return [
				parseFloat(+cache[1]) / 360.0, parseFloat(+cache[2]), parseFloat(+cache[3]), parseFloat(+cache[4])
			];
		}

		return null;
	},

	color2array: function(a) {
		"use strict";
		// input rgba(128,128,128,1.0)
		// output [0.5,0.5,0.5,1.0] // red, green, blue, alpha

		var cache;
		if ((cache = /^rgba\(([\d]+)[,]([\d]+)[,]([\d]+)[,]([\d]+|[\d]*.[\d]+)\)/.exec(a))) {
			cache = [
				parseInt(+cache[1], 10), parseInt(+cache[2], 10), parseInt(+cache[3], 10), parseFloat(+cache[4])
			];
			return cache;
		}
		return null;
	},

	string2long: function(a) {
		"use strict";
		if (typeof a == "boolean") {
			return a ? 1 : 0;
		}
		return parseInt(a, 10);
	},

	string2float: function(a) {
		"use strict";
		if (typeof a == "boolean") {
			return a ? 1.0 : 0.0;
		}
		return parseFloat(a);
	},

	// ........................................................................//
	// to string conversions..................................................//

	float2string: function(a) {
		"use strict";
		return a.toString();
	},

	vector2string: function(a) {
		"use strict";
		// merge to a semicolon separated string...............................//
		var tmp = "";
		for (var nJ = 0; nJ < a.length; ++nJ) {
			tmp += a[nJ];
			if ((nJ + 1) < a.length) {
				tmp += ";";
			}
		}
		return tmp;
	},

	color2string: function(a) {
		"use strict";
		var res;
		if ((res = /^rgba\(([\d]+),([\d]+),([\d]+),([\d]+|[\d]*.[\d]+)\)/.exec(a))) {
			res = [
				+res[1], +res[2], +res[3], parseInt(parseFloat(+res[4]) * 255.0, 10)
			];
			return "RGBA(" + res[0] + "," + res[1] + "," + res[2] + "," + res[3] + ")";
		}
		return null;
	},

	long2float: function(a) {
		"use strict";
		return parseFloat(a, 10);
	},

	float2long: function(a) {
		"use strict";
		return parseInt(a, 10);
	}
};

// ...........................................................................//
// data type provider........................................................//
// ...........................................................................//

VBI.DataTypeProvider = function() {
	"use strict";
	var datatypeprovider = {};
	datatypeprovider.m_datatypenodes = [];
	datatypeprovider.vbiclass = "DataTypeProvider";

	// ........................................................................//
	// general purpose functions..............................................//

	datatypeprovider.isParentOf = function(oParent, oCurrent) {
		if (!oCurrent) {
			return false;
		}

		// check if oParent is a parent of oCurrent
		var tmp = oCurrent;
		while ((tmp = tmp.m_Parent)) {
			if (tmp == oParent) {
				return true;
			}
		}
		return false;
	};

	// ........................................................................//
	// interface functions....................................................//

	datatypeprovider.clear = function() {
		// clear the datatypeprovider..........................................//
		var o, nCount = this.m_datatypenodes.length;
		for (var nJ = 0; nJ < nCount; ++nJ) {
			if ((o = this.m_datatypenodes[nJ])) {
				o.clear();
			}
		}

		this.m_datatypenodes = []; // reset array
	};

	datatypeprovider.set = function(dat, ctx) {
		if (dat.type && dat.name) {
			/*
			 * TO DO:
			 * Set multiple types.
			 */
			if ((dat.type == "N")) {
				if (jQuery.type(dat.N) == 'object') {
					var destnode;
					if ((destnode = datatypeprovider.GetTypeNode(dat.name, true))) {
						destnode.load(dat.N);
						return;
					}
				} // else if (jQuery.type(dat.N) == 'array') {
				// set a node type............................................//
				/*
				 * TO DO:
				 * Set multiple nodes explicitily.
				 */
			}
		} else {
			// data type context should be set completely.......................//
			this.clear();
		}

		var dtn;
		if (jQuery.type(dat.N) == 'object') {
			this.m_datatypenodes.push(dtn = new VBI.DataTypeProvider.DataTypeNode(this, this.m_datatypenodes.length));

			if (dat.name) {
				dtn.m_Name = dat.name;
			}
			if (dat.N.key) {
				dtn.m_Key = dat.N.key;
			}

			// load subsequent data.......................................//
			dtn.load(dat.N);
		} else if (jQuery.type(dat.N) == 'array') {
			// load from array
			for (var i = 0, len = dat.N.length; i < len; ++i) {
				this.m_datatypenodes.push(dtn = new VBI.DataTypeProvider.DataTypeNode(this, this.m_datatypenodes.length));

				if (dat.N[i].name) {
					dtn.m_Name = dat.N[i].name;
				}
				if (dat.N[i].key) {
					dtn.m_Key = dat.N[i].key;
				}

				// load subsequent data.......................................//
				dtn.load(dat.N[i]);
			}
		}
	};

	datatypeprovider.load = function(dat, ctx) {
		// remove data first...................................................//
		// due sequence is not determined in our json, the sequence is always..//
		// remove then set, this can be different in the xml implementation....//
		// because the sequence is specified there.............................//

		// load the json delta data............................................//
		if (dat.Set) {
			if (jQuery.type(dat.Set) == 'object') {
				datatypeprovider.set(dat.Set, ctx);
			} else if (jQuery.type(dat.Set) == 'array') {
				for (var i = 0, len = dat.Set.length; i < len; ++i) {
					datatypeprovider.set(dat.Set[i], ctx);
				}
			}
		}
	};

	datatypeprovider.GetTypeNode = function(name, bcreate) {
		// get the type node...................................................//
		// when not available, create it.......................................//
		for (var i = 0; i < this.m_datatypenodes.length; ++i) {
			if (this.m_datatypenodes[i].m_Name == name) {
				return this.m_datatypenodes[i];
			}
		}

		// not found, create it................................................//
		if (!bcreate) {
			return null;
		}

		var node;
		// it is important that the new index is provided......................//
		this.m_datatypenodes.push(node = new VBI.DataTypeProvider.DataTypeNode(null, this.m_datatypenodes.length));
		node.m_Name = name;

		return node;
	};

	datatypeprovider.FindTypeRefs = function() {
		var aRef = [];
		// find the mapping reference..........................................//
		for (var i = 0, len = this.m_datatypenodes.length; i < len; ++i) {
			var ref = this.m_datatypenodes[i].m_Ref;
			if (ref) {
				aRef.push({
					m_Ref: ref,
					m_DTN: this.m_datatypenodes[i]
				});
			}
		}
		return aRef;
	};

	datatypeprovider.FindTypeNodeFromPath = function(path) {
		var nodeTemp, node = this.GetTypeNode(path[0], false); // find node but do not create
		for (var nJ = 1; nJ < path.length; ++nJ) {
			if (!(nodeTemp = node.GetTypeNode(path[nJ], false))) {
				continue;
			}

			node = nodeTemp;
		}

		return node;
	};

	datatypeprovider.FindTypeAttributeFromPath = function(path) {
		var ntPath = [];
		for (var nJ = 0; nJ < (path.length - 1); ++nJ) {
			ntPath.push(path[nJ]);
		}

		var nt = this.FindTypeNodeFromPath(ntPath); // find the nodetype
		return nt ? nt.GetTypeAttribute(path[path.length - 1]) : null; // find the attribute on the nodetype
	};

	// ........................................................................//
	// data type node.........................................................//

	VBI.DataTypeProvider.DataTypeNode = function(parent, arrayindex) {
		var datatypenode = {};
		datatypenode.m_datatypenodes = []; // a node can have other nodes or
		datatypenode.m_datatypeattributes = []; // attributes
		datatypenode.m_nArrayIndex = arrayindex; // node index inside parents container

		// a data node contains elements.......................................//
		datatypenode.m_Name = "";
		datatypenode.m_Key = null;
		datatypenode.m_Ref = null;
		datatypenode.m_Parent = parent;

		// selection types.....................................................//
		datatypenode.m_MinSelect = 1;
		datatypenode.m_MaxSelect = 1;

		// ( 0, 0 ) no selection at all will be done........................//
		// ( 0,-1 ) any number of elements can be selected, select state of elements is used, lead selection represents last positive selection
		// ( 1, 1 ) exactly one element is selected->lead selection is used and element selection is set accordingly
		// ( 1, -1) at least one element must be selected, any number of elements can be selected->lead selection can be used and can be empty

		datatypenode.clear = function() {
			var o, nJ, nCount;

			// clear inner data.................................................//
			datatypenode.m_Parent = null;

			// clear the nodes..................................................//
			nCount = datatypenode.m_datatypenodes.length;
			for (nJ = 0; nJ < nCount; ++nJ) {
				if ((o = datatypenode.m_datatypenodes[nJ])) {
					o.clear();
				}
			}
			datatypenode.m_datatypenodes = [];

			// clear the attributes.............................................//
			nCount = datatypenode.m_datatypeattributes.length;
			for (nJ = 0; nJ < nCount; ++nJ) {
				if ((o = datatypenode.m_datatypeattributes[nJ])) {
					o.clear();
				}
			}
			datatypenode.m_datatypeattributes = [];
		};

		datatypenode.load = function(dat) {
			// load data type nodes attributes..................................//
			if (dat.name) {
				datatypenode.m_Name = dat.name;
			}
			if (dat.key) {
				datatypenode.m_Key = dat.key;
			}
			if (dat.ref) {
				datatypenode.m_Ref = dat.ref;
			}
			if (dat.minSel) {
				datatypenode.m_MinSelect = parseInt(dat.minSel, 10);
			}
			if (dat.maxSel) {
				datatypenode.m_MaxSelect = parseInt(dat.maxSel, 10);
			}

			// load the attributes..............................................//
			var i;
			if (dat.A) {
				var ta;
				if (jQuery.type(dat.A) == 'array') {
					for (i = 0; i < dat.A.length; ++i) {
						// create only when not yet in.............................//
						ta = datatypenode.GetTypeAttribute(dat.A[i].name, true);
						// load subsequent data....................................//
						ta.load(dat.A[i]);
					}
				} else if (jQuery.type(dat.A) == 'object') {
					// create only when not yet in................................//
					ta = datatypenode.GetTypeAttribute(dat.A.name, true);
					// load subsequent data.......................................//
					ta.load(dat.A);
				}
			}

			// load subsequent nodes............................................//
			if (dat.N) {
				var tn;
				if (jQuery.type(dat.N) == 'array') {
					for (i = 0; i < dat.N.length; ++i) {
						datatypenode.m_datatypenodes.push(tn = new VBI.DataTypeProvider.DataTypeNode(this, datatypenode.m_datatypenodes.length));

						// load subsequent data....................................//
						tn.load(dat.N[i]);
					}
				} else if (jQuery.type(dat.N) == 'object') {
					datatypenode.m_datatypenodes.push(tn = new VBI.DataTypeProvider.DataTypeNode(this, datatypenode.m_datatypenodes.length));

					// load subsequent data.......................................//
					tn.load(dat.N);
				}
			}
		}; // end of load()

		datatypenode.GetTypeNode = function(name, bcreate) {
			// get the type node................................................//
			// when not available, create it....................................//
			var adtn = datatypenode.m_datatypenodes;
			for (var i = 0, len = adtn.length; i < len; ++i) {
				if (adtn[i].m_Name == name) {
					return adtn[i];
				}
			}

			// not found, create it.............................................//
			if (!bcreate) {
				return null;
			}

			var node;
			adtn.push(node = new VBI.DataTypeProvider.DataTypeNode(this, adtn.length));
			node.m_Name = name;

			return node;
		}; // end of GetTypeNode()

		datatypenode.GetKeyTypeAttribute = function() {
			// always create the key type attribute when not yet in.............//
			if (datatypenode.m_Key) {
				return datatypenode.GetTypeAttribute(datatypenode.m_Key, true);
			} else {
				return datatypenode.GetTypeAttribute("VB:ix", true);
			}
			return null;
		}; // end of GetKeyTypeAttribute()

		datatypenode.GetSelectTypeAttribute = function(bCreate) {
			return datatypenode.GetTypeAttribute("VB:s", bCreate);
		}; // end of GetSelectTypeAttribute()

		datatypenode.GetPath = function() {
			var names = [];
			var node = this;
			do {
				names.splice(0, 0, node.m_Name);
			} while ((node = node.m_Parent) && node['m_Name']);

			return names;
		};

		datatypenode.GetTypeAttribute = function(name, bCreate) {
			// get the type node................................................//
			// when not available, create it....................................//
			var adta = datatypenode.m_datatypeattributes;
			for (var i = 0, len = adta.length; i < len; ++i) {
				var dta = adta[i];
				// check for alias or name.......................................//
				if (dta.m_Alias == name || dta.m_Name == name) {
					return dta;
				}
			}

			if (bCreate) {
				// not found, create it and put in into the array................//
				var attribute;
				adta.push(attribute = new VBI.DataTypeProvider.DataTypeAttribute(adta.length));
				attribute.m_Name = name;
				attribute.m_Parent = this;

				// some attribute will be interpreted with a specific type.......//
				// when not set in datatypes.....................................//
				attribute.m_Type = (name == "VB:s") ? VBI.Types.st_bool : VBI.Types.st_string;

				return attribute;
			}

			return null;
		}; // end of GetTypeAttribute()

		return datatypenode;
	};

	VBI.DataTypeProvider.DataTypeAttribute = function(arrayindex) {
		var datatypeattribute = {};

		// a data type attribute may contain nodes.............................//
		datatypeattribute.m_Name = "";
		datatypeattribute.m_Alias = "";
		datatypeattribute.m_bChangeable = false; // by default attributes are !not! changeable
		datatypeattribute.m_Type = VBI.Types.st_unknown; // build in type
		datatypeattribute.m_nArrayIndex = arrayindex; // index where the attribute is located
		datatypeattribute.m_Parent = null;

		datatypeattribute.clear = function() {
			datatypeattribute.m_Parent = null; // reset the parent object
		};

		datatypeattribute.load = function(dat) {
			// load data type attributes values.................................//
			if (dat.name) {
				datatypeattribute.m_Name = dat.name;
			}
			if (dat.alias) {
				datatypeattribute.m_Alias = dat.alias;
			}
			if (dat.changeable) {
				datatypeattribute.m_bChangeable = VBI.Types.string2bool(dat.changeable);
			}

			if (dat.type) {
				switch (dat.type) {
					case "vectorarraymulti":
						datatypeattribute.m_Type = VBI.Types.st_vectorarraymulti;
						break;
					case "vectorarray":
						datatypeattribute.m_Type = VBI.Types.st_vectorarray;
						break;
					case "vector":
						datatypeattribute.m_Type = VBI.Types.st_vector;
						break;
					case "long":
						datatypeattribute.m_Type = VBI.Types.st_long;
						break;
					case "string":
						datatypeattribute.m_Type = VBI.Types.st_string;
						break;
					case "color":
						datatypeattribute.m_Type = VBI.Types.st_color;
						break;
					case "boolean":
						datatypeattribute.m_Type = VBI.Types.st_bool;
						break;
					case "float":
						datatypeattribute.m_Type = VBI.Types.st_float;
						break;
					default:
						// unknown type, set to string.............................//
						datatypeattribute.m_Type = VBI.Types.st_string;
						break;
				}
			}
		};

		return datatypeattribute;
	};

	return datatypeprovider;
};

// ...........................................................................//
// data provider.............................................................//
// ...........................................................................//

VBI.DataProvider = function() {
	"use strict";
	var dataprovider = {};

	// node, element, attribute
	var N = 0, E = 1, A = 2;

	dataprovider.vbiclass = "DataProvider";
	dataprovider.m_datanodes = [];
	dataprovider.m_dtp = null;
	dataprovider.m_Ctx = null;

	// ........................................................................//
	// dataprovider methods...................................................//

	dataprovider.clear = function() {
		// clear the datatypeprovider..........................................//
		var o, nCount = dataprovider.m_datanodes.length;
		for (var nJ = 0; nJ < nCount; ++nJ) {
			if ((o = dataprovider.m_datanodes[nJ])) {
				o.clear();
			}
		}

		// reset array
		dataprovider.m_datanodes = [];
		dataprovider.m_Ctx = null;
		dataprovider.m_dtp = null;
	};

	dataprovider.set = function(dat, ctx) {
		// the 'dat' should be now always an set object........................//

		// get the dataprovider from the context...............................//
		var dtp = ctx.m_DataTypeProvider;

		if (!dtp) {
			jQuery.sap.log.error("Data types are not available");
			return;
		}

		if (dat.type && dat.name) {
			if ((dat.type == "N")) {
				if (jQuery.type(dat.N) == 'object') { // set a node type............................................//
					var destnode;
					var path = dat.name.split(".");
					if ((destnode = this.FindNodeFromPath(path))) {
						if (dat.name != dat.N.name) {
							jQuery.sap.log.error("Node loading delta operation failed");
							return;
						}
						destnode.load(dat.N, dtp.FindTypeNodeFromPath(path));
						return;
					}
				} // else if (jQuery.type(dat.N) == 'array') {
				// set a node type............................................//
				/*
				 * TO DO:
				 * Set multiple nodes explicitly.
				 */
				// }
			} // else if ((dat.type == "E")) { }
			/*
			 * TO DO:
			 * do delta handling for elements
			 */
		} else {
			// data context should be set.......................................//
			this.clear();
		}

		if (dat.N) {
			var dtn, node, name;
			if (jQuery.type(dat.N) == 'object') {
				// ensure that node is in type section
				dtn = dtp.GetTypeNode(name = dat.N.name, true);
				this.m_datanodes[dtn.m_nArrayIndex] = (node = new VBI.DataProvider.DataNode());
				node.m_Parent = this;
				node.m_Name = name;

				// load subsequent data..........................................//
				node.load(dat.N, dtn);
			} else if (jQuery.type(dat.N) == 'array') {
				for (var i = 0; i < dat.N.length; ++i) {
					// ensure that node is in type section
					dtn = dtp.GetTypeNode(name = dat.N[i].name, true);
					this.m_datanodes[dtn.m_nArrayIndex] = (node = new VBI.DataProvider.DataNode());
					node.m_Parent = this;
					node.m_Name = name;

					// load subsequent data.......................................//
					node.load(dat.N[i], dtn);
				}
			}
		}
	};

	dataprovider.remove = function(inst, ctx) {
		// remove node.........................................................//
		var destnode, name;
		if (inst.type == "N" && (name = inst.name)) {
			if ((destnode = this.FindNodeFromPath(name.split(".")))) {
				// remove just the one node......................................//
				destnode.m_Parent.RemoveNode(destnode);
			}
		} else if (inst.type == "E" && (name = inst.name)) {
			if ((destnode = this.FindNodeFromPath(name.split(".")))) {
				// all the elements specified in the node should be..............//
				// removed.......................................................//
				destnode.RemoveElements(inst.N);
			}
		}
	};

	dataprovider.load = function(dat, ctx) { // load data in the dataprovider

		// get the dataprovider from the context...............................//
		var dtp = ctx.m_DataTypeProvider;

		// delta handling......................................................//
		// first execute the remove command....................................//
		if (dat.Remove) {
			if (jQuery.type(dat.Remove) == 'object') {
				this.remove(dat.Remove, ctx);
			} else if (jQuery.type(dat.Remove) == 'array') {
				// remove a set of objects.......................................//
				for (var nJ = 0, len = dat.Remove.length; nJ < len; ++nJ) {
					this.remove(dat.Remove[nJ], ctx);
				}
			}
		}

		// after the remove the set is executed................................//
		// load the json delta data............................................//
		if (dat.Set) {
			if (jQuery.type(dat.Set) == 'object') {
				dataprovider.set(dat.Set, ctx);
			} else if (jQuery.type(dat.Set) == 'array') {
				for (var i = 0; i < dat.Set.length; ++i) {
					dataprovider.set(dat.Set[i], ctx);
				}
			}
		}

		// store the datatypeprovider..........................................//
		dataprovider.m_dtp = dtp; // store datatypeprovider reference
		dataprovider.m_Ctx = ctx; // store context reference
	};

	dataprovider.store = function(dat) {
		if (this.IsModified()) {
			// check if dataprovider is modified
			dat.Data = {};
			dat.Data.Merge = {};
			var nodes = dat.Data.Merge.N = [];

			// the dataprovider is modofoed when one of its nodes is modified...//
			var tmp;
			for (var nJ = 0; nJ < this.m_datanodes.length; ++nJ) {
				if ((tmp = this.m_datanodes[nJ]) && tmp.IsModified()) {
					// create a node object and push..............................//
					var node = {};
					nodes.push(node);

					// call storing of nodes......................................//
					tmp.store(node);
				}
			}
		}
	};

	// ........................................................................//
	// dataprovider events....................................................//

	dataprovider.OnAttributeChanged = function(attrib) {
		// check for subscribed action and fire event..........................//
		var actions;
		if ((actions = dataprovider.m_Ctx.m_Actions)) {
			var action;
			if ((action = actions.findAction("AttributeChanged", null, null))) {
				var inst = attrib.m_Parent.GetPath() + "." + attrib.m_dta.m_Name;
				dataprovider.m_Ctx.FireAction(action, null, null, null, null, inst);
			}
		}
	};

	dataprovider.OnNodeChanged = function(node) {
		// check for subscribed action and fire event.......................//
		var actions;
		if ((actions = dataprovider.m_Ctx.m_Actions)) {
			var action;
			if ((action = actions.findAction("NodeChanged", null, null))) {
				var path = null;
				if (node.m_Parent && node.m_Parent.GetPath) {
					path = node.m_Parent.GetPath() + ".";
				} else {
					path = "";
				}
				dataprovider.m_Ctx.FireAction(action, null, null, null, null, path + node.m_dtn.m_Name);
			}
		}
	};

	dataprovider.OnElementChanged = function(element) {
		// check for subscribed action and fire event.......................//
		var actions;
		if ((actions = dataprovider.m_Ctx.m_Actions)) {
			var action;
			if ((action = actions.findAction("ElementChanged", null, null))) {
				dataprovider.m_Ctx.FireAction(action, null, null, null, null, element.GetPath());
			}
		}
	};

	// determine if something in the datacontext is modified and needs to be..//
	// serialized.............................................................//
	dataprovider.IsModified = function() {
		// the dataprovider is modofoed when one of its nodes is modified......//
		var tmp;
		for (var nJ = 0; nJ < this.m_datanodes.length; ++nJ) {
			if ((tmp = this.m_datanodes[nJ]) && tmp.IsModified()) {
				return true;
			}
		}
		return false;
	};

	dataprovider.RemoveNode = function(node) {
		var aix = node.m_dtn.m_nArrayIndex;
		this.m_datanodes[aix].clear();
		this.m_datanodes[aix] = null; // set the node to a null
	};

	// ........................................................................//
	// finding different kind of data.........................................//

	dataprovider.FindFromPathEx = function(parts, sidx, type, ele, node) {
		// when element is set, start pasing with element, else start with.....//
		// node parsing........................................................//

		var bParseElement = false, curNodeType = null, curElement = null, curNode = null;

		// get the start parameters............................................//
		if (node) {
			bParseElement = true;
			curNode = node;
			curNodeType = node.m_dtn;
		} else if (ele) {
			// set start parameters.............................................//
			curElement = ele;
			curNodeType = ele.m_Parent.m_dtn;
		}

		for (var nJ = sidx, len = parts.length; nJ < len; ++nJ) {
			if (bParseElement) {
				if (curNodeType.m_Key) {
					// expect element specified as a key..........................//
					if ((curElement = curNode.FindElementByKey(parts[nJ]))) {
						bParseElement = false;
						continue; // element parsed
					}
				} else if (VBI.isInt(parts[nJ])) {
					// element specified as an index..............................//
					curElement = curNode.m_dataelements[parseInt(parts[nJ], 10)];
					bParseElement = false; // element parsed
					continue;
				} else {
					// no element specified, so we use the first one .............//
					if (curNode.m_dataelements.length) {
						curElement = curNode.m_dataelements[0];
					}
					if (!curElement) {
						VBI.m_bTrace && VBI.Trace("Error: invalid lead selected element");
					}
				}
			}

			// check if we have to parse for the attribute......................//
			if (type == A && (nJ + 1) == len) {
				var ta;
				if ((ta = curNodeType.GetTypeAttribute(parts[nJ], false))) {
					return curElement.m_dataattributes[ta.m_nArrayIndex];
				}
			}

			// get the node type information....................................//
			curNodeType = curNodeType.GetTypeNode(parts[nJ], true);
			if (!curElement) {
				VBI.m_bTrace && VBI.Trace("Error: Invalid Binding Path " + parts);
				return false;
			}

			curNode = curElement.m_datanodes[curNodeType.m_nArrayIndex];

			// next is an element that should be parsed..........................//
			bParseElement = true;
		}

		if (type == A || type == E) {
			return null; // nothing found
		}
		return curNode; // node found
	};

	dataprovider.FindFromPath = function(parts, type) {
		if (!dataprovider.m_dtp) {
			return null; // no datatypes specified.........................//
		}

		// get the first node from the dataprovider............................//
		// provide it to the extended function to do continuous searching......//
		var curNodeType = dataprovider.m_dtp.GetTypeNode(parts[0], false);
		if (!curNodeType) {
			return null; // invalid binding path to type
		}
		var curNode = dataprovider.m_datanodes[curNodeType.m_nArrayIndex];
		if (!curNode) {
			return null; // invalid binding path to value
		}

		return dataprovider.FindFromPathEx(parts, 1, type, null, curNode);
	};

	dataprovider.FindAttributeFromPath = function(parts) {
		return dataprovider.FindFromPath(parts, A);
	};

	dataprovider.FindNodeFromPath = function(parts) {
		return dataprovider.FindFromPath(parts, N);
	};

	// global selection, all tables are affecte...............................//
	dataprovider.SetSelection = function(bSelect, bCheckCardinality) {
		var tmp, aNodes = dataprovider.m_datanodes;
		for (var nJ = 0, len = aNodes.length; nJ < len; ++nJ) {
			if ((tmp = aNodes[nJ])) {
				tmp.SetSelection(bSelect, bCheckCardinality);
			}
		}
	};

	VBI.DataProvider.DataNode = function() {
		var datanode = {};

		// a datanode contains elements........................................//
		datanode.m_Name = "";
		datanode.m_dataelements = [];
		datanode.m_Parent = null; // parent of the datanode
		datanode.m_dtn = null; // typeinfo for node
		datanode.m_bModified = false; // modified flag, usually selection

		datanode.clear = function() {
			// reset type information...........................................//
			datanode.m_dtn = null;

			// clear the elements...............................................//
			for (var nJ = 0; nJ < datanode.m_dataelements.length; ++nJ) {
				datanode.m_dataelements[nJ].clear();
				datanode.m_dataelements[nJ].m_Parent = null;
			}

			// clear the array..................................................//
			datanode.m_dataelements = [];
			datanode.m_Parent = null;
		};

		datanode.IsModifiedSelection = function() {
			return datanode.m_bModified ? true : false;
		};

		datanode.IsModifiedElements = function() {
			// the dataprovider is modofoed when one of its nodes is modified...//
			var aElements = datanode.m_dataelements;
			for (var nJ = 0; nJ < aElements.length; ++nJ) {
				if (aElements[nJ].IsModified()) {
					return true;
				}
			}
			return false;
		};

		datanode.IsModified = function() {
			// either datanode is modified or elements are modified.............//
			if (datanode.IsModifiedSelection() || datanode.IsModifiedElements()) {
				return true;
			}

			return false;
		};

		datanode.store = function(dat) {
			// store the node itself............................................//
			dat.name = datanode.m_dtn.m_Name; // set node name...............//

			// store the modified elements......................................//
			if (datanode.IsModifiedElements()) {
				dat.E = [];

				for (var nJ = 0; nJ < datanode.m_dataelements.length; ++nJ) {
					// store only modified elements...............................//
					if (datanode.m_dataelements[nJ].IsModified()) {
						// create the element object push it and call its store....//
						var ele = {};
						dat.E.push(ele);
						datanode.m_dataelements[nJ].store(ele);
					}
				}
			}
		};

		// .....................................................................//
		// node removers.......................................................//

		datanode.RemoveNode = function(node) {
			var aix = node.m_dtn.m_nArrayIndex;
			datanode.m_datanodes[aix].clear();
			datanode.m_datanodes[aix] = null; // set the node to a null
		};

		datanode.RemoveElements = function(dat) {
			// remove the elements specified in the node........................//
			// create a temporary keymap........................................//
			var kta = datanode.m_dtn.GetKeyTypeAttribute();
			var keymap = datanode.GetElementKeyMap(kta);

			// load the elements................................................//
			if (dat.E) {
				if (jQuery.type(dat.E) == 'object') {
					// find the element and remove it............................//
					datanode.InternalFindAndRemoveExistingElement(dat.E, 0, kta, keymap);
				} else if (jQuery.type(dat.E) == 'array') {
					for (var i = 0; i < dat.E.length; ++i) {
						datanode.InternalFindAndRemoveExistingElement(dat.E[i], i, kta, keymap);
					}
				}
			}
		};

		// .....................................................................//
		// element finders.....................................................//

		datanode.GetElementKeyMap = function(kta) {
			// create an element keymap.........................................//
			var tmp, keymap = [];
			var ktattribute = kta ? kta : datanode.m_dtn.GetKeyTypeAttribute();

			for (var nJ = 0; nJ < datanode.m_dataelements.length; ++nJ) {
				keymap[(tmp = datanode.m_dataelements[nJ]).m_dataattributes[ktattribute.m_nArrayIndex].m_Value] = tmp;
			}

			return keymap;
		};

		datanode.FindElementByKey = function(key, kta, keymap) {
			// use the provided map.............................................//
			var tmp;
			if (keymap) {
				return (tmp = keymap[key]) ? tmp : null;
			}

			// do sequential search.............................................//
			var ktattribute = kta ? kta : datanode.m_dtn.GetKeyTypeAttribute();

			var ele, aElements = this.m_dataelements;
			for (var nJ = 0, len = aElements.length; nJ < len; ++nJ) {
				if ((ele = aElements[nJ])) {
					if (ele.m_dataattributes[ktattribute.m_nArrayIndex].m_Value == key) {
						return ele;
					}
				}
			}
			return null;
		};

		datanode.FindElementByIndex = function(index) {
			return this.m_dataelements[index];
		};

		datanode.InternalFindAndRemoveExistingElement = function(dat, idx, kta, keymap) {
			var key = null, ele = null;
			if (kta.m_Alias && (key = dat[kta.m_Alias])) {
				ele = this.FindElementByKey(key, kta, keymap);
			} else if (kta.m_Name && (key = dat[kta.m_Name])) {
				ele = this.FindElementByKey(key, kta, keymap);
			} else {
				ele = this.FindElementByKey(key = idx, kta, keymap);
			}

			if (ele) {
				// remove the element from the array.............................//
				this.m_dataelements.splice(VBI.IndexOf(this.m_dataelements, ele), 1);

				// correct the key map...........................................//
				if (keymap) {
					keymap.splice(key, 1);
				}

				// clear the element.............................................//
				ele.clear();
			}
		};

		datanode.InternalFindOrCreateExistingElement = function(dat, idx, kta, keymap) {
			var key = null, ele = null;
			if (kta.m_Alias && (key = dat[kta.m_Alias])) {
				ele = datanode.FindElementByKey(key, kta, keymap);
			} else if (kta.m_Name && (key = dat[kta.m_Name])) {
				ele = datanode.FindElementByKey(key, kta, keymap);
			} else {
				ele = datanode.FindElementByKey(key = idx, kta, keymap);
			}

			if (ele) {
				return ele; // return the found element.......................//
			}

			// create the new element...........................................//
			ele = new VBI.DataProvider.DataElement();

			// push the element to the array....................................//
			datanode.m_dataelements.push(ele);

			// add the element to the keymap....................................//
			if (keymap) {
				keymap[key] = ele;
			}

			return ele;
		};

		datanode.load = function(dat, dtn) {
			datanode.m_dtn = dtn; // store type info for node.................//

			// create a temporary keymap........................................//
			var kta = datanode.m_dtn.GetKeyTypeAttribute();
			var keymap = datanode.GetElementKeyMap(kta);

			// load the elements................................................//
			if (dat.E) {
				var da, de;
				if (jQuery.type(dat.E) == 'object') {
					/*
					 * TO DO:
					 * Load element when it is submitted as single object.
					 */
					de = datanode.InternalFindOrCreateExistingElement(dat.E, 0, kta, keymap);
					de.m_Parent = datanode;

					// load subsequent data.......................................//
					de.load(dat.E, dtn);

					// ensure that the index attribute is available...............//
					// when not available, create it now..........................//
					if (de.m_dataattributes[kta.m_nArrayIndex] == null) {
						da = new VBI.DataProvider.DataAttribute(kta, null, de);
						da.m_Value = 0;
						de.m_dataattributes[kta.m_nArrayIndex] = da;
					}
				} else if (jQuery.type(dat.E) == 'array') {
					for (var i = 0, len = dat.E.length; i < len; ++i) {
						de = datanode.InternalFindOrCreateExistingElement(dat.E[i], i, kta, keymap);
						de.m_Parent = datanode;

						// load subsequent data....................................//
						de.load(dat.E[i], dtn);

						// ensure that the index attribute is available............//
						// when not available, create it now.......................//
						if (de.m_dataattributes[kta.m_nArrayIndex] == null) {
							da = new VBI.DataProvider.DataAttribute(kta, null, de);
							da.m_Value = i;
							de.m_dataattributes[kta.m_nArrayIndex] = da;
						}
					}
				}
			}
		};

		datanode.GetName = function() {
			/*
			 * TO DO:
			 * we can use the type for storing the name
			 */
			return this.m_Name;
		};

		datanode.GetPath = function() {
			return this.m_dtn.GetPath();
		};

		datanode.SetModified = function() {
			this.m_bModified = true; // set modified flag..................//

			var p = this;
			while (p.m_Parent) {
				p = p.m_Parent;
			}
			// raise the node changed event.....................................//
			if (p) {
				p.OnNodeChanged(this);
			}
		};

		datanode.GetSelectedElements = function() {
			var aSelElements = [];

			// get all selected elements, this includes the lead selected.......//
			// element..........................................................//

			var aElements = this.m_dataelements;
			var kta = this.m_dtn.GetTypeAttribute("VB:s", true);

			// set the selection state for all the elements.....................//
			for (var nJ = 0, len = aElements.length; nJ < len; ++nJ) {
				if (aElements[nJ].IsSelected(kta)) {
					aSelElements.push(aElements[nJ]);
				}
			}

			return aSelElements;
		};

		datanode.GetNumOfSelectedElements = function() {
			return (datanode.m_NumSelectedEltes != undefined) ? datanode.m_NumSelectedEltes : datanode.GetSelectedElements().length;
		};

		datanode.SetNumOfSelectedElements = function() {
			datanode.m_NumSelectedEltes = datanode.GetSelectedElements().length;
		};

		datanode.UnSetNumOfSelectedElements = function() {
			datanode.m_NumSelectedEltes = undefined;
		};

		datanode.SetSelection = function(bSelect, bCheckCardinality) {
			// set the selection state for all elements to the same value.......//
			// when the cardinality flag is set, it is used to keep state.......//
			// consistent.......................................................//
			var aElements = this.m_dataelements;
			var tmp = null, kta = this.m_dtn.GetTypeAttribute("VB:s", true);
			if (!bSelect && bCheckCardinality) {
				this.SetNumOfSelectedElements();
			}

			// set the selection state for all the elements.....................//
			for (var nJ = 0, len = aElements.length; nJ < len; ++nJ) {
				if ((tmp = aElements[nJ])) {
					if (bCheckCardinality) {
						tmp.Select(bSelect);
					} else {
						tmp.SetElementSelectionState(bSelect, kta);
					}
				}
			}
			this.UnSetNumOfSelectedElements();
			return null;
		};

		return datanode;
	};

	// ........................................................................//
	// DataElement............................................................//

	VBI.DataProvider.DataElement = function() {
		// a dataelement contains attributes or subsequent nodes...............//
		this.m_dataattributes = [];
		this.m_datanodes = [];
		this.m_Parent = null; // the parent should be always a node.......//
		this.m_bChangeable = false;// by default an element is not changeable..//
	};

	VBI.DataProvider.DataElement.prototype = {
		// a dataelement contains attributes or subsequent nodes...............//
		m_dataattributes: null,
		m_datanodes: null,
		m_Parent: null, // the parent should be always a node.//
		m_nModified: 0, // 0: nothing, 1: selection, 2: chanageableflag VB:c, 4: modifiedflag VB:m
		m_bChangeable: false, // the data element is not changeable.//

		clear: function() {
			// clear the nodes..................................................//
			var nJ, tmp;
			for (nJ = 0; nJ < this.m_datanodes.length; ++nJ) {
				if ((tmp = this.m_datanodes[nJ])) {
					tmp.clear();
					tmp.m_Parent = null;
				}
			}
			this.m_datanodes = [];

			// clear the attributes.............................................//
			for (nJ = 0; nJ < this.m_dataattributes.length; ++nJ) {
				if ((tmp = this.m_dataattributes[nJ])) {
					tmp.clear();
					tmp.m_Parent = null;
				}
			}

			this.m_dataattributes = [];
		},

		load: function(dat, dtn) {
			var bModified = false;
			this.m_nModified = 0;

			// get and remove the the elements modified flag....................//
			if (dat["VB:m"]) {
				// set both flags to modified, that the flags get submitted......//
				// in the next submit event......................................//
				if ((bModified = VBI.Types.string2bool(dat["VB:m"]))) {
					this.m_nModified = 7;
				}

				delete dat["VB:m"];
			}
			// get and remove the the elements changeable flag..................//
			if (dat["VB:c"]) {
				this.m_bChangeable = VBI.Types.string2bool(dat["VB:c"]);
				delete dat["VB:c"];
			}

			// add the attributes and put them into an array....................//
			for ( var a in dat) {
				if (!dat.hasOwnProperty(a)) {
					continue;
				}

				if (a == "N" && !(typeof dat[a] == 'string')) {
					var ldtn, node;
					if (jQuery.type(dat[a]) == 'object') {
						// this is interpreted as a node...........................//

						// determine the datatype node for the inner node..........//
						ldtn = dtn.GetTypeNode(dat.N.name, true);

						// place the node at its indexed position..................//
						this.m_datanodes[ldtn.m_nArrayIndex] = (node = new VBI.DataProvider.DataNode());
						node.m_Parent = this;
						node.m_Name = dat.N.name;

						node.load(dat[a], ldtn);
					} else if (jQuery.type(dat[a]) == 'array') {
						// this is interpreted as an array of nodes................//
						var na = dat[a];
						for (var nJ = 0; nJ < na.length; ++nJ) {
							var ndo = na[nJ];

							// determine the datatype node for the inner node.......//
							ldtn = dtn.GetTypeNode(ndo.name, true);

							// place the node at its indexed position...............//
							this.m_datanodes[ldtn.m_nArrayIndex] = (node = new VBI.DataProvider.DataNode());
							node.m_Parent = this;
							node.m_Name = ndo.name;

							node.load(ndo, ldtn);
						}
					}
				} else {
					// this is interpreted as an attribute........................//

					// determine the datatype attribute...........................//
					var dta = dtn.GetTypeAttribute(a, true);

					// place the attribute at the indexed position................//
					this.m_dataattributes[dta.m_nArrayIndex] = new VBI.DataProvider.DataAttribute(dta, dat[a], this, bModified);

				}
			}
		},

		IsModified: function(dat) {
			// when anything is modified return immediately.....................//
			if (this.m_nModified) {
				return true;
			}

			// check if there are attributes that are modified..................//
			var nJ, len, tmp;
			for (nJ = 0, len = this.m_dataattributes.length; nJ < len; ++nJ) {
				if ((tmp = this.m_dataattributes[nJ]) && tmp.IsModified()) {
					return true;
				}
			}

			// check if subnodes have changed...................................//
			for (nJ = 0, len = this.m_datanodes.length; nJ < len; ++nJ) {
				if ((tmp = this.m_datanodes[nJ]) && tmp.IsModified()) {
					return true;
				}
			}

			return false;
		},

		IsChangeable: function() {
			// just return the changable flag...................................//
			return this.m_bChangeable;
		},

		IsSelected: function(kta) {
			// the key type attribute can be applied to speed up in loops.......//
			var idx, dta = kta ? kta : this.m_Parent.m_dtn.GetSelectTypeAttribute(false);

			// when the select attribute is true, the item is selected..........//
			if (dta && ((idx = dta.m_nArrayIndex) < this.m_dataattributes.length)) {
				var tmp;

				// check the select attribute....................................//
				if ((tmp = this.m_dataattributes[idx])) {
					if (dta.m_Type == VBI.Types.st_string) {
						return VBI.Types.string2bool(tmp.m_Value);
					} else {
						return (tmp.m_Value ? true : false);
					}
				}
			}

			return false;
		},

		SetModified: function() {
			this.m_nModified |= 1; // set selection as modified...............//

			var p = this;
			while (p.m_Parent) {
				p = p.m_Parent;
			}
			// raise the attribute changed event................................//
			if (p) {
				p.OnElementChanged(this);
			}
		},

		store: function(dat) {
			// write the key attribute..........................................//
			var kta = this.m_Parent.m_dtn.GetKeyTypeAttribute();
			var ktaname = kta.m_Alias ? kta.m_Alias : kta.m_Name;
			dat[ktaname] = this.m_dataattributes[kta.m_nArrayIndex].GetStringValue();

			// when the changeable flag is modified, we submit the changeable ..//
			// flag as well.....................................................//

			if (this.m_nModified & 2) {
				dat["VB:c"] = this.m_bChangeable ? "true" : "false";
			}

			// when the modified flag was set initially we submit it............//
			if (this.m_nModified & 4) {
				dat["VB:m"] = "true";
			}

			// iterate through attributes and save the new values...............//
			// the selection information is in the attributes array.............//
			var nJ, len, tmp;
			for (nJ = 0, len = this.m_dataattributes.length; nJ < len; ++nJ) {
				if ((tmp = this.m_dataattributes[nJ]) && tmp.IsModified()) {
					var taname = tmp.m_dta.m_Alias ? tmp.m_dta.m_Alias : tmp.m_dta.m_Name;
					dat[taname] = tmp.GetStringValue();
				}
			}

			// iterate through nodes and save them as well......................//
			for (nJ = 0, len = this.m_datanodes.length; nJ < len; ++nJ) {
				if ((tmp = this.m_datanodes[nJ]) && tmp.IsModified()) {
					// create the node object.....................................//
					// and store the node into it.................................//
					tmp.store(dat["N"] = {});
				}
			}
		},

		// determine the elements path.........................................//
		GetKeyValue: function() {
			var kta;
			if (this.m_Parent && (kta = this.m_Parent.m_dtn.GetKeyTypeAttribute())) {
				return this.m_dataattributes[kta.m_nArrayIndex].m_Value;
			}

			return null;
		},

		// determine the explicit path of an element, this is usually needed in//
		// events that identify the clicked instance...........................//
		GetPath: function() {
			var path = null;
			var cur = this;
			while (cur) {
				// prepend key...................................................//
				var key = cur.GetKeyValue();
				if (path) {
					path = key + "." + path;
				} else {
					path = key;
				}

				// prepend node name.............................................//
				var n;
				if ((n = this.m_Parent)) {
					path = this.m_Parent.m_dtn.m_Name + "." + path;
				} else {
					break;
				}

				// go up one level...............................................//
				if (n.m_Parent && n.m_Parent.m_Parent) {
					// this is noe the dataprovider
					cur = n.m_Parent ? n.m_Parent : null;
				} else {
					break;
				}
			}

			return path;
		},

		SetElementSelectionState: function(bSelect, typeattribute) {
			// no cardinality checks are done when the function is called.......//
			var kta = typeattribute;
			if (!kta) {
				// select or unselect an element.................................//
				kta = typeattribute ? typeattribute : this.m_Parent.m_dtn.GetTypeAttribute("VB:s", true);
				kta.m_Type = VBI.Types.st_bool;
			}

			// when the key is not yet created, create it now...................//
			var idx = kta.m_nArrayIndex;
			if (this.m_dataattributes[idx] == null) {
				this.m_dataattributes[idx] = new VBI.DataProvider.DataAttribute(kta, null, this);
			}

			// set the selection state..........................................//
			// and mark it as modified..........................................//
			var bSelModified, attrib = this.m_dataattributes[idx];
			if ((bSelModified = (attrib.m_Value != (bSelect ? true : false)))) {
				attrib.m_Value = bSelect ? true : false;
				attrib.m_bModified = true;
			}

			// call modified function when selection has changed................//
			if (bSelModified) {
				this.SetModified();
				return true;
			}

			return false;
		},

		GlobalSingleSelect: function() {
			var dtn = this.m_Parent.m_dtn;
			if (dtn.m_MaxSelect == 0) {
				return 0;
			}

			// unselect all elements in this table...........................//
			this.m_Parent.SetSelection(false, false);

			// finally do the single selection on this element...............//
			this.Select(true);

			return 1;
		},

		Select: function(bSelect, oldCount) {
			var dtn = this.m_Parent.m_dtn;
			if (!oldCount) {
				oldCount = 0;
			}

			// this function checks the selection cardinalities.................//
			// selection and unselection is only possible when cardinality is...//
			// sufficient.......................................................//

			// selection is requested for the element...........................//
			// ( 0, 0 ) no selection will be done
			// ( 0,-1 ) any number of elements can be selected, select state of elements is used, lead selection represents last positive selection
			// ( 1, 1 ) exactly one element is selected->lead selection is used and element selection is set accordingly
			// ( 1, -1) at least one element must be selected, any number of elements can be selected->lead selection can be used and must not be
			// empty

			// selection remove is requested....................................//
			// ( 0, 0 ) exiting element selection is removed
			// ( 0,-1 ) exiting element selection can be removed
			// ( 1, 1 ) removing of selection not allowed
			// ( 1, -1) lead selection is keept, removing of selection only for selection state
			var nChanges;
			if (bSelect) {
				// element sould be selected.....................................//
				if (dtn.m_MaxSelect == 0) {
					// cardinality does not allow any selection
					return 0;
				}

				if (dtn.m_MaxSelect < 0) {
					// any number of elements can be selected
					nChanges = this.SetElementSelectionState(true) ? 1 : 0;
					return oldCount + nChanges;
				}

				if (dtn.m_MaxSelect == 1) {
					// exactly one element can be selected
					this.m_Parent.SetSelection(false, false); // unselect all elements, no cardinality check
					this.SetElementSelectionState(true); // select this element only
					return 1;
				}
			} else {
				// element should be unselected..................................//
				if (((dtn.m_MinSelect == 1) && (this.m_Parent.GetNumOfSelectedElements() > 1)) || (dtn.m_MinSelect == 0)) {
					// ensure that there are currently at least two elements......//
					// selected...................................................//
					nChanges = this.SetElementSelectionState(false) ? 1 : 0; // unselect this element only
					return oldCount - nChanges;
				}
			}
		},

		FindNodeFromPath: function(parts) {
			return dataprovider.FindFromPathEx(parts, 0, N, this, null);
		},

		FindAttributeFromPath: function(parts) {
			// call central function that should do everything correct..........//
			return dataprovider.FindFromPathEx(parts, 0, A, this, null);
		}
	};

	// ........................................................................//
	// DataAttribute..........................................................//

	VBI.DataProvider.DataAttribute = function(dta, value, parent, modified) {
		this.m_dta = dta; // the attributes name is stored in the dta.//
		this.m_Parent = parent;

		// set modified flag...................................................//
		if (modified) {
			this.m_bModified = true;
		}

		// data type enumerator................................................//
		// this.TypeEnum = { st_unknown : 0, st_vector : 1, st_string : 2, st_vectorarray : 3, st_float : 4, st_color : 5, st_long : 6, st_bool : 7 };

		// in this case the attributes value will not be assigned from a string//
		if (value === null) {
			return;
		}

		var vt = VBI.Types;
		if (dta.m_Type == vt.st_vectorarraymulti) {
			this.m_Value = vt.stringarray2vectorarray(value);
		} else if (dta.m_Type == vt.st_vectorarray || dta.m_Type == vt.st_vector) {
			this.m_Value = vt.string2vector(value);
		} else if (dta.m_Type == vt.st_long) {
			this.m_Value = vt.string2long(value);
		} else if (dta.m_Type == vt.st_float) {
			this.m_Value = vt.string2float(value);
		} else if (dta.m_Type == vt.st_bool) {
			this.m_Value = vt.string2bool(value);
		} else if (dta.m_Type == vt.st_color) {
			this.m_Value = vt.string2color(value);
		} else if (dta.m_Type == vt.st_string) {
			this.m_Value = value;
		} else {
			/*
			 * TO DO:
			 * support other datatypes
			 */
			this.m_Value = value;
		}
	};

	VBI.DataProvider.DataAttribute.prototype = {
		m_dta: null, // attributes type, containing name/alias......//
		m_Value: null, // attribute value, type depends on m_dta......//
		m_Parent: null, // attributes parent element...................//
		m_bModified: false, // modified state of attribute.................//

		clear: function() {
			this.m_Parent = null; // reset parent
			this.m_dta = null; // reset type relationship
		},

		store: function(dat) {
			/*
			 * TO DO:
			 * write the attribute to the object
			 */
		},

		set: function(val) {
			// set the attribute................................................//
			if (val != this.m_Value) {
				this.SetModified();
			}

			this.m_Value = val;
		},

		// .....................................................................//
		// helper functions....................................................//

		SetModified: function() {
			this.m_bModified = true;

			var p = this;
			while (p.m_Parent) {
				p = p.m_Parent;
			}
			// raise the attribute changed event................................//
			if (p) {
				p.OnAttributeChanged(this);
			}
		},

		IsModified: function() {
			return this.m_bModified;
		},

		IsChangeable: function() {
			// the attribute is changeable when the datatype and the elements...//
			// reports it as changeable.........................................//
			return (this.m_dta.m_bChangeable && this.m_Parent.m_bChangeable);
		},

		GetStringValue: function() {
			var tmp = "";

			// dependent on datatype we have to convert the value to a....//
			switch (this.m_dta.m_Type) {
				case VBI.Types.st_vectorarray:
				case VBI.Types.st_vector:
					return VBI.Types.vector2string(this.m_Value);
				case VBI.Types.st_long:
					tmp += this.m_Value;
					return tmp;
				case VBI.Types.st_float:
					tmp += this.m_Value;
					return tmp;
				case VBI.Types.st_string:
					return this.m_Value;
				case VBI.Types.st_bool:
					return this.m_Value ? "true" : "false";
				case VBI.Types.st_color:
					// convert the color back from rgba( 255,255,255, 0.1 ).......//
					// RGBA( ....)
					var cache;
					if ((cache = /^rgba\(([\d]+),([\d]+),([\d]+),([\d]+|[\d]*.[\d]+)\)/.exec(this.m_Value))) {
						cache = [
							+cache[1], +cache[2], +cache[3], parseInt(parseFloat(+cache[4]) * 255.0, 10)
						];
						return "RGBA(" + cache[0] + "," + cache[1] + "," + cache[2] + "," + cache[3] + ")";
					}
					break;
				default:
					// assume this is a string..........................................//
					return this.m_Value;
			}
		}
	};

	return dataprovider;
};

// ...........................................................................//
// data adaptors.............................................................//

VBI.Adaptor = function(ctx) {
	"use strict";
	var Ctx = ctx; // current session context................................//

	this.RecursiveLoadElement = function(de, odn, dtn) {
		var nK;
		// push the attributes into the current element........................//
		for (nK = 0; nK < dtn.m_datatypeattributes.length; ++nK) {
			var dta = dtn.m_datatypeattributes[nK];
			var da = odn[dta.m_Name];

			// append the attribute to the element, when not undefined..........//
			if (da === undefined) {
				continue;
			}

			// do correct data conversion
			if ((dta.m_Type == VBI.Types.st_vector) && jQuery.type(da) == "array") {
				de[dta.m_Alias] = "" + da[0] + ";" + da[1] + ";0";
			} else {
				de[dta.m_Alias] = da.toString();
			}
		}

		// dive deeper and get the nodes.......................................//
		if (dtn.m_datatypenodes.length) {
			var dna = de.N = [];
			for (nK = 0; nK < dtn.m_datatypenodes.length; ++nK) {
				// for each typenode create node.................................//
				var next_dn = dna[nK] = {};
				var next_dtn = dtn.m_datatypenodes[nK];
				var next_odn = odn[next_dtn.m_Name];
				if (next_odn) {
					this.RecursiveLoad(next_dn, next_odn, next_dtn);
				}
			}
		}
	};

	this.RecursiveLoad = function(dn, odn, dtn) {
		dn.name = dtn.m_Name; // set the datanode name
		dn.E = []; // create the element array

		// add all attributes to the new created elements......................//
		var de;
		if (jQuery.type(odn) == 'array') {
			for (var nJ = 0; nJ < odn.length; ++nJ) {
				de = dn.E[nJ] = {};
				this.RecursiveLoadElement(de, odn[nJ], dtn);
			}
		} else {
			de = dn.E[0] = {};
			this.RecursiveLoadElement(de, odn, dtn);
		}
	};

	this.LoadFindRefNode = function(data) {
		var aRefs = Ctx.m_DataTypeProvider.FindTypeRefs();

		for (var nJ = 0, len = aRefs.length; nJ < len; ++nJ) {
			var start = data;
			var parts = aRefs[nJ].m_Ref.split(".");
			for (var nK = 0, lenPart = parts.length; nK < lenPart; ++nK) {
				start = start[parts[nK]];
				if (start && ((nK + 1) == lenPart)) {
					aRefs[nJ].m_Root = start;
					return aRefs[nJ];
				}
				if (!start) {
					break;
				}
			}
		}

		return null; // not found
	};

	this.CreateLoadData = function(data) {
		if (!Ctx.m_DataTypeProvider) {
			return null;
		}

		var ref = null;
		if (!(ref = this.LoadFindRefNode(data))) {
			return null; // no match found
		}

		// get the type information...............................................//
		var dtn = ref.m_DTN;
		var root = ref.m_Root;

		// determine the type references..........................................//
		var vbiDat = {
			SAPVB: {
				"version": "2.0",
				"Data": {
					"Remove": {
						"type": "N",
						"name": dtn.m_Name
					},
					"Set": {
						"type": "N",
						"name": dtn.m_Name,
						"N": {}
					}
				}
			}
		};

		var odn = root;
		var dn = vbiDat.SAPVB.Data.Set.N;

		// recursively load the data...........................................//
		this.RecursiveLoad(dn, odn, dtn);

		// do a load of the converted data.....................................//
		return vbiDat;
	};
};
// ...........................................................................//
// this module does the events implementation on a scene.....................//

// Author: Ulrich Roegelein

// ...........................................................................//
// vb sap events:

// sapdown // touchstart, mousedown,
// sapmove // mousemove
// sapleave // mouseleave
// sapup
// sapclick
// sapdblclick // double mouse click
// sapsecclick // contextmenu rightclick taphold

// // sapzoom
// // saprotate

// ...........................................................................//
// pointer events............................................................//

VBI.ScenePointerEvents = function(scene, ele) {
	"use strict";
	/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
	// gesture support........................................................//
	scene.m_Gesture = null; // we move the gesture to the scene as state...//

	this.m_Events = [
		"msgesturehold", "msgesturestart", "msgestureend", "msgesturechange", "msgestureinertiastart", "gesturehold", "gesturestart", "gestureend", "gesturechange", "gestureinertiastart", "pointerdown", "pointermove", "pointerup", "mspointerdown", "mspointermove", "mspointerup"
	];

	// ........................................................................//
	// subscribe and cleanup..................................................//

	this.clear = function() {
		// unsubscribe events..................................................//
		for (var nJ = 0, nLen = this.m_Events.length; nJ < nLen; ++nJ) {
			ele["on" + this.m_Events[nJ]] = null;
		}
	};

	this.subscribe = function() {
		// unsubscribe events..................................................//
		var ae = this.m_Events;
		for (var nJ = 0, nLen = ae.length; nJ < nLen; ++nJ) {
			var handlername;
			// check for platform tags to skip them.............................//
			if (ae[nJ].slice(0, 2) == "ms") {
				handlername = "process" + ae[nJ].slice(2);
			} else {
				handlername = "process" + ae[nJ];
			}

			if (!scene[handlername]) {
				if (VBI.m_bTrace) {
					VBI.Trace("Error: Handler " + handlername + " not defined");
				}
			}
			ele["on" + ae[nJ]] = scene[handlername];
		}
	};

	// .......................................................................//
	// attach the required handlers to the scene object.......................//

	scene.processgesturehold = function(event) {
		if (VBI.m_bTrace) {
			VBI.Trace("processgesturehold");
		}
		// dispatch the event..................................................//
		scene.DispatchEvent(event, "sapsecclick");

		event.preventDefault(); // the event is handled
	};

	scene.processgesturestart = function(event) {
		if (VBI.m_bTrace) {
			VBI.Trace("processgesturestart");
		}
		scene.m_Gesture.started = true;
		// event.preventDefault(); // the event is handled
	};

	scene.processgestureend = function(event) {
		if (VBI.m_bTrace) {
			VBI.Trace("processgestureend");
		}

		// stop gesture recognition............................................//
		if (scene.m_Gesture) {
			scene.m_Gesture.target = null;
		}

		scene.m_Gesture = null;
	};

	scene.processgesturechange = function(event) {
		if (VBI.m_bTrace) {
			VBI.Trace("processgesturechange mode: " + scene.m_nInputMode);
		}

		if ((scene.m_nInputMode != VBI.InputModeDefault) && (scene.m_nInputMode != VBI.InputModeTrackMap)) {
			// dispatch the event..................................................//
			scene.DispatchEvent(event, "sapmove");
			return;
		}

		if (VBI.m_bTrace) {
			VBI.Trace("processgesturechange");
			VBI.Trace("rotation:" + event.rotation);
			VBI.Trace("scale:" + event.scale);
			VBI.Trace("trans:" + event.translationX + "," + event.translationY);
		}

		var g = event.gestureObject;
		var addX = Math.round(g.tx) - g.txdone;
		var addY = Math.round(g.ty) - g.tydone;
		var itx = Math.round(event.translationX) + addX;
		var ity = Math.round(event.translationY) + addY;

		g.tx += event.translationX;
		g.ty += event.translationY;
		g.txdone += itx;
		g.tydone += ity;

		if (VBI.m_bTrace) {
			VBI.Trace("done:" + g.txdone + "," + g.tydone);
			VBI.Trace("calc:" + g.tx + "," + g.ty);
		}

		if (itx || ity) {
			if (VBI.m_bTrace) {
				VBI.Trace("scene.processgesturechange move");
			}
			scene.MoveMap(itx, ity);
		}

		if (event.scale != 1.0) {
			scene.ZoomMap(event.scale, event.offsetX, event.offsetY);
			scene.TriggerReRenderTimer(400);
		}

		event.stopPropagation();
		event.preventDefault(); // the event is handled
		return true;
	};

	scene.processgestureinertiastart = function(event) {
		if (VBI.m_bTrace) {
			VBI.Trace("processgestureinertiastart");
		}
		event.preventDefault(); // the event is handled
	};

	// ........................................................................//
	// pointer messages.......................................................//

	scene.processpointerdown = function(event) {
		if (VBI.m_bTrace) {
			VBI.Trace("scene.processpointerdown ");
		}

		// everything inside is handled using gesture events...................//
		// if( scene.DispatchEvent( event, "sapdown" ) == true )
		// return true;

		scene.onsapdown(event);

		// call the internal function before creating the gesture.............//
		var ges = scene.m_Gesture;

		if (ges && ((event.pointerType != ges.pointerType) || !ges.started)) {
			if (VBI.m_bTrace) {
				VBI.Trace("processpointerdown gesture pointer type mismatch or gesture hasn't been started");
			}
			scene.m_Gesture.target = null;
			ges = scene.m_Gesture = null;
		}

		if (!ges) {
			if (VBI.m_bTrace) {
				VBI.Trace("processpointerdown create gesture");
			}
			ges = scene.m_Gesture = new window.MSGesture();
			ges.pointerCount = 0;
			ges.target = event.srcElement; // set the element
			ges.pointerType = event.pointerType; // additionally remember pointer type
			ges.tx = 0; // x translation
			ges.ty = 0; // y translation
			ges.txdone = 0; // x translation
			ges.tydone = 0; // y translation
		}

		// pointer type must fit...............................................//
		if (event.pointerType == ges.pointerType) {
			ges.addPointer(event.pointerId);
			ges.pointerCount++;
		}
		return;
	};

	scene.processpointerup = function(event) {
		if (VBI.m_bTrace) {
			VBI.Trace("processpointerup");
		}
		if (scene.m_Gesture) {
			scene.m_Gesture.pointerCount--;
			if (!scene.m_Gesture.pointerCount) {
				scene.m_Gesture.target = null;
				scene.m_Gesture = null;
			}
		}
		return scene.onsapup(event);
	};

	scene.processpointermove = function(event) {
		if (VBI.m_bTrace) {
			VBI.Trace("scene.processpointermove");
		}

		// store some mouse position state.....................................//
		scene.m_currentMouseX = event.clientX;
		scene.m_currentMouseY = event.clientY;

		scene.onsapmove(event);
		return;
	};

	// ........................................................................//
	// do the event subscription..............................................//
	this.subscribe();
};

// ...........................................................................//
// touch events..............................................................//
VBI.SceneTouchEvents = function(scene, ele) {
	"use strict";
	var isNavigationDisabled = scene.m_SuppressedNavigation.move && scene.m_SuppressedNavigation.zoom;

	this.m_Events = [
		"touchstart", "touchend", "touchmove", "touchcancel"
	];

	// ........................................................................//
	// subscribe and cleanup..................................................//
	this.clear = function() {
		// unsubscribe events..................................................//
		for (var nJ = 0, nLen = this.m_Events.length; nJ < nLen; ++nJ) {
			ele["on" + this.m_Events[nJ]] = null;
		}
	};

	this.subscribe = function() {
		// unsubscribe events..................................................//
		var ae = this.m_Events;
		for (var nJ = 0, nLen = ae.length; nJ < nLen; ++nJ) {
			var handlername;
			// check for platform tags to skip them.............................//
			if (ae[nJ].slice(0, 2) == "ms") {
				handlername = "process" + ae[nJ].slice(2);
			} else {
				handlername = "process" + ae[nJ];
			}

			if (!scene[handlername]) {
				if (VBI.m_bTrace) {
					VBI.Trace("Error: Handler " + handlername + " not defined");
				}
			}

			ele["on" + ae[nJ]] = scene[handlername];
		}
	};

	// ........................................................................//
	// mobile event handling..................................................//
	scene.processtouchstart = function(e) {
		var handled = false;

		var ctx = scene.m_Ctx; // closing menu in case we have an open one
		if (ctx.m_strOpenMenu) {
			var oMenuObject = ctx.m_Menus.findMenuByID(ctx.m_strOpenMenu);
			oMenuObject.close();
			ctx.m_strOpenMenu = undefined;
		}

		if (VBI.m_bTrace) {
			VBI.Trace("processtouchstart");
		}

		if (scene.m_TapTimer) { // second click done before tap timer ran up -> no single tap
			window.clearInterval(scene.m_TapTimer);
		}

		if (scene.DispatchEvent(e, "sapdown") == true) {// dispatch the event
			return;
		}

		// store the touch event...............................................//
		scene.m_Touches.push(e);
		scene.m_Touches.m_bMoveWasDone = false;

		if (e.touches.length == 1 && !scene.m_SuppressedNavigation.move) {
			scene.SetInputMode(VBI.InputModeDefault); // we set TrackMap when we move

			var touch = e.touches[0];
			scene.m_currentMouseX = touch.clientX;
			scene.m_currentMouseY = touch.clientY;

			if (VBI.m_bTrace) {
				VBI.Trace("processtouchstart" + "X:" + scene.m_currentMouseX + "Y:" + scene.m_currentMouseY);
			}
			scene.RestartContextMenuTimer(e, touch, 700);
			handled = true;
		} else if (e.touches.length == 2) {
			scene.SetInputMode(VBI.InputModeDefault);

			var touch1 = e.touches[0];
			var touch2 = e.touches[1];

			var touchMidX = (touch2.clientX + touch1.clientX) / 2;
			var touchMidY = (touch2.clientY + touch1.clientY) / 2;

			scene.m_currentMouseX = touchMidX;
			scene.m_currentMouseY = touchMidY;

			scene.m_midPointX = touchMidX;
			scene.m_midPointY = touchMidY;

			// calculate touch distance.........................................//
			// and store it.....................................................//

			var touchDistance = Math.sqrt(Math.pow(touch1.clientX - touch2.clientX, 2) + Math.pow(touch1.clientY - touch2.clientY, 2));

			scene.m_currentTouchDistance = touchDistance;

			if (VBI.m_bTrace) {
				VBI.Trace("processtouchstart" + "X1:" + touch1.clientX + "Y1:" + touch1.clientY + "X2:" + touch2.clientX + "Y2:" + touch2.clientY);
			}
			handled = true;
		}

		if (handled && !isNavigationDisabled) {
			e.preventDefault();
			return false;
		}
	};

	scene.RestartContextMenuTimer = function(event, touch, delay) {
		if (scene.m_ContextMenuTimer) {
			window.clearInterval(scene.m_ContextMenuTimer);
		}
		scene.m_ContextMenuTimer = window.setInterval(function() {
			window.clearInterval(scene.m_ContextMenuTimer);
			scene.m_ContextMenuTimer = null;
			scene.onPseudoRightClick(event, touch);
		}, delay);
	};

	scene.onPseudoRightClick = function(event, touch) {
		scene.SetInputMode(VBI.InputModeDefault);
		if (VBI.m_bTrace) {
			VBI.Trace("Pseudo Right Click");
		}
		if (scene.DispatchEvent(event, "sapsecclick") == true) { // dispatch the event
			scene.m_Touches = [];
			return;
		}
		var action;
		if ((action = scene.m_Ctx.m_Actions.findAction("ContextMenu", scene, "Map"))) {
			scene.m_Touches = [];
			var rect = scene.GetInternalDivClientRect();
			scene.m_Ctx.FireAction(action, scene, "Map", null, {
				x: touch.clientX - rect.left,
				y: touch.clientY - rect.top,
				scene: scene.m_ID
			});
		}
	};

	// ........................................................................//
	// tap analysis...........................................................//
	scene.IsDoubleTap = function(events) {
		// check whether there are two single taps with small distance.........//
		// and small timegap in the queue......................................//
		// there must be at least 4 events in the queue........................//
		// the last event must be a touchend...................................//
		if (events.length < 4) {
			return null;
		}

		var idxFirstStart = events.length - 4;
		var idxSecondStart = events.length - 2;

		// ensure that this was done with one finger only......................//
		if (events[idxFirstStart].type == "touchstart" && events[idxFirstStart].touches.length != 1) {
			return null;
		}
		if (events[idxSecondStart].type == "touchstart" && events[idxSecondStart].touches.length != 1) {
			return null;
		}

		var dx = events[idxFirstStart].touches[0].clientX - events[idxSecondStart].touches[0].clientX;
		var dy = events[idxFirstStart].touches[0].clientY - events[idxSecondStart].touches[0].clientY;

		// check distance......................................................//
		if ((dx * dx + dy * dy) > 1000) {
			return null; // distance of taps is too large.....................//
		}

		// check delta of time.................................................//
		var idxFirstEnd = events.length - 3;
		var idxSecondEnd = events.length - 1;
		var dt = events[idxSecondEnd].timeStamp - events[idxFirstEnd].timeStamp;
		if (dt > 300) {
			return null;
		}

		// deliver the client coordinates......................................//
		return [
			events[idxSecondStart].touches[0].clientX, events[idxSecondStart].touches[0].clientY
		];
	};

	scene.IsTwoFingerTap = function(events) {
		// check whether there are two single taps with small distance.........//
		// and small timegap in the queue......................................//
		// there must be at least 2 events in the queue........................//
		// and there must be no move as it is otherwise no tap.................//
		if ((events.length < 2) || (events.m_bMoveWasDone)) {
			return null;
		}

		var idxStart = events.length - 2;
		var idxEnd = events.length - 1;

		// ensure that this was done with two fingers..........................//
		if (events[idxStart].type != "touchstart" || events[idxStart].touches.length != 2) {
			return null;
		}

		// check delta of time.................................................//
		var dt = events[idxEnd].timeStamp - events[idxStart].timeStamp;
		if (dt > 300) {
			return null;
		}

		// deliver the client coordinates in the middle of the fingers.........//
		var touches = events[idxStart].touches;
		return [
			(touches[0].clientX + touches[1].clientX) / 2, (touches[0].clientY + touches[1].clientY) / 2
		];
	};

	scene.IsSingleTap = function(events) {
		if (events.length != 2 || (events.m_bMoveWasDone)) {
			return null;
		}

		var idxStart = events.length - 2;
		var idxEnd = events.length - 1;

		// the previous event has to be a touchstart...........................//
		if (events[idxStart].type != "touchstart" || events[idxStart].touches.length != 1) {
			return null;
		}
		if (events[idxEnd].type != "touchend") {
			return null;
		}

		var retVal = [
			events[idxStart].touches[0].clientX, events[idxStart].touches[0].clientY
		];
		retVal.timeTouchDown = events[idxEnd].timeStamp - events[idxStart].timeStamp;

		// delivers client coordinates.........................................//
		return retVal;
	};

	scene.processtouchend = function(e) {

		if (scene.m_DesignVO) {
			if (scene.DispatchEvent(e, "sapup") == true) {
				return;
			}
		}

		if (!scene.m_Touches.length) {
			return; // pseudo right click was triggered, no further processing on touch up
		}
		if (e.m_delayedExamination) {
			scene.m_Touches.pop(); // remove the previously added event and add it later again
		}
		if (VBI.m_bTrace) {
			VBI.Trace("touchend");
		}
		window.clearInterval(scene.m_ContextMenuTimer);
		scene.m_ContextMenuTimer = null;
		if (scene.DispatchEvent(e, "sapup") == true) {
			// dispatch the event
			// handled by vos, therefore the queue can be cleared...............//
			scene.m_Touches = [];
			return;
		}

		var rectDiv = scene.GetInternalDivClientRect();
		if ((rectDiv.width != scene.m_nDivWidth) || (rectDiv.height != scene.m_nDivHeight)) {
			scene.resizeCanvas(0);
		}

		// store the touch events..............................................//
		scene.m_Touches.push(e);

		var xy;
		if ((xy = scene.IsDoubleTap(scene.m_Touches))) {
			if (scene.DispatchEvent(e, "sapdblclick") == true) {
				// dispatch the event
				// handled by vos, therefore the queue can be cleared............//
				scene.m_Touches = [];
				e.stopPropagation();
				return;
			}
			if (!scene.m_SuppressedNavigation.zoom) {
				scene.AnimateZoom(true, xy[0], xy[1], 5);
			}
			scene.m_Touches = [];
		} else if ((xy = scene.IsTwoFingerTap(scene.m_Touches))) {
			if (!scene.m_SuppressedNavigation.zoom) {
				scene.AnimateZoom(false, xy[0], xy[1], 5);
			}
			scene.m_Touches = [];
		} else {
			// when touchend is reached rerender the overlay, due it was........//
			// supressed during zoom............................................//

			if (!(scene.m_nInputMode == VBI.InputModeTrackMap)) {
				scene.InternalRenderLayer(scene.m_Canvas[scene.m_nOverlayIndex], false, true, true, scene.m_Canvas[0].m_nExactLOD);
			}
		}

		// when more than 2 events are in, delete all except the 2 remaining...//
		if (scene.m_Touches.length > 2) {
			scene.m_Touches.splice(0, scene.m_Touches.length - 2);
		}

		// reset move state and touch distance.................................//
		scene.SetInputMode(VBI.InputModeDefault);

		// determine if this was a single tap..................................//
		if ((xy = scene.IsSingleTap(scene.m_Touches))) {
			// check delta of time..............................................//
			if (xy.timeTouchDown < 300 && !e.m_delayedExamination) {
				scene.m_TapTimer = window.setInterval(function() {
					e.m_delayedExamination = true;
					scene.processtouchend(e);
					window.clearInterval(scene.m_TapTimer);
				}, 300);
			} else {
				if (scene.DispatchEvent(e, "sapclick")) {
					// dispatch the event
					// handled by vos, therefore the queue can be cleared.........//
					scene.m_Touches = [];
					e.stopPropagation();
					return;
				}

				// check for map based event subscription........................//
				var action, actions = scene.m_Ctx.m_Actions;
				if (actions) {
					if ((action = actions.findAction("Click", scene, "Map"))) {
						var rect = scene.GetInternalDivClientRect();
						scene.m_Ctx.FireAction(action, scene, "Map", null, {
							x: xy[0] - rect.left,
							y: xy[1] - rect.top
						});
					}
				}
				scene.m_Touches = [];
			}
		}
		if (!isNavigationDisabled) {
			e.preventDefault();
		}
	};

	scene.processtouchcancel = function(e) {
		if (VBI.m_bTrace) {
			VBI.Trace("touchcancel");
		}

		if (scene.DispatchEvent(e, "sapup") == true) {// dispatch the event
			return;
		}
		scene.SetInputMode(VBI.InputModeDefault);
		if (!isNavigationDisabled) {
			e.preventDefault();
		}
	};

	scene.processtouchmove = function(e) {
		if (VBI.m_bTrace) {
			VBI.Trace("touchmove");
		}

		if (scene.m_DesignVO) {
			if (scene.DispatchEvent(e, "sapmove") == true) {
				return;
			}
		}
		if (!scene.m_Touches.length || !scene.m_currentMouseX) {
			return; // (length) pseudo right click was triggered, no further processing on touch up
		} // (mouse) sometimes touchmove seems to be trigger on Androids withhout touchstart

		var dx, dy, touch = {}, touch1;
		if (e.touches.length == 1) {
			touch = e.touches[0];
			dx = touch.clientX - scene.m_currentMouseX;
			dy = touch.clientY - scene.m_currentMouseY;
			if ((dx == 0) && (dy == 0)) {
				e.stopPropagation();
				return true;
			}
		}

		if (VBI.m_bIsAndroid && (e.touches.length == 2)) {
			var touch0 = e.touches[0];
			touch1 = e.touches[1];
			dx = touch0.clientX + touch1.clientX - 2 * scene.m_currentMouseX;
			dy = touch0.clientY + touch1.clientY - 2 * scene.m_currentMouseY;
			if ((dx == 0) && (dy == 0)) {
				e.stopPropagation();
				return true;
			}
		} // Android raises a move event also without move; Mouse must be in middle of both touches

		scene.m_Touches.m_bMoveWasDone = true;
		window.clearInterval(scene.m_ContextMenuTimer);
		scene.m_ContextMenuTimer = null;
		var handled = false;
		scene.m_nTapCount = 0;
		scene.SetInputMode(VBI.InputModeTrackMap);

		if (e.touches.length == 1) {

			// only deal with one finger.....................................//

			scene.RestartContextMenuTimer(e, touch, 1100);

			if (VBI.m_bTrace) {
				VBI.Trace("ontouchmove " + "X1:" + touch.pageX + "Y1:" + touch.pageY);
			}

			// we are in move mode...........................................//
			// dx and dy were calculated above and one of them is unequal to zero

			scene.m_currentMouseX = touch.clientX;
			scene.m_currentMouseY = touch.clientY;

			scene.MoveMap(dx, dy);
			handled = true;
		} else if (e.touches.length == 2 && !scene.m_SuppressedNavigation.zoom) {
			var rectDiv = scene.GetInternalDivClientRect();
			if ((rectDiv.width != scene.m_nDivWidth) || (rectDiv.height != scene.m_nDivHeight)) {
				scene.resizeCanvas(0);
			}

			touch1 = e.touches[0];
			var touch2 = e.touches[1];

			var touchMidX = touch1.clientX + (touch2.clientX - touch1.clientX) / 2;
			var touchMidY = touch1.clientY + (touch2.clientY - touch1.clientY) / 2;

			// the touch mid is relative to page (bug?).....................//
			// correct it to be canvas relative.............................//
			var rect = scene.m_Canvas[0].getBoundingClientRect();
			touchMidX -= rect.left;
			touchMidY -= rect.top;

			// calculate touch distance and decide if it is a zoomin or.....//
			// a zoomout....................................................//
			var touchDistance = Math.sqrt(Math.pow(touch1.clientX - touch2.clientX, 2) + Math.pow(touch1.clientY - touch2.clientY, 2));

			if (Math.abs(scene.m_currentTouchDistance - touchDistance) > 10) {
				var bZoomIn = (touchDistance > scene.m_currentTouchDistance) ? true : false;
				scene.m_currentTouchDistance = touchDistance;

				if (VBI.m_bTrace) {
					VBI.Trace("ontouchmove " + " X1:" + touch1.pageX + " Y1:" + touch1.pageY + " X2:" + touch2.pageX + " Y2:" + touch2.pageY);
				}
				scene.ZoomMap(bZoomIn ? scene.m_nLodFactorZoomIn : scene.m_nLodFactorZoomOut, touchMidX, touchMidY, scene.m_nTicksInALod);
				scene.TriggerReRenderTimer(400);
			}
			handled = true;
		}

		if (handled && !isNavigationDisabled) {
			e.stopPropagation();
			return true;
		}
	};

	scene.SetInputModeTrackMap = function(bSet) {
		// the desktop version tries to capture mousemove and mouseup events...//
		// here we do nearly nothing...........................................//
		if (!bSet) {
			// reset input mode when set before.................................//
			scene.m_currentMouseX = 0;
			scene.m_currentMouseY = 0;
		}
	};

	// ........................................................................//
	// do the event subscription..............................................//

	this.subscribe();
};

// ...........................................................................//
// scene events .............................................................//
VBI.SceneEvent = function(scene, ele) {
	"use strict";
	// device specific additional handlers....................................//
	this.m_DeviceHandlers = [];
	VBI.m_bMouseSupported = false;

	this.m_Events = [
		"mousedown", "mouseup", "mousemove", "mousewheel", "wheel", "mouseout", "click", "dblclick", "contextmenu", "selectstart", "dragstart", "dragenter", "dragover", "dragleave", "drop", "dragend", "keydown", "keypress", "keyup"
	];

// additional stuff.......................................................//
	ele.dropzone = "true";

// check for pointer events...............................................//
// when available add the specific device handler.........................//
// only when touch events are available, instantiate the gesture object...//// and dispatch pointer
// events............................................//

	if (sap.ui.Device.support.pointer && navigator.msMaxTouchPoints) {
		this.m_DeviceHandlers.push(new VBI.ScenePointerEvents(scene, ele));
	}

// ........................................................................//
// subscribe and cleanup..................................................//

	this.clear = function() {
		// clear specific device handlers......................................//
		var nJ;
		for (nJ = 0; nJ < this.m_DeviceHandlers.length; ++nJ) {
			this.m_DeviceHandlers[nJ].clear();
		}
		this.m_DeviceHandlers = [];

		// unsubscribe events..................................................//
		for (nJ = 0; nJ < this.m_Events.length; ++nJ) {
			var name = "on" + this.m_Events[nJ];
			if (ele[name]) {
				ele[name] = null;
			}
		}
	};

	this.subscribe = function() {
		// unsubscribe events..................................................//
		var ae = this.m_Events;
		for (var nJ = 0, nLen = ae.length; nJ < nLen; ++nJ) {
			var handlername;
			// check for platform tags to skip them.............................//
			if (ae[nJ].slice(0, 2) == "ms") {
				handlername = "process" + ae[nJ].slice(2);
			} else if (scene.m_SuppressedNavigation.zoom && (ae[nJ] === "wheel" || ae[nJ] === "mousewheel")) {
				// skip handler registration for wheel events if no zoom is required -> this should enable page scrolling
				continue;
			} else {
				handlername = "process" + ae[nJ];
			}

			if (!scene[handlername]) {
				jQuery.sap.log.error("Handler " + handlername + " not defined");
			}

			ele["on" + ae[nJ]] = scene[handlername];
		}
	};

	// check for touch, but no pointer support................................//
	if (sap.ui.Device.support.touch && !(sap.ui.Device.support.pointer && navigator.msMaxTouchPoints)) {
		this.m_DeviceHandlers.push(new VBI.SceneTouchEvents(scene, ele));

		if (!sap.ui.Device.system.desktop) { // no mouse and keyboard events for non-desktop
			return;
		}
	}

	// mouse events are supported
	VBI.m_bMouseSupported = true;
	
	// ........................................................................//
	// helper functions.......................................................//
	scene.SetInputModeTrackMap = function(bSet) {
		// !capured event listeners on canvas will not work, <document> is.....//
		// is mandatory........................................................//

		if (bSet) {
			// remove documents event listeners.................................//
			// current positions must be set outside............................//
			document.addEventListener('mouseup', scene.processmouseup, true);
			document.addEventListener('mousemove', scene.processmousemove, true);
		} else {
			// reset input mode when set before.................................//
			scene.m_currentMouseX = 0;
			scene.m_currentMouseY = 0;
			document.removeEventListener('mouseup', scene.processmouseup, true);
			document.removeEventListener('mousemove', scene.processmousemove, true);
		}
	};

	// ........................................................................//
	// event handlers.........................................................//
	scene.onsapdown = function(event) {
		if (VBI.m_bTrace) {
			VBI.Trace("scene.onsapdown");
		}

		// store current mouse positions.......................................//
		scene.m_currentMouseDownX = event.clientX;
		scene.m_currentMouseDownY = event.clientY;
		scene.m_currentMouseX = event.clientX;
		scene.m_currentMouseY = event.clientY;

		if (scene.DispatchEvent(event, "sapdown") == true) { // dispatch the event
			return true;
		}
	};

	scene.onsapup = function(event) {
		if (VBI.m_bTrace) {
			VBI.Trace("scene.onsapup");
		}

		if (scene.DispatchEvent(event, "sapup") == true) { // dispatch the event
			return;
		}

		if (scene.vbiclass == "3DScene") {
			return; // TODO: handle the event
		}

		// prevent from default handling.......................................//
		scene.SetInputMode(VBI.InputModeDefault);

		event.preventDefault();
		return false;
	};

	scene.onsapclick = function(event) {
		// raise a click event.................................................//
		// when the click is subscribed........................................//
		// use the m_clientX and m_clientY values to get relative canvas.......//
		// relative coordinates................................................//

		if (VBI.m_bTrace) {
			VBI.Trace("scene.onsapclick");
		}

		var dx = scene.m_currentMouseDownX - event.clientX;
		var dy = scene.m_currentMouseDownY - event.clientY;
		if ((dx * dx + dy * dy) <= 5) {
			// dispatch the event
			if (VBI.m_bTrace) {
				VBI.Trace("process click dispatch");
			}
			if (scene.DispatchEvent(event, "sapclick") == true) {
				if (VBI.m_bTrace) {
					VBI.Trace("process click handled in dispatch");
				}
				return;
			}

			// the criteria for a click is fulfilled
			if (scene.Click) {
				// enhance the event with canvas relative click coordinates...//
				var rect = scene.m_Canvas[scene.m_nOverlayIndex].getBoundingClientRect();
				event.m_clientX = event.clientX - rect.left;
				event.m_clientY = event.clientY - rect.top;
				if (scene.Click(event)) {
					return; // the event is handled...........................//
				}
			}

			// check for map based event subscription........................//
			var action, actions = scene.m_Ctx.m_Actions;
			if (actions) {
				if ((action = actions.findAction("Click", scene, "Map"))) {
					scene.m_Ctx.FireAction(action, scene, "Map", null, scene.GetEventVPCoordsObj(event));
				}
				event.preventDefault(); // the event is handled
			}
		}
	};

	scene.onsapmove = function(event) {
		// this is the common move handle between pointer and mouse messages...//
		if (VBI.m_bTrace) {
			VBI.Trace("scene.onsapmove");
		}

		if (scene.DispatchEvent(event, "sapmove") == true) { // dispatch the event
			return true;
		}

		if (scene.vbiclass == "3DScene") {
			return true;
		}

		scene.SetToolTip("");
		scene.SetCursor('default');
		scene.InternalSetHotItem(null, null);

		return false;
	};

	scene.processmousedown = function(event) {
		if (VBI.m_bTrace) {
			VBI.Trace("scene.processmousedown");
		}
		if (scene.m_Gesture) {
			return;
		}
		if (scene.onsapdown(event)) {
			return;
		}
		if (scene.vbiclass == "3DScene") {
			return; // TODO: handle the event
		}
		// do default mouse handling...........................................//
		if (!scene.m_SuppressedNavigation.move && (event.type.indexOf("pointer") < 0) && (!sap.ui.Device.os.macintosh || event.which == 1)) {
			// On Mac we do not set track mode for right mouse as context menu is triggered immediatelly
			if (VBI.m_bTrace) {
				VBI.Trace("set input mode track map");
			}
			scene.SetInputMode(VBI.InputModeTrackMap);
			// !capured event listeners on canvas will not work, document is....//
			// is mandatory.....................................................//
			// it is important to remove the listener with the capture flag!....//

			// do !not! prevent from default handling...........................//
			// IE needs to activate the canvas..................................//
			scene.m_Canvas[scene.m_nLabelIndex].focus();
		}
	};

	scene.BuildKeyEventParams = function(event) {
		return {
			key: event.key,
			code: event.keyCode,
			shift: event.shiftKey,
			ctrl: event.ctrlKey,
			alt: event.altKey,
			meta: event.metaKey
		};
	};

	scene.processkeyup = function(event) {
		if (VBI.m_bTrace) {
			VBI.Trace("scene.processkeyup");
		}
		if (event.code == undefined) {
			event.code = event.keyCode;
		}
		var down = scene.m_KeysDown.indexOf(event.code);
		var up = scene.m_KeysSkipUp.indexOf(event.code);
		var press = scene.m_KeysSkipPress.indexOf(event.code);

		if (down != -1) {
			scene.m_KeysDown.splice(down, 1); //reset down state
		}
		if (press != -1) {
			scene.m_KeysSkipPress.splice(press, 1); //reset press state
		}
		if (up != -1) {
			scene.m_KeysSkipUp.splice(up, 1); //reset skip up state & skip processing
			return;
		}
		if (scene.m_Ctx.m_Actions) { // check for subscribed action and raise it
			var action = scene.m_Ctx.m_Actions.findAction("KeyUp", scene); // check if action is subscribed
			if (action) {
				scene.m_Ctx.FireAction(action, scene, this, null, scene.BuildKeyEventParams(event));
			}
		}
	};

	scene.processkeypress = function(event) {
		if (VBI.m_bTrace) {
			VBI.Trace("scene.processkeypress");
		}
		if (event.code == undefined) {
			event.code = event.keyCode;
		}
		var press = scene.m_KeysSkipPress.indexOf(event.code);

		if (press != -1) {
			scene.m_KeysSkipPress.splice(press, 1); //reset press state & skip processing
			return;
		}
		//skip if event is not recorded in the list of down events due to code modification
		if (scene.m_KeysDown.indexOf(event.code) == -1) {
			return;
		}
		if (scene.m_Ctx.m_Actions) { // check for subscribed action and raise it
			var action = scene.m_Ctx.m_Actions.findAction("KeyPress", scene); // check if action is subscribed
			if (action) {
				scene.m_Ctx.FireAction(action, scene, this, null, scene.BuildKeyEventParams(event));
			}
		}
	};

	scene.processkeydown = function(event) {
		if (VBI.m_bTrace) {
			VBI.Trace("scene.processkeydown");
		}
		event.m_Repeat = event.repeat;

		if (event.code == undefined) {
			event.code = event.keyCode;
		}
		if (scene.m_KeysDown.indexOf(event.code) != -1) { //key down flag is not cleared -> IE repeating case
			event.m_Repeat = true;
		} else {
			scene.m_KeysDown.push(event.code); //mark which keys is in down state
		}
		// if repeat is not allowed -> skip it & following press event as well, but keep up event intact
		if (event.m_Repeat && !scene.m_Ctx.m_Control.getAllowKeyEventRepeat()) {
			if (scene.m_KeysSkipPress.indexOf(event.code) == -1) {
				scene.m_KeysSkipPress.push(event.code); //mark which key press event should be skipped
			}
			return;
		}
		if (event.code == scene.m_lastKey && scene.m_lastKeyDown != null && (Date.now() - scene.m_lastKeyDown) < scene.m_Ctx.m_Control.getKeyEventDelay()) {
			// if down event is too frequent -> skip it (applies only to repeats or same key sequences)
			// and following press and up events as well
			if (scene.m_KeysSkipPress.indexOf(event.code) == -1) {
				scene.m_KeysSkipPress.push(event.code); //mark which press event should be skipped
			}
			if (!event.m_Repeat) {
				if (scene.m_KeysSkipUp.indexOf(event.code) == -1) {
					scene.m_KeysSkipUp.push(event.code); //mark which up event should be skipped
				}
			}
			return;
		}
		scene.m_lastKey = event.code;
		scene.m_lastKeyDown = Date.now(); // keep time stamp of last processed event

		var rectDiv = scene.GetInternalDivClientRect();
		if ((rectDiv.width != scene.m_nDivWidth) || (rectDiv.height != scene.m_nDivHeight)) {
			scene.resizeCanvas(0);
		}
		var defaultAction = true;

		if (scene.m_Ctx.m_Actions) { // check for subscribed action and raise it
			var action = scene.m_Ctx.m_Actions.findAction("KeyDown", scene); // check if action is subscribed
			if (action) {
				defaultAction = scene.m_Ctx.FireAction(action, scene, this, null, scene.BuildKeyEventParams(event), null, true);
			}
		}

		if (defaultAction) { //default processing of key events
			var handled = false;

			switch (event.keyCode) {
				case 72: // 'h' for got to initial start position
					scene.GoToInitialStart();
					handled = true;
					break;
				case 90: // 'z' for rectangular zoom mode
					scene.endTrackingMode();
					new scene.RectangularZoom();
					scene.m_Ctx.onChangeTrackingMode(VBI.InputModeRectZoom, true);
					handled = true;
					break;
				case 82: // 'r' for rectangular selection
					scene.endTrackingMode();
					new scene.RectSelection();
					scene.m_Ctx.onChangeTrackingMode(VBI.InputModeRectSelect, true);
					handled = true;
					break;
				case 65: // 'a' for lasso selection
					scene.endTrackingMode();
					new scene.LassoSelection();
					scene.m_Ctx.onChangeTrackingMode(VBI.InputModeLassoSelect, true);
					handled = true;
					break;
			}
			if (!scene.m_SuppressedNavigation.zoom) {
				var zoomStep = 0;

				switch (event.keyCode) {
					case 107: // zoom in (+)
					case 171: // 171 for Firefox!!
					case 187:
						zoomStep = 1;
						break;
					case 109: // zoom out (-)
					case 173: // 173 for Firefox!!
					case 187:
						zoomStep = -1;
						break;
				}
				if (zoomStep != 0) {
					var centerPoint = scene.GetCenterPos();
					var newZoomLevel = scene.getCanvas().m_nExactLOD;
					var minLOD = scene.GetMinLOD();

					if (zoomStep > 0 && newZoomLevel == minLOD && newZoomLevel != Math.ceil(newZoomLevel)) {
						newZoomLevel = Math.ceil(newZoomLevel);
					} else {
						newZoomLevel += zoomStep;
					}
					scene.AnimateZoomToGeo(centerPoint, Math.round(newZoomLevel), 5);
					handled = true;
				}
			}
			if (!scene.m_SuppressedNavigation.move) {
				var distance = 20;

				switch (event.keyCode) {
					case 37: // arrow left
						scene.MoveMap(distance, 0);
						handled = true;
						break;
					case 39: // arrow right
						scene.MoveMap(-distance, 0);
						handled = true;
						break;
					case 38: // arrow up
						scene.MoveMap(0, distance);
						handled = true;
						break;
					case 40: // arrow down
						scene.MoveMap(0, -distance);
						handled = true;
						break;
				}
			}
			if (handled) {
				event.preventDefault();
			}
		}
	};

	scene.processcontextmenu = function(event) {

		if (event.target != scene.m_Canvas[scene.m_nLabelIndex]) {
			return;
		}

		if (VBI.m_bTrace) {
			VBI.Trace("scene.processcontextmenu");
		}

		// dispatch the event..................................................//
		if (scene.DispatchEvent(event, "sapsecclick") == true) {
			return; // return due it has been handled by a VO
		}

		// check for map based event...........................................//
		var action, actions = scene.m_Ctx.m_Actions;
		if (actions) {
			if ((action = actions.findAction("ContextMenu", scene, "Map"))) {
				scene.m_Ctx.FireAction(action, scene, "Map", null, scene.GetEventVPCoordsObjWithScene(event));
			}
			event.preventDefault(); // the event is handled
		}
	};

	scene.processmouseout = function(event) {
		if (VBI.m_bTrace) {
			VBI.Trace("scene.processmouseout");
		}

		// dispatch the event
		if (scene.DispatchEvent(event, "sapout") == true) {
			return;
		}

		// when the mouse moves out, reset the hot state.......................//
		scene.InternalSetHotItem(null, null);

		return false;
	};

	scene.processdblclick = function(event) {
		if (VBI.m_bTrace) {
			VBI.Trace("scene.processdblclick");
		}

		// dispatch the event..................................................//
		if (scene.DispatchEvent(event, "sapdblclick") == true) {
			return; // return due it has been handled by a VO
		}
		return;
	};

	scene.processclick = function(event) {

		if (event.target != scene.m_Canvas[scene.m_nLabelIndex]) {
			return;
		}

		if (VBI.m_bTrace) {
			VBI.Trace("scene.processclick");
		}

		// when a gesture is running the click is produced there...............//
		if (scene.m_Gesture) {
			return;
		}

		return scene.onsapclick(event);
	};

	scene.processmouseup = function(event) {
		if (VBI.m_bTrace) {
			VBI.Trace("scene.processmouseup");
		}
		scene.dragclear();

		return scene.onsapup(event);
	};

	scene.processmousemove = function(event) {
		if (VBI.m_bTrace) {
			VBI.Trace("scene.processmousemove");
		}
		if (scene.m_DragInfo) {
			if (scene.m_DragInfo.bDragStart) {
				return false;
			}
			return;
		}

		// store some mouse position state.....................................//
		var dx = event.clientX - scene.m_currentMouseX;
		var dy = event.clientY - scene.m_currentMouseY;
		scene.m_currentMouseX = event.clientX;
		scene.m_currentMouseY = event.clientY;

		// when a gesture is processed return immediately due .................//
		// pointer move events should do the same thing........................//
		if (scene.m_Gesture) {
			return;
		}
		if (scene.onsapmove(event)) {
			return;
		}

		if (scene.m_nInputMode == VBI.InputModeTrackMap) {
			if (!(event.buttons == 1 || event.which == 1)) {
				// button is no longer pressed, stop mouse capturing and move....//
				// mode..........................................................//
				scene.SetInputMode(VBI.InputModeDefault);
				return false;
			}

			if (dx || dy) {
				scene.MoveMap(dx, dy);
			}
			return false;
		}
		event.preventDefault();
	};

	scene.processmousewheel = function(event) { // Internet Explorer
		scene.processcommonwheel(event, event.wheelDelta);
		return false;
	};

	scene.processwheel = function(event) { // Chrome and Firefox
		scene.processcommonwheel(event, -event.deltaY);
		return false;
	};

	scene.processcommonwheel = function(event, delta) {
		var rect = scene.m_Canvas[scene.m_nLabelIndex].getBoundingClientRect();

		event.m_OffsetX = event.clientX - rect.left;
		event.m_OffsetY = event.clientY - rect.top;
		event.m_Delta = delta;

		var timeNow = Date.now();
		if ((scene.m_LastCWEvent != undefined) && (timeNow - scene.m_LastCWEvent < 200)) {
			return;
		}
		scene.m_LastCWEvent = timeNow;

		if (VBI.m_bTrace) {
			VBI.Trace("processcommonwheel");
		}

		if (scene.DispatchEvent(event) == true) {// dispatch the event
			return;
		}

		if (scene.vbiclass == "3DScene") {
			// event processing

			event.preventDefault();
		} else if (!scene.m_SuppressedNavigation.zoom && event.m_Delta) {
			var rect = scene.GetInternalDivClientRect();
			if ((rect.width != scene.m_nDivWidth) || (rect.height != scene.m_nDivHeight)) {
				scene.resizeCanvas(0);
			}
			if (scene.m_nZoomMode) {
				var rc = scene.m_Canvas[0].getBoundingClientRect();
				// VBI.Trace("Call AnimateZoom with "+event.m_OffsetX+"+"+rc.left+" / "+event.m_OffsetY+"+"+rc.top)
				scene.AnimateZoom(event.m_Delta > 0, event.m_OffsetX + rc.left, event.m_OffsetY + rc.top, 5, event);
			} else {
				scene.ZoomMap(event.m_Delta > 0 ? scene.m_nLodFactorZoomIn : scene.m_nLodFactorZoomOut, event.m_OffsetX, event.m_OffsetY, scene.m_nTicksInALod);
			}

			event.preventDefault();
		}

		return;
	};

	// .....................................................................//
	// drag and drop processing............................................//
	scene.dragclear = function(event) {
		var img = document.getElementById(scene.m_Target.id + "-transparentImg");
		if (img) {
			scene.m_Div.removeChild(img);
		}
		scene.m_DragInfo = null;
		VBI.m_DndTarget = null;
	};

	scene.processdragleave = function(event) {
		// if (scene.m_DragInfo) { }
		return;
	};

	scene.processdragend = function(event) {
		event.preventDefault();
		event.stopPropagation();

		scene.dragclear();
		return true;
	};

	scene.processselectstart = function(event) {
		if (event.target.dragDrop && scene.m_DragInfo) {
			event.target.dragDrop();
		}
		event.preventDefault();
		return true;
	};

	scene.processdragstart = function(event) {
		if (scene.m_DragInfo) {
			if (scene.m_DragInfo.strExtData) {
				event.dataTransfer.setData('text', scene.m_DragInfo.strExtData);
			} else {
				event.dataTransfer.setData('text', "");
			}
			event.dataTransfer.effectAllowed = 'copy';

			scene.m_DragInfo.bDragStart = true;
			VBI.m_DndTarget = event.target;

			if (event.dataTransfer.setDragImage || VBI.Utilities.SetDragImage) {
				var image = VBI.Utilities.GetTransparentImage();
				image.id = scene.m_Target.id + "-transparentImg";
				scene.m_Div.appendChild(image);

				if (event.dataTransfer.setDragImage) {
					event.dataTransfer.setDragImage(image, 0, 0); //natural browser support
				} else {
					VBI.Utilities.SetDragImage(image, 0, 0); //IE10 + Edge workaround
				}
			}
			if (scene.m_Gesture) {
				scene.m_Gesture.target = null;
				scene.m_Gesture = null;
			}
			return true;
		}
		return false;
	};

	scene.processdragenter = function(event) {
		if (!event.dataTransfer) {
			return false;
		}
		if (event.dataTransfer) {
			try {
				event.dataTransfer.dropEffect = 'copy';
			} catch (err) {
				// just trace the message...........................................//
				jQuery.sap.log.warning("scene.processdragenter exception occured: " + err.message);
			}
		}
		event.preventDefault();
		return true;
	};

	scene.processdragover = function(event) {
		if (!event.dataTransfer) {
			return false; // Is required for cross browser compatibility!
		}
		if (scene.m_Gesture) {
			return;
		}

		if (scene.m_DragInfo && scene.m_DragInfo.bDragStart) {
			scene.DispatchEvent(event, "sapdrag");
		} else {
			event.preventDefault();
		}
		// var dat = event.dataTransfer.getData('text');
		// todo: dat should be analyzed to determine further steps

		return;
	};

	scene.DesignCreateObject = function(data, pos, func) {
		// ensure that the data parameter is of type string....................//
		var dat = null;
		if (typeof data == 'string') {
			dat = data;
		} else {
			dat = JSON.stringify(data);
		}

		// .....................................................................//
		// only one placeholder can be processed when an object is created.....//

		if (dat.indexOf("{POS}") >= 0) {
			// replace single positions when specified..........................//
			if (pos) {
				var strpos = "" + pos[0] + ";" + pos[1] + ";" + "0.0";
				var tmp = dat.replace(/{POS}/g, strpos);
				func(tmp); // done
			} else {
				// just get one point............................................//
				new scene.DesignPositionArray(null, dat, func, "{POS}", 1); // create exactly
			}
		} else if (dat.indexOf("{POSARRAY}") >= 0) {
			// get a complete array.............................................//
			new scene.DesignPositionArray(pos ? [
				pos[0], pos[1], 0.0
			] : null, dat, func, "{POSARRAY}", null);
		} else {
			// just call the function...........................................//
			func(data);
		}
		return;
	};

	scene.processdrop = function(event) {

		if (!event.dataTransfer) {
			scene.dragclear();
			return false;
		}

		if (scene.m_DragInfo && scene.m_DragInfo.bDragStart) {
			scene.DispatchEvent(event, "sapdrop");
			// dispatch the event
			event.preventDefault();
			event.stopPropagation();
			scene.dragclear();
			return true;
		}
		// get the transfer data...............................................//
		var dat = event.dataTransfer.getData('text');

		// determine the drop position.........................................//
		var rect = scene.m_Canvas[0].getBoundingClientRect();
		var pos = scene.GetPosFromPoint([
			event.clientX - rect.left, event.clientY - rect.top, 0.0
		]);

		// check if there is a drop action subscribed..........................//
		var action = null, actions = scene.m_Ctx.m_Actions;
		if (actions) {
			action = scene.m_Ctx.m_Actions.findAction("Drop", scene, "Map");
		}

		// determine the right callback function for the drop action...........//
		var func = null;
		if (action) {
			// bind to a callback that raises the event.........................//
			func = function(data) {
				var params = scene.GetEventVPCoordsObj(event);
				params.content = data; // append the load content..............//
				scene.m_Ctx.FireAction(action, scene, "Map", null, params);
			};
		} else {
			// by default we bind the loader function of the vbi instance.......//
			func = scene.m_Ctx.m_Control.load.bind(scene.m_Ctx.m_Control);
		}

		// call object creator function........................................//
		// scene.DesignCreateObject( dat, pos, func );
		scene.DesignCreateObject(dat, pos, func);

		// important for ff to stop propagation................................//
		event.preventDefault();
		event.stopPropagation();

		scene.dragclear();
		return true;
	};

// ........................................................................//
// design object movements................................................//
// mode: InputModeTrackObject
	scene.DesignTrack = function(obj) {
		// start tracking......................................................//
		this.m_Tcx = obj; // store track object

		// ........................................................................//
		// event handlers.........................................................//

		this.onsapkeydown = function(e) {
			if (e.keyCode == 27) { // ESC
				// exit mode array creation without applying data................//
				this.UnHook(false);
				e.preventDefault();
				return true;
			}
		};

		this.onsapclick = function(e) {
			if (VBI.m_bTrace) {
				VBI.Trace("Track sapclick");
			}

			// stop tracking....................................................//
			this.UnHook();
			return false;
		};

		this.onsapdown = function(e) {
			if (VBI.m_bTrace) {
				VBI.Trace("Track sapdown");
			}

			// this helps to prevent from moving the control into visible.......//
			// area.............................................................//
			e.preventDefault();
			return true;
		};

		this.onsapmove = function(e) {
			if (VBI.m_bTrace) {
				VBI.Trace("Track sapmove");
			}

			// process move callback............................................//
			// provide current relative canvas coordinates......................//
			var tcx = this.m_Tcx;
			tcx.m_ClientX = e.offsetX;
			tcx.m_ClientY = e.offsetY;

			if (tcx.m_CBDrag) {
				if (VBI.m_bTrace) {
					VBI.Trace("Track sapmove: orig type " + e.type);
				}
				tcx.m_CBDrag(tcx, e);
			}

			e.preventDefault();
			e.stopPropagation();
			return true;
		};

		this.onsapup = function(e) {
			if (VBI.m_bTrace) {
				VBI.Trace("Track sapup");
			}

			// process move callback............................................//
			// provide current relative canvas coordinates......................//
			var tcx = this.m_Tcx;
			tcx.m_ClientX = e.offsetX;
			tcx.m_ClientY = e.offsetY;

			if (tcx.m_CBDrop) {
				// notify about drop
				tcx.m_CBDrop(tcx, e);
			}

			if (tcx.m_CBEnd) {
				// notify about end of operation
				tcx.m_CBEnd(tcx, e);
			}

			// stop tracking....................................................//
			this.UnHook();

			// prevent from default handling....................................//
			e.preventDefault();
			e.stopPropagation();
			return true;
		};

		// .....................................................................//
		// hook and unhook into scene events...................................//

		this.Hook = function() {
			scene.SetInputMode(VBI.InputModeTrackObject);
			scene.m_DesignVO = this;
		};

		this.UnHook = function() {
			// check if hook is still there.....................................//
			if (scene.m_DesignVO != this) {
				return;
			}

			if (scene.m_nInputMode == VBI.InputModeTrackObject) {
				scene.SetInputMode(VBI.InputModeDefault);
			} else {
				jQuery.sap.log.error("Wrong InputMode in UnHook: " + scene.m_nInputMode);
			}

			// release object references........................................//
			scene.m_DesignVO = null;
			this.m_Tcx = null;

			scene.RenderAsync(true); // trigger async rendering...............//
		};

		// render calls........................................................//
		this.Render = function(canvas, dc) {
			return;
		};

		this.Hook();
	};

// ........................................................................//
// design create a position array.........................................//

	scene.DesignPositionArray = function(pos, loaddata, func, placeholder, maxpos) {
		// it should be possible to call this function by automation...........//

		// add a design object creator to the scene that captures the required.//
		// events and removes itself when done.................................//

		// pos can be the initial drop array which can be empty as well........//
		// loaddata is the json string that can be loaded afterwards...........//
		// maxpos is optional the object will unhook when the maximum positions//
		// are entered to the array............................................//

		this.m_PosArray = pos ? pos : []; // prefill position array..........//
		this.m_PosMove = null;
		this.m_Func = func;
		this.m_PlaceHolder = placeholder;

		scene.SetCursor('crosshair');

		this.onsapkeydown = function(e) {
			if (e.keyCode == 27) {
				// ESC
				// exit mode array creation without applying data................//
				this.UnHook(false);
				e.preventDefault();
				return true;
			}
		};

		this.onsapclick = function(e) {
			if (VBI.m_bTrace) {
				VBI.Trace("this.onsapclick " + e.type);
			}

			// determine the click position.....................................//
			var rect = scene.m_Canvas[scene.m_nOverlayIndex].getBoundingClientRect();
			var pos = scene.GetPosFromPoint([
				e.clientX - rect.left, e.clientY - rect.top, 0
			]);
			var tmp = [
				pos[0], pos[1], 0.0
			];

			var alen = this.m_PosArray.length;
			var numPos = alen / 3;

			// check if last position is already in.............................//
			if ((numPos >= 1) && (this.m_PosArray[alen - 3] == tmp[0]) && (this.m_PosArray[alen - 2] == tmp[1]) && (this.m_PosArray[alen - 1] == tmp[2])) {
				return true;
			}

			// push the position to the position array..........................//
			for (var nJ = 0, len = tmp.length; nJ < len; ++nJ) {
				this.m_PosArray.push(tmp[nJ]);
			}

			numPos = this.m_PosArray.length / 3;

			scene.RenderAsync(true); // trigger async rendering...................//
			e.preventDefault();

			// end of position creation reached.................................//
			if (maxpos && numPos >= maxpos) {
				this.UnHook(true);
			}

			return true;
		};

		this.onsapdown = function(e) {
			// this helps to prevent from moving the control into visible.......//
			// area.............................................................//
			e.preventDefault();
			return true;
		};

		this.onsapmove = function(e) {
			jQuery.sap.log.debug("this.onsapmove");
			jQuery.sap.log.error("Wrong InputMode in onsapmove: " + scene.m_nInputMode);

			// determine the move position......................................//
			var rect = scene.m_Canvas[0].getBoundingClientRect();
			this.m_PosMove = scene.GetPosFromPoint([
				e.clientX - rect.left, e.clientY - rect.top, 0
			]);

			scene.RenderAsync(true); // trigger async rendering...................//
			e.preventDefault();
			return true;
		};

		this.onsapdblclick = function(e) {
			this.UnHook(true);
			return true;
		};

		// .....................................................................//
		// hook and unhook into scene events...................................//
		this.Hook = function() {
			scene.SetInputMode(VBI.InputModeTrackDesign);

			scene.m_DesignVO = this;
		};

		this.UnHook = function(bApply) {
			if (scene.m_nInputMode == VBI.InputModeTrackDesign) {
				scene.SetInputMode(VBI.InputModeDefault);
			} else {
				jQuery.sap.log.error("Wrong InputMode in UnHook: " + scene.m_nInputMode);
			}

			this.m_PosMove = null;
			var strposarray = VBI.Types.vector2string(this.m_PosArray);

			var tmp = loaddata.replace(new RegExp(this.m_PlaceHolder, 'g'), strposarray);

			scene.m_DesignVO = null;
			scene.RenderAsync(true); // trigger async rendering...................//

			// do the callback when requested...................................//
			// we do not do a callback
			if (bApply && this.m_Func) {
				this.m_Func(tmp);
			}
		};

		// render..............................................................//
		this.Render = function(canvas, dc) {
			var xyz, linewidth = 1.0;

			if (!this.m_PosArray.length) {
				return;
			}

			// one burst convert to points......................................//
			// for all round world instances....................................//

			// determine the nearest position array.............................//
			// and the instance offsets.........................................//
			var bStrokeRequired = false;
			var aCompletePositions = this.m_PosArray.concat(this.m_PosMove);
			var apos = scene.GetNearestPosArray(aCompletePositions);
			var pointarray = scene.GetPointArrayFromPosArray(apos, false);

			dc.strokeStyle = "rgba( 255, 0, 20, 0.5 )";
			dc.lineWidth = linewidth;
			var sqdistance = linewidth * linewidth / 2;

			dc.beginPath();
			var tmp = [
				pointarray[0], pointarray[1]
			];
			dc.moveTo(pointarray[0], pointarray[1]); // move to start.......//
			for (var nJ = 0, tdx, tdy; nJ < pointarray.length / 3; ++nJ) {
				xyz = [
					pointarray[nJ * 3], pointarray[nJ * 3 + 1], 0.0
				];

				// when the distance is too small between projected points.......//
				// skip rendering................................................//
				if (((tdx = (tmp[0] - xyz[0])) * tdx + (tdy = (tmp[1] - xyz[1])) * tdy) < sqdistance) {
					continue;
				}

				// set flag that strokeis required...............................//
				bStrokeRequired = true;

				dc.lineTo(xyz[0], xyz[1]);
				tmp = xyz;
			}

			if (bStrokeRequired) {
				dc.stroke();
			}
		};

		this.Hook();
	};

// ........................................................................//
// do the event subscription...............................................//
	this.subscribe();
};

VBI.ThumbnailEvent = function(scene, ele) {
	"use strict";
	// device specific additional handlers....................................//
	this.m_DeviceHandlers = [];

	this.m_Events = [
		"click", "contextmenu"
	];
	if (sap.ui.Device.support.touch && !(sap.ui.Device.support.pointer && navigator.msMaxTouchPoints)) {
		var touchEvents = [
			"touchstart", "touchend"
		];

		if (!sap.ui.Device.system.desktop) { // no mouse and keyboard events for non-desktop
			this.m_Events = touchEvents;
		} else {
			this.m_Events = this.m_Events.concat(touchEvents);
		}
	}

// ........................................................................//
// subscribe and cleanup..................................................//

	this.clear = function() {
		// clear specific device handlers......................................//
		var nJ;
		for (nJ = 0; nJ < this.m_DeviceHandlers.length; ++nJ) {
			this.m_DeviceHandlers[nJ].clear();
		}
		this.m_DeviceHandlers = [];

		// unsubscribe events..................................................//
		for (nJ = 0; nJ < this.m_Events.length; ++nJ) {
			var name = "on" + this.m_Events[nJ];
			if (ele[name]) {
				ele[name] = null;
			}
		}
	};

	this.subscribe = function() {
		// unsubscribe events..................................................//
		var ae = this.m_Events;
		for (var nJ = 0, nLen = ae.length; nJ < nLen; ++nJ) {
			var handlername;
			// check for platform tags to skip them.............................//
			if (ae[nJ].slice(0, 2) == "ms") {
				handlername = "process" + ae[nJ].slice(2);
			} else {
				handlername = "process" + ae[nJ];
			}

			if (!scene[handlername]) {
				jQuery.sap.log.error("Handler " + handlername + " not defined");
			}

			ele["on" + ae[nJ]] = scene[handlername];
		}
	};

	scene.processclick = function(event) {
		if (VBI.m_bTrace) {
			VBI.Trace("thumbnail.processclick");
		}

		// check for map based event subscription........................//
		var action, actions = scene.m_Ctx.m_Actions;
		if (actions) {
			if ((action = actions.findAction("Click", scene, "Thumbnail"))) {
				scene.m_Ctx.FireAction(action, scene, "Thumbnail", null, scene.GetEventVPCoordsObj(event));
			}
			event.preventDefault(); // the event is handled
		}
	};

	scene.processcontextmenu = function(event) {
		if (VBI.m_bTrace) {
			VBI.Trace("thumbnail.processcontextMenu");
		}

		// check for map based event subscription........................//
		var action, actions = scene.m_Ctx.m_Actions;
		if (actions) {
			if ((action = actions.findAction("ContextMenu", scene, "Thumbnail"))) {
				scene.m_Ctx.FireAction(action, scene, "Thumbnail", null, scene.GetEventVPCoordsObj(event));
			}
			event.preventDefault(); // the event is handled
		}
	};

	scene.onPseudoThumbRightClick = function(event, touch) {
		if (VBI.m_bTrace) {
			VBI.Trace("Pseudo Right Click");
		}
		var action;
		if ((action = scene.m_Ctx.m_Actions.findAction("ContextMenu", scene, "Thumbnail"))) {
			scene.m_Touches = [];
			var rect = scene.GetInternalDivClientRect();
			scene.m_Ctx.FireAction(action, scene, "Thumbnail", null, {
				x: touch.clientX - rect.left,
				y: touch.clientY - rect.top,
				scene: scene.m_ID
			});
		}
	};

	scene.RestartThumbnailCMTimer = function(event, touch, delay) {
		if (scene.m_ContextMenuTimer) {
			window.clearInterval(scene.m_ContextMenuTimer);
		}
		scene.m_ContextMenuTimer = window.setInterval(function() {
			window.clearInterval(scene.m_ContextMenuTimer);
			scene.m_ContextMenuTimer = null;
			scene.onPseudoThumbRightClick(event, touch);
		}, delay);
	};

	scene.processtouchstart = function(e) {
		var bHandled = true; // ??

		if (VBI.m_bTrace) {
			VBI.Trace("processtouchstart");
		}

		// store the touch event...............................................//
		scene.m_Touches.push(e);

		if (e.touches.length == 1) {

			var touch = e.touches[0];
			scene.m_currentMouseX = touch.clientX;
			scene.m_currentMouseY = touch.clientY;

			scene.RestartThumbnailCMTimer(e, touch, 700);
			bHandled = true;
		}

		if (bHandled) {
			e.preventDefault();
			e.stopPropagation();
			return false;
		}
	};

	scene.IsSingleTapOnThumb = function(events) {
		if (events.length != 2) {
			return null;
		}

		var idxStart = events.length - 2;
		var idxEnd = events.length - 1;
		// the previous event has to be a touchstart...........................//
		if (events[idxStart].type != "touchstart" || events[idxStart].touches.length != 1) {
			return null;
		}
		if (events[idxEnd].type != "touchend") {
			return null;
		}
		var retVal = [
			events[idxStart].touches[0].clientX, events[idxStart].touches[0].clientY
		];
		retVal.timeTouchDown = events[idxEnd].timeStamp - events[idxStart].timeStamp;

		// delivers client coordinates.........................................//
		return retVal;
	};

	scene.processtouchend = function(e) {
		if (!scene.m_Touches.length) {
			return; // pseudo right click was triggered, no further processing on touch up
		}

		if (VBI.m_bTrace) {
			VBI.Trace("touchend");
		}

		window.clearInterval(scene.m_ContextMenuTimer);
		scene.m_ContextMenuTimer = null;

		// store the touch events..............................................//
		scene.m_Touches.push(e);

		var xy, action, actions = scene.m_Ctx.m_Actions;
		if ((xy = scene.IsSingleTapOnThumb(scene.m_Touches)) && actions) {
			if ((action = actions.findAction("Click", scene, "Thumbnail"))) {
				var rect = scene.GetInternalDivClientRect();
				scene.m_Ctx.FireAction(action, scene, "Thumbnail", null, {
					x: xy[0] - rect.left,
					y: xy[1] - rect.top
				});
			}
		}
		scene.m_Touches = [];
		e.stopPropagation();
		e.preventDefault();
	};

	// ........................................................................//
	// do the event subscription..............................................//

	this.subscribe();
};
﻿// ...........................................................................//
// sapgeolocation.js.........................................................//

// Author: Ulrich Roegelein

VBI.GeoLocation = function() {
	"use strict";
	/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
	var geolocation = {};
	geolocation.vbiclass = "GeoLocation";

	geolocation.m_coords = {};
	geolocation.m_bValid = false;

	// copy of last geoposition...............................................//
	geolocation.m_coords.latiude = 0;
	geolocation.m_coords.longitude = 0;
	geolocation.m_coords.altitude = 0;
	geolocation.m_coords.accuracy = 0;
	geolocation.m_coords.altiudeAccuracy = 0;
	geolocation.m_coords.heading = 0;
	geolocation.m_coords.speed = 0;
	geolocation.m_timestamp = 0;

	geolocation.m_watch = null;

	geolocation.OnError = function(msg) {
		// trace the geolocation error.........................................//
		jQuery.sap.log.debug("GeoLocation.OnError: " + (typeof msg == 'string' ? msg : "unknown"));
	};

	geolocation.OnPosition = function(pos) {
		geolocation.m_coords.latiude = pos.coords.latitude * Math.PI / 180;
		geolocation.m_coords.longitude = pos.coords.longitude * Math.PI / 180;
		geolocation.m_coords.altitude = pos.coords.altitude;
		geolocation.m_coords.accuracy = pos.coords.accuracy;
		geolocation.m_coords.altiudeAccuracy = pos.coords.altiudeAccuracy;
		geolocation.m_coords.heading = pos.coords.heading;
		geolocation.m_coords.speed = pos.coords.speed;
		geolocation.m_timestamp = pos.timestamp;

		geolocation.m_bValid = true;

		// call changed event...................................................//
		geolocation.OnPositionChanged(geolocation);
	};

	// interface..............................................................//

	geolocation.StartWatch = function() {
		if (geolocation.watch) { // watch handle already active
			return;
		}

		if (!navigator) {
			return;
		}

		geolocation.m_watch = navigator.geolocation.watchPosition(geolocation.OnPosition, geolocation.OnError);
		return;
	};

	geolocation.StopWatch = function() {
		if (geolocation.watch) {
			navigator.geolocation.clearWatch(geolocation.watch);
		}

		geolocation.watch = null;
	};

	geolocation.GetWifiScan = function(longitude, latitude) {
		// try to get the wifi scanner object and do a wif scan................//
		var wifi = VBI.Utilities.CreateWifiObject();
		if (wifi) {
			return wifi.ScanWifi("Scan " + latitude + "," + longitude, 0);
		}

		return null;
	};

	// public interface.......................................................//
	geolocation.OnPositionChanged = null;

	return geolocation;
};
﻿// ...........................................................................//
// math library for geo......................................................//

// Author: Ulrich Roegelein

// !remark!, all arguments work with radians.................................//

VBI.MathLib = (function() {
	"use strict";
	/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
	var mathlib = {};

	mathlib.min_longitude = -Math.PI;
	mathlib.max_longitude = Math.PI;
	mathlib.min_latitude = (-85.05112878 * 2 * Math.PI) / 360.0;
	mathlib.max_latitude = (85.05112878 * 2 * Math.PI) / 360.0;
	mathlib.mercator_for_max_latitude = 3.1415942;
	mathlib.div_mercator_for_max_latitude = (0.5 / mathlib.mercator_for_max_latitude);
	mathlib.div_max_longitude = (1.0 / mathlib.max_longitude);
	mathlib.earthradius = 6378137;
	mathlib.piDiv180 = Math.PI / 180.0;
	mathlib.One180DivPi = 1 / mathlib.piDiv180;

	mathlib.stdWorldBorder = -180;

	// ........................................................................//
	// common.................................................................//

	mathlib.CreateGUID = function() {
		// create random strings...............................................//
		var aS = [];
		for (var nJ = 0; nJ < 8; ++nJ) {
			aS[nJ] = (((Math.random() + 1) * 0x10000) | 0).toString(16).substring(1);
		}

		// concat to guid......................................................//
		return (aS[0] + aS[1] + "-" + aS[2] + "-" + aS[3] + "-" + aS[4] + "-" + aS[5] + aS[6] + aS[7]);
	};

	// ........................................................................//
	// basic transformations..................................................//

	mathlib.DegToRad = function(lonlat) {
		return [
			lonlat[0] * mathlib.piDiv180, lonlat[1] * mathlib.piDiv180
		];
	};

	mathlib.RadToDeg = function(lonlat) {
		return [
			lonlat[0] * mathlib.One180DivPi, lonlat[1] * mathlib.One180DivPi
		];
	};

	// for mercator projection only..........................................//
	mathlib.LonLatToUCS = function(lonlat, uxy) {
		// the original uxy contains the normalization values, store them......//
		// the x-coordinates increase to the right, y-coordinates increase.....//
		// from top to bottom..................................................//

		var normX = uxy[0];
		var normY = uxy[1];

		var fLongitude = lonlat[0];
		var fLatitude = lonlat[1];

		// there is !no! round world support in this function..................//
		// when the longitude is out of range of -pi to pi, he normalized......//

		if (fLatitude < mathlib.min_latitude) {
			fLatitude = mathlib.min_latitude;
		} else if (fLatitude > mathlib.max_latitude) {
			fLatitude = mathlib.max_latitude;
		}

		// geometry range is 0 to for longitude -180 to 180...................//
		uxy[0] = fLongitude * mathlib.div_max_longitude;
		uxy[0] = (uxy[0] + 1.0) * normX * 0.5;

		// geometry range is 0 to normY for latitude -max_latitude to max_latitude using the mercator projection
		var fSinLatitude = Math.sin(fLatitude);
		uxy[1] = (Math.log((1.0 + fSinLatitude) / (1.0 - fSinLatitude)) * mathlib.div_mercator_for_max_latitude); // scaled to 1
		uxy[1] = 0.5 * normY * (1.0 - uxy[1]);

		return uxy;
	};

	mathlib.UCSToLonLat = function(uxy, lonlat) {
		// the x-coordinates increase to the right, y-coordinates increase.....//
		// from top to bottom..................................................//

		// uxy must be in the range of [-1,1]..................................//
		lonlat[0] = uxy[0] * Math.PI; // range -pi ... pi..//
		lonlat[1] = Math.atan(mathlib.sinh(-uxy[1] * mathlib.mercator_for_max_latitude));
		return lonlat;
	};

	mathlib.sinh = function(val) {
		var a = Math.pow(Math.E, val);
		var b = Math.pow(Math.E, -val);
		return (a - b) / 2.0;
	};

	mathlib.Distance = function(lonlat1, lonlat2) {
		var R = mathlib.earthradius;
		var lat1 = lonlat1[1];
		var lon1 = lonlat1[0];
		var lat2 = lonlat2[1];
		var lon2 = lonlat2[0];
		var dLat = lat2 - lat1;
		var dLon = lon2 - lon1;

		var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
		var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
		var d = R * c;

		return d;
	};

	mathlib.EquidistantLonLat = function(lonlatcenter, distance, slices) {
		// the center must be don in radians and the result is delivered in....//
		// in radians..........................................................//
		var result = [];
		slices = slices || 64;

		var brng, y, x;
		var angle = distance / mathlib.earthradius;

		var cx = lonlatcenter[0]; // centerx
		var cy = lonlatcenter[1]; // centery

		// calculate iteration constants first.................................//
		var sinangle = Math.sin(angle);
		var cosangle = Math.cos(angle);
		var sincenter = Math.sin(cy);
		var coscenter = Math.cos(cy);

		var minX = cx, maxX = cx;
		var minY = cy, maxY = cy;

		for (var nJ = 0; nJ < slices; ++nJ) {
			brng = nJ * 2 * Math.PI / slices;

			y = Math.asin(sincenter * cosangle + coscenter * sinangle * Math.cos(brng));
			x = cx + Math.atan2(Math.sin(brng) * sinangle * coscenter, cosangle - sincenter * Math.sin(y));

			// determine mins and max values....................................//
			if (minX > x) {
				minX = x;
			}
			if (maxX < x) {
				maxX = x;
			}
			if (minY > y) {
				minY = y;
			}
			if (maxY < y) {
				maxY = y;
			}

			// push the lonlat to the result vector.............................//
			result.push([
				x, y
			]);
		}

		// set the minimum and maximum values..................................//
		result.m_MinX = minX;
		result.m_MaxX = maxX;
		result.m_MinY = minY;
		result.m_MaxY = maxY;

		return result;
	};

	mathlib.GetSurroundingBox = function(boxList, maxXDistShownSeparate, minXLod, fCalcYLod, maxDelta) {
		// Method calculates the surrounding box over a list of bounding boxes (picture mode == false)
		// or points (picture mode == true). For the second case an array for each box is expected in the
		// following order: x_min, x_max, y_min, y_max (point mode: x,y).
		// Main task ist to find maximum outside x-distance in a round world scenario,
		// y-coordinates are taken on the fly.

		var maxDistanceFor2ndToWB = 100;
		var wb = mathlib.stdWorldBorder; // world border is set to -180/180 but may be changed from outside

		if (maxXDistShownSeparate == undefined) {
			maxXDistShownSeparate = 360;
		}

		// method might be called with points (2 fields only) instead of boxes (4 fields required)
		var pointMode = (boxList[0].length == 2);
		var ixL = 0, ixR = 1, iyB = 2, iyT = 3;
		if (pointMode) {
			ixR = 0;
			iyB = iyT = 1;
		}

		// normalize left x coordinates to [-180->180] and right > left always
		// fetch extrema of y
		var minY = Number.MAX_VALUE, maxY = -Number.MAX_VALUE;
		var myValL, myValR, rg, ww, i;
		for (i = 0; i < boxList.length; ++i) {
			rg = boxList[i];
			if (((myValL = rg[ixL]) < -180) || (myValL > 180)) {
				ww = Math.floor((myValL + 180) / 360);
				myValL = (rg[ixL] -= 360 * ww);
				rg[ixR] -= 360 * ww;
			}
			if ((myValR = rg[ixR]) < myValL) {
				ww = Math.ceil((myValL - myValR) / 360);
				myValR = (rg[ixR] += 360 * ww);
			}
			if (rg[iyB] < minY) {
				minY = rg[iyB];
			}
			if (rg[iyT] > maxY) {
				maxY = rg[iyT];
			}
		}

		//
		// search for biggest x-gap in boxlist, plus the biggest x-gap in boxlist
		// which has one border close to the world border
		//

		boxList.sort(function(a, b) {
			return a[0] - b[0];
		}); // sort boxes on left x coordinate.

		var maxDistance = -1, maxDistance2 = -1;
		var indexMaxDistance = -1, indexMaxDistance2 = -1;
		var leftFromMaxDist, leftFromMaxDist2;

		var ele = boxList[0];
		var right, curRightX = ele[ixR], left = ele[ixL];
		var nLeftDistWB, nRightDistWB;

		// check all gaps from i->i+1 plus from max(i)->0 after the loop
		for (i = 1; i < boxList.length; ++i) {
			ele = boxList[i];
			left = ele[ixL];
			right = ele[ixR];
			if (left < curRightX) { // no gap to previous box
				if (right > curRightX) {
					curRightX = right; // curRightX must be maximum of both
				}
			} else {
				if ((left - curRightX) > maxDistance) {
					leftFromMaxDist = curRightX;
					maxDistance = left - curRightX;
					indexMaxDistance = i;
				}
				if ((left - curRightX) > maxDistance2) { // calculate distance to world border and update dist2 if near enough
					nLeftDistWB = Math.abs(((left - wb + 540) % 360) - 180);
					nRightDistWB = Math.abs(((curRightX - wb + 540) % 360) - 180);
					if ((nLeftDistWB < maxDistanceFor2ndToWB) || (nRightDistWB < maxDistanceFor2ndToWB)) {
						leftFromMaxDist2 = curRightX;
						maxDistance2 = left - curRightX;
						indexMaxDistance2 = i;
					}
				}
				curRightX = right;
			}
		}

		ele = boxList[0];
		left = ele[ixL];
		var closingDist = left - curRightX + 360;

		if (closingDist > maxDistance2) {
			nLeftDistWB = Math.abs(((left - wb + 540) % 360) - 180);
			nRightDistWB = Math.abs(((curRightX - wb + 540) % 360) - 180);
			if ((nLeftDistWB < maxDistanceFor2ndToWB) || (nRightDistWB < maxDistanceFor2ndToWB)) {
				leftFromMaxDist2 = curRightX;
				maxDistance2 = closingDist;
				indexMaxDistance2 = 0;
			}
		}

		if (closingDist > maxDistance) {
			maxDistance = closingDist;
			leftFromMaxDist = curRightX;
		} else {
			if (indexMaxDistance < 0) {
				return [
					wb, wb + 360, minY, maxY, false
				]; // there is no gap at all
			}
			ele = boxList[indexMaxDistance];
		}

		// normalize right coordinate to [-180,180] again
		leftFromMaxDist -= 360 * Math.floor((leftFromMaxDist + 180) / 360);

		// if the Box exceeds given limits we show the whole world europe-centric
		var nIntLodAboveXMin = Math.floor(minXLod) + 1;
		var nXLowestDist = (minXLod == undefined) ? 0 : 360 / Math.pow(2, nIntLodAboveXMin - minXLod);

		var nYLOD = 1000; // calculate y LOD. This requires knowledge of the projection, so the method to calculate
		// the minimal Y Lod has to be provided by the caller
		if (maxXDistShownSeparate == 0) { // adapt to LOD mode
			maxXDistShownSeparate = nXLowestDist;
			if (fCalcYLod != undefined) {
				nYLOD = Math.floor(fCalcYLod(minY, maxY));
			}
		}

		var shownDistance = leftFromMaxDist - ele[ixL] + 360 * (leftFromMaxDist < ele[ixL]);
		var bSecondApproachIsEqualInLOD = false;
		if (minXLod != undefined) {
			var nXBestLOD = Math.floor(nIntLodAboveXMin + Math.log(nXLowestDist / (360 - maxDistance)) / Math.LN2);
			if ((shownDistance > maxXDistShownSeparate) || Math.min(nXBestLOD, nYLOD) <= minXLod + maxDelta) {
				return [
					wb, wb + 360, minY, maxY, false
				];
			}
			if (nXLowestDist && (maxDistance2 >= 0)) { // Check whether 2nd Approach is equally good in LOD quality
				var nXLOD2 = Math.floor(nIntLodAboveXMin + Math.log(nXLowestDist / (360 - maxDistance2)) / Math.LN2);
				bSecondApproachIsEqualInLOD = ((nXBestLOD == nXLOD2) || (nXBestLOD <= nXLOD2));
			}
			if (bSecondApproachIsEqualInLOD) {
				ele = boxList[indexMaxDistance2];
				leftFromMaxDist = leftFromMaxDist2 - 360 * Math.floor((leftFromMaxDist2 + 180) / 360);
			}
		}
		return [
			ele[ixL], leftFromMaxDist, minY, maxY
		];
	};

	return mathlib;
})();
﻿// ...........................................................................//
// tools extensions for VBI namespace........................................//

VBI.QuadTree = function(maxQuadItems, maxLOD, rect) {
	"use strict";
	/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
	// quadrants
	// ---------
	// | 0 | 1 |
	// | ------|
	// | 2 | 3 |
	// ---------
	// constants for quadrants................................................//
	var LT = 0, RT = 1, LB = 2, RB = 3, OUT = 4;

	// quad creator...........................................................//
	var quad = function(rc, depth, maxQuadItems, maxLOD) {
		var quads = []; // array of quadrants
		var items = []; // array of items

		// returns the quad object.............................................//
		return {
			// functions...............................................//
			// query using callback....................................//
			quc: function(rect, cb) {
				var tmp;
				for (var nJ = 0, len = items.length; nJ < len; ++nJ) {
					// the item might be located on a division line......//
					tmp = items[nJ];
					if (tmp[0] > rect[2] || tmp[2] < rect[0] || tmp[1] > rect[3] || tmp[3] < rect[1]) {
						continue;
					}
					cb(tmp);
				}

				// iterate through quads................................//
				// to get the sub items.................................//
				if (quads.length) {
					// call query on all matching subquads
					// this.calcIntersectingNodes( rect, function( dir ) { quads[dir].quc( rect, cb ); } );
					// todo: remove function
					// this.calcIntersectingNodes( rect, function( dir ) { quads[dir].quc( rect, cb ); } );
					this.calcIntersectingNodes(rect, cb);
				}
			},

			// query using array.......................................//
			qua: function(rect, a) {
				this.quc(rect, function(item) {
					a.push(item);
				});
			},

			// detect the quads that are affected......................//
			calcIntersectingNodes: function(rect, cb) {
				// h2, w2 half of height and half of width
				var l = rc[0], t = rc[1], w2 = (rc[2] - l) / 2.0, h2 = (rc[3] - t) / 2.0;

				if (rect[0] < l + w2) { // left side
					if (rect[1] < t + h2) {
						quads[LT].quc(rect, cb);
					}
					// cb( LT ); // top
					if (rect[3] >= t + h2) {
						quads[LB].quc(rect, cb);
					}
					// cb( LB ); // bottom
				}
				if (rect[2] >= l + w2) {// right side
					if (rect[1] < t + h2) {
						quads[RT].quc(rect, cb);
					}
					// cb( RT ); // top
					if (rect[3] >= t + h2) {
						quads[RB].quc(rect, cb);
					}
					// cb( RB ); // bottom
				}
			},

			// find the quadrant where the rect fits...................//
			// when there is an intersection at the border, it reports.//
			// an out..................................................//
			calcQuadrant: function(rect) {
				var l, t, w2 = ((rc[2] - (l = rc[0])) / 2.0), h2 = ((rc[3] - (t = rc[1])) / 2.0);

				// left quadrants.......................................//
				if (rect[2] < l + w2) {
					if (rect[3] < t + h2) {
						return LT;
					}
					if (rect[1] >= t + h2) {
						return LB;
					}
					return OUT;
				}

				// right quadrants......................................//
				if (rect[0] >= l + w2) {
					if (rect[3] < t + h2) {
						return RT;
					}
					if (rect[1] >= t + h2) {
						return RB;
					}
					return OUT;
				}

				return OUT;
			},

			subdivide: function() {
				var cx = rc[0]; // current x
				var cy = rc[1]; // current y

				// split the quad into the 4 quadrants..................//
				var width = ((rc[2] - cx) / 2.0), height = ((rc[3] - cy) / 2.0);
				var childrenDepth = ++this.m_D;

				var l, t;
				// set new quad, left top, right top, left bottom, right bottom
				quads[LT] = quad([
					l = cx, t = cy, l + width, t + height
				], childrenDepth, maxQuadItems, maxLOD); // left top
				quads[RT] = quad([
					l = cx + width, t = cy, l + width, t + height
				], childrenDepth, maxQuadItems, maxLOD); // right top
				quads[LB] = quad([
					l = cx, t = cy + height, l + width, t + height
				], childrenDepth, maxQuadItems, maxLOD); // left bottom
				quads[RB] = quad([
					l = cx + width, t = cy + height, l + width, t + height
				], childrenDepth, maxQuadItems, maxLOD); // right bottom

				// remember the current item............................//
				var tmp = items;
				items = []; // clear current items....//

				// insert them again into the subquads..................//
				for (var nJ = 0, len = tmp.length; nJ < len; ++nJ) {
					this.insert(tmp[nJ]);
				}
			},

			// insert an item..........................................//
			insert: function(rect) {
				var res;
				if (quads.length) {
					// quadrants are available...........................//
					// determine the quadrant to place the item..........//
					if ((res = this.calcQuadrant(rect)) == OUT) {
						// add it as child................................//
						items.push(rect);
					} else {
						quads[res].insert(rect);
					}
				} else {
					// add it to the item list...........................//
					items.push(rect); // just add it to the items.....//

					// subdivide as long as limits are not reached.......//
					if (items.length > maxQuadItems && this.m_D < maxLOD) {
						this.subdivide();
					}
				}
			},

			// clear content...........................................//
			clear: function() {
				for (var nJ = 0, len = quads.length; nJ < len; ++nJ) {
					quads[nJ].clear();
				}
				items.length = 0;
				quads.length = 0;
			},

			// access the quads........................................//
			getNodes: function() {
				return quads.length ? quads : null;
			},

			// quad members............................................//
			m_R: rc, // rectangle of node
			m_D: depth
		// nesting level of node

		}; // end of quad object return
	}; // end of quad constructor function

	return {
		// members.......................................................//
		insertArray: function(item) {
			for (var nJ = 0, len = item.length; nJ < len; ++nJ) {
				this.m_Root.insert(item[nJ]);
			}
		},

		// members.......................................................//
		insert: function(rect) {
			this.m_Root.insert(rect);
		},

		// this query returns an array of potentially fitting items......//
		queryArray: function(rect, a) {
			return this.m_Root.qua(rect, a);
		},

		// this array does a callback on fitting items...................//
		queryCallback: function(rect, cb) {
			return this.m_Root.quc(rect, cb);
		},

		clear: function() {
			this.m_Root.clear();
		},

		// the root quad itself is a quad................................//
		m_Root: (function() {
			return quad(rect, 0, maxQuadItems, maxLOD);
		})()
	};
};
// init creatable objects in vbi context
/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
VBI.Tex = null; // texture object
VBI.Shader = null; // shader object
VBI.FB = null; // frame buffer object
VBI.Vals = null;
VBI.Ro = null; // render output

VBI.Hm = null; // heatmap object

// ...........................................................................//
// hook into webgl...........................................................//

VBI.Hook = (function() {
	"use strict";
	// override getExtension for different vendors............................//
	if (window.WebGLRenderingContext) {
		// hook get the rendercontect getExtension.............................//
		var getExtension = WebGLRenderingContext.prototype.getExtension;
		WebGLRenderingContext.prototype.getExtension = function(name) {
			var vendors = [
				'', 'MS', 'WEBKIT', 'MOZ', 'O'
			];
			var oExt, vendor;
			if ((oExt = getExtension.call(this, name)) === null) {
				for (var nJ = 0, len = vendors.length; nJ < len; ++nJ) {
					vendor = vendors[nJ];
					if ((oExt = getExtension.call(this, vendor + '_' + name)) !== null) {
						return oExt;
					}
				}
				return null;
			} else {
				return oExt;
			}
		};

		// add helper function.................................................//
		WebGLRenderingContext.prototype.getExtensions = function(spec) {
			// try to get needed extensions
			return this.getExtension('OES_texture_float'); 

			// this extension tells if the device supports render to float texture, but mobile browsers don't report it yet
			// this.getExtension('WEBGL_color_buffer_float'); 
		};
	}
})();

VBI.Shader = (function() {
	"use strict";
	function Shader(gl, vs, fs) {
		this.m_GL = gl; // store gl object
		this.m_UL = {}; // variable locations in program

		// compile and link the provided coding
		this.m_Prog = this.m_GL.createProgram();
		this.m_VS = this.m_GL.createShader(this.m_GL.VERTEX_SHADER);
		this.m_FS = this.m_GL.createShader(this.m_GL.FRAGMENT_SHADER);
		this.m_GL.attachShader(this.m_Prog, this.m_VS);
		this.Compile(this.m_VS, vs);
		this.m_GL.attachShader(this.m_Prog, this.m_FS);
		this.Compile(this.m_FS, fs);

		this.Link();
	}

	Shader.prototype.getShaderVar = function(name) {
		return this.m_GL.getAttribLocation(this.m_Prog, name);
	};

	Shader.prototype.Compile = function(shader, source) {
		this.m_GL.shaderSource(shader, source);
		this.m_GL.compileShader(shader);
		if (!this.m_GL.getShaderParameter(shader, this.m_GL.COMPILE_STATUS)) {
			jQuery.sap.log.error("Shader Compilation Error");
			jQuery.sap.log.error(this.m_GL.getShaderInfoLog(shader));
		}
	};

	Shader.prototype.Link = function() {
		this.m_GL.linkProgram(this.m_Prog);
		if (!this.m_GL.getProgramParameter(this.m_Prog, this.m_GL.LINK_STATUS)) {
			jQuery.sap.log.error("Shader Link Error");
			jQuery.sap.log.error(this.m_GL.getProgramInfoLog(this.m_Prog));
		}
	};

	Shader.prototype.Apply = function() {
		this.m_GL.useProgram(this.m_Prog);
		return this;
	};

	Shader.prototype.getLoc = function(name) {
		var loc = this.m_UL[name];
		if (typeof (loc) === "undefined") {
			loc = this.m_UL[name] = this.m_GL.getUniformLocation(this.m_Prog, name);
		}
		return loc;
	};

	Shader.prototype.SetInt = function(name, val) {
		this.m_GL.uniform1i(this.getLoc(name), val);
		return this;
	};

	return Shader;
})();

VBI.FB = (function() {
	"use strict";
	function FB(gl) {
		this.m_GL = gl;
		this.m_FB = this.m_GL.createFramebuffer();
	}

	FB.prototype.destroy = function() {
		return this.m_GL.deleteFramebuffer(this.m_FB);
	};

	FB.prototype.BindFB = function() {
		this.m_GL.bindFramebuffer(this.m_GL.FRAMEBUFFER, this.m_FB);
		return this;
	};

	FB.prototype.UnBindFB = function() {
		this.m_GL.bindFramebuffer(this.m_GL.FRAMEBUFFER, null);
		return this;
	};

	FB.prototype.SetTex = function(tex) {
		this.m_GL.framebufferTexture2D(this.m_GL.FRAMEBUFFER, this.m_GL.COLOR_ATTACHMENT0, this.m_GL.TEXTURE_2D, tex.m_Tex, 0);

		// check if render to float texture is supported by the hardware
		var status = this.m_GL.checkFramebufferStatus(this.m_GL.FRAMEBUFFER);
		if (status !== this.m_GL.FRAMEBUFFER_COMPLETE) {
			return null;
		}
	    
		return this;
	};

	return FB;
})();

VBI.Tex = (function() {
	"use strict";
	function Tex(gl, params) {
		var tmp;
		this.m_GL = gl;

		params = params ? params : {};

		this.m_colFmt = this.m_GL[((tmp = params.colfmt) != null ? tmp : 'rgba').toUpperCase()];
		if (typeof params.type === 'number') {
			this.type = params.type;
		} else {
			this.type = this.m_GL[((tmp = params.type) != null ? tmp : 'unsigned_byte').toUpperCase()];
		}

		this.m_Tex = this.m_GL.createTexture();
	}

	Tex.prototype.destroy = function() {
		return this.m_GL.deleteTexture(this.m_Tex);
	};

	Tex.prototype.BindTex = function(slot) {
		if (slot == null) {
			slot = 0;
		}
		this.m_GL.activeTexture(this.m_GL.TEXTURE0 + slot);
		this.m_GL.bindTexture(this.m_GL.TEXTURE_2D, this.m_Tex);
		return this;
	};

	Tex.prototype.AdjustSize = function(w, h) {
		this.m_W = w;
		this.m_H = h;
		this.m_GL.texImage2D(this.m_GL.TEXTURE_2D, 0, this.m_colFmt, w, h, 0, this.m_colFmt, this.type, null);
		return this;
	};

	Tex.prototype.SetImage = function(data) {
		this.m_W = data.width;
		this.m_H = data.height;
		this.m_GL.texImage2D(this.m_GL.TEXTURE_2D, 0, this.m_colFmt, this.m_colFmt, this.type, data);
		return this;
	};

	Tex.prototype.SetFilterNearest = function() {
		this.m_GL.texParameteri(this.m_GL.TEXTURE_2D, this.m_GL.TEXTURE_MAG_FILTER, this.m_GL.NEAREST);
		this.m_GL.texParameteri(this.m_GL.TEXTURE_2D, this.m_GL.TEXTURE_MIN_FILTER, this.m_GL.NEAREST);
		return this;
	};

	Tex.prototype.SetWrapEdge = function() {
		this.m_GL.texParameteri(this.m_GL.TEXTURE_2D, this.m_GL.TEXTURE_WRAP_S, this.m_GL.CLAMP_TO_EDGE);
		this.m_GL.texParameteri(this.m_GL.TEXTURE_2D, this.m_GL.TEXTURE_WRAP_T, this.m_GL.CLAMP_TO_EDGE);
		return this;
	};

	return Tex;
})();

VBI.Ro = (function() {
	"use strict";
	function Ro(gl, width, height) {
		this.m_GL = gl;
		this.m_W = width;
		this.m_H = height;

		var ext = this.m_GL.getExtensions(); // check if the required extensions are supported
		var texType = null;
		if (ext) {
			texType = this.m_GL.FLOAT;
		}

		// create a float texture
		this.m_Tex = new VBI.Tex(this.m_GL, {
			type: texType
		});
		
		this.m_Tex.BindTex(0);
		this.m_Tex.AdjustSize(width, height);
		this.m_Tex.SetFilterNearest();
		this.m_Tex.SetWrapEdge();

		// create the frame buffer based on texture
		this.m_FB = new VBI.FB(this.m_GL);
		this.m_FB.BindFB();

		// check if render to float texture is supported
		if (!this.m_FB.SetTex(this.m_Tex)) {
			this.m_FB.UnBindFB();
			
			// render to float texture not supported => try to create integer texture and then render to it
			//jQuery.sap.log.error("Render to float texture not supported => creating integer texture");
			
			// create an integer texture
			this.m_Tex = new VBI.Tex(this.m_GL, {
				type: null
			});
			
			this.m_Tex.BindTex(0);
			this.m_Tex.AdjustSize(width, height);
			this.m_Tex.SetFilterNearest();
			this.m_Tex.SetWrapEdge();

			// create the frame buffer based on texture
			this.m_FB = new VBI.FB(this.m_GL);
			this.m_FB.BindFB();
			this.m_FB.SetTex(this.m_Tex);
			this.m_FB.UnBindFB();
		} else {
			this.m_FB.UnBindFB();
		}
	}

	Ro.prototype.Apply = function() {
		return this.m_FB.BindFB();
	};

	Ro.prototype.BindRo = function(slot) {
		return this.m_Tex.BindTex(slot);
	};

	Ro.prototype.UnBindRo = function() {
		this.m_FB.UnBindFB();
	};

	Ro.prototype.AdjustSize = function(width, height) {
		this.m_W = width;
		this.m_H = height;

		// set the new size of the texture
		return this.m_Tex.BindTex(0).AdjustSize(width, height);
	};

	return Ro;
})();

// values for heatmap
VBI.Vals = (function() {
	"use strict";
	function Vals(gl, width, height) {
		this.m_GL = gl;

		// constants
		this.m_nPointChunk = 10240; // chunksize
		this.m_nVertexSize = 8;

		this.m_W = width;
		this.m_H = height;

		this.m_Shader = new VBI.Shader(this.m_GL, 
						"uniform vec4 uTM;" +
						"attribute vec4 aPos;" +
						"attribute float aValue;" +
						"varying vec3 vData;" +
						"void main(){" +
						"  gl_Position = vec4(aPos.xy * uTM.xy + uTM.zw, 0.0, 1.0);" +
						"  vData.xy = aPos.zw;" +
						"  vData.z = aValue;" +
						"}",
						"#ifdef GL_FRAGMENT_PRECISION_HIGH\n" +
						"  precision highp int;" +
						"  precision highp float;\n" +
						"#else\n" +
						"  precision mediump int;" +
						"  precision mediump float;\n" +
						"#endif\n" +
						"varying vec3 vData;" +
						"void main(){" +
						"  float f = smoothstep(1.0, 0.0, length(vData.xy)) * vData.z;" +
						"  gl_FragColor = vec4(f);" +
						"}");

		// "#ifdef GL_FRAGMENT_PRECISION_HIGH\n precision highp int;\n precision highp float;\n#else\n precision mediump int;\n precision mediump
		// float;\n#endif\nvarying vec2 off, dim;\nvarying float val;\nvoid main(){ float d = length(off/dim); float f = exp( -1.0/(d*d) ); float tmp
		// = f*val; gl_FragColor=vec4(tmp);}\n");

		this.m_Shader.aPos = this.m_Shader.getShaderVar('aPos');
		this.m_Shader.aValue = this.m_Shader.getShaderVar('aValue');
		this.m_Shader.uTM = this.m_Shader.getLoc('uTM');

		// create a render output buffer
		this.m_Ro = new VBI.Ro(this.m_GL, this.m_W, this.m_H);

		this.m_VB = this.m_GL.createBuffer();
		this.m_vBuf = new Float32Array(this.m_nPointChunk * this.m_nVertexSize * 6);

		this.m_IB = this.m_GL.createBuffer();
		var elements = new Uint16Array(this.m_nPointChunk * 6);
		for (var i = 0, j = 0; i < elements.length; j += 4) {
			elements[i++] = j;
			elements[i++] = j + 1;
			elements[i++] = j + 2;
			elements[i++] = j + 2;
			elements[i++] = j + 1;
			elements[i++] = j + 3;
		}
		this.m_GL.bindBuffer(this.m_GL.ELEMENT_ARRAY_BUFFER, this.m_IB);
		this.m_GL.bufferData(this.m_GL.ELEMENT_ARRAY_BUFFER, elements, this.m_GL.STATIC_DRAW);

		this.m_nIdx = 0;
		this.m_nPoints = 0;
	}

	Vals.prototype.AdjustSize = function(w, h) {
		this.m_W = w;
		this.m_H = h;
		this.m_Ro.AdjustSize(this.m_W, this.m_H);
		return;
	};

	Vals.prototype.Render = function() {
		if (this.m_nPoints > 0) {
			var gl = this.m_GL;
			gl.enable(gl.BLEND);
			this.m_Ro.Apply();
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.m_IB);
			gl.bindBuffer(gl.ARRAY_BUFFER, this.m_VB);
			gl.bufferData(gl.ARRAY_BUFFER, this.m_vBuf, gl.STREAM_DRAW);

			this.m_Shader.Apply();

			gl.enableVertexAttribArray(1);
			gl.vertexAttribPointer(this.m_Shader.aPos, 4, gl.FLOAT, false, 20, 0);
			gl.vertexAttribPointer(this.m_Shader.aValue, 1, gl.FLOAT, false, 20, 16);

			gl.uniform4f(this.m_Shader.uTM, 2 / this.m_W, 2 / this.m_H, -1, -1);

			// draw squares
			gl.drawElements(gl.TRIANGLES, this.m_nPoints * 6, gl.UNSIGNED_SHORT, 0);
			gl.disableVertexAttribArray(1);

			// cleanup
			this.m_Ro.UnBindRo();
			gl.disable(gl.BLEND);
			this.m_nPoints = 0;
			this.m_nIdx = 0;
		}
	};

	Vals.prototype.Clear = function() {
		this.m_Ro.Apply();
		this.m_GL.clearColor(0.0, 0.0, 0.0, 0.0);
		this.m_GL.clear(this.m_GL.COLOR_BUFFER_BIT);
		return this.m_Ro.UnBindRo();
	};

	Vals.prototype.AddPoint = function(x, y, val, s) {
		// when more points than chunksize render multiple times the gray image..//
		if ((this.m_nPoints + 1) >= this.m_nPointChunk) {
			this.Render();
		}

		y = this.m_H - y; // flip y coordinate

		// the flat rectangle to draw to.........................................//
		this.PushVertex(x - s, y - s, -1, -1, val);
		this.PushVertex(x + s, y - s, +1, -1, val);
		this.PushVertex(x - s, y + s, -1, +1, val);
		this.PushVertex(x + s, y + s, +1, +1, val);
		this.m_nPoints += 1;
		return this.m_nPoints;
	};

	Vals.prototype.PushVertex = function(x, y, xs, ys, val) {
		var a = this.m_vBuf;
		var cnt = this.m_nIdx;
		a[cnt++] = x;
		a[cnt++] = y;
		a[cnt++] = xs;
		a[cnt++] = ys;
		a[cnt++] = val;
		this.m_nIdx = cnt;
	};

	return Vals;
})();

VBI.Hm = (function() {
	"use strict";
	function Hm(oArgs) {
		var calcAlpha; // shader fragment to calculate an alpha
		var calcCol; // shader fragment to calculate the color

		var scene = oArgs.scene;

		// adjust arguments
		if (typeof (oArgs.alphaBounds == 'undefined')) {
			oArgs.alphaBounds = [
				0.0, 1.0
			];
		}
		if (typeof (oArgs.alpha == 'undefined')) {
			oArgs.alpha = true;
		}

		this.m_Canv = oArgs.canvas; // store the canvas
		this.m_W = oArgs.width; // store width
		this.m_H = oArgs.height; // store height
		this.m_aFunc = oArgs.aFunc.toFixed(8);
		this.m_cFunc = oArgs.cFunc.toFixed(8);

		if (!this.m_Canv) {
			this.m_Canv = document.createElement("canvas");
		}

		var oAttibutes = {
			depth: false,
			antialias: false,
			alpha: true
		}; // webgl attributes

		// get the webgl context...............................................//
		if (!this.m_GL) {
			this.m_GL = this.m_Canv.getContext("experimental-webgl", oAttibutes);
		}
		if (!this.m_GL) {
			this.m_GL = this.m_Canv.getContext("webgl", oAttibutes);
		}
		if (!this.m_GL) {
			jQuery.sap.log.error("WebGL not supported");
			return;
		}

		this.m_GL.blendFunc(this.m_GL.ONE, this.m_GL.ONE); // no blend, just copy to colors to output
		this.m_GL.enableVertexAttribArray(0);

		// check if a gradient texture is specified
		if (oArgs.colorTexture) {
			this.m_ColorTexture = new VBI.Tex(this.m_GL, {
				colfmt: "rgba"
			});
			this.m_ColorTexture.BindTex(0);
			this.m_ColorTexture.SetFilterNearest();
			this.m_ColorTexture.SetWrapEdge();
			this.m_ColorTexture.AdjustSize(2, 2);

// if (typeof (oArgs.colorTexture) === "string") {
// image = new Image();
// image.onload = function() {
// this.m_ColorTexture.BindTex(0);
// this.m_ColorTexture.SetImage(image);
// scene.RenderAsync(false);
// }.bind(this);
// image.src = oArgs.colorTexture;
// }

			this.m_ColorTexture.BindTex(0);
			this.m_ColorTexture.SetImage(oArgs.colorTex);
			if (!oArgs.colorTex.IsLoaded) {
				scene.RenderAsync(false);
			}

			calcCol = 
				"uniform sampler2D colTex; " +
				"vec3 calcCol( float g ){ " +
				"  return texture2D( colTex, vec2( g, 0.5 )).rgb; " +
				"}";
		} else {
			calcCol = 
				"vec3 calcCol( float g ){ " +
				"  return smoothstep( vec3( 0.0, 0.0, 1.0 ), vec3( 1.0, 1.0, 0.0 ), vec3( g ) ); " +
				"}";
		}

		// assemble alpha usage shader code
		if (oArgs.alpha) {
			calcAlpha = 
				"vec4 calcAlpha(vec3 c,float i){ " +
				"  float a = smoothstep(" + (oArgs.alphaBounds[0].toFixed(8)) + "," + (oArgs.alphaBounds[1].toFixed(8)) + ", pow(i, 1.0)); " +
				"  return vec4( c*a, a); " +
				"}";
		} else {
			calcAlpha = 
				"vec4 calcAlpha(vec3 c, float i){ " +
				"  return vec4(c, 1.0);" +
				"}";
		}

		var fsVars = 
			"#ifdef GL_FRAGMENT_PRECISION_HIGH \n" +
			"  precision highp int;" +
			"  precision highp float; \n" +
			"#else \n" +
			"  precision mediump int;" +
			"  precision mediump float; \n" +
			"#endif \n" +
			"uniform sampler2D src;" +
			"varying vec2 txy;";
		
		var fsMain = 
			"void main(){ " +
			"  float f = clamp( texture2D(src, txy).r, 0.0, 1.0 ); " +
			"  vec3 color = calcCol(pow(f, " + (this.m_cFunc) + ")); " +
			"  gl_FragColor = calcAlpha(color, pow(f, " + (this.m_aFunc) + ")); " +
			"}";

		// create the shader that does the output to the canvas, it uses the blue channel for color mapping
		this.m_Shader = new VBI.Shader(this.m_GL, 
		                               "attribute vec4 pos; " +
		                               "varying vec2 txy; " +
		                               "void main(){ " +
		                               "  txy = pos.xy * 0.5 + 0.5; " +
		                               "  gl_Position = pos; " +
		                               "}", 
		                               fsVars + calcCol + "\n" + calcAlpha + fsMain);

		if (this.m_W == null) {
			this.m_W = this.m_Canv.offsetWidth || 2;
		}

		if (this.m_H == null) {
			this.m_H = this.m_Canv.offsetHeight || 2;
		}

		this.m_Canv.width = this.m_W;
		this.m_Canv.height = this.m_H;

		// square geometry with uv coordinates
		var geo = new Float32Array([
			-1, -1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, 1, 1, 0, 1
		]);
		this.m_Geo = this.m_GL.createBuffer();

		this.m_GL.viewport(0, 0, this.m_W, this.m_H);
		this.m_GL.bindBuffer(this.m_GL.ARRAY_BUFFER, this.m_Geo);

		this.m_GL.bufferData(this.m_GL.ARRAY_BUFFER, geo, this.m_GL.STATIC_DRAW);
		this.m_GL.bindBuffer(this.m_GL.ARRAY_BUFFER, null);

		// values
		this.m_V = new VBI.Vals(this.m_GL, this.m_W, this.m_H);
	}

	Hm.prototype.AdjustSize = function() {
		if (!this.m_GL) {
			return; // do nothing
		}

		var cH = this.m_Canv.offsetHeight || 2;
		var cW = this.m_Canv.offsetWidth || 2;
		if (this.m_W !== cW || this.m_H !== cH) {
			this.m_GL.viewport(0, 0, cW, cH);
			this.m_Canv.width = cW;
			this.m_Canv.height = cH;
			this.m_W = cW;
			this.m_H = cH;
			this.m_V.AdjustSize(this.m_W, this.m_H);
		}
	};

	Hm.prototype.RenderColors = function() {
		// important, the values have to be rendered already in the output buffer
		if (!this.m_GL) {
			return; // do nothing
		}

		// set simple full canvas geometry
		this.m_GL.bindBuffer(this.m_GL.ARRAY_BUFFER, this.m_Geo);
		this.m_GL.vertexAttribPointer(0, 4, this.m_GL.FLOAT, false, 0, 0);

		// set the render output and the color mapping texture
		this.m_V.m_Ro.BindRo(0);
		if (this.m_ColorTexture) {
			this.m_ColorTexture.BindTex(1);
		}

		// bind the final canvas shader
		this.m_Shader.Apply();
		this.m_Shader.SetInt("src", 0);
		this.m_Shader.SetInt("colTex", 1);
		this.m_GL.drawArrays(this.m_GL.TRIANGLE_STRIP, 0, 4);
		return;
	};

	Hm.prototype.RenderValues = function() {
		if (!this.m_GL) {
			return; // do nothing
		}
		if (this.m_V) {
			this.m_V.Render();
		}
	};

	Hm.prototype.Render = function() {
		this.RenderValues(); // render values in gray texture
		this.RenderColors(); // apply colors to gray texture and rener to canvas
	};

	Hm.prototype.Clear = function() {
		return this.m_V ? this.m_V.Clear() : null;
	};

	Hm.prototype.AddPoint = function(x, y, val, sz) {
		return this.m_V ? this.m_V.AddPoint(x, y, val, sz) : null;
	};

	// return the heatmap object..............................................//
	return Hm;
})();

VBI.CreateHM = function(params) {
	"use strict";
	return new VBI.Hm(params);
};
// ...........................................................................//
// this module does the label handling.......................................//

// Author: Martina Gozlinski, extraction by Jürgen

// ...........................................................................//
// First part enriches scene with label specific functions //
// Second part consists of the VBI.Label object, formerly part of vobase //
/* global VBI */// declare unusual global vars for JSLint/SAPUI5 validation
VBI.addSceneLabelFunctions = function(scene) {
	"use strict";
	scene.InternalDrawLabelTexts = function(dc, label, textcolor, substrings) {
		for (var nJ = 0; nJ < label.m_Pos.length; ++nJ) {
			for (var nZ = 0; nZ < label.m_Pos[nJ].length; nZ++) {

				var height = Math.round(label.m_Height);
				var width = Math.round(label.m_Width);
				var startX = Math.round(label.m_Pos[nJ][nZ][0]);
				var startY = Math.round(label.m_Pos[nJ][nZ][1]);
				var alignment = label.m_Arrow ? label.m_Align : 0;// 1;3;5;7
				var radius = label.m_Rounded ? height / 2 : 10;
				var nK;
				dc.beginPath();
				dc.lineWidth = 2;
				dc.moveTo(startX + radius, startY); // 0

				if (alignment == 5) {
					label.m_Pos[nJ][nZ].tri = [
						[
							startX + width / 2 - 3, startY
						], [
							startX + width / 2, startY - 5
						], [
							startX + width / 2 + 3, startY
						]
					];
					for (nK = 0; nK < 3; ++nK) {
						dc.lineTo(label.m_Pos[nJ][nZ].tri[nK][0], label.m_Pos[nJ][nZ].tri[nK][1]);
					}
				}
				dc.lineTo(startX + width - radius, startY); // 1
				dc.arcTo(startX + width, startY, startX + width, startY + radius, radius); // 2

				if (alignment == 7 && !label.m_Rounded) {
					label.m_Pos[nJ][nZ].tri = [
						[
							startX + width, startY + height / 2 - 3
						], [
							startX + width + 5, startY + height / 2
						], [
							startX + width, startY + height / 2 + 3
						]
					];
					for (nK = 0; nK < 3; ++nK) {
						dc.lineTo(label.m_Pos[nJ][nZ].tri[nK][0], label.m_Pos[nJ][nZ].tri[nK][1]);
					}

				}
				dc.lineTo(startX + width, startY + height - radius); // 3
				dc.arcTo(startX + width, startY + height, startX + width - radius, startY + height, radius); // 4

				if (alignment == 1) {
					label.m_Pos[nJ][nZ].tri = [
						[
							startX + width / 2 + 3, startY + height
						], [
							startX + width / 2, startY + height + 5
						], [
							startX + width / 2 - 3, startY + height
						]
					];
					for (nK = 0; nK < 3; ++nK) {
						dc.lineTo(label.m_Pos[nJ][nZ].tri[nK][0], label.m_Pos[nJ][nZ].tri[nK][1]);
					}
				}
				dc.lineTo(startX + radius, startY + height); // 5
				dc.arcTo(startX, startY + height, startX, startY + height - radius, radius); // 6

				if (alignment == 3 && !label.m_Rounded) {
					label.m_Pos[nJ][nZ].tri = [
						[
							startX, startY + height / 2 + 3
						], [
							startX - 5, startY + height / 2
						], [
							startX, startY + height / 2 - 3
						]
					];
					for (nK = 0; nK < 3; ++nK) {
						dc.lineTo(label.m_Pos[nJ][nZ].tri[nK][0], label.m_Pos[nJ][nZ].tri[nK][1]);
					}
				}
				dc.lineTo(startX, startY + radius); // 7
				dc.arcTo(startX, startY, startX + radius, startY, radius); // 8

				dc.fillStyle = label.m_BgColor;
				dc.fill();
				if (label.m_BrdrCol) {
					dc.strokeStyle = label.m_BrdrCol;
				} else {
					dc.strokeStyle = label.m_BgColor;
				}
				dc.stroke();

				var nLineHeight = textcolor.length == 1 ? VBI.Utilities.RemToPixel(0.75) : VBI.Utilities.RemToPixel(0.75) + 1;
				var ntransparentOffset = 0;
				for (var nX = 0; nX < textcolor.length; ++nX) {
					dc.fillStyle = textcolor[nX];
					var nYOffset = 0;
					for (nK = 0; nK < substrings.length; nK++) {
						nYOffset = label.m_Padding[1] + nLineHeight * nK;
						dc.fillText(substrings[nK], startX + label.m_Padding[0] + ntransparentOffset, startY + nYOffset + ntransparentOffset + 7);
					}
					ntransparentOffset++;
				}
				// rectangle for icon
				if (label.m_Icon) {
					label.m_IcInfo = sap.ui.core.IconPool.getIconInfo(label.m_Icon);
					if (label.m_IcInfo) {
						var iconPosX = (label.m_Align == 7 && label.m_Arrow) ? startX : startX + width;
						dc.fillStyle = label.m_IcBgrdCol;

						dc.fillRect(iconPosX - 7, startY + height - 7, 14, 14);
						label.m_Pos[nJ][nZ].rc = [
							iconPosX - 7, startY + height - 7, iconPosX - 7 + 14, startY + height - 7 + 14
						];

					}
				}
			}
		}
	};

	scene.InternalDrawLabels = function(dc, label, textcolor, substrings) {
		for (var nJ = 0; nJ < label.m_Pos.length; ++nJ) {
			for (var nZ = 0; nZ < label.m_Pos[nJ].length; nZ++) {
				VBI.Utilities.SetTextAttributes(dc, VBI.Utilities.RemToPixel(0.75) + "px 'Lucida Sans Unicode',sans-serif", undefined, undefined, "start", "middle");
				var height = Math.round(label.m_Height);
				var width = Math.round(label.m_Width);
				var startX = Math.round(label.m_Pos[nJ][nZ][0]);
				// if ( startX + width > 1000)continue;
				var startY = Math.round(label.m_Pos[nJ][nZ][1]);
				var alignment = label.m_Arrow ? label.m_Align : 0;// 1;3;5;7
				var radius = label.m_Rounded ? height / 2 : 6;
				var nK;
				dc.beginPath();
				dc.lineWidth = 2;
				dc.moveTo(startX + radius, startY); // 0

				if (alignment == 5) {
					label.m_Pos[nJ][nZ].tri = [
						[
							startX + width / 2 - 3, startY
						], [
							startX + width / 2, startY - 5
						], [
							startX + width / 2 + 3, startY
						]
					];
					for (nK = 0; nK < 3; ++nK) {
						dc.lineTo(label.m_Pos[nJ][nZ].tri[nK][0], label.m_Pos[nJ][nZ].tri[nK][1]);
					}
				}
				dc.lineTo(startX + width - radius, startY); // 1
				dc.arcTo(startX + width, startY, startX + width, startY + radius, radius); // 2

				if (alignment == 7 && !label.m_Rounded) {
					label.m_Pos[nJ][nZ].tri = [
						[
							startX + width, startY + height / 2 - 3
						], [
							startX + width + 5, startY + height / 2
						], [
							startX + width, startY + height / 2 + 3
						]
					];
					for (nK = 0; nK < 3; ++nK) {
						dc.lineTo(label.m_Pos[nJ][nZ].tri[nK][0], label.m_Pos[nJ][nZ].tri[nK][1]);
					}

				}
				dc.lineTo(startX + width, startY + height - radius); // 3
				dc.arcTo(startX + width, startY + height, startX + width - radius, startY + height, radius); // 4

				if (alignment == 1) {
					label.m_Pos[nJ][nZ].tri = [
						[
							startX + width / 2 + 3, startY + height
						], [
							startX + width / 2, startY + height + 5
						], [
							startX + width / 2 - 3, startY + height
						]
					];
					for (nK = 0; nK < 3; ++nK) {
						dc.lineTo(label.m_Pos[nJ][nZ].tri[nK][0], label.m_Pos[nJ][nZ].tri[nK][1]);
					}

				}
				dc.lineTo(startX + radius, startY + height); // 5
				dc.arcTo(startX, startY + height, startX, startY + height - radius, radius); // 6

				if (alignment == 3 && !label.m_Rounded) {
					label.m_Pos[nJ][nZ].tri = [
						[
							startX, startY + height / 2 + 3
						], [
							startX - 5, startY + height / 2
						], [
							startX, startY + height / 2 - 3
						]
					];
					for (nK = 0; nK < 3; ++nK) {
						dc.lineTo(label.m_Pos[nJ][nZ].tri[nK][0], label.m_Pos[nJ][nZ].tri[nK][1]);
					}
				}
				dc.lineTo(startX, startY + radius); // 7
				dc.arcTo(startX, startY, startX + radius, startY, radius); // 8

				dc.fillStyle = label.m_BgColor;
				dc.fill();
				dc.strokeStyle = (label.m_BrdrCol ? label.m_BrdrCol : label.m_BgColor);
				dc.stroke();
				var nLineHeight = textcolor.length == 1 ? VBI.Utilities.RemToPixel(0.75) : VBI.Utilities.RemToPixel(0.75) + 1;
				var ntransparentOffset = 0;
				for (var nX = 0; nX < textcolor.length; ++nX) {
					dc.fillStyle = textcolor[nX];
					var nYOffset = 0;
					for (nK = 0; nK < substrings.length; nK++) {
						nYOffset = label.m_Padding[1] + nLineHeight * nK;
						dc.fillText(substrings[nK], (VBI.m_bIsRtl) ? (startX + width - label.m_Padding[0] + ntransparentOffset) : (startX + label.m_Padding[0] + ntransparentOffset), startY + nYOffset + ntransparentOffset + 7);
					}
					ntransparentOffset++;
				}
				// rectangle for icon
				if (label.m_Icon) {
					label.m_IcInfo = sap.ui.core.IconPool.getIconInfo(label.m_Icon);
					if (label.m_IcInfo) {
						var iconPosX = (label.m_Align == 7 && label.m_Arrow) ? startX : startX + width;
						dc.fillStyle = label.m_IcBgrdCol;

						dc.fillRect(iconPosX - 7, startY + height - 7, 14, 14);

						label.m_Pos[nJ][nZ].rc = [
							iconPosX - 7, startY + height - 7, iconPosX - 7 + 14, startY + height - 7 + 14
						];

						// the icon itself
						VBI.Utilities.SetTextAttributes(dc, "12px SAP-icons", undefined, undefined, "center", "middle");
						dc.fillStyle = label.GetLabelIconColor();
						dc.fillText(label.m_IcInfo.content, iconPosX, startY + height);
					}
				}
			}
		}
	};

	scene.InternalDrawLabelIcons = function(dc, label) {
		var height = Math.round(label.m_Height);
		var width = Math.round(label.m_Width);
		for (var nJ = 0; nJ < label.m_Pos.length; ++nJ) {
			for (var nZ = 0; nZ < label.m_Pos[nJ].length; nZ++) {
				var startX = Math.round(label.m_Pos[nJ][nZ][0]);
				var startY = Math.round(label.m_Pos[nJ][nZ][1]);

				if (label.m_Icon && label.m_IcInfo) {
					dc.fillStyle = label.GetLabelIconColor();
					var iconPosX = (label.m_Align == 7 && label.m_Arrow) ? startX : startX + width;
					dc.fillText(label.m_IcInfo.content, iconPosX, startY + height);
				}
			}
		}
	};

	scene.InternalRenderLabels = function(canvas, dc) {
		// iterate over VOs : 1. loop: calculate label data: position, width and height, alignment, textcolor and substrings; then draw the texts
		// iterate over VOs : 2. loop: draw the icons
		// separate both to not switch fonts for each label ( performance reason )
		var aVO = scene.m_VOS;
		for (var nI = 0, len = aVO.length; nI < len; ++nI) {
			var aLabels = aVO[nI].getLabelData(true);
			for (var nY = 0; nY < aLabels.length; ++nY) {
				var label = aLabels[nY];
				VBI.Utilities.SetTextAttributes(dc, VBI.Utilities.RemToPixel(0.75) + "px 'Lucida Sans Unicode',sans-serif", undefined, undefined, "start", "middle");
				label.SetDimensions(dc);
				label.AlignLabel();
				var textcolor = label.GetLabelTextColor();
				var substrings = label.m_Text.split(/\r\n/);

				/*
					REPOSITIONING THE LABELS TO AVOID THEM BEING CUT
					Before drawing the labels, we check if they fit in the current map.
					If they don't we reposition them by 5 pixels towards
					left/right/top/bottom, depending on where it's necessary.
				*/
				var viewportCoord = scene.GetViewport();
				for (var i = 0; i < label.m_Pos.length; i++) {
					for (var j = 0; j < label.m_Pos[i].length; j++) {

						var voPosition = label.m_PosArray.pa,
							labelBottomLeftCoord = label.m_Pos[i][j];

						// Performing the repositioning for all kinds of labels
						if (voPosition.length !== 3 || voPosition[0] > viewportCoord[0] && voPosition[0] < viewportCoord[2]) {
							// Check if label fits at the left
							if (labelBottomLeftCoord[0] - viewportCoord[0] < 5) {
								labelBottomLeftCoord[0] = viewportCoord[0] + 5;
							} else if (labelBottomLeftCoord[0] + label.m_Width > viewportCoord[2] - 5) {
								// Check if label fits at the right
								labelBottomLeftCoord[0] = viewportCoord[2] - label.m_Width - 5;
							}

							// Check if the label fits at the top
							if (labelBottomLeftCoord[1] - viewportCoord[1] < 5) {
								labelBottomLeftCoord[1] = viewportCoord[1] + 5;
							} else if (labelBottomLeftCoord[1] + label.m_Height > viewportCoord[3] - 5) {
								// Check if the label fits at the bottom
								labelBottomLeftCoord[1] = viewportCoord[3] - label.m_Height - 5;
							}
						} else {
							// Performing the repositioning for spot labels in the scenario
							// where they get a position value after substracting the tile width
							if (labelBottomLeftCoord[0] + (label.m_aIO[1] || 0) - viewportCoord[0] < 5) {
								labelBottomLeftCoord[0] = viewportCoord[0] + 5;
							} else if (labelBottomLeftCoord[0] + (label.m_aIO[1] || 0) + label.m_Width > viewportCoord[2] - 5) {
								// Check if label fits at the right
								labelBottomLeftCoord[0] = viewportCoord[2] - label.m_Width - 5;
							} else {
								labelBottomLeftCoord[0] += label.m_aIO[1] || 0;
							}

							// Check if the label fits at the top
							if (labelBottomLeftCoord[1] - viewportCoord[1] < 5) {
								labelBottomLeftCoord[1] = viewportCoord[1] + 5;
							} else if (labelBottomLeftCoord[1] + label.m_Height > viewportCoord[3] - 5) {
								// Check if the label fits at the bottom
								labelBottomLeftCoord[1] = viewportCoord[3] - label.m_Height - 5;
							}
						}

					}
				}

				scene.InternalDrawLabels(dc, label, textcolor, substrings);
			}
		}

	};

};

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< //
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< //
// Label functions of the scene //
// ===================================================================================================== //
// ===================================================================================================== //
// VBI.Label object //
// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> //
// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> //

VBI.Label = function(label, nIndex, recalc, posarray, rcbox, aIO) {
	"use strict";
	this.m_bAligned = false;
	this.mIndex = nIndex;
	this.m_aIO = aIO;
	this.m_rcBox = rcbox;
	this.m_Text = label.text;
	this.m_BgColor = label.bgColor;
	this.m_BrdrCol = label.brdrCol;
	this.m_Icon = label.icon;
	this.m_IcBgrdCol = label.icColor;
	this.m_IcTextCol = label.icTextColor;
	this.m_Arrow = label.arrow;
	this.m_Rounded = label.rounded;
	this.m_Align = label.Align;
	this.m_Offset = label.offset;
	this.m_Padding = [
		7, 5
	];
	this.m_ArrowHeight = 5;
	this.m_ArrowWidth = 3;
	this.m_LineWidth = 2;
	this.m_LabelIconColor = null;
	this.m_PosArray = posarray; // the position ( positionarray ) of the VO Instance calculated in RenderInstance

	this.m_Pos = []; // the calculated position of the labeltext
	this.m_Width = 0;
	this.m_Height = 0;
	this.m_LabelTextColor = [];
	if (!recalc) { // predefined positions only if no recalc method available
		var nLen = Math.floor(this.m_PosArray.pa.length / 3) * 3;
		for (var nH = 0; nH < aIO.length; nH++) {
			var aTmp = [];
			for (var nI = 0; nI < nLen; nI += 3) {
				var pt = [
					this.m_PosArray.pa[nI] + aIO[nH], this.m_PosArray.pa[nI + 1]
				];
				aTmp.push(pt);
			}
			this.m_Pos.push(aTmp);
		}
	}

	this.CalculateLabelPos = recalc;

	this.getContrastCol = function(rgba) {
		// calculate brightness difference to get the best contrast
		var idxText = (299 * 250 + 587 * 250 + 114 * 250) / 1000.0;
		var idxBgCol = (299 * rgba[0] + 587 * rgba[1] + 114 * rgba[2]) / 1000.0;
		return (Math.abs(idxBgCol - idxText) <= 125.0 ? "#000000" : "#FAFAFA");
	};

	this.GetLabelTextColor = function() {
		if (!this.m_LabelTextColor.length) {
			var rgba = VBI.Types.string2rgba(this.m_BgColor);
			if (rgba[3] == 0 && rgba[4] == 1) { // transparent background
				this.m_LabelTextColor[0] = "#FFFFFF";
				this.m_LabelTextColor[1] = "#000000";
			} else {
				this.m_LabelTextColor[0] = this.getContrastCol(rgba);
			}
		}
		return this.m_LabelTextColor;
	};

	this.GetLabelIconColor = function() {
		if (!this.m_LabelIconColor) {
			if (this.m_IcTextCol) {
				this.m_LabelIconColor = this.m_IcTextCol;
			} else {
				var rgba = VBI.Types.string2rgba(this.m_IcBgrdCol);
				this.m_LabelIconColor = ((rgba[3] == 0 && rgba[4] == 1) ? "#000000" : this.getContrastCol(rgba));
			}
		}
		return this.m_LabelIconColor;
	};

	this.SetDimensions = function(preconfiguredDC) {
		if (!this.m_Width || !this.m_Height) {
			var substrings = this.m_Text.split(/\r\n/);
			var nMaxLength = 0;
			var nMaxIdx = 0;
			var nLineHeight = VBI.Utilities.RemToPixel(0.75);
			for (var nJ = 0; nJ < substrings.length; nJ++) {
				var ntmp = substrings[nJ].length;
				if (ntmp > nMaxLength) {
					nMaxLength = ntmp;
					nMaxIdx = nJ;
				}
			}

			this.m_Width = preconfiguredDC.measureText(substrings[nMaxIdx]).width + this.m_Padding[0] * 2;
			this.m_Height = nLineHeight * substrings.length + this.m_Padding[1] * 2;
		}

	};

	this.AlignLabel = function() {

		if (!this.m_bAligned) {
			var rcBox = [
				0, 0, 0, 0
			];
			var pt;
			var corr = this.m_ArrowHeight + this.m_LineWidth;
			if (this.m_rcBox) {
				rcBox = this.m_rcBox;
			}
			for (var nI = 0; nI < this.m_Pos.length; nI++) { // loop over all Positions
				for (var nJ = 0; nJ < this.m_Pos[nI].length; nJ++) {

					pt = (this.m_rcBox ? [
						this.m_rcBox[0] + (this.m_rcBox[2] - this.m_rcBox[0]) / 2, this.m_rcBox[1] + (this.m_rcBox[3] - this.m_rcBox[1]) / 2
					] : this.m_Pos[nI][nJ]);

					switch (this.m_Align) {
						case 0:
							pt[0] -= this.m_Width / 2;
							pt[1] -= this.m_Height / 2;
							break;
						case 1:
							pt[0] -= this.m_Width / 2;
							pt[1] -= (rcBox[3] - rcBox[1]) / 2 + this.m_Height;
							if (this.m_Arrow) {
								pt[1] -= corr;
							}
							break;
						case 2:
							pt[0] += (rcBox[2] - rcBox[0]) / 2;
							pt[1] -= (rcBox[3] - rcBox[1]) / 2 + this.m_Height;
							break;
						case 3:
							pt[0] += (rcBox[2] - rcBox[0]) / 2;
							pt[1] -= this.m_Height / 2;
							if (this.m_Arrow && !this.m_Rounded) {
								pt[0] += corr;
							}
							break;
						case 4:
							pt[0] += (rcBox[2] - rcBox[0]) / 2;
							pt[1] += (rcBox[3] - rcBox[1]) / 2;
							break;
						case 5:
							pt[0] -= (this.m_Width / 2);
							pt[1] += (rcBox[3] - rcBox[1]) / 2;
							if (this.m_Arrow) {
								pt[1] += corr;
							}
							break;
						case 6:
							pt[0] -= (rcBox[2] - rcBox[0]) / 2 + this.m_Width;
							pt[1] += (rcBox[3] - rcBox[1]) / 2;
							break;
						case 7:
							pt[0] -= (rcBox[2] - rcBox[0]) / 2 + this.m_Width;
							pt[1] -= this.m_Height / 2;
							if (this.m_Arrow && !this.m_Rounded) {
								pt[0] -= corr;
							}
							break;
						case 8:
							pt[0] -= (rcBox[2] - rcBox[0]) / 2 + this.m_Width;
							pt[1] -= (rcBox[3] - rcBox[1]) / 2 + this.m_Height;
							break;
						default:
							if (VBI.m_bIsRtl) {
								pt[0] -= this.m_Width;
							}
							pt[1] += (rcBox[3] - rcBox[1]) / 2;
							break;
					}
					if (!this.CalculateLabelPos) {
						pt[0] += this.m_aIO[nI];
					}
					pt[0] += this.m_Offset[0];
					pt[1] += this.m_Offset[1];
					this.m_Pos[nI][nJ] = pt;
				}
			}
		}
		this.m_bAligned = true;
	};

	this.clear = function() {
		this.CalculateLabelPos = null;
		this.m_Pos = null;
		this.m_PosArray = null;
		this.m_rcBox = null;
		this.m_aIO = null;
		this.m_LabelTextColor = null;
		this.m_LabelIconColor = null;
	};

	return this;
};
// ...........................................................................//
// this module does the label handling.......................................//

// Author: Martina Gozlinski, extraction by Jürgen

// ...........................................................................//
/* global VBI */// declare unusual global vars for JSLint/SAPUI5 validation
VBI.addSceneLassoTrackingFunctions = function(scene) {
	"use strict";

	// ........................................................................//
	// Lasso Tracking .........................................................//
	// ........................................................................//

	scene.LassoTracking = function() {
		this.m_PosMoves = [];
		this.m_bTrack = false;
		this.m_keycode = 0;
	};

	scene.LassoTracking.prototype.onsapkeydown = function(e) {
		if (e.keyCode == this.m_keycode) {
			// exit mode selection mode ................//
			this.ExitMode();
			e.preventDefault();
			return true;
		}

	};
	scene.LassoTracking.prototype.onsapdown = function(e) {
		// determine the sap down position.....................................//
		var rect = scene.m_Canvas[scene.m_nOverlayIndex].getBoundingClientRect();
		var zf = scene.GetStretchFactor4Mode();
		this.m_PosMoves.push([
			(e.clientX - rect.left) / zf[0], (e.clientY - rect.top) / zf[1]
		]);
		this.m_bTrack = true;
		if (e.type == "mousedown") {
			document.addEventListener('mouseup', this, true);
		} else if (e.type == "touchstart") {
			document.addEventListener('touchend', this, true);
		} else if (e.type == "pointerdown") {
			document.addEventListener('pointerup', this, true);
		}
		e.preventDefault();
		scene.m_Canvas[scene.m_nLabelIndex].focus();
		return true;
	};

	scene.LassoTracking.prototype.handleEvent = function(e) {
		if (e.type == "mouseup") {
			document.removeEventListener('mouseup', this, true);
		} else if (e.type == "touchend") {
			document.removeEventListener('touchend', this, true);
		} else if (e.type == "pointerup") {
			document.removeEventListener('pointerup', this, true);
			if (scene.m_Gesture) {
				scene.m_Gesture.pointerCount--;
				if (!scene.m_Gesture.pointerCount) {
					scene.m_Gesture.target = null;
					scene.m_Gesture = null;
				}
			}

		}
		this.TrackEnd(e);
	};

	scene.LassoTracking.prototype.TrackEnd = function(e) {
		if (!this.m_bTrack) {
			return false;
		}

		if (this.m_PosMoves.length > 2) {
			this.execute(e);
		}
		this.m_PosMoves = [];
		this.m_bTrack = false;

		// trigger async rendering..........................................//
		scene.RenderAsync(true);
		e.preventDefault();
		e.stopPropagation();
		return true;

	};

	scene.LassoTracking.prototype.onsapmove = function(e) {
		if (this.m_bTrack) {
			var zf = scene.GetStretchFactor4Mode();
			var rect = scene.m_Canvas[scene.m_nOverlayIndex].getBoundingClientRect();
			this.m_PosMoves.push([
				(e.clientX - rect.left) / zf[0], (e.clientY - rect.top) / zf[1]
			]);
		}
		scene.SetCursor('crosshair');
		scene.RenderAsync(true); // trigger async rendering...................//
		e.preventDefault();
		return true;
	};

	scene.LassoTracking.prototype.onsapout = function(e) {

	};
	scene.LassoTracking.prototype.execute = function(e) {
		// The prototype impl is empty
	};

	scene.LassoTracking.prototype.Hook = function() {
		scene.SetInputMode(VBI.InputModeLassoSelect);
		scene.m_Ctx.m_Control.setLassoSelection(true);
		scene.m_DesignVO = this;
		scene.SetCursor('crosshair');
		scene.RenderAsync(true);
	};

	scene.LassoTracking.prototype.UnHook = function() {
		if (scene.m_nInputMode == VBI.InputModeLassoSelect) {
			scene.m_Ctx.onChangeTrackingMode(scene.m_nInputMode, false);
			scene.SetInputMode(VBI.InputModeDefault);
			scene.m_Ctx.m_Control.setLassoSelection(false);
		} else {
			jQuery.sap.log.error("Wrong InputMode in UnHook: " + scene.m_nInputMode);
		}

		this.m_PosMoves = [];
		this.m_bTrack = false;

		scene.m_DesignVO = null;
		scene.RenderAsync(true); // trigger async rendering...................//
	};

	scene.LassoTracking.prototype.ExitMode = function() {
		// exit mode selection mode ................//
		this.UnHook();
		scene.SetCursor('default');
		scene.RenderAsync(true); // trigger async rendering...................//

	};

	// ........................................................................//
	// lasso selection ........................................................//
	// ........................................................................//
	scene.LassoSelection = function() {
		scene.LassoTracking.call(this);
		this.m_keycode = 65;
		this.Hook();
	};

	scene.LassoSelection.prototype = Object.create(scene.LassoTracking.prototype);

	scene.LassoSelection.prototype.constructor = scene.LassoSelection;

	scene.LassoSelection.prototype.execute = function(e) {
		scene.PerFormMultiSelect(e, this);
	};

	scene.LassoSelection.prototype.Render = function(canvas, dc) {
		if (!this.m_bTrack) {
			return false;
		}

		// check positions to prevent from failures.........................//
		if (this.m_PosMoves.length) {
			VBI.Utilities.DrawTrackingLasso(dc, this.m_PosMoves);
		}
	};

};
// ...........................................................................//
// maplayer objects..........................................................//

// Author: Ulrich Roegelein

// mapprovider prototype functions...........................................//
// VBI.prototype = { this.prototype = { Add: function (source) { this.SourceArray.push( source ); }, }, }
// VBI.mapproviders = { this.prototype = { Add: function (mapprovider) { this.MapProviderArray.push( mapprovider ); }, }, }

// ...........................................................................//
// MapLayerStack namespace...................................................//
// enables: new VBI.MapLayerStackManager(...)

VBI.MapLayerStackManager = function() {
	"use strict";
	/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
	var maplayerstackmanager = {};
	maplayerstackmanager.vbiclass = "MapLayerStackManager";
	maplayerstackmanager.m_MapLayerStackArray = [];

	maplayerstackmanager.clear = function() {
		// clear the sources...................................................//
		for (var nJ = 0; nJ < maplayerstackmanager.m_MapLayerStackArray.length; ++nJ) {
			maplayerstackmanager.m_MapLayerStackArray[nJ].clear();
		}

		// clear the array.....................................................//
		maplayerstackmanager.m_MapLayerStackArray = [];
	};

	// load from json
	maplayerstackmanager.load = function(dat, ctx) {
		if (dat.Set) {
			// todo: refine delta handling
			maplayerstackmanager.clear();

			var mls;
			if (jQuery.type(dat.Set.MapLayerStack) == 'object') {
				mls = new VBI.MapLayerStack();
				mls.load(dat.Set.MapLayerStack, ctx);
				maplayerstackmanager.Add(mls);
			} else if (jQuery.type(dat.Set.MapLayerStack) == 'array') {
				for (var nJ = 0; nJ < dat.Set.MapLayerStack.length; ++nJ) {
					mls = new VBI.MapLayerStack();
					mls.load(dat.Set.MapLayerStack[nJ], ctx);
					maplayerstackmanager.Add(mls);
				}
			}
		}
	};

	// functions..............................................................//
	maplayerstackmanager.Add = function(maplayerstack) {
		this.m_MapLayerStackArray.push(maplayerstack);
	};

	maplayerstackmanager.GetMapLayerStack = function(name) {
		for (var i = 0; i < this.m_MapLayerStackArray.length; ++i) {
			if (this.m_MapLayerStackArray[i].m_Name == name) {
				return this.m_MapLayerStackArray[i];
			}
		}
		return null;
	};

	return maplayerstackmanager;
};

// ...........................................................................//
// MapLayerStack namespace...................................................//
// Description: map layer stacks will keep the switchable stack entities.....//

VBI.MapLayerStacks = VBI.MapLayerStackManager();

// ...........................................................................//
// MapLayerStack namespace...................................................//
// enables: new VBI.MapLayerStack(...)

VBI.MapLayerStack = function(name, description) {
	"use strict";
	var maplayerstack = {}; // create the object
	maplayerstack.vbiclass = "MapLayerStack";
	maplayerstack.m_MapLayerArray = [];

	// assign members.........................................................//
	maplayerstack.m_Name = name;
	maplayerstack.m_Description = description;
	maplayerstack.m_nMaxSquare = 0;
	maplayerstack.m_colBkgnd = null;

	maplayerstack.clear = function() {
		// clear the sources...................................................//
		for (var nJ = 0; nJ < maplayerstack.m_MapLayerArray.length; ++nJ) {
			maplayerstack.m_MapLayerArray[nJ].clear();
		}

		// clear the array.....................................................//
		maplayerstack.m_MapLayerArray = [];
	};

	// load from json parsed object
	maplayerstack.load = function(dat, ctx) {
		// todo: check for additional attributes and add them here
		if (dat.name) {
			maplayerstack.m_Name = dat.name;
		}
		if (dat.description) {
			maplayerstack.m_Description = dat.description;
		}
		if (dat.copyright) {
			maplayerstack.m_Copyright = dat.copyright;
		}
		if (dat.copyrightLink) {
			maplayerstack.m_CopyrightLink = dat.copyrightLink;
		}
		if (dat.copyrightImage) {
			maplayerstack.m_CopyrightImage = dat.copyrightImage;
		}
		if (dat.maxSquare) {
			maplayerstack.m_nMaxSquare = dat.maxSquare;
		}
		if (dat.previewPosition) {
			maplayerstack.m_PreviewPosition = dat.previewPosition;
		}
		if (dat.colBkgnd) {
			maplayerstack.m_colBkgnd = dat.colBkgnd;
		}
		maplayerstack.m_bSingleBMP = (dat.singleBMP && dat.singleBMP == "true");

		var ml;
		if (dat.MapLayer) {
			if (jQuery.type(dat.MapLayer) == 'object') {
				ml = new VBI.MapLayer();
				ml.load(dat.MapLayer, ctx);
				maplayerstack.Add(ml);
			} else if (jQuery.type(dat.MapLayer) == 'array') {
				for (var nJ = 0; nJ < dat.MapLayer.length; ++nJ) {
					ml = new VBI.MapLayer();
					ml.load(dat.MapLayer[nJ], ctx);
					maplayerstack.Add(ml);
				}
			}
		}
	};

	// functions..............................................................//
	maplayerstack.Add = function(maplayer) {
		this.m_MapLayerArray.push(maplayer);
	};

	// determine maximum LOD of layer.........................................//
	maplayerstack.GetMaxLOD = function() {
		var nLOD, maxLOD = 0;
		var mla = this.m_MapLayerArray;
		for (var i = 0; i < mla.length; ++i) {
			nLOD = parseInt(mla[i].GetMaxLOD(),10);
			if (nLOD > maxLOD) {
				maxLOD = nLOD;
			}
		}
		return maxLOD;
	};

	// determine minimum LOD of layer.........................................//
	maplayerstack.GetMinLOD = function() {
		var nLOD, minLOD = Number.MAX_VALUE;
		var mla = this.m_MapLayerArray;
		for (var i = 0; i < mla.length; ++i) {
			nLOD = mla[i].GetMinLOD();
			if (nLOD < minLOD) {
				minLOD = nLOD;
			}
		}
		return minLOD;
	};

	maplayerstack.GetCopyright = function() {
		if (this.m_Copyright) {
			return VBI.Utilities.AssembleCopyrightString(this.m_Copyright, this.m_CopyrightLink, this.m_CopyrightImage);
		}
		var sCopyright = null;

		for (var nJ = 0; nJ < this.m_MapLayerArray.length; nJ++) {
			var mapProvider = this.m_MapLayerArray[nJ].GetMapProvider();
			if (!sCopyright) {
				sCopyright = mapProvider.GetCopyright();
			} else {
				sCopyright = sCopyright + ", " + mapProvider.GetCopyright();
			}
		}
		return sCopyright;
	};

	return maplayerstack;
};

VBI.MapLayer = function() {
	"use strict";
	var maplayer = {}; // create the object
	maplayer.vbiclass = "MapLayer";
	maplayer.m_Name = null;
	maplayer.m_refMapProvider = null;
	maplayer.m_fOpacity = 1.0;

	maplayer.clear = function() {
		// clear the references................................................//
		maplayer.m_refMapProvider = null;
	};

	// load from json parsed object...........................................//
	maplayer.load = function(dat, ctx) {
		// todo: check for additional attributes and add them here
		if (dat.name) {
			maplayer.m_Name = dat.name;
		}
		if (dat.opacity) {
			maplayer.m_fOpacity = dat.opacity;
		}

		// determine the map provider..........................................//
		if (dat.refMapProvider) {
			if (ctx.m_MapProviders) {
				maplayer.m_refMapProvider = ctx.m_MapProviders.GetMapProviderByName(dat.refMapProvider);
			}
		}

		if (!maplayer.m_refMapProvider) {
			jQuery.sap.log.error("MapLayer: no valid mapprovider specified");
		}
	};

	maplayer.GetMinLOD = function() {
		// get the min lod of the referenced map provider
		if (maplayer.m_refMapProvider) {
			return maplayer.m_refMapProvider.GetMinLOD();
		}
	};

	maplayer.GetMaxLOD = function() {
		// get the min lod of the referenced map provider
		if (maplayer.m_refMapProvider) {
			return maplayer.m_refMapProvider.GetMaxLOD();
		}
	};

	maplayer.GetMapProvider = function() {
		// get the referenced to the map provider
		if (maplayer.m_refMapProvider) {
			return maplayer.m_refMapProvider;
		}

		return null;
	};

	return maplayer;
};
// ...........................................................................//
// mapmanager object.........................................................//
// ...........................................................................//

// Author: Ulrich Roegelein

VBI.MapManager = (function() {
	"use strict";
	/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
	var mapmanager = {};
	mapmanager.vbiclass = "MapManager";

	mapmanager.m_nRequest = 0;
	mapmanager.m_tileWidth = 256;
	mapmanager.m_tileHeight = 256;
	mapmanager.m_runningRequests = 0;
	mapmanager.m_limitRequests = 12;
	mapmanager.m_requestQueue = [];
	mapmanager.m_renderQueue = [];
	mapmanager.m_renderRequestID = 0;
	mapmanager.m_failedSendTimer = 0;
	mapmanager.m_renderJunksize = 100;

	// ........................................................................//
	// image is loaded........................................................//

	mapmanager.onAbort = function(event) {
		mapmanager.CheckReqQueue();

		var image = event.srcElement;

		if (VBI.m_bTrace) {
			VBI.Trace("onAbort " + image.src);
		}

		// unlink the image from within the image chain
		mapmanager.UnlinkImage(image);
		mapmanager.CheckTmpCanvas(image.m_Target, image.m_nRequest, image.m_nLayersAbove);
	};

	mapmanager.onFailedSend = function(object) {
		if (VBI.m_bTrace) {
			VBI.Trace("onFailedSend " + object.src);
		}
		mapmanager.m_runningRequests--;
		mapmanager.m_bRequestError = true;
		if (!mapmanager.m_failedSendTimer) {
			mapmanager.m_failedSendTimer = setInterval(function() {
				mapmanager.RetrySending();
			}, 750);
		}

	};

	mapmanager.onError = function(event) {
		mapmanager.CheckReqQueue();

		var image = event.srcElement;
		var imageRender = null;

		if (VBI.m_bTrace) {
			VBI.Trace("onError " + image.src);
		}

		// inherit the fillstyle
		if (image.m_Next != null) {
			image.m_Next.m_FillStyle = image.m_FillStyle;
		}

		if (image.m_Prev == null && image.m_Next != null && image.m_Next.complete == true) {
			imageRender = image.m_Next;
		}

		// unlink the image from within the image chain
		mapmanager.UnlinkImage(image);

		// when the image is the first in current and would be rendered........//
		if (imageRender != null) {
			mapmanager.m_renderQueue.push(imageRender);
			if (!mapmanager.m_renderRequestID) {
				mapmanager.m_renderRequestID = window.requestAnimationFrame(mapmanager.RenderTiles);
			}
		} else {
			mapmanager.CheckTmpCanvas(image.m_Target, image.m_nRequest, image.m_nLayersAbove);
		}

	};

	mapmanager.onLoad = function(event) {
		mapmanager.CheckReqQueue();

		var image = event.target;

		if (VBI.m_bTrace) {
			VBI.Trace("VBI.MapManager: onLoad  " + image.src);
		}

		var bChainComplete = true; // i for myself am complete as I am in onLoad.
		var item;
		for (item = image.m_Prev; item != null; item = item.m_Prev) {
			bChainComplete &= item.complete;
		}
		for (item = image.m_Next; item != null; item = item.m_Next) {
			bChainComplete &= item.complete;
		}
		if (!bChainComplete) {
			if (VBI.m_bTrace) {
				VBI.Trace("VBI.MapManager: onLoad skip as there is a a not yet loaded tile ");
			}
			return;
		}
		// mapmanager.RenderTile( image );
		mapmanager.m_renderQueue.push(image);
		if (!mapmanager.m_renderRequestID) {
			mapmanager.m_renderRequestID = window.requestAnimationFrame(mapmanager.RenderTiles);
		}
	};

	mapmanager.RetrySending = function() {
		clearInterval(mapmanager.m_failedSendTimer);
		mapmanager.m_failedSendTimer = 0;
		mapmanager.m_bRequestError = false;
		mapmanager.m_runningRequests++;
		mapmanager.CheckReqQueue();
	};

	mapmanager.CheckReqQueue = function() {
		while ((mapmanager.m_requestQueue.length) && (!mapmanager.m_bRequestError)) {
			var image = mapmanager.m_requestQueue.shift();
			var targetCanvas = image.m_Target;
			if (image.m_nLOD != targetCanvas.m_nCurrentLOD || targetCanvas.m_bInvalid) {
				mapmanager.UnlinkImage(image);
				mapmanager.CheckTmpCanvas(targetCanvas, image.m_nRequest, image.m_nLayersAbove);
			} else {
				try {
					image.src = image.src2execute;
				} catch (e) {
					mapmanager.m_requestQueue.unshift(image);
					mapmanager.onFailedSend(image);
				}
				return;
			}
		}
		// no further request to be executed
		mapmanager.m_runningRequests--;
	};

	mapmanager.RenderTiles = function() {
		var nCount = Math.min(mapmanager.m_renderQueue.length, mapmanager.m_renderJunksize);
		for (var i = 0; i < nCount; ++i) {
			mapmanager.RenderTile(mapmanager.m_renderQueue.shift());
		}

		mapmanager.m_renderRequestID = mapmanager.m_renderQueue.length > 0 ? window.requestAnimationFrame(mapmanager.RenderTiles) : 0;
	};

	mapmanager.RenderTile = function(image) {
		if (!image.bRendered) {
			var targetCanvas = image.m_Target;
			if ((targetCanvas.m_CanvasRedirect != undefined) && (targetCanvas.m_CanvasRedirRequest == image.m_nRequest)) {
				targetCanvas = targetCanvas.m_CanvasRedirect;
			}

			var currentScene = targetCanvas.m_Scene;
			if (!currentScene) {
				return;
			}

			var canvasWidth = targetCanvas.getPixelWidth();
			var canvasHeight = targetCanvas.getPixelHeight();

			targetCanvas.m_nAppliedRequest = Math.max(targetCanvas.m_nAppliedRequest, image.m_nRequest);
			var context = targetCanvas.getContext('2d');

			var nMaxX = (1 << context.canvas.m_nCurrentLOD);

			var nCol = ((image.m_nReqX - context.canvas.m_nCurrentX) % nMaxX + nMaxX) % nMaxX; // double mod for neg.numbers
			if (nMaxX < currentScene.m_nTilesX) {
				nCol = image.m_nCol + image.m_nXOrigin - context.canvas.m_nCurrentX;
			}

			var nRow = image.m_nReqY - context.canvas.m_nCurrentY;

			// unlink and return when image request is outdated....................//
			if (image.m_bOutdated || (nCol < 0) || (nRow < 0) || (nCol >= image.m_numCol) || (nRow >= image.m_numRow) || (image.m_nLOD != targetCanvas.m_nCurrentLOD || targetCanvas.m_bInvalid)) {
				mapmanager.UnlinkImage(image);

				if (VBI.m_bTrace) {
					VBI.Trace("VBI.MapManager: RenderTile  " + image.src + " is outdated");
				}
				mapmanager.CheckTmpCanvas(targetCanvas, image.m_nRequest, image.m_nLayersAbove);
				return;
			}

			if (VBI.m_bTrace) {
				VBI.Trace("VBI.MapManager: RenderTile  " + image.src);
			}

			// do regular work.....................................................//

			var nWidth = currentScene.m_nWidthCanvas;
			var nHeight = currentScene.m_nHeightCanvas;

			// size it down to prevent from fragments..............................//
			targetCanvas.setPixelWidth(nWidth);
			targetCanvas.setPixelHeight(nHeight);

			var tilewidth = nWidth / currentScene.m_nTilesX;
			var tileheight = nHeight / currentScene.m_nTilesY;
			var left = nCol * tilewidth;
			var top = nRow * tileheight;
			var picWidth = image.m_nXExpansion * tilewidth;
			var picHeight = image.m_nYExpansion * tileheight;

			// draw chained images in sequence.....................................//
			var imageTemp = image;
			var tmpFillStyle;
			while (imageTemp.m_Prev != null) {
				imageTemp = imageTemp.m_Prev;
			}
			while (imageTemp != null && imageTemp.complete == true) {
				// optional draw the image background into the canvas...............//
				if (imageTemp.m_FillStyle != null) {
					if (VBI.m_bTrace) {
						VBI.Trace("RenderTile fillRect " + imageTemp.src);
					}

					tmpFillStyle = context.fillStyle;
					context.fillStyle = imageTemp.m_FillStyle;
					context.fillRect(left, top, picWidth, picHeight);
					context.fillStyle = tmpFillStyle;
				}

				// as soon as an image is rendererd set the parent of the next......//
				// to null..........................................................//
				if (VBI.m_bTrace) {
					VBI.Trace("RenderTile drawImage " + imageTemp.src);
				}
				context.globalAlpha = imageTemp.m_Opacity;

				context.drawImage(imageTemp, left, top, picWidth, picHeight);
				imageTemp.bRendered = true;

				if (imageTemp.m_Next != null) {
					imageTemp.m_Next.m_Prev = null;
				}

				imageTemp = imageTemp.m_Next;
			}

			// draw debug information on tile......................................//
			if (VBI.m_bTrace) {
				tmpFillStyle = context.fillStyle;
				context.fillStyle = "#FF0000";
				context.font = "18px Arial";
				context.fillText(image.m_nRequest + "." + image.m_nCount + ":" + image.m_nLOD + "/" + image.m_nReqX + "/" + image.m_nReqY + "@(" + (left / 256) + "," + (top / 256) + ")", left + 10, top + 30);
				context.fillStyle = tmpFillStyle;
			}

			// size it up again....................................................//
			targetCanvas.setPixelWidth(canvasWidth);
			targetCanvas.setPixelHeight(canvasHeight);

			// raise the changed event.............................................//
			if (targetCanvas.onTileLoaded) {
				targetCanvas.onTileLoaded(image);
			}
			context.globalAlpha = 1.0;

			mapmanager.CheckTmpCanvas(targetCanvas, image.m_nRequest, 0);
			if (currentScene.m_Ctx.moThumbnail) {
				currentScene.Copy2Thumbnail();
			}
		}
	};

	mapmanager.CheckTmpCanvas = function(targetCanvas, imgRequest, nTilesAbove) {

		if ((targetCanvas.m_nTilesBefSwitch != undefined) && (targetCanvas.m_nRequest == imgRequest) && !nTilesAbove) {
			targetCanvas.m_nTilesBefSwitch--;
			if (!targetCanvas.m_nTilesBefSwitch) {
				targetCanvas.m_Scene.SwitchTmpCanvasToActive();
			}
		}

	};

	// ........................................................................//
	// request the tiles......................................................//

	mapmanager.RequestTiles = function(targetCanvas, maplayerstack, x, y, nx, ny, leftOffset, topOffset, rightOffset, bottomOffset, lod, bclear) {
		mapmanager.m_bRequestError = false;
		if (lod < 0) {
			return false;
		}
		var sc = targetCanvas.m_Scene;

		if (!maplayerstack || ((sc.AnimZoomTarget) && (Math.abs(sc.AnimZoomTarget - lod) > sc.m_nMaxAnimLodDiff))) { // - With an existing
			// animation target which is
			// too far away we skip
			// loading as otherwise
			// we would have to wait for all intermediate tiles after reaching target
			// - Without maplayerstack requesting is also not done
			targetCanvas.m_nCurrentX = x;
			targetCanvas.m_nCurrentY = y;
			targetCanvas.m_nCurrentLOD = lod;
			return false;
		}

		var nCount = 0;
		var nYMax = (1 << lod);
		var xyRatio = sc.m_Proj.m_nXYRatio;
		var nXMax = nYMax * xyRatio;

		var fTileSize = 2.0 / nYMax;

		if (bclear) {
			var context = targetCanvas.getContext("2d");
			context.fillStyle = 'white';
			context.clearRect(0, 0, context.canvas.width, context.canvas.height);
		}

		var maplayerarray = maplayerstack.m_MapLayerArray;

		targetCanvas.m_nRequest = mapmanager.m_nRequest++;
		targetCanvas.m_bInvalid = false; // the request makes it valid

		// store current requested tile information in the canvas..............//
		targetCanvas.m_nCurrentX = x;
		targetCanvas.m_nCurrentY = y;
		targetCanvas.m_nCurrentLOD = lod;

		var ni, nk, nYExpansion, nCurrentXExpansion = 1;
		var yCorr = y;

		if (maplayerstack.m_bSingleBMP) {
			nk = 1;
			yCorr = Math.max(0, y);
			nYExpansion = Math.min(ny - topOffset - bottomOffset, nYMax - yCorr);
		} else {
			nk = ny - topOffset - bottomOffset;
			nYExpansion = 1;
		}

		var nLayerArrayLen = maplayerarray.length;
		ni = nx - leftOffset - rightOffset; // on LOD 0 and 1 there are less tiles
		for (var i = 0; i < ni; ++i) {
			nCurrentXExpansion--;
			if (!nCurrentXExpansion) { // we are no more part of an expanded tile
				for (var k = 0; k < nk; ++k) {
					nCount++;
					var imagePrev = null;
					var fillStyle = null;
					var nReqX = (x + leftOffset + i) % nXMax;
					if (nReqX < 0) {
						nReqX = nXMax + nReqX;
					}
					var nReqY = yCorr + topOffset + k;
					if ((nReqY + nYExpansion) <= 0 || nReqY >= nYMax) {
						if ((targetCanvas.m_nTilesBefSwitch != undefined) && (targetCanvas.m_nTilesBefSwitch > 0)) {
							targetCanvas.m_nTilesBefSwitch--;
						}
						continue;
					}
					nCurrentXExpansion = maplayerstack.m_bSingleBMP ? Math.min(nXMax - nReqX, ni - i) : 1;

					// iterate over all map providers................................//
					for (var s = 0; s < nLayerArrayLen; ++s) {
						var maplayer = maplayerarray[s];

						// remember the maplayer fill style...........................//
						// to inherit the style when image chain gets shortened due...//
						// to LOD limits..............................................//

						if (maplayerstack.fillStyle) {
							fillStyle = maplayerstack.fillStyle;
						} else if (maplayerstack.m_colBkgnd) {
							fillStyle = maplayerstack.m_colBkgnd;
						}

						// create the chained list only in the vaild LOD range........//
						if ((maplayer.GetMinLOD() > lod) || (maplayer.GetMaxLOD() < lod)) {
							continue;
						}

						var imageObj = new Image();

						// enhance image object.......................................//
						imageObj.m_nLayersAbove = nLayerArrayLen - s - 1;
						imageObj.m_nXOrigin = x;
						imageObj.m_nYOrigin = y;
						imageObj.m_nCol = i + leftOffset; // remember column
						imageObj.m_nRow = k + topOffset; // remember row
						imageObj.m_numCol = nx; // remember column count
						imageObj.m_numRow = ny; // remember row count
						imageObj.m_Target = targetCanvas; // canvas to render into
						imageObj.m_nRequest = targetCanvas.m_nRequest;
						// imageObj.m_MapProvider = maplayer.GetMapProvider();
						imageObj.m_Opacity = maplayer.m_fOpacity;
						imageObj.m_bOutdated = false;

						// do image linkage...........................................//
						// this leads to a uplink and downlink chain..................//
						imageObj.m_Prev = imagePrev;
						if (imagePrev != null) {
							imagePrev.m_Next = imageObj;
						}

						// set the inherited fill style only when image is the chain..//
						// root.......................................................//
						if (imageObj.m_Prev == null) {
							imageObj.m_FillStyle = fillStyle;
						}

						imageObj.m_nReqX = nReqX;
						imageObj.m_nReqY = nReqY;
						imageObj.m_nXExpansion = nCurrentXExpansion;
						imageObj.m_nYExpansion = nYExpansion;
						imageObj.m_nLOD = lod;

						var mapProv = maplayer.GetMapProvider();
						var url;

						if (mapProv.m_bPosRequired) {
							var leftupper = [
								nReqX * fTileSize / xyRatio - 1, nReqY * fTileSize - 1
							];
							var rightlower = [
								(nReqX + nCurrentXExpansion) * fTileSize / xyRatio - 1, (nReqY + nYExpansion) * fTileSize - 1
							];
							// VBI.Trace("Requesting "+nReqX+","+nReqY+" with Extension "+nCurrentXExpansion+". Coordinates :
							// "+leftupper[0]+"-->"+rightlower[0]+","+rightlower[1]);

							url = mapProv.CombineUrlWPos(nReqX, nReqY, lod, fTileSize, leftupper, rightlower, nCurrentXExpansion, nYExpansion, mapmanager.m_requestTileWidth, mapmanager.m_requestTileHeight);
						} else {
							url = mapProv.CombineUrl(nReqX, nReqY, lod);
						}

						// subscribe to events........................................//
						imageObj.onload = mapmanager.onLoad;
						imageObj.onabort = mapmanager.onAbort;
						imageObj.onerror = mapmanager.onError;
						if ((mapmanager.m_runningRequests < mapmanager.m_limitRequests) && (!mapmanager.m_bRequestError)) {
							mapmanager.m_runningRequests++;
							try {
								imageObj.src = url;
							} catch (e) {
								imageObj.src2execute = url;
								mapmanager.m_requestQueue.push(imageObj);
								mapmanager.onFailedSend(imageObj);
							}
						} else {
							imageObj.src2execute = url;
							mapmanager.m_requestQueue.push(imageObj);
						}

						imageObj.m_nCount = nCount;

						if (VBI.m_bTrace) {
							VBI.Trace("RequestTiles " + url);
						}

						// remember previous image....................................//
						imagePrev = imageObj;
						// VBI.Trace("Requesting from origin ("+x+","+y+") m_col/row:("+lod+"/"+imageObj.m_nCol+","+imageObj.m_nRow+")
						// m_NumCol/Row:"+imageObj.m_numCol+","+imageObj.m_numRow+")\n");
					}
				}
			}
		}
		return true;
	};

	mapmanager.UnlinkImage = function(img) {
		var item;
		for (item = img.m_Prev; item; item = item.m_Prev) {
			item.m_bOutdated = true;
		}

		for (item = img.m_Next; item; item = item.m_Next) {
			item.m_bOutdated = true;
		}

		var curPrev = img.m_Prev;
		var curNext = img.m_Next;

		if (curPrev != null) {
			img.m_Prev.m_Next = curNext;
			img.m_Prev = null;
		}
		if (curNext != null) {
			img.m_Next.m_Prev = curPrev;
			img.m_Next = null;
		}
	};

	mapmanager.GetPreviewImage = function(lon, lat, lod, maplayerstack, scene, callback) {
		//extend layer configuration object with preview location object which is {lat, lon, lod}
		if (!callback || !maplayerstack  || !lon || !lod || !lat || !scene ) { //check that parameters are valid
			return;
		}

		var exactLod = Math.min(Math.max(lod, scene.GetMinLOD()), scene.GetMaxLOD()); // clamp [min lod...max lod]
		lod = Math.floor(exactLod); //avoid fractional lod

		var tileWidth = scene.m_MapManager.m_tileWidth; //get proper tile width
		var tileHeight = scene.m_MapManager.m_tileHeight; //get proper tile height
		var xyRatio = scene.m_Proj.m_nXYRatio; //ratio from  current projection
		var lodDistance = (1 << lod); //how many tiles on a particular lod?
		var tileSize = 2.0 / lodDistance; //???
		var lonlat = VBI.MathLib.DegToRad([parseFloat(lon),parseFloat(lat)]); //from degrees to radians
		var uxy = [lodDistance * tileWidth, lodDistance * tileHeight]; //prepare conversion from lat,lon
		scene.m_Proj.LonLatToUCS(lonlat, uxy); // to User Coordinate System (pixel space of a target lod)
		var x = Math.floor(uxy[0] / tileWidth); // calculate X tile coordinate
		var y = Math.floor(uxy[1] / tileHeight); //calculate Y tile coordinate

		var mapLayerArray = maplayerstack.m_MapLayerArray;

		var context = {
			m_Callback: callback,
			m_Images: [],
			m_ImagesRemain: mapLayerArray.length,
			m_MapLayerStack: maplayerstack,

			compose: function() {
				this.m_ImagesRemain -= 1;

				if (this.m_ImagesRemain <= 0) { //all images processes (succeeded, failed or aborted)
					//create canvas to store image
					var canvas = document.createElement('canvas');
					context = canvas.getContext('2d');

					var background = this.m_MapLayerStack.m_colBkgnd;
					context.fillStyle = background; //respect background colour
					context.fillRect(0, 0, canvas.width, canvas.height);

					for (var i = 0; i < this.m_Images.length; ++i) {
						if (this.m_Images[i]) { //skip failed images

							// respect transparency
							context.globalAlpha = this.m_Images[i].m_Opacity;

							// X and Y Starting positions of the clipping
							var clipPosX = 0;
							var clipPosY = 0;

							// Portion of image you want to clip.
							var clipWidth = this.m_Images[i].width;
							var clipHeight = this.m_Images[i].height;

							//	Draw image onto canvas
							var offsetX = 0;
							var offsetY = 0;

							// Scale to stretch
							var stretchX = canvas.width;
							var stretchY = canvas.height;

							// Draw image based on measurments
							context.drawImage(this.m_Images[i],clipPosX,clipPosY,clipWidth,clipHeight, offsetX,offsetY, stretchX, stretchY); //draw image to canvas
						}
					}
					var tileImages = new Image();
					// convert into image
					tileImages.src = canvas.toDataURL();
					callback(tileImages);
				}
			}
		};

		var onImageLoad = function(event) {
			if (VBI.m_bTrace) {
				VBI.Trace("onLoad " + event.target.src);
			}
			var image = event.target;
			image.m_Context.compose();
		};

		var onImageAbort = function(event) {
			if (VBI.m_bTrace) {
				VBI.Trace("onAbort " + event.target.src);
			}
			var image = event.target;
			image.m_Context.m_Images[image.m_Index] = null;
			image.m_Context.compose();
		};

		var onImageError = function(event) {
			if (VBI.m_bTrace) {
				VBI.Trace("onError " + event.target.src);
			}
			var image = event.target;
			image.m_Context.m_Images[image.m_Index] = null;
			image.m_Context.compose();
		};

		for (var i = 0; i < mapLayerArray.length; ++i) {
			var layer = mapLayerArray[i];
			var provider = layer.GetMapProvider();

			if (layer.GetMinLOD() > lod || layer.GetMaxLOD() < lod) { //skip if provider doesn't support required lod
				continue;
			}
			var url;

			if (provider.m_bPosRequired) {
				var leftUpper = [x * tileSize / xyRatio - 1, y * tileSize - 1];
				var rightLower = [(x + 1) * tileSize / xyRatio - 1, (y + 1) * tileSize - 1];
				url = provider.CombineUrlWPos(x, y, lod, tileSize, leftUpper, rightLower, 1, 1, tileWidth, tileHeight);
			} else {
				url = provider.CombineUrl(x, y, lod);
			}
			var image = new Image();
			image.setAttribute('crossOrigin', 'anonymous');
			context.m_Images[i] = image;
			image.m_Index = i;
			image.m_Context = context;

			if (layer.m_fOpacity) {
				image.m_Opacity = layer.m_fOpacity;
			}

			image.onload = onImageLoad;

			image.onabort = onImageAbort;

			image.onerror = onImageError;

			try {
				image.src = url;
			} catch (ex) {
				if (VBI.m_bTrace) {
					VBI.Trace("GetPreviewImage " + ex);
				}
				image.m_Context.m_Images[image.m_Index] = null;
				image.m_Context.compose();
			}
		}
	};
	return mapmanager;
})();
﻿// ...........................................................................//
// mapprovider object........................................................//

// Author: Ulrich Roegelein

VBI.MapProviders = function() {
	"use strict";
	/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
	var mapproviders = {};
	mapproviders.vbiclass = "MapProviders";
	mapproviders.m_MapProviderArray = [];

	mapproviders.clear = function() {
		// clear the sources...................................................//
		for (var nJ = 0; nJ < mapproviders.m_MapProviderArray.length; ++nJ) {
			mapproviders.m_MapProviderArray[nJ].clear();
		}

		// clear the array.....................................................//
		mapproviders.m_MapProviderArray = [];
	};

	mapproviders.load = function(dat, ctx) {
		// load the json delta data............................................//
		// todo: do more than only set
		if (dat.Set) {
			var mp;

			// todo: refine delta loading
			mapproviders.clear();
			// load the mapproviders............................................//
			// todo: support specialized sets and removes.......................//
			if (dat.Set.MapProvider) {
				if (jQuery.type(dat.Set.MapProvider) == 'object') {
					mp = new VBI.MapProvider();
					mp.load(dat.Set.MapProvider);
					mapproviders.Add(mp);
				} else if (jQuery.type(dat.Set.MapProvider) == 'array') {
					for (var nJ = 0; nJ < dat.Set.MapProvider.length; ++nJ) {
						mp = new VBI.MapProvider();
						mp.load(dat.Set.MapProvider[nJ]);
						mapproviders.Add(mp);
					}
				}
			}
		}
	};

	// add to map provider to array
	mapproviders.Add = function(mapprovider) {
		this.m_MapProviderArray.push(mapprovider);
	};

	// determine the map provider by name.....................................//
	mapproviders.GetMapProviderByName = function(name) {
		for (var nJ = 0; nJ < mapproviders.m_MapProviderArray.length; ++nJ) {
			if (mapproviders.m_MapProviderArray[nJ].m_Name == name) {
				return mapproviders.m_MapProviderArray[nJ];
			}
		}
		return null;
	};

	return mapproviders;
};

// ...........................................................................//
// MapProvider namespace.....................................................//

VBI.MapProvider = function(name, description, copyright, tileX, tileY, minLOD, maxLOD, fillStyle, resolution, projection) {
	"use strict";
	var mapprovider = {};
	mapprovider.vbiclass = "MapProvider";
	mapprovider.m_SourceArray = [];

	// assign members.........................................................//
	mapprovider.m_Name = name;
	mapprovider.m_Description = description;
	mapprovider.m_Copyright = copyright;
	mapprovider.m_tileX = typeof tileX !== 'undefined' ? tileX : 256;
	mapprovider.m_tileY = typeof tileY !== 'undefined' ? tileY : 256;
	mapprovider.m_maxLOD = typeof maxLOD !== 'undefined' ? maxLOD : 19;
	mapprovider.m_minLOD = typeof minLOD !== 'undefined' ? minLOD : 0;
	mapprovider.m_nResolution = typeof resolution != 'undefined' ? resolution : 256;
	mapprovider.m_nProjection = typeof projection != 'undefined' ? projection : 1;

	// set optional background style of map provider..........................//
	if (fillStyle != null) {
		mapprovider.fillStyle = fillStyle;
	}

	mapprovider.clear = function() {
		// clear the sources...................................................//
		for (var nJ = 0; nJ < mapprovider.m_SourceArray.length; ++nJ) {
			mapprovider.m_SourceArray[nJ].clear();
		}

		// clear the array..................................................//
		mapprovider.m_SourceArray = [];
	};

	mapprovider.GetCopyright = function() {
		return VBI.Utilities.AssembleCopyrightString(this.m_Copyright, this.m_CopyrightLink, this.m_CopyrightImage);
	};

	mapprovider.addMapBase = function(left, right, top, bottom, round, stdMapBase) {
		var mapBase = {};

		if (left) {
			mapBase.left = parseFloat(left);
		}
		if (right) {
			mapBase.right = parseFloat(right);
		}
		if (top) {
			mapBase.top = parseFloat(top);
		}
		if (bottom) {
			mapBase.bottom = parseFloat(bottom);
		}
		mapBase.round = (round != undefined ? parseFloat(round) : 0);

		mapBase.xSize = right - left;
		mapBase.ySize = top - bottom;

		if (stdMapBase != undefined) {
			mapBase.relXSize = mapBase.xSize / stdMapBase.xSize;
			mapBase.relYSize = mapBase.ySize / stdMapBase.ySize;
		}

		return mapBase;
	};

	mapprovider.addMapBaseBorder = function(mapBase, minX, maxX, minY, maxY) {
		mapBase.leftBorder = minX;
		mapBase.rightBorder = maxX;
		mapBase.bottomBorder = minY;
		mapBase.topBorder = maxY;
	};

	mapprovider.load = function(dat) {
		// load dataprovider attributes........................................//
		// todo: add additional attributes
		if (dat.name) {
			mapprovider.m_Name = dat.name;
		}
		if (dat.description) {
			mapprovider.m_Description = dat.description;
		}
		if (dat.copyright) {
			mapprovider.m_Copyright = dat.copyright;
		}
		if (dat.copyrightLink) {
			mapprovider.m_CopyrightLink = dat.copyrightLink;
		}
		if (dat.copyrightImage) {
			mapprovider.m_CopyrightImage = dat.copyrightImage;
		}
		if (dat.tileX) {
			mapprovider.m_tileX = dat.tileX;
		}
		if (dat.tileY) {
			mapprovider.m_tileY = dat.tileY;
		}
		if (dat.maxLOD) {
			mapprovider.m_maxLOD = dat.maxLOD;
		}
		if (dat.minLOD) {
			mapprovider.m_minLOD = dat.minLOD;
		}
		if (dat.resolution) {
			mapprovider.m_nResolution = dat.resolution;
		}
		if (dat.projection) {
			if (dat.projection === "Linear") {
				mapprovider.m_nProjection = 2;
			} else if (dat.projection === "Elliptical") {
				mapprovider.m_nProjection = 3;
			}
		}
		var mapBase = dat.MapBase;
		mapprovider.m_StdMapBase = mapprovider.addMapBase(-1, 1, 1, -1, 10);
		if (dat.MapBase) {
			mapprovider.m_MapBase = mapprovider.addMapBase(mapBase.left, mapBase.right, mapBase.top, mapBase.bottom, mapBase.round, mapprovider.m_StdMapBase);
			mapprovider.addMapBaseBorder(mapprovider.m_MapBase, mapBase.minX, mapBase.maxX, mapBase.minY, mapBase.maxY);
		} else {
			mapprovider.m_MapBase = mapprovider.addMapBase(-180, 180, 90, -90, 10, mapprovider.m_StdMapBase);
		}

		// the map provider has source urls, get them..........................//
		if (dat.Source) {
			var source;
			if (jQuery.type(dat.Source) == 'object') {
				// load the source when it is an object type
				source = new VBI.Source(null);
				mapprovider.m_bPosRequired = source.load(dat.Source);
				mapprovider.Add(source);
			} else if (jQuery.type(dat.Source) == 'array') {
				// load multiple sources
				mapprovider.m_bPosRequired = false;
				for (var nJ = 0; nJ < dat.Source.length; ++nJ) {
					// load the source when it is an object type
					source = new VBI.Source(null);
					mapprovider.m_bPosRequired = (source.load(dat.Source[nJ]) || mapprovider.m_bPosRequired);
					mapprovider.Add(source);
				}
			}
		}
	};

	// assign functions......................................................//
	mapprovider.Add = function(source) {
		this.m_SourceArray.push(source);
	};
	mapprovider.CombineUrlWPos = function(x, y, lod, fTileSize, lu, rl, xExpansion, yExpansion, xTileSize, yTileSize) {
		// do load balancing for different sources...........................//

		var nMax = 1 << lod;
		// check levels......................................................//
// if( x < 0 || ( y + yExpansion ) <= 0 || ( x >= nMax ) || ( y >= nYMax ) )
// return null;
		// VBI.Trace("Org on lod "+lod+" : ["+(lu[0]).toFixed(7)+","+(lu[1]).toFixed(7)+"] - ["+(rl[0]).toFixed(7)+","+(rl[1]).toFixed(7)+"]");
		var nRound = 10;
		if (mapprovider.m_MapBase) {
			var stdBase = mapprovider.m_StdMapBase;
			var mapBase = mapprovider.m_MapBase;
			lu[0] = (lu[0] - stdBase.left) * mapBase.relXSize + mapBase.left;
			lu[1] = -((lu[1] - stdBase.bottom) * mapBase.relYSize + mapBase.bottom);
			rl[0] = (rl[0] - stdBase.left) * mapBase.relXSize + mapBase.left;
			rl[1] = -((rl[1] - stdBase.bottom) * mapBase.relYSize + mapBase.bottom);
			nRound = mapBase.round;
		}
		// check and determine size..........................................//
		if (this.m_SourceArray.length == 0) {
			return null;
		}

		// do load balancing on server, assuring cache consistency...........//
		return this.m_SourceArray[((y + x * nMax) % this.m_SourceArray.length)].CombineUrlWPos(x, y, lod, fTileSize, lu, rl, xExpansion, yExpansion, nRound, Math.min(xTileSize, mapprovider.m_nResolution), Math.min(yTileSize, mapprovider.m_nResolution));
	};

	mapprovider.CombineUrl = function(x, y, lod) {
		// do load balancing for different sources...........................//

		var nMax = 1 << lod;

		// check levels......................................................//
		if (x < 0 || y < 0 || (x >= nMax) || (y >= nMax)) {
			return null;
		}

		// check and determine size..........................................//
		if (this.m_SourceArray.length == 0) {
			return null;
		}

		// do load balancing on server, assuring cache consistency...........//
		return this.m_SourceArray[((y + x * nMax) % this.m_SourceArray.length)].CombineUrl(x, y, lod);
	};

	mapprovider.GetMaxLOD = function() {
		return this.m_maxLOD;
	};

	mapprovider.GetMinLOD = function() {
		return this.m_minLOD;
	};

	return mapprovider;
};

// ...........................................................................//
// Source namespace..........................................................//

VBI.Source = function(url) {
	"use strict";
	var source = {};
	source.vbiclass = "Source";
	source.m_ID = null;
	source.m_Url = url;

	source.clear = function() {
	};

	source.load = function(dat) {
		if (dat.url) {
			source.m_Url = dat.url;
		}
		if (dat.id) {
			source.m_ID = dat.id;
		}

		source.m_bQuadkey = (source.m_Url.indexOf("{QUAD}") >= 0);
		source.m_bNumkey = (source.m_Url.indexOf("{NUM}") >= 0);
		return ((source.m_Url.indexOf("LU_LAT") >= 0) || (source.m_Url.indexOf("LU_LONG") >= 0) || (source.m_Url.indexOf("RL_LAT") >= 0) || (source.m_Url.indexOf("RL_LONG") >= 0));
	};

	// assign functions......................................................//
	source.CombineUrl = function(x, y, lod) {
		var temp = source.m_Url;
		// replace our placeholders..........................................//
		temp = temp.replace("{X}", x);
		temp = temp.replace("{Y}", y);
		temp = temp.replace("{-Y}", (1 << lod) - y - 1);
		temp = temp.replace("{LOD}", lod);
		if (source.m_bQuadkey){
			temp = temp.replace("{QUAD}", this.TileXYToQuadKey(x, y, lod));
		}
		if (source.m_bNumkey){
			temp = temp.replace("{NUMT}", this.TileXYToNumKey(x, y, lod));
		}

		return temp;
	};

	source.CombineUrlWPos = function(x, y, lod, fTileSize, lu, rl, xExpansion, yExpansion, nRound, xTileSize, yTileSize) {
		var temp = source.m_Url;
		var nDec = Math.pow(10, nRound);

		// replace our placeholders..........................................//
		temp = temp.replace("{X}", x);
		temp = temp.replace("{Y}", y);
		temp = temp.replace("{-Y}", (1 << lod) - y - 1);
		temp = temp.replace("{LOD}", lod);
		if (source.m_bQuadkey){
			temp = temp.replace("{QUAD}", this.TileXYToQuadKey(x, y, lod));
		}
		if (source.m_bNumkey){
			temp = temp.replace("{NUMT}", this.TileXYToNumKey(x, y, lod));
		}
		temp = temp.replace("{WIDTH}", xTileSize * xExpansion);
		temp = temp.replace("{HEIGHT}", yTileSize * yExpansion);
		temp = temp.replace("{LU_LONG}", Math.round(lu[0] * nDec) / nDec);
		temp = temp.replace("{LU_LAT}", Math.round(lu[1] * nDec) / nDec);
		temp = temp.replace("{RL_LONG}", Math.round(rl[0] * nDec) / nDec);
		temp = temp.replace("{RL_LAT}", Math.round(rl[1] * nDec) / nDec);

		return temp;
	};
	// .......................................................................//
	// get a quad key for the specified tile.................................//

	source.TileXYToQuadKey = function(x, y, lod) {
		var quadDigits = [];
		for (var i = lod; i > 0; --i) {
			var digit = '0';
			var mask = 1 << (i - 1);
			if (x & mask) {
				digit++;
			}

			if (y & mask) {
				digit++;
				digit++;
			}

			quadDigits.push(digit);
		}
		var quadKey = quadDigits.join("");
		return quadKey;
	};

	// .......................................................................//
	// get a numeric key for the specified tile..............................//

	source.TileXYToNumKey = function(x, y, lod) {
		// sum up tiles of prior lod's
		var numKey = 0;
		for (var i = 1; i < lod; ++i) {
			numKey += (1 << i) * (1 << i);
		}

		// add current LOD tiles
		numKey += (y * (1 << lod) + x + 1); // TileX 0 counts!
		return numKey;
	};

	return source;
};
/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
VBI.NavigationControl = function(SuppressedNavControlVisibility) {
	"use strict";
	var nc = {};
	sap.ui.core.IconPool.insertFontFaceStyle();
	nc.scene = null;
	nc.suppressedVisibility = SuppressedNavControlVisibility;
	nc.m_MinLOD = null;
	nc.m_MaxLOD = null;
	nc.m_lengthScrollLine = 94 - 18;
	nc.m_startScrollPoint = null;
	nc.m_ID = null;
	nc.zoomtimerfrq = 40;
	nc.zoomtimer = 0;
	nc.movetimer = 0;
	nc.bInitDrag = false;
	nc.offsetX = 0;
	nc.offsetY = 0;
	nc.curMoveX = 0;
	nc.curMoveY = 0;
	nc.curZoomY = 0;
	nc.tint = 20;
	nc.midpointForZoom = [
		0, 0
	];
	nc.timer_mapnav = null;

	nc.m_Div = nc.m_Divmapnav = nc.m_Divmapscrollarea = nc.m_Divmapscrollpoint = nc.m_Divmapcursorgrip = nc.m_Divmapcursor = nc.m_Divmapcursorreset = nc.m_Divmapcursorleft = nc.m_Divmapcursortop = nc.m_Divmapcursorright = nc.m_Divmapcursordown = nc.m_DivmapmobileHome = nc.m_DivmapmobileHomeIcon = nc.m_DivmapmobileZoomin = nc.m_DivmapmobileZoominIcon = nc.m_DivmapmobileZoomout = nc.m_DivmapmobileZoomoutIcon = null;

	nc.clear = function() {

		if (nc.timer_mapnav) {
			window.clearInterval(nc.timer_mapnav);
		}
		nc.DetachEvents();
		// remove references ...........................................//
		nc.scene = null;
		nc.m_Div = nc.m_Divmapnav = nc.m_Divmapscrollarea = nc.m_Divmapscrollpoint = nc.m_Divmapcursorgrip = nc.m_Divmapcursor = nc.m_Divmapcursorreset = nc.m_Divmapcursorleft = nc.m_Divmapcursortop = nc.m_Divmapcursorright = nc.m_Divmapcursordown = nc.m_DivmapmobileHome = nc.m_DivmapmobileHomeIcon = nc.m_DivmapmobileZoomin = nc.m_DivmapmobileZoominIcon = nc.m_DivmapmobileZoomout = nc.m_DivmapmobileZoomoutIcon = null;

	};

	nc.getId = function(a, b) {
		return b + '-' + a;
	};

	nc.DetachEvents = function() {
		if (VBI.m_bIsMobile) {
			jQuery(nc.m_DivmapmobileHome).off();
			jQuery(nc.m_DivmapmobileZoomin).off();
			jQuery(nc.m_DivmapmobileZoomout).off();
		} else {
			jQuery(nc.m_Divmapnav).off();
			jQuery(nc.m_Divmapscrollpoint).off();
			jQuery(nc.m_Divmapcursorgrip).off();
			jQuery(nc.m_Divmapcursorleft).off();
			jQuery(nc.m_Divmapcursorright).off();
			jQuery(nc.m_Divmapcursortop).off();
			jQuery(nc.m_Divmapcursordown).off();
			jQuery(nc.m_Divmapcursorreset).off();

			document.removeEventListener('mouseup', nc.zoom_processmouseup, true);
			document.removeEventListener('mousemove', nc.zoom_processmousemove, true);
		}
	};

	nc.AttachEvents = function() {
		if (VBI.m_bIsMobile) {
			nc.AttachTouchEvents();
		} else {
			nc.AttachMouseEvents();
		}
	};

	nc.AttachTouchEvents = function() {

		jQuery(nc.m_DivmapmobileHome).on("click", function() {
			if (VBI.m_bTrace) {
				VBI.Trace("Home Button : click");
			}
			nc.scene.GoToInitialStart();
		});
		jQuery(nc.m_DivmapmobileHome).on("touchstart", function() {
			if (VBI.m_bTrace) {
				VBI.Trace("Home Button : touchstart");
			}
			nc.scene.GoToInitialStart();
		});
		jQuery(nc.m_DivmapmobileHome).on("touchend", function(event) {
			if (VBI.m_bTrace) {
				VBI.Trace("Home Button : touchend");
			}
			event.preventDefault();
		});

		jQuery(nc.m_DivmapmobileZoomin).on("touchstart", function() {
			if (VBI.m_bTrace) {
				VBI.Trace("ZoomIn Button : touchstart");
			}
			nc.StartAnimatedZoom(1);
		});
		jQuery(nc.m_DivmapmobileZoomin).on("touchend", function(event) {
			if (VBI.m_bTrace) {
				VBI.Trace("ZoomIn Button : touchend");
			}
			if (nc.zoomtimer) {
				window.clearInterval(nc.zoomtimer);
				nc.ZoomToNextIntegerLOD(true);
			}
			event.preventDefault();
		});
		jQuery(nc.m_DivmapmobileZoomin).on("touchleave", function() {
			if (VBI.m_bTrace) {
				VBI.Trace("ZoomIn Button : touchleave");
			}
			if (nc.zoomtimer) {
				window.clearInterval(nc.zoomtimer);
				nc.ZoomToNextIntegerLOD(true);
			}
		});

		jQuery(nc.m_DivmapmobileZoomout).on("touchstart", function() {
			if (VBI.m_bTrace) {
				VBI.Trace("ZoomOut Button : touchstart");
			}
			nc.StartAnimatedZoom(-1);
		});
		jQuery(nc.m_DivmapmobileZoomout).on("touchend", function(event) {
			if (VBI.m_bTrace) {
				VBI.Trace("ZoomOut Button : touchend");
			}
			if (nc.zoomtimer) {
				window.clearInterval(nc.zoomtimer);
				nc.ZoomToNextIntegerLOD(false);
			}
			event.preventDefault();
		});
		jQuery(nc.m_DivmapmobileZoomout).on("touchleave", function() {
			if (VBI.m_bTrace) {
				VBI.Trace("ZoomOut Button : touchleave");
			}
			if (nc.zoomtimer) {
				window.clearInterval(nc.zoomtimer);
				nc.ZoomToNextIntegerLOD(false);
			}
		});

	};
	nc.AttachMouseEvents = function() {
		var opacity = 1.0;
		var timerFrequency = 50;
		nc.timer_mapnav = null;
		var focusSource = null;

		// fade handling
		if (nc.suppressedVisibility.fade) {
			nc.m_Divmapnav.style.opacity = 1;
		}

		jQuery(nc.m_Divmapnav).on("mouseenter", function(event) {
			focusSource = event.fromElement;
		});

		jQuery(nc.m_Divmapnav).on("mouseup", function() {
			if (focusSource) {
				focusSource.focus();
			}
		});

		jQuery(nc.m_Divmapnav).on("mouseleave", function() {
			// window.clearInterval(nc.movetimer);
			if (!nc.suppressedVisibility.fade) {
				opacity = 1.0;
				nc.timer_mapnav = window.setInterval(function() {
					if (!nc.m_Divmapnav || opacity <= 0.5) {
						window.clearInterval(nc.timer_mapnav);
					} else {
						opacity -= 0.01;
						nc.m_Divmapnav.style.opacity = opacity;
					}
				}, timerFrequency);
			}
		});

		jQuery(nc.m_Divmapnav).on("mouseenter", function() {
			window.clearInterval(nc.timer_mapnav);
			nc.m_Divmapnav.style.opacity = 1;
		});

		// zoom handling
		if (!nc.suppressedVisibility.zoom) {
			if (nc.suppressedVisibility.move) {
				jQuery(nc.m_Divmapscrollarea).css('top', 10 + 'px');
			}

			jQuery(nc.m_Divmapscrollpoint).on("mousedown", function(event) {
				if (event.which == 1) {
					nc.midpointForZoom = nc.scene.GetCenterPos();
					nc.curZoomY = jQuery(nc.m_Divmapscrollpoint).position().top;

					nc.offsetY = event.pageY - nc.curZoomY;

					document.addEventListener('mouseup', nc.zoom_processmouseup, true);
					document.addEventListener('mousemove', nc.zoom_processmousemove, true);

				}
			});

			jQuery(nc.m_Divmapscrollpoint).on("dragstart", function(e) {
				e.preventDefault();
			});

		} // zoom handling

		// move handling
		if (!nc.suppressedVisibility.move) {
			jQuery(nc.m_Divmapcursorgrip).on("mouseenter", function() {
				jQuery(nc.m_Divmapcursor).css("background-position", "-5px 228px");
			}).on("mouseleave", function() {
				jQuery(nc.m_Divmapcursor).css("background-position", "-5px 305px");
			});

			var distance = 10;

			jQuery(nc.m_Divmapcursorleft).on("mousedown", function(event) {
				if (event.which == 1) {
					jQuery(this).css("background-position", "-134px 194px");
					window.clearInterval(nc.movetimer);
					nc.movetimer = window.setInterval(function() {
						nc.scene.MoveMap(distance, 0);
					}, nc.tint);
				}
			}).on("mouseup", function(event) {
				window.clearInterval(nc.movetimer);
				jQuery(this).css("background-position", "-134px 211px");
			}).on("mouseout", function(event) {
				if (nc.bInitDrag == false) {
					window.clearInterval(nc.movetimer);
					jQuery(this).css("background-position", "-134px 228px");
				}
			}).on("mousemove", function(event) {
				if (nc.bInitDrag == true) {
					jQuery(this).css("background-position", "-134px 177px");
				}
			});

			jQuery(nc.m_Divmapcursorright).on("mousedown", function(event) {
				if (event.which == 1) {
					jQuery(this).css("background-position", "-116px 194px");
					window.clearInterval(nc.movetimer);
					nc.movetimer = window.setInterval(function() {
						nc.scene.MoveMap(-distance, 0);
					}, nc.tint);
				}
			}).on("mouseup", function(event) {
				window.clearInterval(nc.movetimer);
				jQuery(this).css("background-position", "-116px 211px");
			}).on("mouseout", function(event) {
				if (nc.bInitDrag == false) {
					window.clearInterval(nc.movetimer);
					jQuery(this).css("background-position", "-116px 228px");
				}
			}).on("mousemove", function(event) {
				if (nc.bInitDrag == true) {
					jQuery(this).css("background-position", "-116px 177px");
				}
			});

			jQuery(nc.m_Divmapcursortop).on("mousedown", function(event) {
				if (event.which == 1) {
					jQuery(this).css("background-position", "-82px 192px");
					window.clearInterval(nc.movetimer);
					nc.movetimer = window.setInterval(function() {
						nc.scene.MoveMap(0, distance);
					}, nc.tint);
				}
			}).on("mouseup", function(event) {
				window.clearInterval(nc.movetimer);
				jQuery(this).css("background-position", "-82px 210px");
			}).on("mouseout", function(event) {
				if (nc.bInitDrag == false) {
					window.clearInterval(nc.movetimer);
					jQuery(this).css("background-position", "-82px 228px");
				}
			}).on("mousemove", function(event) {
				if (nc.bInitDrag == true) {
					jQuery(this).css("background-position", "-82px 174px");
				}
			});

			jQuery(nc.m_Divmapcursordown).on("mousedown", function(event) {
				if (event.which == 1) {
					jQuery(this).css("background-position", "-99px 192px");
					window.clearInterval(nc.movetimer);
					nc.movetimer = window.setInterval(function() {
						nc.scene.MoveMap(0, -distance);
					}, nc.tint);
				}
			}).on("mouseup", function(event) {
				window.clearInterval(nc.movetimer);
				jQuery(this).css("background-position", "-99px 210px");
			}).on("mouseout", function(event) {
				if (nc.bInitDrag == false) {
					window.clearInterval(nc.movetimer);
					jQuery(this).css("background-position", "-99px 228px");
				}
			}).on("mousemove", function(event) {
				if (nc.bInitDrag == true) {
					jQuery(this).css("background-position", "-99px 174px");
				}
			});

			jQuery(nc.m_Divmapcursorreset).on("dragstart", function(e) {
				e.preventDefault();
			});
			jQuery(nc.m_Divmapcursorreset).on("mousedown", function(e) {
				if (e.which == 1) {
					nc.curMoveX = jQuery(nc.m_Divmapcursorreset).position().left;
					nc.curMoveY = jQuery(nc.m_Divmapcursorreset).position().top;

					// change appearance of arrows to inactive
					jQuery(nc.m_Divmapcursorleft).css("background-position", "-134px 177px");
					jQuery(nc.m_Divmapcursorright).css("background-position", "-116px 177px");
					jQuery(nc.m_Divmapcursordown).css("background-position", "-99px 174px");
					jQuery(nc.m_Divmapcursortop).css("background-position", "-82px 174px");

					jQuery(this).css("background-position", "-222px 263px");
					nc.offsetX = e.pageX - nc.curMoveX;
					nc.offsetY = e.pageY - nc.curMoveY;

					window.clearInterval(nc.movetimer);
					nc.movetimer = 0;
					nc.bInitDrag = true;
					document.addEventListener('mouseup', nc.processmouseup, true);
					document.addEventListener('mousemove', nc.processmousemove, true);
				}
			});

			jQuery(nc.m_Divmapcursorreset).css("position", ""); // does not work in Chrome otherwise

			jQuery(nc.m_Divmapcursorreset).on("dblclick", function() {
				nc.scene.GoToInitialStart();
			});
		} // move handling
	};

	nc.AppendButton = function() {
		nc.m_Divmapnav = VBI.Utilities.CreateGeoSceneDivCSS(nc.getId('vbi-nav', nc.m_ID), 'vbi-nav');
		nc.m_Divmapnav.m_VBIType = "N";
		nc.m_DivmapmobileHome = VBI.Utilities.CreateGeoSceneDivCSS(nc.getId('vbi-navmobile-home', nc.m_ID), 'vbi-navmobile-home');
		nc.m_DivmapmobileHome.innerHTML = "\ue070";
		nc.m_Divmapnav.appendChild(nc.m_DivmapmobileHome);
		if (!nc.suppressedVisibility.zoom) {
			nc.m_DivmapmobileZoomin = VBI.Utilities.CreateGeoSceneDivCSS(nc.getId('vbi-navmobile-zoomin', nc.m_ID), 'vbi-navmobile-zoomin');
			nc.m_DivmapmobileZoomin.innerHTML = "+";
			nc.m_Divmapnav.appendChild(nc.m_DivmapmobileZoomin);

			nc.m_DivmapmobileZoomout = VBI.Utilities.CreateGeoSceneDivCSS(nc.getId('vbi-navmobile-zoomout', nc.m_ID), 'vbi-navmobile-zoomout');
			nc.m_DivmapmobileZoomout.innerHTML = "-";
			nc.m_Divmapnav.appendChild(nc.m_DivmapmobileZoomout);
		}

		nc.scene.m_Div.appendChild(nc.m_Divmapnav);

	};

	nc.AppendDiv = function() {
		var oResourceBundle = sap.ui.getCore().getLibraryResourceBundle("sap.ui.vbm.i18n");
		var sTooltipArrows = oResourceBundle.getText("NAVCTL_TITLE_MOVE_ARROWS");
		var sTooltipZoom = oResourceBundle.getText("NAVCTL_TITLE_ZOOM", [
			0
		]);
		sTooltipZoom = sTooltipZoom.substr(0, sTooltipZoom.search(/[0-9]/));

		// create the divs
		nc.m_Divmapnav = VBI.Utilities.CreateGeoSceneDivCSS(nc.getId('vbi-nav', nc.m_ID), 'vbi-nav');
		nc.m_Divmapnav.m_VBIType = "N";

		nc.m_Divmapcursor = VBI.Utilities.CreateGeoSceneDivCSS(nc.getId('vbi-cursor', nc.m_ID), 'vbi-cursor');
		nc.m_Divmapscrollarea = VBI.Utilities.CreateGeoSceneDivCSS(nc.getId('vbi-scrollarea', nc.m_ID), 'vbi-scrollarea');
		nc.m_Divmapcursorgrip = VBI.Utilities.CreateGeoSceneDivCSS(nc.getId('vbi-cursor-grip', nc.m_ID), 'vbi-cursor-grip');
		var mapcursormiddle = VBI.Utilities.CreateGeoSceneDivCSS(nc.getId('vbi-cursor-middle', nc.m_ID), 'vbi-cursor-middle');
		var mapscrolllineupperending = VBI.Utilities.CreateGeoSceneDivCSS(nc.getId('vbi-scrolllineupperending', nc.m_ID), 'vbi-scrolllineupperending');
		var mapscrollline = VBI.Utilities.CreateGeoSceneDivCSS(nc.getId('vbi-scrollline', nc.m_ID), 'vbi-scrollline');
		var mapscrolllinelowerending = VBI.Utilities.CreateGeoSceneDivCSS(nc.getId('vbi-scrolllinelowerending', nc.m_ID), 'vbi-scrolllinelowerending');
		nc.m_Divmapscrollpoint = VBI.Utilities.CreateGeoSceneDivCSS(nc.getId('vbi-scrollpoint', nc.m_ID), 'vbi-scrollpoint', sTooltipZoom);
		nc.m_Divmapcursorleft = VBI.Utilities.CreateGeoSceneDivCSS(nc.getId('vbi-cursor-left', nc.m_ID), 'vbi-cursor-left', sTooltipArrows);
		nc.m_Divmapcursorright = VBI.Utilities.CreateGeoSceneDivCSS(nc.getId('vbi-cursor-right', nc.m_ID), 'vbi-cursor-right', sTooltipArrows);
		nc.m_Divmapcursortop = VBI.Utilities.CreateGeoSceneDivCSS(nc.getId('vbi-cursor-top', nc.m_ID), 'vbi-cursor-top', sTooltipArrows);
		nc.m_Divmapcursordown = VBI.Utilities.CreateGeoSceneDivCSS(nc.getId('vbi-cursor-down', nc.m_ID), 'vbi-cursor-down', sTooltipArrows);
		nc.m_Divmapcursorreset = VBI.Utilities.CreateGeoSceneDivCSS(nc.getId('vbi-cursor-reset', nc.m_ID), 'vbi-cursor-reset', oResourceBundle.getText("NAVCTL_TITLE_MOVE"));

		mapcursormiddle.appendChild(nc.m_Divmapcursorleft);
		mapcursormiddle.appendChild(nc.m_Divmapcursorright);
		mapcursormiddle.appendChild(nc.m_Divmapcursortop);
		mapcursormiddle.appendChild(nc.m_Divmapcursordown);
		mapcursormiddle.appendChild(nc.m_Divmapcursorreset);

		nc.m_Divmapcursorgrip.appendChild(mapcursormiddle);

		nc.m_Divmapscrollarea.appendChild(mapscrolllineupperending);
		nc.m_Divmapscrollarea.appendChild(mapscrollline);
		nc.m_Divmapscrollarea.appendChild(mapscrolllinelowerending);
		nc.m_Divmapscrollarea.appendChild(nc.m_Divmapscrollpoint);

		if (!nc.suppressedVisibility.zoom) {
			nc.m_Divmapnav.appendChild(nc.m_Divmapscrollarea);
		}

		if (!nc.suppressedVisibility.move) {
			nc.m_Divmapnav.appendChild(nc.m_Divmapcursor);
			nc.m_Divmapnav.appendChild(nc.m_Divmapcursorgrip);
		}

		nc.scene.m_Div.appendChild(nc.m_Divmapnav);
	};

	nc.AdaptMinMaxLOD = function(scene) {
		nc.m_MinLOD = nc.scene.GetMinLOD();
		nc.m_MaxLOD = nc.scene.GetMaxLOD();
	};

	nc.Awake = function(scene, target) {
		nc.scene = scene;
		nc.m_MinLOD = nc.scene.GetMinLOD();
		nc.m_MaxLOD = nc.scene.GetMaxLOD();
		var l_vbiObj = jQuery.sap.byId(target);
		nc.m_ID = jQuery(l_vbiObj).attr('id');
		if (VBI.m_bIsMobile) {
			nc.AppendButton();

		} else {
			nc.AppendDiv();
			nc.m_Divmapnav.style.opacity = 0.5;
			nc.m_startScrollPoint = 0;
		}
		nc.AttachEvents();

	};

	nc.AdjustScrollPoint = function(lod) {
		if (VBI.m_bIsMobile) {
			return;
		}
		var currentScrollPointPos;
		if (lod) {
			currentScrollPointPos = ((nc.m_lengthScrollLine * (lod - nc.m_MinLOD)) / (nc.m_MaxLOD - nc.m_MinLOD)) + nc.m_startScrollPoint;
			jQuery(nc.m_Divmapscrollpoint).css('top', currentScrollPointPos + 'px');
		} else {
			var currentZoomLevel = nc.scene.GetCurrentZoomlevel();
			currentScrollPointPos = ((nc.m_lengthScrollLine * (currentZoomLevel - nc.m_MinLOD)) / (nc.m_MaxLOD - nc.m_MinLOD)) + nc.m_startScrollPoint;
			jQuery(nc.m_Divmapscrollpoint).css('top', currentScrollPointPos + 'px');
		}
	};

	nc.StopAnimatedMove = function() {

		window.clearInterval(nc.movetimer);
		nc.movetimer = 0;
		jQuery(nc.m_Divmapcursorleft).removeAttr("style");
		jQuery(nc.m_Divmapcursorright).removeAttr("style");
		jQuery(nc.m_Divmapcursordown).removeAttr("style");
		jQuery(nc.m_Divmapcursortop).removeAttr("style");
		jQuery(nc.m_Divmapcursorreset).removeAttr("style");
		jQuery(nc.m_Divmapcursorreset).css('top', nc.curMoveX + 'px');
		jQuery(nc.m_Divmapcursorreset).css('left', nc.curMoveY + 'px');

	};

	nc.ZoomToNextIntegerLOD = function(zoomDir) {
		var fLod = nc.scene.m_Canvas[0].m_nExactLOD;
		var nLod = zoomDir ? Math.ceil(fLod) : Math.floor(fLod);
		if (fLod != nLod) {
			nc.scene.AnimateZoomToGeo(nc.scene.GetCenterPos(), nLod, nc.zoomtimerfrq);
		} else {
			nc.scene.InternalOnZoomLayer(nc.scene.m_Canvas[nc.scene.m_nOverlayIndex]);
		}
	};

	nc.StartAnimatedZoom = function(zoomin) {
		var zoompoint = nc.scene.GetCenterPos();
		if (nc.zoomtimer) {
			window.clearInterval(nc.zoomtimer);
		}
		nc.zoomtimer = window.setInterval(function() {
			var newZoomLevel = nc.scene.GetCurrentZoomlevel() + 0.2 * zoomin;
			nc.scene.ZoomToZoomlevel(zoompoint, newZoomLevel, true);
		}, nc.zoomtimerfrq);
	};

	nc.processmouseup = function() {
		nc.bInitDrag = false;
		nc.StopAnimatedMove();

		document.removeEventListener('mouseup', nc.processmouseup, true);
		document.removeEventListener('mousemove', nc.processmousemove, true);

	};

	nc.zoom_processmouseup = function(e) {
		document.removeEventListener('mouseup', nc.zoom_processmouseup, true);
		document.removeEventListener('mousemove', nc.zoom_processmousemove, true);

		if (nc.bInitDrag) {
			var newMouseY = e.pageY - nc.offsetY;
			if (newMouseY < 0) {
				newMouseY = 0;
			}
			if (newMouseY > nc.m_lengthScrollLine) {
				newMouseY = nc.m_lengthScrollLine;
			}

			var zoomlevel = nc.m_MinLOD + (((nc.m_MaxLOD - nc.m_MinLOD) * (newMouseY)) / nc.m_lengthScrollLine);
			nc.scene.AnimateZoomToGeo(nc.midpointForZoom, Math.round(zoomlevel), 5);
		}
		nc.bInitDrag = false;
	};

	nc.processmousemove = function(e) {
		var setNewX, setNewY;
		if (nc.bInitDrag == true) {
			// clear timer
			window.clearInterval(nc.movetimer);
			nc.movetimer = 0;

			var newMouseX = e.pageX - nc.offsetX;
			var newMouseY = e.pageY - nc.offsetY;
			var currentDeviationLength = parseInt(Math.sqrt(Math.pow(newMouseX - nc.curMoveX, 2) + Math.pow(newMouseY - nc.curMoveY, 2)), 10);
			var maxDeviationLength = 17;
			if (currentDeviationLength > maxDeviationLength) {
				var angle = Math.atan2(newMouseX - nc.curMoveX, newMouseY - nc.curMoveY);
				setNewX = Math.ceil((nc.curMoveX + (Math.sin(angle) * maxDeviationLength)));
				setNewY = Math.ceil((nc.curMoveY + (Math.cos(angle) * maxDeviationLength)));
				currentDeviationLength = maxDeviationLength;
			} else {
				setNewX = newMouseX;
				setNewY = newMouseY;
			}

			jQuery(nc.m_Divmapcursorreset).css('top', setNewY + 'px');
			jQuery(nc.m_Divmapcursorreset).css('left', setNewX + 'px');

			var newXOffset = -(jQuery(nc.m_Divmapcursorreset).position().left - nc.curMoveX) * (currentDeviationLength / maxDeviationLength);
			var newYOffset = -(jQuery(nc.m_Divmapcursorreset).position().top - nc.curMoveY) * (currentDeviationLength / maxDeviationLength);

			// start timer again
			nc.movetimer = window.setInterval(function() {
				nc.scene.MoveMap(newXOffset, newYOffset);
			}, nc.tint);
		}

	};
	nc.zoom_processmousemove = function(e) {
		var newMouseY = e.pageY - nc.offsetY;

		if (!nc.bInitDrag) {
			if (newMouseY != nc.curZoomY) {
				nc.bInitDrag = true;
			}
		}
		if (nc.bInitDrag) {
			if (newMouseY < 0) {
				newMouseY = 0;
			}
			if (newMouseY > nc.m_lengthScrollLine) {
				newMouseY = nc.m_lengthScrollLine;
			}

			jQuery(nc.m_Divmapscrollpoint).css('top', newMouseY + 'px');
			var zoomlevel = nc.m_MinLOD + (((nc.m_MaxLOD - nc.m_MinLOD) * (newMouseY)) / nc.m_lengthScrollLine);
			nc.scene.ZoomToZoomlevel(nc.midpointForZoom, zoomlevel);
		}
	};

	return nc;
};
/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
VBI.Parser = function() {
	"use strict";
	var parser = {};

	parser.formulas = [];
	parser.fPos = 0;
	parser.fCode = "";
	parser.fAttributes = [];

	parser.clear = function() {
		var temp;
		while ((temp = parser.formulas.shift()) != undefined) {
			parser.clearExpression(temp.dTree);
		}
	};

	parser.evaluate = function(vo, voind, ctx) {
		parser.vo = vo;
		parser.voi = voind;
		parser.ctx = ctx;
		parser.pos = undefined;
		var n = parser.formulas.length;
		for (var i = 0; i < n; ++i) {
			var f = parser.formulas[i];
			if (parser.evalF(f.dTree)) {
				return f.index;
			}
		}
		return -1; // no matching found
	};

	parser.evalF = function(node) {
		if ((node.operator == false) || (node.operator == true)) {
			return node.operator;
		}
		var result1;
		if (node.operator == 600) { // &
			result1 = parser.evalF(node.operand1);
			return result1 ? parser.evalF(node.operand2) : false;
		}
		if (node.operator == 700) { // |
			result1 = parser.evalF(node.operand1);
			return result1 ? true : parser.evalF(node.operand2);
		}
		var op1;
		var vo = parser.vo;
		switch (node.operand1) {
			case "text":
				op1 = vo.m_Text.GetValueString(parser.ctx);
				break;
			case "itext":
				op1 = parseInt(vo.m_Text.GetValueString(parser.ctx), 10);
				break;
			case "id":
				op1 = vo.m_ID;
				break;
			case "image":
				op1 = vo.m_Image.GetValueString(parser.ctx);
				break;
			case "x":
				if (!parser.pos) {
					parser.pos = parser.vo.m_Pos.GetValueVector(parser.ctx);
				}
				op1 = parser.pos[0];
				break;
			case "y":
				if (!parser.pos) {
					parser.pos = parser.vo.m_Pos.GetValueVector(parser.ctx);
				}
				op1 = parser.pos[1];
				break;
			case "tooltip":
				op1 = vo.m_Tooltip.GetValueString(parser.ctx);
				break;
			default:
				var attrTable = parser.fAttributes[parser.voi];
				op1 = ""; // default value
				for (var j = 0; j < attrTable.length; ++j) {
					if (attrTable[j].name == node.operand1) {
						var dat = vo.m_DataSource.m_CurElement.m_dataattributes[attrTable[j].index];
						if (dat != undefined) {
							op1 = dat.m_Value;
						}
					}
				}
		}
		switch (node.operator) {
			case 50:
				return op1 == node.operand2;
			case 51:
				return op1 >= node.operand2;
			case 52:
				return op1 > node.operand2;
			case 55:
				return op1 != node.operand2;
			case 56:
				return op1 <= node.operand2;
			case 57:
				return op1 < node.operand2;
		}

	};

	parser.verifyAttribute = function(node, vos, dtp) {
		if (jQuery.type(node.operand2) == 'object') {
			parser.verifyAttribute(node.operand2, vos, dtp);
		}
		if (jQuery.type(node.operand1) == 'object') {
			parser.verifyAttribute(node.operand1, vos, dtp);
		} else {
			var elte = node.operand1;
			if ((elte != "id") && (elte != "image") && (elte != "x") && (elte != "y") && (elte != "tooltip")) {
				if (!parser.fAttributes) {
					parser.buildAttributeTable(vos);
				}
				for (var i = 0; i < dtp.m_datatypenodes.length; ++i) {
					var cdtp = dtp.m_datatypenodes[i];
					var dtName = cdtp.m_Name;
					var attr = cdtp.m_datatypeattributes;
					for (var j = 0; j < attr.length; ++j) {
						var cattr = attr[j];
						if (cattr.m_Name == elte) {
							for (var k = 0; k < parser.fAttributes.length; ++k) {
								var cfAttr = parser.fAttributes[k];
								if (cfAttr.m_Name == dtName) {
									var fFound = false;
									for (var l = 0; l < cfAttr.length; ++l) {
										if (cfAttr[l].name == elte) {
											fFound = true;
										}
									}
									if (!fFound) {
										cfAttr.push({
											name: elte,
											index: j
										});
									}
								}
							}
						}

					}
				}
			}
		}
	};

	parser.buildAttributeTable = function(vos) {
		parser.fAttributes = [];
		for (var i = 0; i < vos.length; ++i) {
			var PList = [];
			var dataSource = vos[i].m_DataSource;
			if (dataSource != undefined) {
				PList.m_Name = dataSource.m_NPath[0];
				parser.fAttributes.push(PList);
			}
		}
	};

	parser.verifyAttributes = function(vos, ctx) {
		parser.fAttributes = undefined;
		var dtp = ctx.m_DataTypeProvider;
		for (var ii = 0; ii < parser.formulas.length; ++ii) {
			parser.verifyAttribute(parser.formulas[ii].dTree, vos, dtp);
		}
	};

	parser.clearExpression = function(myExpression) {
		if (jQuery.type(myExpression) != 'object') {
			return;
		}
		parser.clearExpression(myExpression.operand1);
		parser.clearExpression(myExpression.operand2);
		myExpression.operand1 = myExpression.operand2 = undefined;

	};

	parser.addFormula = function(index, myFormula) {
		parser.formulas.push({
			index: index,
			formula: myFormula,
			dTree: parser.buildDecisionTree(myFormula)
		});
		return parser.formulas.length - 1;
	};

	parser.buildDecisionTree = function(myFormula) {
		parser.fPos = 0;
		parser.fCode = myFormula;
		var currentNode = {};
		if (!parser.parseExpression(currentNode)) {
			VBI.Trace("Error: " + myFormula + " could not be interpreted");
			currentNode.operator = false;
		}

		return currentNode;
	};

	parser.parseExpression = function(node) {
		var op1 = parser.scan();
		if (op1 == -1) {
			node.operator = true;
			return (node.operator);
		}
		if (op1 == 10) {
			node.operand1 = {};
			if (!parser.parseExpression(node.operand1)) {
				return false;
			}
			if (parser.scan() != 20) {
				return false;
			}
			node.operator = parser.scan();
			if (parser.ttype != 2) {
				return false;
			}
			if (parser.scan() != 10) {
				return false;
			}
			node.operand2 = {};
			if (!parser.parseExpression(node.operand2)) {
				return false;
			}
			if (parser.scan() != 20) {
				return false;
			}
			return true;
		}
		if (op1 == 500) {
			node.operand1 = parser.token;
			node.operator = parser.scan();
			if (parser.ttype != 1) {
				return false;
			}
			parser.scan();
			if (parser.ttype != 10) {
				return false;
			}
			node.operand2 = parser.token;
			return true;
		}
		return false;
	};

	parser.scan = function() {
		var lookahead;
		var nOffset = 0;
		if (parser.fPos >= parser.fCode.length) {
			return -1;
		}
		var myChar = parser.fCode.substr(parser.fPos, 1);

		switch (true) {
			case myChar == "(":
				return parser.getToken(myChar, 10, 0);
			case myChar == ")":
				return parser.getToken(myChar, 20, 0);
			case myChar == "=":
				return parser.getToken(myChar, 50, 1);
			case myChar == "!":
				return parser.fCode.substr(parser.fPos + 1, 1) == "=" ? parser.getToken("!=", 55, 1) : false;
			case myChar == "<":
			case myChar == ">":
				nOffset = 5 * (myChar == "<");
				lookahead = parser.fCode.substr(parser.fPos + 1, 1);
				if (lookahead == "=") {
					return parser.getToken(myChar + lookahead, 51 + nOffset, 1);
				}
				if (myChar == "<" && lookahead == ">") {
					return parser.getToken("!=", 55, 1);
				}
				return parser.getToken(myChar, 52 + nOffset, 1);
			case myChar == "|":
			case myChar == "&":
				nOffset = 100 * (myChar == "|");
				lookahead = parser.fCode.substr(parser.fPos + 1, 1);
				if (myChar != lookahead) {
					lookahead = "";
				}
				return parser.getToken(myChar + lookahead, 600 + nOffset, 2);
			case ((myChar >= "0") && (myChar <= "9")):
				return parser.readNumber(myChar);
			case (((myChar >= "a") && (myChar <= "z")) || ((myChar >= "A") && (myChar <= "Z"))):
				return parser.readString(myChar);
			default:
				return -2; // invalid character
		}

	};

	parser.readNumber = function(firstChar) {
		var str = firstChar;
		var i = 1;
		var nextChar = parser.fCode.substr(parser.fPos + i, 1);
		while ((nextChar >= "0") && (nextChar <= "9")) {
			str += nextChar;
			i++;
			nextChar = parser.fCode.substr(parser.fPos + i, 1);
		}
		return parser.getToken(str, 600, 10);
	};

	parser.readString = function(firstChar) {
		var str = firstChar;
		var i = 1;
		var nextChar = parser.fCode.substr(parser.fPos + i, 1);
		while ((((nextChar >= "a") && (nextChar <= "z")) || ((nextChar >= "A") && (nextChar <= "Z"))) || ((nextChar >= "0") && (nextChar <= "9")) || (nextChar == "_") || (nextChar == ".") || (nextChar == "/") || (nextChar == "\\")) {
			str += nextChar;
			i++;
			nextChar = parser.fCode.substr(parser.fPos + i, 1);
		}
		return parser.getToken(str, 500, 10);
	};

	parser.getToken = function(str, id, type) {
		parser.fPos += str.length;
		parser.token = str;
		parser.ttype = type;
		return id;
	};

	return parser;
};
// ...........................................................................//
// this module does the label handling.......................................//

// Author: Martina Gozlinski, extraction by Jürgen

// ...........................................................................//
// First part enriches scene with label specific functions //
// Second part consists of the VBI.Label object, formerly part of vobase //
/* global VBI */// declare unusual global vars for JSLint/SAPUI5 validation
VBI.addScenePositioningFunctions = function(scene) {
	"use strict";
	scene.GetNearestPosArray = function(posarray) {
		// do a copy of the array..............................................//
		var pa = posarray.slice();
		var nLen = Math.floor(pa.length / 3) * 3;

		var nx = pa[0];
		var ny = pa[1];
		var minX = nx, maxX = nx;
		var minY = ny, maxY = ny;

		for (var nJ = 3; nJ < nLen; nJ += 3) {
			// determine the nearest position around............................//
			while (pa[nJ] - nx > 180) {
				pa[nJ] -= 360;
			}
			while (nx - pa[nJ] > 180) {
				pa[nJ] += 360;
			}

			// next nx..........................................................//
			nx = pa[nJ];

			// do minmax........................................................//
			ny = pa[nJ + 1];
			if (minX > nx) {
				minX = nx;
			}
			if (maxX < nx) {
				maxX = nx;
			}
			if (minY > ny) {
				minY = ny;
			}
			if (maxY < ny) {
				maxY = ny;
			}
		}

		// set the minimum and maximum values..................................//
		pa.m_MinX = minX;
		pa.m_MaxX = maxX;
		pa.m_MinY = minY;
		pa.m_MaxY = maxY;

		return pa;
	};

	scene.GetNearestPos = function(pos, nearpos) {
		// do a copy of the pos................................................//
		var p = pos.slice();

		// determine the nearest position around...............................//
		var nx = nearpos[0];
		while (p[0] - nx > 180) {
			p[0] -= 360;
		}
		while (nx - p[0] > 180) {
			p[0] += 360;
		}
		return p;
	};

	scene.BuildCacheDataObj = function() {
		var newObj = {};

		newObj.mul = Math.PI / 180.0;

		var cv = scene.m_Canvas[0];
		var cvo = scene.m_Canvas[scene.m_nOverlayIndex];
		var lod = cv.m_nCurrentLOD;

		newObj.minLOD = scene.GetMinLOD();
		newObj.lod = lod;
		newObj.nMaxLODTiles = (1 << lod);

		newObj.tilePixelWidth = scene.m_nWidthCanvas / scene.m_nTilesX;
		newObj.tilePixelHeight = scene.m_nHeightCanvas / scene.m_nTilesY;

		newObj.completeX = newObj.nMaxLODTiles * newObj.tilePixelWidth;
		newObj.completeY = newObj.nMaxLODTiles * newObj.tilePixelHeight;

		newObj.fx = cvo.getPixelWidth() / scene.m_nWidthCanvas;
		newObj.fy = cvo.getPixelHeight() / scene.m_nHeightCanvas;

		var proj = scene.m_Proj;

		newObj.ucs_min = proj.m_nUCSMin * newObj.completeX;
		newObj.ucs_max = proj.m_nUCSMax * newObj.completeX;
		newObj.ucs_compl = proj.m_nXYRatio * newObj.completeX;

		newObj.ox = cv.m_nCurrentX * newObj.tilePixelWidth + newObj.ucs_min;
		newObj.oy = cv.m_nCurrentY * newObj.tilePixelHeight;

		newObj.factX = newObj.completeX * newObj.fx;
		newObj.factY = newObj.completeY * newObj.fy;
		newObj.addX = -newObj.ox * newObj.fx;
		newObj.addY = -newObj.oy * newObj.fy;

		scene.m_CacheVars = newObj;

	};

	scene.DestroyCacheDataObj = function() {
		scene.m_CacheVars = undefined;
	};

	scene.FillPositionCache = function(posarray, bUnordered) {
		// Get original data and fill cache
		//
		var n = scene.m_CacheVars;

		var ucs = [
			1.0, 1.0
		], cache = [];

		var nx = bUnordered ? 0 : posarray[0];
		var cx, cy;
		var minX = posarray[0], maxX = posarray[0];
		var minY = posarray[1], maxY = posarray[1];

		var lltucs = scene.m_Proj.LonLatToUCS;
		var mul = n.mul;

		for (var nJ = 0, len = posarray.length; nJ < len; nJ += 3) {
			// determine the nearest position around............................//
			cx = posarray[nJ];
			cy = posarray[nJ + 1];
			while (cx - nx > 180) {
				cx -= 360;
			}
			while (nx - cx > 180) {
				cx += 360;
			}
			if (cx < minX) {
				minX = cx;
			}
			if (cx > maxX) {
				maxX = cx;
			}
			if (cy < minY) {
				minY = cy;
			}
			if (cy > maxY) {
				maxY = cy;
			}
			ucs = lltucs([
				mul * cx, mul * cy
			], [
				1.0, 1.0
			]);
			cache.push(ucs[0], ucs[1], 0);
			if (!bUnordered) {
				nx = cx;
			}
		}

		posarray.cache = {
			data: cache,
			ref: scene.m_CacheVars,
			lt: lltucs([
				mul * minX, mul * maxY
			], [
				1.0, 1.0
			]),
			rb: lltucs([
				mul * maxX, mul * minY
			], [
				1.0, 1.0
			]),
			minLod: -Math.log(Math.max(maxX - minX, maxY - minY)) / Math.log(2)
		};
	};

	scene.GetVOExtension = function(posarray) {
		if (posarray.cache == undefined) {
			scene.FillPositionCache(posarray);
		}
		return posarray.cache.BB;
	};

	scene.GetPointArrayFromPosArrayWCache = function(posarray) {

		if (posarray.cache == undefined) {
			scene.FillPositionCache(posarray);
		}
		return posarray.cache.data;
	};

	scene.GetPointFromUCSPoint = function(point) {
		var n = scene.m_CacheVars;
		return [
			point[0] * n.factX + n.addX, point[1] * n.factY + n.addY
		];
	};

	scene.GetPointArrayFromUCSArray = function(posarray) {
		var n = scene.m_CacheVars;
		var factX = n.factX, factY = n.factY;
		var addX = n.addX, addY = n.addY;
		var ret = [];
		for (var nJ = 0; nJ <= posarray.length - 3; nJ += 3) {
			ret.push(posarray[nJ] * factX + addX, posarray[nJ + 1] * factY + addY, 0.0);
		}
		return ret;
	};

	scene.GetShortPointArrayFromUCSArray = function(posarray) {
		var n = scene.m_CacheVars;
		var factX = n.factX, factY = n.factY;
		var addX = n.addX, addY = n.addY;
		var ret = [];
		for (var nJ = 0; nJ <= posarray.length - 3; nJ += 3) {
			ret.push(posarray[nJ] * factX + addX, posarray[nJ + 1] * factY + addY);
		}
		return ret;
	};

	scene.GetPointArrayFromPosArray = function(posarray, adjust, bIgnoreStretch) {
		// in a geoscene the pos is specified as lon/lat/height, where lon and.//
		// lat are specified in degrees, convert them to radians...............//
		// the posarray is one large array with triples lon/lat,height.........//

		var lonlat = [
			0.0, 0.0
		], ret = [];
		var cv = scene.m_Canvas[0];
		var nMaxLODTiles = (1 << cv.m_nCurrentLOD);

		var tilePixelWidth = scene.m_nWidthCanvas / scene.m_nTilesX;
		var tilePixelHeight = scene.m_nHeightCanvas / scene.m_nTilesY;

		// normalize complete dimension on current LOD.........................//
		var completeX = nMaxLODTiles * tilePixelWidth;
		var completeY = nMaxLODTiles * tilePixelHeight;

		// adjust to current zoom factor for the rendering canvas..............//
		var cvo = scene.m_Canvas[scene.m_nOverlayIndex];
		var fx = bIgnoreStretch ? 1 : cvo.getPixelWidth() / scene.m_nWidthCanvas;
		var fy = bIgnoreStretch ? 1 : cvo.getPixelHeight() / scene.m_nHeightCanvas;

		// geo connversion routine.............................................//
		var lltucs = scene.m_Proj.LonLatToUCS;

		var ucs = [
			0, 0
		], mul = Math.PI / 180.0;
		var proj = scene.m_Proj;
		var ucs_min = proj.m_nUCSMin * completeX;
		var ucs_max = proj.m_nUCSMax * completeX;
		var ucs_compl = proj.m_nXYRatio * completeX;

		var ox = cv.m_nCurrentX * tilePixelWidth + ucs_min;
		var oy = cv.m_nCurrentY * tilePixelHeight;
		var nJ, len;

		for (nJ = 0, len = posarray.length; nJ < len; nJ += 3) {
			// deg to rad now inline due to performance.........................//
			lonlat[0] = mul * posarray[nJ];
			lonlat[1] = mul * posarray[nJ + 1];

			ucs[0] = completeX;
			ucs[1] = completeY;
			ucs = lltucs(lonlat, ucs);

			// map position into canvas area....................................//
			ucs[0] = ucs[0] - ox;
			ucs[1] = ucs[1] - oy;
			if (adjust) {
				// adjust to round world.........................................//
				while (ucs[0] < ucs_min) {
					ucs[0] += ucs_compl;
				}
				while (ucs[0] > ucs_max) {
					ucs[0] -= ucs_compl;
				}
			}
			ret.push(ucs[0] * fx, ucs[1] * fy, 0.0);

		}

		// only when it was a single point, calculate visibility...............//
		if (len == 1 && ucs) {
			// do point clipping and set the visible state......................//
			var x, y;
			ret.m_bVisible = (((x = ucs[0]) > 0) && ((y = ucs[1]) > 0) && (x < scene.m_nWidthCanvas) && (y < scene.m_nHeightCanvas));
		}

		return ret;
	};

	scene.GetPointFromGeo = function(lonlat, adjust) {
		// lonlat is specified in !radians! before using the array function....//
		// we must convert them................................................//
		return scene.GetPointArrayFromPosArray(VBI.MathLib.RadToDeg(lonlat), adjust);
	};

// determine an array of x offsets that need to be used to render the.....//
// the object for round world.............................................//
// this is calculated assuming non zoomed canvas..........................//

	scene.GetInstanceOffsets = function(rect) {
		var rc = rect.slice(); // copy the array..............................//

		// determine theoretical pixels of this lod............................//
		var cv = scene.m_Canvas[0];
		var tilePixelWidth = scene.m_nWidthCanvas / scene.m_nTilesX;
		var completeX = (1 << cv.m_nCurrentLOD) * tilePixelWidth * scene.m_Proj.m_nXYRatio;

		var rcCanvas = [
			0, 0, scene.m_nWidthCanvas, scene.m_nHeightCanvas
		];
		var nCount = 0;

		// shift the object to the left, till it is out of bounds..............//
		while (rc[2] > 0) {
			--nCount;
			VBI.Utilities.RectOffset(rc, -completeX, 0);
		}

		// start to shift the object to the right and collect intersection.....//
		var aOffsets = [];
		while (rc[0] < scene.m_nWidthCanvas) {
			nCount++;
			VBI.Utilities.RectOffset(rc, completeX, 0);
			if (VBI.Utilities.RectIntersect(rc, rcCanvas)) {
				aOffsets.push(nCount * completeX);
			}
		}

		return aOffsets; // return the offsets for rendering the instance.....//
	};

	scene.GetCorrectedInstanceOffsets = function(rect, zf) {
		var rc = rect.slice(); // copy the array..............................//

		// determine theoretical pixels of this lod............................//
		var cv = scene.m_Canvas[0];
		var tilePixelWidth = scene.m_nWidthCanvas / scene.m_nTilesX;
		var completeX = zf[0] * (1 << cv.m_nCurrentLOD) * tilePixelWidth * scene.m_Proj.m_nXYRatio;

		var rcCanvas = [
			0, 0, zf[0] * scene.m_nWidthCanvas, zf[1] * scene.m_nHeightCanvas
		];
		var nCount = 0;

		// shift the object to the left, till it is out of bounds..............//
		while (rc[2] > 0) {
			--nCount;
			VBI.Utilities.RectOffset(rc, -completeX, 0);
		}

		// start to shift the object to the right and collect intersection.....//
		var aOffsets = [];
		while (rc[0] < scene.m_nWidthCanvas) {
			nCount++;
			VBI.Utilities.RectOffset(rc, completeX, 0);
			if (VBI.Utilities.RectIntersect(rc, rcCanvas)) {
				aOffsets.push(nCount * completeX);
			}
		}

		return aOffsets; // return the offsets for rendering the instance.....//
	};
// ........................................................................//
// get the geoposition from a given pixel point of the viewport/div.......//

	scene.GetPosFromVPPoint = function(pt) {
		var canv = scene.m_Canvas[scene.m_nOverlayIndex];

		// determine the position in the canvas................................//
		var cp = [
			pt[0] - canv.getPixelLeft(), pt[1] - canv.getPixelTop(), 0
		];
		var tmp = this.GetGeoFromPoint(cp); // radians are returned here.//
		return VBI.MathLib.RadToDeg(tmp); // convert to deg............//
	};

// .......................................................................//
// determine the geoposition from a given pixel point of the zoomed.......//
// canvas.................................................................//

	scene.GetPosFromPoint = function(pt) {
		var tmp = this.GetGeoFromPoint(pt); // radians are returned here.//
		return VBI.MathLib.RadToDeg(tmp); // convert to deg............//
	};

	scene.GetGeoFromPoint = function(pt) {
		var cv = scene.m_Canvas[0];
		var nLOD = cv.m_nCurrentLOD;

		// in pixel space we are
		var nMaxLODTiles = (1 << nLOD);
		var canvasPixelLeft = pt[0] * scene.m_nWidthCanvas / cv.getPixelWidth();
		var canvasPixelTop = pt[1] * scene.m_nHeightCanvas / cv.getPixelHeight();

		var tilePixelWidth = scene.m_nWidthCanvas / scene.m_nTilesX;
		var tilePixelHeight = scene.m_nHeightCanvas / scene.m_nTilesY;

		// number of pixels outside............................................//
		var nOutsideX = cv.m_nCurrentX * tilePixelWidth;
		var nOutsideY = cv.m_nCurrentY * tilePixelHeight;

		// in pixel space for the current lod we are at........................//
		var currentX = nOutsideX + canvasPixelLeft;
		var currentY = nOutsideY + canvasPixelTop;

		// complete pixel space................................................//
		var completeX = nMaxLODTiles * tilePixelWidth;
		var completeY = nMaxLODTiles * tilePixelHeight;

		// do not normalize ...................................................//
		// with normalization we can not handle big geometrical shapes.........//
		/*
		 * while( currentX < 0 ) currentX += completeX; while( currentY < 0 ) currentY += completeY; while( currentX > completeX ) currentX -=
		 * completeX; while( currentY > completeY ) currentY -= completeY;
		 */

		// normalize complete dimension on current LOD.........................//
		var lonlat = [
			0, 0
		];
		var ucs = [
			currentX / completeX * 2.0 - 1.0, currentY / completeY * 2.0 - 1.0
		];

		return scene.m_Proj.UCSToLonLat(ucs, lonlat);
	};
};
﻿// ...........................................................................//
// this module deals with the projections ...................................//

// Author: Jürgen Gatter
/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
VBI.LinearProjection = function(target) {
	"use strict";
	var projection = {};
	projection.vbiclass = "Projection/Linear";
	projection.m_nXYRatio = 2;
	projection.m_nXMin = -2;
	projection.m_nXMax = 2;
	projection.m_nGeometrySize = 4;

	projection.m_nUCSMin = -0.5;
	projection.m_nUCSMax = 1.5;
	projection.m_bIsIsogonal = true;

	projection.LonLatToUCS = function(lonlat, uxy) {
		var xSize = uxy[0];
		var ySize = uxy[1];
		uxy[0] = xSize * (0.5 + lonlat[0] / Math.PI);
		uxy[1] = ySize * (0.5 - lonlat[1] / Math.PI);
		return uxy;
	};

	projection.UCSToLonLat = function(uxy, lonlat) {
		lonlat[0] = Math.PI * (projection.m_nUCSMin + uxy[0] / 2);
		lonlat[1] = -Math.PI * (uxy[1] / 2);
		return lonlat;
	};

	return projection;
};

VBI.MercatorProjection = function(target) {
	"use strict";
	var projection = {};
	projection.vbiclass = "Projection/Mercator";
	projection.m_nXYRatio = 1;
	projection.m_nXMin = -1;
	projection.m_nXMax = 1;
	projection.m_nGeometrySize = 2;

	projection.m_nUCSMin = 0;
	projection.m_nUCSMax = 1;
	projection.m_bIsIsogonal = true;

	projection.LonLatToUCS = VBI.MathLib.LonLatToUCS;
	projection.UCSToLonLat = VBI.MathLib.UCSToLonLat;

	return projection;

};

VBI.ElliMercatorProjection = function(target) {
	"use strict";
	var projection = {};
	projection.vbiclass = "Projection/EllipticalMercator";
	projection.m_nXYRatio = 1;
	projection.m_nXMin = -1;
	projection.m_nXMax = 1;
	projection.m_nGeometrySize = 2;

	projection.m_nUCSMin = 0;
	projection.m_nUCSMax = 1;
	projection.m_bIsIsogonal = true;

	projection.m_rmajor = 6378137;
	projection.m_rminor = 6356752.3142;
	var ratio = projection.m_rminor / projection.m_rmajor;
	projection.m_eccent = Math.sqrt(1.0 - (ratio * ratio));
	projection.m_halfEccent = 0.5 * projection.m_eccent;
	projection.m_PI_Div_180 = Math.PI / 180.0;
	projection.m_PI_Div_2 = Math.PI / 2;
	projection.m_PI_Div_4 = Math.PI / 4;
	projection.m_majMultPIDiv180 = projection.m_PI_Div_180 * projection.m_rmajor;
	projection.m_tolerance = 0.0000000001;
	projection.m_EllipticalBorder = 89.5 * projection.m_PI_Div_180;
	projection.m_PIx2 = 2.0 * Math.PI;
	projection.m_yMax = 2.0 * Math.PI * projection.m_rmajor;

	projection.LonLatToUCS = function(lonlat, uxy) {
		var lon = lonlat[0], lat = Math.max(Math.min(lonlat[1], projection.m_EllipticalBorder), -projection.m_EllipticalBorder);
		var temp = projection.m_eccent * Math.sin(lat);
		temp = Math.pow((1 - temp) / (1 + temp), projection.m_halfEccent);
		var x = 0.5 + lon / projection.m_PIx2; // as we norm to [0..1] the multiplication with rmajor is not required
		var y = 0.5 + Math.log(Math.tan(projection.m_PI_Div_4 - lat / 2) / temp) / projection.m_PIx2;

		uxy[0] = uxy[0] * x;
		uxy[1] = uxy[1] * y;

		return uxy;
	};

	projection.UCSToLonLat = function(uxy, lonlat) {
		lonlat[0] = Math.PI * uxy[0];
		lonlat[1] = this.CalcPhi(Math.exp(Math.PI * uxy[1]));
		return lonlat;
	};

	projection.CalcPhi = function(ts) {
		var j = 15, delta, con, phi = projection.m_PI_Div_2 - 2.0 * Math.atan(ts);
		do {
			con = projection.m_eccent * Math.sin(phi);
			delta = projection.m_PI_Div_2 - 2.0 * Math.atan(ts * Math.pow((1.0 - con) / (1.0 + con), projection.m_halfEccent)) - phi;
			phi += delta;
		} while (Math.abs(delta) > projection.m_tolerance && --j);
		return phi;
	};

	return projection;

};
// ...........................................................................//
// this module does the label handling.......................................//

// Author: Martina Gozlinski, extraction by Jürgen

// ...........................................................................//
/* global VBI */// declare unusual global vars for JSLint/SAPUI5 validation
VBI.addSceneRectangularTrackingFunctions = function(scene) {
	"use strict";

	// ........................................................................//
	// RectangularTracking ....................................................//
	// ........................................................................//

	scene.RectangularTracking = function() {
		this.m_PosStart = null;
		this.m_PosMove = null;
		this.m_bTrack = false;
		this.m_keycode = 0;
	};

	scene.RectangularTracking.prototype.onsapkeydown = function(e) {
		if (e.keyCode == this.m_keycode) {
			// exit tracking mode ................//
			this.ExitMode();
			e.preventDefault();
			return true;
		}

	};

	scene.RectangularTracking.prototype.onsapdown = function(e) {
		// determine the sap down position.....................................//
		var rect = scene.m_Canvas[scene.m_nOverlayIndex].getBoundingClientRect();
		this.m_PosStart = scene.GetPosFromPoint([
			e.clientX - rect.left, e.clientY - rect.top, 0
		]);
		this.m_bTrack = true;

		if (e.type == "mousedown") {
			document.addEventListener('mouseup', this, true);
		} else if (e.type == "touchstart") {
			document.addEventListener('touchend', this, true);
		} else if (e.type == "pointerdown") {
			document.addEventListener('pointerup', this, true);
		}
		e.preventDefault();
		scene.m_Canvas[scene.m_nLabelIndex].focus();
		return true;
	};

	scene.RectangularTracking.prototype.handleEvent = function(e) {
		if (e.type == "mouseup") {
			document.removeEventListener('mouseup', this, true);
		} else if (e.type == "touchend") {
			document.removeEventListener('touchend', this, true);
		} else if (e.type == "pointerup") {
			document.removeEventListener('pointerup', this, true);
			if (scene.m_Gesture) {
				scene.m_Gesture.pointerCount--;
				if (!scene.m_Gesture.pointerCount) {
					scene.m_Gesture.target = null;
					scene.m_Gesture = null;
				}
			}

		}
		this.TrackEnd(e);
	};

	scene.RectangularTracking.prototype.TrackEnd = function(e) {

		if (!this.m_bTrack) {
			return false;
		}

		if (this.m_PosStart && this.m_PosMove) {
			this.execute(e);
		}
		this.m_PosStart = null;
		this.m_PosMove = null;
		this.m_bTrack = false;

		// trigger async rendering..........................................//
		scene.RenderAsync(true);
		e.preventDefault();
		e.stopPropagation();

		return true;
	};

	scene.RectangularTracking.prototype.onsapmove = function(e) {
		if (this.m_bTrack) {
			// determine the move position......................................//
			var rect = scene.m_Canvas[scene.m_nOverlayIndex].getBoundingClientRect();
			this.m_PosMove = scene.GetPosFromPoint([
				e.clientX - rect.left, e.clientY - rect.top, 0
			]);
		}
		scene.SetCursor('crosshair');
		scene.RenderAsync(true); // trigger async rendering...................//
		e.preventDefault();
		return true;
	};

	scene.RectangularTracking.prototype.onsapout = function(e) {
	};

	scene.RectangularTracking.prototype.execute = function(e) {
		// The prototype impl is empty
	};

	scene.RectangularTracking.prototype.Hook = function(inputmode) {
		scene.SetInputMode(inputmode);
		if (inputmode == VBI.InputModeRectSelect) {
				scene.m_Ctx.m_Control.setProperty("rectangularSelection",true);
		} else {
			scene.m_Ctx.m_Control.setProperty("rectZoom",true);
		}
		scene.m_DesignVO = this;
		scene.SetCursor('crosshair');
		scene.RenderAsync(true);

	};

	scene.RectangularTracking.prototype.UnHook = function() {
		if (scene.m_nInputMode == VBI.InputModeRectSelect || scene.m_nInputMode == VBI.InputModeRectZoom) {
			scene.m_Ctx.onChangeTrackingMode(scene.m_nInputMode, false);
			if (scene.m_nInputMode == VBI.InputModeRectSelect) {
				scene.m_Ctx.m_Control.setProperty("rectangularSelection",false);
			} else {
				scene.m_Ctx.m_Control.setProperty("rectZoom",false);
			}
			scene.SetInputMode(VBI.InputModeDefault);
		} else {
			jQuery.sap.log.error("Wrong InputMode in UnHook: " + scene.m_nInputMode);
		}

		this.m_PosStart = null;
		this.m_PosMove = null;
		this.m_bTrack = false;

		scene.m_DesignVO = null;
		scene.RenderAsync(true); // trigger async rendering...................//
	};

	scene.RectangularTracking.prototype.ExitMode = function() {
		// exit mode selection mode ................//
		this.UnHook();
		scene.SetCursor('default');
		scene.RenderAsync(true); // trigger async rendering...................//

	};

// ........................................................................//
// rectangular zoom ( sub class of RectangularTracking ) .................//
// ........................................................................//
	scene.RectangularZoom = function() {
		scene.RectangularTracking.call(this);
		this.m_keycode = 90;
		this.Hook(VBI.InputModeRectZoom);
	};

	scene.RectangularZoom.prototype = Object.create(scene.RectangularTracking.prototype);

	scene.RectangularZoom.prototype.constructor = scene.RectangularZoom;

	scene.RectangularZoom.prototype.execute = function(e) {
		var lons = [];
		var lats = [];
		lons[0] = this.m_PosStart[0];
		lons[1] = this.m_PosMove[0];
		lats[0] = this.m_PosStart[1];
		lats[1] = this.m_PosMove[1];
		scene.ZoomToMultiplePositions(lons, lats, 1.0);
	};

	scene.RectangularZoom.prototype.Render = function(canvas, dc) {
		if (!this.m_bTrack) {
			return false;
		}

		// check positions to prevent from failures.........................//
		if (this.m_PosMove && this.m_PosStart) {
			var ptStart = scene.GetPointFromPos(this.m_PosStart, false);
			var ptMove = scene.GetPointFromPos(this.m_PosMove, false);

			var ptCorrectedMove = ptMove.slice(0);
			var CurrentWidthZoomRect = ptMove[0] - ptStart[0];
			var CurrentHeightZoomRect = ptMove[1] - ptStart[1];

			var rectDiv = scene.GetInternalDivClientRect();

			var currentRatioDiv = Math.abs(rectDiv.width / rectDiv.height);
			var currentRatioZoomRect = Math.abs(CurrentWidthZoomRect / CurrentHeightZoomRect);
			var height = 0;
			var width = 0;

			if (currentRatioZoomRect < currentRatioDiv) {
				// keep width
				width = ptMove[0] - ptStart[0];
				height = width / currentRatioDiv;
				if (ptMove[0] < ptStart[0] && ptMove[1] > ptStart[1] || ptMove[0] > ptStart[0] && ptMove[1] < ptStart[1]) {
					ptCorrectedMove[1] = ptStart[1] - height;
				} else {
					ptCorrectedMove[1] = ptStart[1] + height;
				}
			} else {
				// keep height
				height = ptMove[1] - ptStart[1];
				width = currentRatioDiv * height;
				if (ptMove[0] < ptStart[0] && ptMove[1] > ptStart[1] || ptMove[0] > ptStart[0] && ptMove[1] < ptStart[1]) {
					ptCorrectedMove[0] = ptStart[0] - width;
				} else {
					ptCorrectedMove[0] = ptStart[0] + width;
				}
			}

			VBI.Utilities.DrawTrackingRect(dc, ptStart[0], ptStart[1], ptCorrectedMove[0], ptCorrectedMove[1]);

			var zf = scene.GetStretchFactor4Mode();
			ptCorrectedMove[0] *= zf[0];
			ptCorrectedMove[1] *= zf[1];

			this.m_PosMove = scene.GetPosFromPoint([
				ptCorrectedMove[0], ptCorrectedMove[1]
			]);

		}
	};

// ........................................................................//
// rectangular selection ( sub class of RectangularTracking ) ............//
// ........................................................................//
	scene.RectSelection = function() {
		scene.RectangularTracking.call(this);
		this.m_keycode = 82;
		this.Hook(VBI.InputModeRectSelect);
	};

	scene.RectSelection.prototype = Object.create(scene.RectangularTracking.prototype);

	scene.RectSelection.prototype.constructor = scene.RectSelection;

	scene.RectSelection.prototype.execute = function(e) {
		var pt1 = scene.GetPointFromPos(this.m_PosStart, false);
		var pt2 = scene.GetPointFromPos(this.m_PosMove, false);
		var ptStart = [];
		var ptMove = [];
		var nJ;
		for (nJ = 0; nJ <= 1; nJ++) {
			if (pt1[nJ] < pt2[nJ]) {
				ptStart[nJ] = pt1[nJ];
				ptMove[nJ] = pt2[nJ];
			} else {
				ptStart[nJ] = pt2[nJ];
				ptMove[nJ] = pt1[nJ];
			}
		}

		var zf = scene.GetStretchFactor4Mode();

		// bounding boxes are defined always in non stretched canvas........//
		// coordinates, therefore transform them............................//
		ptStart[0] /= zf[0];
		ptMove[0] /= zf[0];
		ptStart[1] /= zf[1];
		ptMove[1] /= zf[1];

		this.selectionRect = [
			ptStart[0], ptStart[1], ptMove[0], ptMove[1]
		];

		scene.PerFormMultiSelect(e, this);
	};

	scene.RectSelection.prototype.Render = function(canvas, dc) {
		if (!this.m_bTrack) {
			return false;
		}

		// check positions to prevent from failures.........................//
		if (this.m_PosMove && this.m_PosStart) {
			var ptStart = scene.GetPointFromPos(this.m_PosStart, false);
			var ptMove = scene.GetPointFromPos(this.m_PosMove, false);
			VBI.Utilities.DrawTrackingRect(dc, ptStart[0], ptStart[1], ptMove[0], ptMove[1]);
		}
	};

};
﻿// ...........................................................................//
// resources manager object..................................................//

// Author: Ulrich Roegelein

// uses: <saputilities.js>

VBI.ResourceManager = (function() {
	"use strict";
	/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
	var resourcemanager = {};

	// this is the dummy image used when data is missing......................//
	resourcemanager.m_DummyData = "iVBORw0KGgoAAAANSUhEUgAAABcAAAAfCAYAAAAMeVbNAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3FpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NDkxMSwgMjAxMy8xMC8yOS0xMTo0NzoxNiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowNzUzN2NlNC1jZDhiLTE5NDQtYTQ0Ni01MTkxY2RjZDI4MDUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6Q0YzODU2OThGNEM3MTFFNDlBRDQ5OUJGNUQ2N0Q4NjMiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6Q0YzODU2OTdGNEM3MTFFNDlBRDQ5OUJGNUQ2N0Q4NjMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOmRiODhkOTNmLThiOTAtNDg0Zi1iMjljLThjNTEwOTYxZDNlOCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDowNzUzN2NlNC1jZDhiLTE5NDQtYTQ0Ni01MTkxY2RjZDI4MDUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4LelIfAAADWklEQVR42qyWbUhTYRTHz+7UvTRfZls4FWe+a74wl1EfbFJpfsiMQjAlIcm3vhTUhyIl0KIvJRSF1ocoA78YSIhoJLalYoEvBb3oB80NlkYFLi1sNtc513un5jbn3IH/fc69z93vOXue85z7COx2O2xgR1A5qGxUFOojqg/1AjXg7ocCqNU77bA36K5hk4fKcvN7A6oNdc9Zp58TaC42t1BpdD9knoOnH76B/rMFTJYFSFFug9w4ORSlKiFGLtbhK6RC1BmUyWXkCL6PTSX5/UYL1PZMgWFq1mnIQkYARbuU0HAoGuJCJfTIgjqIGl4HR3ATNtW2JTvU641w3WAC8jeyIJEQmo4mQEn6Dv7Rbn4AhgNrCUxrW94+DvUvjR6ByX7+sUFp2ye4PWjmH7XQH3PA0erpcue1GVrefgVv7EL3BD+FKai77LRgKu7FdvD770WIbXzDRuKtZYTJYPSsFgSC5WShyAvIezQysyUw2buZeXhldCRAAcNtDugY/wG+sI4xByeb4BryRr7M+wQ+Ou3gaAgu+2W1wbzV5hP49JyVd1Vstiz8XQJf2SqWiIUHi/18Bg9ZYVkIbvLDrawOEfsEHrNcCsgmCT7E7tmIQJ/AM1Uy3h1huNoM+fFyn8Dz40N5t4/g3eQdS1ZAgFCwtSmRi0GzEnk/I6gzjKHTq5D6szV6K1aZFc5vfSpeS3zhoq8J1OrUQIvrjVHGVWWp+NsHjqqI0Tdjo09SSqE8M8wr+OX9UXwadvLfVmZV/0O6XD0QDYEi4abAiQopnN8Xwd/e4B0HHKN/gk1XeGAA3MyP9RhM09hyIglEbIFlAxxYB+fsIl0qtCooxOzxxK7oomBPJLtH6NNWvbpvDRyjpzNJM6344+OJkKCQuAXnxsqhLkfN315CLbqEcwPUYNNKq995Kg3kEud1JxkXv604hT0FcNnR8/87jIugTtOJio4Mz0pTQeq/9rXIIBE7MFfwWlFVziBO4Ri9lRvgfbY6GNpLUkHCDaDCBe8tz4CdcrbQ0e4uczVtjMtzXp3BzJ2kJvLwhNVVlgaZ4TLor9BA/HZ2LWgaTqJsm4ZzA0xic5gOn7roEBiu0bL1A+05qhj7Z92m6UaphoAJPDSlo9vIfcz78Nk5T9L0nwADACJ96CJRTtd4AAAAAElFTkSuQmCC";

	return resourcemanager;
})();

//  

VBI.Resources = function() {
	"use strict";
	var resources = {};

	resources.m_resourcedata = [];
	resources.m_resourceinstance = [];

	resources.clear = function() {
		// clear instances and data............................................//
		resources.m_resourcedata = [];
		resources.m_resourceinstance = [];
	};

	// load the resources specified in the application area...................//

	resources.load = function(dat, ctx) {
		// load the json delta data............................................//
		if (dat.Set) {
			// todo: process different kinds of set to enable delta
			resources.clear();

			var res = dat.Set.Resource;
			if (jQuery.type(res) == 'object') {
				resources.m_resourcedata[res.name] = res.value;
			} else if (jQuery.type(res) == 'array') {
				// load from array...............................................//
				for (var nJ = 0, len = res.length; nJ < len; ++nJ) {
					resources.m_resourcedata[res[nJ].name] = res[nJ].value;
				}
			}
		}
	};

	resources.GetData = function(name) {
		return resources.m_resourcedata[name];
	};

	resources.GetImageBits = function(name, rhls1, rhls2, lcb) {
		var ri, nname = name;
		if (rhls1) {
			nname += rhls1;
		}
		if (rhls2) {
			nname += rhls2;
		}

		ri = resources.m_resourceinstance[name];
		if (ri && ri.m_Bits) {
			return ([
				ri.m_Bits, ri.m_Image.naturalWidth, ri.m_Image.naturalHeight
			]); // everything created
		}

		// todo: use the color shifted image to be precise, currently the original image is used
		var img = resources.GetImage(name, null, null, lcb);
		if (img) {
			var imageData = VBI.Utilities.GetImagePixelData(img).data;
			resources.m_resourceinstance[name].m_Bits = imageData;
			return ([
				resources.m_resourceinstance[name].m_Bits, img.naturalWidth, img.naturalHeight
			]);
		}
		return null;
	};

	resources.GetImage = function(name, rhls1, rhls2, lcb) {
		var ri, rd;

		var imgType = "";
		if (name != undefined) {
			var dotPos = name.lastIndexOf(".");
			if (dotPos >= 0) {
				imgType = "/" + name.substring(dotPos + 1);
			}
		}

		var nname = name;
		if (rhls1) {
			nname += rhls1;
		}
		if (rhls2) {
			nname += rhls2;
		}
		// the hue shifted image is stored under the name + the rhls1 string + th rhls2 string
		ri = resources.m_resourceinstance[nname];
		if (ri && ri.m_Image) {
			return ri.m_Image; // everything created
		}

		// try to create the resource..........................................//
		if (ri) {
			// try to parse rhls1...............................................//
			if (rhls1 || rhls2) {
				ri.m_Image = VBI.Utilities.CreateDOMColorShiftedImageFromData(resources.m_resourcedata[name], imgType, rhls1, rhls2, lcb);
				return (ri.m_Image);
			}
			ri.m_Image = VBI.Utilities.CreateDOMImageFromData(resources.m_resourcedata[name], imgType, lcb);
			return (ri.m_Image);
		} else {
			var bResFound = (rd = resources.m_resourcedata[name]);
			if (!bResFound) {
				if (VBI.m_bTrace) {
					VBI.Trace("resource not found; default image loaded");
				}
				imgType = '/png';
				rd = VBI.ResourceManager.m_DummyData;
			}
			// try to parse rhls1...............................................//
			if (rhls1 || rhls2) {
				resources.m_resourceinstance[nname] = {
					m_Image: VBI.Utilities.CreateDOMColorShiftedImageFromData(rd, imgType, rhls1, rhls2, lcb)
				};
				return resources.GetImage(name, null, null, lcb); // Hot Stated Image not yet there, so we take normal one. Will be updated with
				// next onLoad
			}

			return (resources.m_resourceinstance[nname] = {
				m_Image: VBI.Utilities.CreateDOMImageFromData(rd, imgType, lcb)
			}).m_Image;
		}
	};

	return resources;
};
/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
VBI.SupportedUnitsOfLength = [
	{
		RequestedUnit: "km",
		DisplayUnitDefault: "m",
		DisplayUnit2: "km",
		ConvFactor: 1000.0,
		ConvFactorMeter: 1.0
	}, {
		RequestedUnit: "mi",
		DisplayUnitDefault: "ft",
		DisplayUnit2: "mi",
		ConvFactor: 5280.0,
		ConvFactorMeter: 0.3048
	}, {
		RequestedUnit: "nm",
		DisplayUnitDefault: "ft",
		DisplayUnit2: "nm",
		ConvFactor: 6076.12,
		ConvFactorMeter: 0.3048
	}
];
VBI.Scale = function() {
	"use strict";
	var scale = {};
	scale.scene = null;
	scale.m_ID = null;
	scale.m_Image = null;
	scale.m_CurrentUnit = null;
	scale.m_DisplayUnit = null;
	scale.m_nDivider = 0;
	scale.m_nScalerLength = 0;
	scale.m_nDistance = 0;
	scale.m_bRtl = false;
	scale.clear = function() {

		var item = document.getElementById(scale.m_canvas.id);
		if (item) {
			item.parentNode.removeChild(item);
		}

		scale.m_Image = null;
		// remove scene reference..............................................//
		scale.scene = null;
	};

	scale.Awake = function(scene, target) {
		scale.scene = scene;
		var l_vbiObj = jQuery.sap.byId(target);
		scale.m_ID = jQuery(l_vbiObj).attr('id');
		scale.AppendCanvas();
	};

	scale.getId = function(a, b) {
		return b + '-' + a;
	};

	scale.AppendCanvas = function() {
		scale.m_bRtl = (document.dir == 'rtl') ? true : false;
		scale.m_canvas = document.createElementNS("http://www.w3.org/2000/svg", "svg");
		scale.m_canvas.setAttribute("class", "vbi-scale");
		scale.m_canvas.setAttribute("id", scale.getId('vbi-scale-canvas', scale.m_ID));
		scale.m_canvas.m_VBIType = "S";

		scale.scene.m_MapDecoDiv.appendChild(scale.m_canvas);
	};

	scale.getConfig = function() {
		if (scale.m_CurrentUnit) {
			return scale.m_CurrentUnit;
		} else {
			var context = scale.scene.m_Ctx;
			var config, unit;
			if (context) {
				config = context.GetConfig();
			}
			if (config) {
				unit = config.GetData("UnitOfLength");
			}
			if (unit) {
				for (var nJ = 0; nJ < VBI.SupportedUnitsOfLength.length; ++nJ) {
					if (VBI.SupportedUnitsOfLength[nJ].RequestedUnit == unit) {
						scale.m_CurrentUnit = VBI.SupportedUnitsOfLength[nJ];
						break;
					}
				}
			}
		}
		if (!scale.m_CurrentUnit) {
			scale.m_CurrentUnit = VBI.SupportedUnitsOfLength[0];
		}
		return scale.m_CurrentUnit;
	};

	scale.getImage = function(lcb) {
		if (scale.m_Image) {
			return scale.m_Image;
		}

		var img = new Image();
		if (lcb) {
			img.onload = function() {
				if (typeof lcb === 'function') {
					lcb(img);
				}

				this.onload = null;
			};
		}

		img.src = sap.ui.resource("sap.ui.vbm", "themes/base/img/sapvisualbusiness.png");
		scale.m_Image = img;
		return img;
	};

	scale.CalcScaleDimensions = function() {
		if (scale.scene.m_Canvas[0].m_nCurrentLOD < 1) {
			return false;
		}
		var rect = scale.scene.GetInternalDivClientRect();

		var currentUnit = scale.getConfig();
		var ptStart = [
			parseInt(rect.width / 2 - 75, 10), parseInt(rect.height / 2, 10)
		];
		var ptMax = [
			ptStart[0] + 180, ptStart[1]
		];

		var dist = scale.scene.GetDistance(ptStart, ptMax);
		var displayDist;
		// convert to requested unit of length
		dist = dist * (1.0 / currentUnit.ConvFactorMeter);
		if (dist >= currentUnit.ConvFactor) {
			displayDist = parseInt(dist / currentUnit.ConvFactor, 10);
			scale.m_DisplayUnit = currentUnit.DisplayUnit2;
		} else {
			displayDist = dist;
			scale.m_DisplayUnit = currentUnit.DisplayUnitDefault;
		}

		var logarithm = parseInt(Math.log(displayDist) / Math.LN10, 10);

		displayDist = parseInt(displayDist / Math.pow(10, logarithm), 10);
		if (displayDist < 2) {
			displayDist = 1;
		} else if (displayDist < 5) {
			displayDist = 2;
		} else if (displayDist < 10) {
			displayDist = 5;
		}
		displayDist = parseInt(displayDist * Math.pow(10, logarithm), 10);

		// convert back
		var displayDistConv; // converted back into meters
		if (dist >= currentUnit.ConvFactor) {
			displayDistConv = displayDist * currentUnit.ConvFactor;
			displayDistConv = displayDistConv * currentUnit.ConvFactorMeter;
		} else {
			displayDistConv = displayDist * currentUnit.ConvFactorMeter;
		}

		// convert point to canvas ( apply offset )

// var ptStartOffset = [
// ptStart[0] - scale.scene.m_Canvas[0].getPixelLeft(), ptStart[1] - scale.scene.m_Canvas[0].getPixelTop()
// ];
		var ret = scale.scene.GetTargetPointForDistance(displayDistConv, ptStart);
		var ptEnd = [
			ret[0] + scale.scene.m_Canvas[0].getPixelLeft(), ret[1] + scale.scene.m_Canvas[0].getPixelTop()
		];

		// calculate the divider
		var tempDist = displayDist;
		var nDivider = 0;
		while (nDivider == 0 && tempDist > 0) {
			nDivider = tempDist % 5;
			tempDist /= 10;
		}
		if (nDivider != 2) {
			nDivider = 5;
		}

		// the scaler length
		var nScalerLength = Math.round(ptEnd[0] - ptStart[0]);

		// cross check
		// var nScalerLengthWithoutCorr = parseInt(((ptMax[0] - ptStart[0]) * displayDistConv) / dist, 10);

		if (nScalerLength > 60 && nScalerLength < (rect.right - rect.left)) {
			scale.m_nScalerLength = nScalerLength;
			scale.m_nDistance = displayDist;
			scale.m_nDivider = nDivider;
			return true;
		}

		return false;

	};

	scale.Update = function() {
		//Update the scale dimensions
		scale.CalcScaleDimensions();

		//pixelLength means how many pixels long the scale bar should be;
		//We perform division by 2 on both the scale bar length and the
		//real-world distance so the bar becomes smaller. This is done for
		//design & aesthetics purposes.
		var pixelLength = (scale.m_nScalerLength + scale.m_nDivider) / 2,
			//The real-world distance represented by the scale bar.
			distance = scale.m_nDistance / 2;

		//creating the svg container where the scale will be rendered
		var svg = document.getElementById(scale.m_canvas.id);
		if (svg) {
			
			svg.setAttribute("height", 15);
			svg.setAttribute("width", pixelLength + 1);
			//Clearing the previous scale
			jQuery(svg).empty();
		

			//This is the actual scale bar
			var path = document.createElementNS("http://www.w3.org/2000/svg", "path");
			path.setAttribute("d", "M 1 4 V 10 H " + pixelLength + " V 4");
			path.setAttribute("stroke", "black");
			path.setAttribute("stroke-width", 2);
			path.setAttribute("fill", "none");
			svg.appendChild(path);
	
			//This is the scale text. For example: "500 km"
			var text = document.createElementNS("http://www.w3.org/2000/svg", "text");
			//How far from the right/left edge we position the text
			var textPositionX;
			//calculating position differently if we are in right-to-left mode
			if (document.dir === "rtl") {
				textPositionX = (distance.toString().length + scale.m_DisplayUnit.length + 1) * 6 + 2;
			} else {
				textPositionX = pixelLength - 2 - (distance.toString().length + scale.m_DisplayUnit.length + 1) * 6;
			}
	
			text.setAttribute("x", textPositionX);
			text.setAttribute("y", 8);
			text.setAttribute("font-size", 10);
			text.textContent = distance + " " + scale.m_DisplayUnit;
			svg.appendChild(text);
		}
	};

	return scale;
};
// ...........................................................................//
// this module does the label handling.......................................//

// Author: Martina Gozlinski, extraction by Jürgen

// ...........................................................................//
// defines...................................................................//
/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
VBI.InputModeDefault = 0; // standard mode.............................//
VBI.InputModeTrackObject = 1; // objects handles or boxes are tracked
VBI.InputModeTrackMap = 2; // map is tracked
VBI.InputModeTrackDesign = 3; // objects are designed/drawn
VBI.InputModeRectSelect = 4; // rectangular selection mode
VBI.InputModeLassoSelect = 5; // lasso selection mode
VBI.InputModeRectZoom = 6; // rectangular zoom mode

// ...........................................................................//
// the scene manager manages the scene instances in a component context......//
VBI.SceneManager = function() {
	"use strict";
	var scenemanager = {};
	scenemanager.vbiclass = "SceneManager";
	scenemanager.m_SceneArray = [];

	// finding................................................................//
	scenemanager.find = function(name) {
		// the scene array.....................................................//
		for (var nJ = 0; nJ < scenemanager.m_SceneArray.length; ++nJ) {
			if (scenemanager.m_SceneArray[nJ].m_ID == name) {
				return scenemanager.m_SceneArray[nJ];
			}
		}
		return null;
	};

	// clearing...............................................................//
	scenemanager.clear = function() {
		// clear the scene array...............................................//
		for (var nJ = 0; nJ < scenemanager.m_SceneArray.length; ++nJ) {
			scenemanager.m_SceneArray[nJ].clear();
		}

		// reset array
		scenemanager.m_SceneArray = [];
	};

	scenemanager.load = function(dat, ctx) {
		if (dat.Set) {
			scenemanager.loadScenes(dat.Set, false, dat, ctx);
		}
		if (dat.Merge) {
			scenemanager.loadScenes(dat.Merge, true, dat, ctx);
		}
	};

	scenemanager.loadScenes = function(setNode, bIsMerge, dat, ctx) {
		if (jQuery.type(setNode) == 'array') {
			for (var nJ = 0; nJ < setNode.length; ++nJ) {
				scenemanager.loadScene(setNode[nJ], bIsMerge, dat, ctx);
			}
		} else {
			scenemanager.loadScene(setNode, bIsMerge, dat, ctx);
		}
	};

	scenemanager.loadScene = function(mainNode, bIsMerge, dat, ctx) {
		// loading from the project file..........................................//
		var scene;
		var bReawakeRequired = false;

		if (mainNode.name) {
			// set a scene by name........................................//
			scene = scenemanager.find(mainNode.name);
			if (scene) {
				// clear the scene before reloading........................//
				if (!bIsMerge) {
					scene.clear();
				}
				// reload the scene........................................//
				if (mainNode.SceneGeo) {
					bReawakeRequired = scene.load(mainNode.SceneGeo, ctx, bIsMerge);
				} else if (mainNode.Scene3D) {
					bReawakeRequired = scene.load(mainNode.Scene3D, ctx, bIsMerge);
				} else {
					bReawakeRequired = scene.load(mainNode.Scene, ctx, bIsMerge);
				}
				if (bReawakeRequired) { // only if layerstack is changed in a GeoScene.Merge
					scene.ReAwake();
				}
				return;
			}
		} else if (!bIsMerge) {
			// clear all scenes...........................................//
			scenemanager.clear();
		}

		if (mainNode.SceneGeo) {
			scenemanager.loadNewScene(mainNode.SceneGeo, 'geo', ctx);
		} else if (mainNode.Scene3D) {
			scenemanager.loadNewScene(mainNode.Scene3D, '3d', ctx);
		} else if (mainNode.Scene) {
			scenemanager.loadNewScene(mainNode.Scene, 'default', ctx);
		}

	};

	scenemanager.loadNewScene = function(sceneNode, sceneType, ctx) {
		var scene = null;
		if (jQuery.type(sceneNode) == 'object') {
			// create the new scene load it and add it to the scene manager
			if (sceneType == 'geo') {
				scene = new VBI.GeoScene(null, null, null);
			} else if (sceneType == '3d') {
				scene = new VBI.Scene3D(null);
			} else {
				scene = new VBI.Scene(null, null, null);
			}

			scene.load(sceneNode, ctx);
			scenemanager.Add(scene);
		} else if (jQuery.type(sceneNode) == 'array') {
			// load array of scenes
			for (var nJ = 0; nJ < sceneNode.length; ++nJ) {
				// create the new scene load it and add it to the scene manager
				scene = null;
				if (sceneType == 'geo') {
					scene = new VBI.GeoScene(null, null, null);
				} else if (sceneType == '3d') {
					scene = new VBI.Scene3D(null);
				} else {
					scene = new VBI.Scene(null, null, null);
				}
				scene.load(sceneNode[nJ], ctx);
				scenemanager.Add(scene);
			}
		}
	};

	// functions..............................................................//
	scenemanager.Add = function(scene) {
		scenemanager.m_SceneArray.push(scene);
	};

	// access a specific scene inside vbi.....................................//
	scenemanager.GetScene = function(target) {
		for (var i = 0; i < scenemanager.m_SceneArray.length; ++i) {
			if (scenemanager.m_SceneArray[i].m_TargetName == target) {
				return scenemanager.m_SceneArray[i];
			}
		}
		return null; // scene not known
	};

	// access a specific scene by name........................................//
	scenemanager.GetSceneByName = function(name) {
		for (var i = 0; i < scenemanager.m_SceneArray.length; ++i) {
			if (scenemanager.m_SceneArray[i].m_ID == name) {
				return scenemanager.m_SceneArray[i];
			}
		}
		return null; // scene not known
	};

	return scenemanager;
};

// ..........................................................................//
// Scene object..............................................................//

VBI.Scene = function(target) {
	"use strict";
	var scene = {};
	scene.vbiclass = "Scene";
	scene.m_TargetName = target;

	scene.m_EvtCont = new VBI.Events(); // publish subscribe container........//

	scene.m_ID = "";
	scene.m_Ctx = null; // application context of scene
	scene.m_Div = null; // the div dom element associated with the scene
	scene.m_Parent = null; // the window in which the scene is hosted

	scene.m_CaptureVO = null; // the vo that currently captures mouse
	scene.m_DesignVO = null; // the vo that is currently used for design

	// input
	scene.m_VOS = []; // visual objects
	scene.m_Events = null; // event handling instance
	scene.m_Proj = null; // Projection
	scene.m_LastDefinedCenterPos = scene.m_LastZoomArea = undefined; // Only ZoomToGeoPositions defines a concrete CenterPos as long as no
	// Zoom/MoveMap occurs

	scene.m_HotItem = {
		m_VO: null,
		m_Index: null,
		m_Design: null,
		m_HitObj: null
	}; // the hot item in the scene and if it is a design handle //
	scene.m_DragInfo = null;

	// assign members.........................................................//
	scene.m_Target = target;
	//for keyboard events
	scene.m_KeysDown = [];
	scene.m_KeysSkipUp = [];
	scene.m_KeysSkipPress = [];

	// base loading function..................................................//
	// this is called by all kind of scenes...................................//

	scene.LoadSingleVO = function(entity, vos, ctx, bIsMerge) {
		if (jQuery.type(entity) == 'object') {
			// load the single object........................................//
			var vo = null;

			if (scene.vbiclass == "3DScene") {
				vo = vos.Factory3D.CreateInstance(entity.type);
			} else {
				vo = vos.Factory.CreateInstance(entity.type);
			}
			vo.m_Scene = scene;
			vo.load(entity, ctx);
			if (bIsMerge) {
				var newID = vo.m_ID;
				for (var i = scene.m_VOS.length; i--;) {
					if (scene.m_VOS[i].m_ID == newID) {
						scene.m_VOS[i] = vo;
						return;
					}
				}
			}

			scene.m_VOS.push(vo);
		}
	};

	scene.BaseLoad = function(dat, ctx, bIsMerge) {
		if (!bIsMerge) {
			// register a keyboard hook............................................//
			VBI.RegisterKeyboardHook();

			// store the application context in the scene..........................//
			// this is necessary to have access to the application context.........//
			scene.m_Ctx = ctx;

			// loading scene members. todo: enhance loading of scene members.......//
			if (dat.id) {
				scene.m_ID = dat.id;
			}
			// load visual objects, these are usually 2d controls with absolute....//
			// positioning.........................................................//
		}

		if (dat.VO) {
			// create the vo and load...........................................//
			var vos = new VBI.VisualObjects();

			if (jQuery.type(dat.VO) == 'array') {
				// load the vo array.............................................//
				for (var nJ = 0; nJ < dat.VO.length; ++nJ) {
					scene.LoadSingleVO(dat.VO[nJ], vos, ctx, bIsMerge);
				}
			} else {
				scene.LoadSingleVO(dat.VO, vos, ctx, bIsMerge);
			}

		}
	};

	scene.BaseClear = function() {
		// clear the vo array..................................................//
		for (var nJ = 0, nlen = scene.m_VOS.length; nJ < nlen; ++nJ) {
			scene.m_VOS[nJ].clear();
		}

		// reset visual objects array..........................................//
		scene.m_VOS = []; // empty visual objects array......//

		// clear scene members.................................................//
		scene.m_Ctx = null;
		scene.m_CaptureVO = null;
		scene.m_DesignVO = null;

		// clean up windows reference to the scene.............................//
		if (scene.m_Parent) {
			scene.m_Parent.m_refSceneInstance = null;
		}
		// reset the hot item..................................................//
		scene.m_HotItem = null;

		if (scene.m_Events) {
			scene.m_Events.clear();
			scene.m_Events = null;
		}

		// unregister a keyboard hook..........................................//
		VBI.UnRegisterKeyboardHook();
	};

	scene.BaseGetVO = function(id) {
		// clear the vo array..................................................//
		for (var nJ = 0, nlen = scene.m_VOS.length; nJ < nlen; ++nJ) {
			if (scene.m_VOS[nJ].m_ID == id) {
				return scene.m_VOS[nJ];
			}
		}
		return null;
	};

	// scene loading..........................................................//
	scene.load = function(dat, ctx, bIsMerge) {
		// call base function..................................................//
		scene.BaseLoad(dat, ctx, bIsMerge);

		return false;
	};

	scene.clear = function() {
		// call clear function.................................................//
		scene.BaseClear();

		scene.m_Div = null;
	};

	scene.VerifyHotItem = function(vo, BBIndex) {
		// verifies that the index has not changed due to rendering
		var hi = scene.m_HotItem;
		if ((BBIndex != hi.m_Index) && (vo == hi.m_VO)) {
			var oRef = vo.m_BBRefs[BBIndex];
			if ((hi.cI == oRef.cI) && (hi.nI == oRef.i)) {
				hi.m_Index = BBIndex;
			}
		}
		scene.m_LastHotItem = undefined;
	};

	scene.CheckHotItem = function() {
		// checks whether the entity has survived a new clustering
		if (this.m_LastHotItem) {
			var oRef = this.m_LastHotItem;
			var InstancesOfVO = (oRef.cI != undefined) ? scene.m_PreassembledData.clust[oRef.cI] : scene.m_PreassembledData.base[scene.m_LastHotItem.m_VO];
			if (InstancesOfVO.m_nRecalcs != oRef.recalcs) {
				scene.InternalSetHotItem(null, null, true);
				this.m_LastHotItem = undefined;
			}
		}
	};

	scene.SetLastHotItem = function(hotItem) {

		// for clustering we have to remember the last hot item during rendering to
		// a) "unhot" it in case it is no more rendered (scene.InvalidateInvisibleHots)
		// b) change index when bounding box index changes (scene.VerifyHotItem)

		if (hotItem.m_VO && hotItem.m_VO.m_BBRefs != undefined) {
			var oRef = hotItem.m_VO.m_BBRefs[hotItem.m_Index];
			var InstancesOfVO = (oRef.cI != undefined) ? scene.m_PreassembledData.clust[oRef.cI] : scene.m_PreassembledData.base[hotItem.m_VO.m_nPreDataIndex];
			scene.m_LastHotItem = {
				cI: oRef.cI,
				i: oRef.i,
				m_VO: hotItem.m_VO.m_nPreDataIndex,
				recalcs: InstancesOfVO.m_nRecalcs
			};
		}
	};

	scene.InvalidateInvisibleHots = function() {
		if (this.m_LastHotItem != undefined) {
			// LastHotItem was not verified -> a) it was from PreassembledData and b) it is no more visible
			var oRef = this.m_LastHotItem;
			var InstancesOfVO = (oRef.cI != undefined) ? scene.m_PreassembledData.clust[oRef.cI] : scene.m_PreassembledData.base[scene.m_LastHotItem.m_VO];
			if (InstancesOfVO[oRef.i] != undefined) {
				InstancesOfVO[oRef.i].h = false;
				scene.InternalSetHotItem(null, null, true);
			}
			this.m_LastHotItem = undefined;
		}
	};

	scene.InternalSetHotItem = function(vo, hitobj, bUnsetAlreadyDone) {
		var hi = scene.m_HotItem;
		var bModified = false;
		var oldIndex = hi.m_Index;
		var oldVO = hi.m_VO;

		// set hot item index..................................................//
		if (hitobj) {
			// copy index.......................................................//
			if (hi.m_Index != hitobj.m_Index) {
				hi.m_Index = hitobj.m_Index;
				bModified = true;
			}

			// copy parts of the design info to the root........................//
			if (hi.m_Design != hitobj.m_Design) {
				hi.m_Design = hitobj.m_Design;
				bModified = true;
			}

			// copy parts of the entity info to the root........................//
			if (hi.m_Entity != hitobj.m_Entity) {
				hi.m_Entity = hitobj.m_Entity;
				bModified = true;
			}
		} else if (hi.m_Entity || hi.m_Detail) {
			// there is no hit object, reset the entity and detail info.........//
			bModified = true;
			hi.m_Entity = null;
			hi.m_Detail = null;
		}

		// set hot item vo.....................................................//
		if (hi.m_VO != vo) {
			hi.m_VO = vo;
			bModified = true;
		}

		// check if the hit object has changed.................................//
		if (!bModified) {
			var ho;
			if (hitobj && (ho = hi.m_HitObj)) {
				if (!jQuery.sap.equal(ho, hitobj, 2)) {
					bModified = true;
				}
			} else if (hitobj != null || hi.m_HitObj != null) {
				bModified = true;
			}
		}

		// store the detail information........................................//
		hi.m_HitObj = hitobj;

		if (bModified) {
			if (oldVO && !bUnsetAlreadyDone) {
				oldVO.InternalChangeHotItem(oldIndex, false, hi); // using PreData? Update value immediately
			}
			if (vo) {
				vo.InternalChangeHotItem(hi.m_Index, true, hi);
			}
			scene.RenderAsync(false); // trigger async rendering when modified
		}

		return bModified;
	};

	scene.InternalRenderVisualObjects = function(canvas, context) {
		// iterate through objects and render them.............................//

		var ts1 = Date.now();
		var aVO = scene.m_VOS;
		VBI.Utilities.BackupFont(context);
		for (var nJ = 0; nJ < scene.m_VOS.length; ++nJ) {
			aVO[nJ].Render(canvas, context);
		}
		VBI.Utilities.RestoreFont(context);
		scene.m_nLastRenderingTime = Date.now() - ts1;
	};

	scene.Render = function() {
	};

	scene.Awake = function(target) {
		// render the visual objects of the scene..............................//
		scene.InternalRenderVisualObjects(null, scene.m_Ctx);
	};

	scene.NotifyDataChange = function() {
		// notify all vo's about a datacontext change..........................//
		for (var nJ = 0; nJ < scene.m_VOS.length; ++nJ) {
			scene.m_VOS[nJ].NotifyDataChange(scene.m_Ctx);
		}
		scene.m_nDataVersion++;
	};

	scene.GetPointArrayFromPosArray = function(posarray, adjust) {
		// zutun: implementation for non geo scene..............................//
		return posarray;
	};

	scene.GetPosFromPoint = function(pt) {
		// zutun: implementation for non geo scene..............................//
		return pt;
	};

	scene.GetPointFromPos = function(pos, adjust, bIgnoreStretch) {
		// determine the pixel point in the canvas from a position vector......//
		// in the geoscene the GetPointArrayFromPosArray is overwritten so the.//
		// input is expected to be a lon/lat/height while in a 3d/2d scene it..//
		// should be the projected point.......................................//
		return scene.GetPointArrayFromPosArray(pos, adjust, bIgnoreStretch);
	};

	// ........................................................................//
	// helper functions.......................................................//

	scene.GetInternalDivClientRect = function() {
		var rect = scene.m_Div.getBoundingClientRect();
		if (this.m_Ctx.moThumbnail && this.m_Ctx.moThumbnail.nOrgWidth && this.m_Ctx.moThumbnail.nOrgHeight) {
			return {
				left: rect.left,
				top: rect.top,
				width: scene.m_Ctx.moThumbnail.nOrgWidth,
				height: scene.m_Ctx.moThumbnail.nOrgHeight,
				right: rect.left + scene.m_Ctx.moThumbnail.nOrgWidth,
				bottom: rect.top + scene.m_Ctx.moThumbnail.nOrgHeight
			};
		}
		return rect;
	};

	scene.GetEventVPCoords = function(event) {
		// returns the relative pixel coordinates to the viewport of the.......//
		// provided event......................................................//
		if (!event) {
			return [
				0, 0
			];
		}

		var rect = scene.GetInternalDivClientRect();
		if (VBI.m_bIsRtl) {
			return [
				rect.right - event.clientX, event.clientY - rect.top
			];

		} else {
			return [
				event.clientX - rect.left, event.clientY - rect.top
			];
		}
	};

	scene.GetEventVPCoordsObj = function(event) {
		// returns the view port coordinates in an object......................//
		var pos = scene.GetEventVPCoords(event);
		return {
			x: pos[0].toString(),
			y: pos[1].toString()
		};
	};

	scene.GetEventVPCoordsObjWithScene = function(event) {
		// returns the view port coordinates in an object......................//
		var pos = scene.GetEventVPCoords(event);
		return {
			x: pos[0].toString(),
			y: pos[1].toString(),
			scene: scene.m_ID
		};
	};

	scene.GetEventDropObjWithScene = function(event) {
		return {
			strSource: scene.m_DragInfo.strScene + "|" + scene.m_DragInfo.strID + "|" + scene.m_DragInfo.strInstance,
			scene: scene.m_ID
		};

	};

	// .......................................................................//
	// do event dispatching...................................................//

	scene.DispatchEvent = function(e, evName) {
		if (VBI.m_bTrace) {
			VBI.Trace("DispatchEvent " + e.type + " as " + evName + " mode:" + scene.m_nInputMode + (scene.m_Gesture ? " gesture active" : ""));
		}

		// when the input mode is tracking, thhere is no dispatching of events.//
		if (scene.m_nInputMode == VBI.InputModeTrackMap) {
			return false;
		}

		var func, eventType = e.type;

		// check for abstract event name.......................................//
		if (evName) {
			e.m_evName = eventType = evName;
		}
		// dispatch the events to the vos......................................//
		e.m_Scene = scene;

		// do some adjustments for offset parameters, usually only done for ff.//
		// and touch events....................................................//
		if (e.offsetX == undefined || e.offsetY == undefined) {
			var rect;
			if (e.clientX !== undefined && e.clientY !== undefined) {
				// due to ff, there is no correct offsetX/Y therefore set it now.//
				rect = e.target.getBoundingClientRect();
				e.offsetX = e.clientX - rect.left;
				e.offsetY = e.clientY - rect.top;
			} else if (e.changedTouches !== undefined && (e.changedTouches.length > 0)) {
				// use the first changed touch as events offset..................//
				// generate clientX and clientY to be able to create submit event//
				rect = e.target.getBoundingClientRect();
				e.clientX = e.changedTouches[0].clientX;
				e.clientY = e.changedTouches[0].clientY;
				e.offsetX = e.clientX - rect.left;
				e.offsetY = e.clientY - rect.top;
			}
		}

		// do adjustments on the keyboard state................................//
		if (e.shiftKey == undefined) {
			e.shiftKey = VBI.m_shiftKey;
		}
		if (e.ctrlKey == undefined) {
			e.ctrlKey = VBI.m_ctrlKey;
		}

		// the design vo is the first one that gets events in the loop.........//
		if (scene.m_DesignVO) {
			if (VBI.m_bTrace) {
				VBI.Trace("DispatchEvent to Design VO");
			}
			if ((func = scene.m_DesignVO["on" + eventType]) && typeof (func) == 'function') {
				// bind the function to the visual objects context, this ensures.//
				// that the this reference points to the vo......................//
				// and call the handler..........................................//
				if ((func.bind(scene.m_DesignVO))(e) == true) {
					return true; // handled
				}
			}
		}

		// when a vo wants to have events first it can capture them, events....//
		// are not further dispatched when the event handler returns true......//
		if (scene.m_CaptureVO) {
			if ((func = scene.m_CaptureVO["on" + eventType]) && typeof (func) == 'function') {
				// bind the function to the visual objects context, this ensures.//
				// that the this reference points to the vo......................//
				// and call the handler..........................................//
				if ((func.bind(scene.m_CaptureVO))(e) == true) {
					return true; // handled
				}
			}
		}

		var idx;
		for (var nJ = 0, len = scene.m_VOS.length; nJ < len; ++nJ) {
			// call the event handler on the objects in reverse order...........//

			idx = len - nJ - 1;
			if ((func = scene.m_VOS[idx]["on" + eventType]) && typeof (func) == 'function') {
				// bind the function to the visual objects context, this ensures.//
				// that the this reference references the vo instance itself.....//
				// and call the handler..........................................//
				if ((func.bind(scene.m_VOS[idx]))(e) == true) {
					return true; // handled
				}
			}
		}

		return false;
	};

	return scene;
};

// ..........................................................................//
// 3DScene object............................................................//

VBI.Scene3D = function(target) {
	"use strict";
	// include 3D library when creating the 3D Scene
	// jQuery.sap.require("sap.ui.vbm.");

	var scene = new VBI.Scene(target); // create scene and specialize.....//

	scene.vbiclass = "3DScene";

	// persisting members.....................................................//
	scene.m_DivCopyright = null;

	scene.m_bMainSceneInitialized = false;
	scene.m_Events = null;
	scene.m_Canvas = []; // canvas elements

	// see discussion in http://stackoverflow.com/questions/6081483/maximum-size-of-a-canvas-element
	scene.m_nMaxCanvasDimension = (VBI.m_bIsMobile ? 6144 : 8192); // all desktop browsers support canvas width/height at least up to 8192

	// clear the scene........................................................//
	scene.clear = function() {
		// call base class.....................................................//
		scene.BaseClear();

		scene.clearCanvases();

		// scene.Remove(); // remove the dom elements

		scene.m_TargetName = null;
		scene.m_Proj = null;

		// remove references to DOM elements...................................//
		scene.m_DivCopyright = null;
		scene.m_Target = null;
	};

	scene.clearCanvas = function(nJ) {
		scene.m_Canvas[nJ].m_Scene = null;
		scene.m_Canvas[nJ] = null;
	};

	scene.clearCanvases = function() {
		// clear the canvas-scene references...................................//
		for (var nJ = 0, nLen = scene.m_Canvas.length; nJ < nLen; ++nJ) {
			scene.clearCanvas(nJ);
		}
		scene.m_Canvas = [];
	};

	scene.Init = function() {
		// if (scene.m_Canvas) {

		// var cnv = scene.m_Canvas[0];
		// var canvasId = cnv.attributes.id.value;

		// do something here
		// }
	};

	scene.InitializeCanvas = function(canvas) {
		// set the scene reference..........................................//
		canvas.m_Scene = scene;

		canvas.m_nCurrentX = undefined;
		canvas.m_nCurrentY = undefined;

		canvas.m_bInvalid = false;

		// set the canvas as a child of the div.............................//
		if (!canvas.m_bNotInDOM) {
			scene.m_Div.appendChild(canvas);
		}
	};

	scene.CreateCanvases = function() {
		scene.m_Canvas.push(VBI.Utilities.Create3DSceneCanvas("layer1", scene.m_nWidthCanvas, scene.m_nHeightCanvas, 2)); // first layer

		for (var nJ = 0; nJ < scene.m_Canvas.length; ++nJ) {
			scene.InitializeCanvas(scene.m_Canvas[nJ]);
		}
	};

	scene.Awake = function(target) {
		if (!(scene.m_Target = VBI.Utilities.GetDOMElement(target))) {
			scene.m_Target = VBI.Utilities.CreateDOMElement(target, "1px", "1px");
		}

		// reuse scene parts...................................................//
		if (scene.m_Div) {
			// when the scenes div's parent is still the place holder, then.....//
			// everything is still fine and we can return.......................//
			if (scene.m_Div.parentNode == scene.m_Target) {
				return;
			}

			// the scenes div is already but the parent is no longer the........//
			// placeholder. In this case we add again the div as a child element//
			scene.m_Target.appendChild(scene.m_Div);
			// if ( scene.m_bNavControlVisible && scene.m_NavControl )
			// //scene.m_NavControl.Awake( scene, target );
			// scene.m_NavControl.AttachEvents();
			return;
		}

		// assign scene information............................................//
		scene.m_TargetName = target;

		// create the viewport.................................................//
		scene.m_Div = VBI.Utilities.Create3DSceneDiv(target + "-3Dscene");

		// set the div as a child of the target................................//
		scene.m_Target.appendChild(scene.m_Div);

		// activate

		// the awakening of the canvases requires the div sizes, if they are not provided
		// behvaiour might be strange. To support a future implementation of a lazy awakening
		// when the div sizes come late this part is put into an own function which may be called
		// from resize also.
		scene.DoAwake(target);
	};

	scene.DoAwake = function(target) {
		// create the viewport.................................................//

		scene.CalculateCanvasDimensions();
		scene.CreateCanvases();

		// initialize the 3D scene
		scene.Init();

		// // append copyright
		// scene.AddCopyright();
		// attach overlay canvas to scene handled events.......................//
		var oCanvas = scene.m_Canvas[0];
		// do event subscriptions..............................................//
		// if( scene.m_Events )
		// scene.m_Events.clear();

		scene.m_Events = new VBI.SceneEvent(this, oCanvas);
		//
		// // awake Navigation Control
		// if ( scene.m_bNavControlVisible && scene.m_NavControl ){
		// scene.m_NavControl.Awake( scene, target );
		// }
		//
		// // awake Scale Control
		// if ( scene.m_bScaleVisible && scene.m_Scale ){
		// scene.m_Scale.Awake( scene, target );
		// }
		//
		// scene.GoToInitialStart();
	};

	scene.CalculateCanvasDimensions = function() {
		var nDummy = scene.m_Target.offsetWidth; // to force browser to have consistent state
		var rect = scene.m_Div.getBoundingClientRect();

		var divWidth = rect.width ? rect.width : scene.m_Div.clientWidth;
		var divHeight = rect.height ? rect.height : scene.m_Div.clientHeight;
		if ((divWidth == scene.m_nDivWidth) && (divHeight == scene.m_nDivHeight)) {
			return; // nothing changed
		}
		if (VBI.m_bTrace) {
			VBI.Trace("Calculating Canvas Dimensions to " + divWidth + "," + divHeight + ", Dummy:" + nDummy);
		}

		scene.m_nDivWidth = divWidth;
		scene.m_nDivHeight = divHeight;
		// scene.m_nWidthCanvas = scene.CalcCanvasWidth ( divWidth, mapMan.m_tileWidth );
		// scene.m_nHeightCanvas = scene.CalcCanvasHeight( divHeight, mapMan.m_tileHeight );

		scene.m_nWidthCanvas = divWidth;
		scene.m_nHeightCanvas = divHeight;

		// VBI.m_bTrace && VBI.Trace("Setting Canvas Size to ("+scene.m_nWidthCanvas+","+scene.m_nHeightCanvas+") on div with size
		// ("+divWidth+","+divHeight+")");
	};

	scene.Render = function() {
		var vo = null;
		var cnt = 0;

		for (var i = scene.m_VOS.length; i--;) {
			vo = scene.m_VOS[i];

			cnt += vo.Render(scene.m_Canvas[0]);
		}

	};

	// when a target is already specified, awake the scene to be alive........//
	if (target) {
		scene.Awake(target);
	}
	return scene;
};

// ..........................................................................//
// GeoScene object...........................................................//

VBI.GeoScene = function(target, mapmanager, maplayerstack) {
	"use strict";
	var scene = new VBI.Scene(target); // create scene and specialize.....//
	scene.vbiclass = "GeoScene";

	// persisting members.....................................................//
	scene.m_RefMapLayerStack = "";
	scene.m_DivCopyright = null;

	scene.m_Canvas = []; // canvas elements
	scene.m_ZoomFactors = [
		1.0, 1.0
	]; // zoom factors
	scene.m_StretchFactors = [
		1.0, 1.0
	]; // zoom factors

	// store the mapmanager and the maplayerstack that should be used.........//
	scene.m_MapManager = mapmanager;
	scene.m_MapLayerStack = maplayerstack;

	// see discussion in http://stackoverflow.com/questions/6081483/maximum-size-of-a-canvas-element
	scene.m_nMaxCanvasDimension = (VBI.m_bIsMobile ? 6144 : 8192); // all desktop browsers support canvas width/height at least up to 8192
	// click handler on scene.................................................//
	scene.Click = null;

	// define overlay index...................................................//
	scene.m_nOverlayIndex = 2;
	scene.m_nLabelIndex = 3;
	scene.m_nNonDomIndex = 4;
	scene.m_nTapCount = 0;

	scene.GetHomeLocation = null;

	scene.m_Touches = []; // touches history, used to detect double tap etc.//

	// event handling members.................................................//
	scene.m_currentMouseX = 0;
	scene.m_currentMouseY = 0;
	scene.m_oldMouseX = 0;
	scene.m_oldMouseY = 0;
	scene.m_currentMouseDownX = 0;
	scene.m_currentTouchCount = 0;
	scene.m_currentMouseDownY = 0;
	scene.m_midPointX = 0;
	scene.m_midPointY = 0;

	scene.m_currentTouchDistance = 0;
	scene.m_nInputMode = VBI.InputModeDefault;

	scene.m_AnimZoomTimer = null; // animation zoom timer

	// initial start position
	scene.m_startPointLonLat = [
		0.0, 0.0
	];
	scene.m_startLOD = 0;

	// Navigation Control
	scene.m_bNavControlVisible = true;
	// scene.m_bNavControlVisible = false;
	scene.m_NavControl = null;
	scene.m_RenderRequestID = 0;

	// Suppressed Navigation
	scene.m_SuppressedNavigation = {
		zoom: false,
		move: false
	};

	// Scale
	scene.m_bScaleVisible = true;
	scene.m_Scale = null;

	// tracking modes
	scene.m_nInitialTrackingMode = VBI.InputModeDefault;
	scene.m_nCanvasXOversize = 2.2; // Canvas is sized floor ( viewport + 2.2 tiles ).
	scene.m_nCanvasYOversize = 2.2; // It should be at least 1.2 tiles available outside the viewport
	scene.m_nCanvasStdXPos = scene.m_nCanvasXOversize / 4;
	scene.m_nCanvasStdYPos = scene.m_nCanvasYOversize / 4;

	scene.m_nTicksInALod = VBI.m_bIsMobile ? 6 : 12; // n mouse scroll ticks are needed to scroll to next lod
	// which leads to the following factors for zoom in / out

	scene.m_nLodFactorZoomIn = Math.pow(2, 1 / scene.m_nTicksInALod);
	scene.m_nLodFactorZoomOut = 1 / scene.m_nLodFactorZoomIn;
	scene.m_nLodFactorZoomInHalf = Math.pow(2, 1 / (2 * scene.m_nTicksInALod));
	scene.m_nLodFactorZoomOutHalf = 1 / scene.m_nLodFactorZoomInHalf;

	scene.m_nMaxAnimLodDiff = 3; // when Lod difference on ZoomMap Animations is bigger than this value we skip tile requests

	scene.m_nZoomMode = 1;

	scene.m_nLastRenderingTime = 0; // from 25 ms onwards we begin to skip rendering steps, if
	scene.m_nRenderTimeTarget = 250; // rendering takes more then 250 ms all intermediate steps are ommited.
	scene.m_nNumOfScalingVOInst = 0;

	scene.m_nLastClusteringTime = 0;
	scene.m_nDataVersion = 0;

	scene.m_bObjCanvasMode = 1;
	scene.m_nlstWidth = scene.m_nlstHeight = 0;
	scene.m_nGetImageDataIncidents = 0;

	// .......................................................................//
	// events.................................................................//

	scene.onTileLoaded = null; // raised when a new tile is loaded

	// clear the scene........................................................//
	scene.clear = function() {
		// call base class.....................................................//
		scene.BaseClear();

		// reset touches array.................................................//
		scene.m_Touches = []; // empty touch event queue.........//

		// remove the scene reference in navigation control....................//
		if (scene.m_NavControl) {
			scene.m_NavControl.clear();
			scene.m_NavControl = null;
		}

		// remove the scene reference in scale control.........................//
		if (scene.m_Scale) {
			scene.m_Scale.clear();
			scene.m_Scale = null;
		}

		// clear timers........................................................//
		scene.clearTimers();
		scene.clearCanvases();

		// remove potential event listeners from document......................//
		scene.SetInputMode(VBI.InputModeDefault);

		scene.Remove(); // remove the dom elements

		// reset object references.............................................//
		scene.m_RefMapLayerStack = "";
		scene.m_MapManager = null;
		scene.m_MapLayerStack = null;
		scene.m_TargetName = null;
		scene.m_Proj = null;

		// remove references to DOM elements...................................//
		scene.m_DivCopyright = null;
		scene.m_Target = null;
	};

	scene.loadSingleRemoveOnScene = function(removeNode, ctx) {
		if (jQuery.type(removeNode) == 'object') {
			switch (removeNode.type) {
				case "VO":
					var id = removeNode.id;
					for (var j = scene.m_VOS.length; j--;) {
						if (scene.m_VOS[j].m_ID == id) {
							scene.m_VOS[j].clear();
							scene.m_VOS.splice(j, 1);
							return;
						}
					}
					break;
				default:
					break;
			}
		}
	};

	scene.loadRemoveOnScene = function(removeNode, ctx) {
		if (jQuery.type(removeNode) == 'array') {
			for (var j = 0; j < removeNode.length; ++j) {
				scene.loadSingleRemoveOnScene(removeNode[j], ctx);
			}
		} else {
			scene.loadSingleRemoveOnScene(removeNode, ctx);
		}
	};

	// scene loading..........................................................//
	scene.load = function(dat, ctx, bIsMerge) {
		var bReawakeRequired = false;
		if (bIsMerge && dat.Remove) {
			scene.loadRemoveOnScene(dat.Remove, ctx);
		}
		// call base loading...................................................//
		scene.BaseLoad(dat, ctx, bIsMerge);

		if (dat.refMapLayerStack) {
			var newLayerStack = ctx.m_MapLayerStackManager.GetMapLayerStack(dat.refMapLayerStack);
			if (scene.m_RefMapLayerStack != newLayerStack) {
				scene.m_RefMapLayerStack = newLayerStack;
				bReawakeRequired = true;
			}
		} else if (VBI.m_bTrace) {
			VBI.Trace("no map layer specified in geo scene");
		}

		if (bIsMerge) {
			return bReawakeRequired; // as of now only exchange of map layer stack is supported
		}

		var minX = -1000, maxX = 1000;
		var minY = -90, maxY = 90;
		scene.m_nMinLodVisualBorder = 0;
		scene.m_nMaxLodVisualBorder = 99;
		scene.m_nOffsetMinLod = 0;
		scene.m_bYBorderExists = false;
		if (dat.VisualFrame) {

			if (dat.VisualFrame.minLon != undefined) {
				minX = dat.VisualFrame.minLon;
			} else {
				minX = (dat.VisualFrame.minX != undefined ? dat.VisualFrame.minX : minX);
			}

			if (dat.VisualFrame.maxLon != undefined) {
				maxX = dat.VisualFrame.maxLon;
			} else {
				maxX = (dat.VisualFrame.maxX != undefined ? dat.VisualFrame.maxX : maxX);
			}

			if (dat.VisualFrame.minLat != undefined) {
				minY = dat.VisualFrame.minLat;
			} else {
				minY = (dat.VisualFrame.minY != undefined ? dat.VisualFrame.minY : minY);
			}

			if (dat.VisualFrame.maxLat != undefined) {
				maxY = dat.VisualFrame.maxLat;
			} else {
				maxY = (dat.VisualFrame.maxY != undefined ? dat.VisualFrame.maxY : maxY);
			}

			if (dat.VisualFrame.minLOD != undefined) {
				scene.m_nMinLodVisualBorder = dat.VisualFrame.minLOD;
			}
			if (dat.VisualFrame.maxLOD != undefined) {
				scene.m_nMaxLodVisualBorder = dat.VisualFrame.maxLOD;
			}
			if (dat.VisualFrame.maxFraction != undefined) {
				scene.m_fMaxMinLODFraction = dat.VisualFrame.maxFraction;
			}
			if (dat.VisualFrame.offsetMinLOD != undefined) {
				scene.m_nOffsetMinLod = dat.VisualFrame.offsetMinLOD;
			}
		}

		scene.m_bXBorderExists = (minX != -1000) || (maxX != 1000);
		scene.m_nBorderMinPoint = VBI.MathLib.DegToRad([
			minX, maxY
		]);
		scene.m_nBorderMaxPoint = VBI.MathLib.DegToRad([
			maxX, minY
		]);

		scene.m_Proj = scene.setProjection();

		var uxyMin = [
			1.0, 1.0
		], uxyMax = [
			1.0, 1.0
		];
		scene.m_Proj.LonLatToUCS(scene.m_nBorderMinPoint, uxyMin);
		scene.m_Proj.LonLatToUCS(scene.m_nBorderMaxPoint, uxyMax);
		scene.m_nXSizeVisualBorder = Math.max(0.0, Math.min(1.0, uxyMax[0] - uxyMin[0]));
		scene.m_nYSizeVisualBorder = Math.max(0.0, Math.min(1.0, uxyMax[1] - uxyMin[1]));

		if (dat.initialStartPosition) {
			var array = dat.initialStartPosition.split(';');
			scene.m_startPointLonLat = VBI.MathLib.DegToRad([
				parseFloat(array[0]), parseFloat(array[1])
			]);
		}

		if (dat.initialZoom) {
			scene.m_startLOD = parseInt(dat.initialZoom, 10);
		}

		// navigation enablement and navigation control visibility
		var SuppressedNavControlVisibility = {
			zoom: false,
			move: false,
			fade: false
		};
		// read properties of navigation enablement
		if (dat.NavigationDisablement) {
			if (dat.NavigationDisablement.zoom) {
				scene.m_SuppressedNavigation.zoom = VBI.Types.string2bool(dat.NavigationDisablement.zoom);
			}
			if (dat.NavigationDisablement.move) {
				scene.m_SuppressedNavigation.move = VBI.Types.string2bool(dat.NavigationDisablement.move);
			}
		}

		// Navigation visibility
		// read properties of NavControl Visibility
		if (dat.navControlVisible) {
			scene.m_bNavControlVisible = VBI.Types.string2bool(dat.navControlVisible);
		}

		SuppressedNavControlVisibility.zoom = scene.m_SuppressedNavigation.zoom;
		SuppressedNavControlVisibility.move = scene.m_SuppressedNavigation.move;

		if (scene.m_SuppressedNavigation.zoom && scene.m_SuppressedNavigation.move) {
			scene.m_bNavControlVisible = false;
		} else if (scene.m_bNavControlVisible) {
			if (dat.SuppressedNavControlVisibility) {
				if (!SuppressedNavControlVisibility.zoom && dat.SuppressedNavControlVisibility.zoom) {
					SuppressedNavControlVisibility.zoom = VBI.Types.string2bool(dat.SuppressedNavControlVisibility.zoom);
				}
				if (!SuppressedNavControlVisibility.move && dat.SuppressedNavControlVisibility.move) {
					SuppressedNavControlVisibility.move = VBI.Types.string2bool(dat.SuppressedNavControlVisibility.move);
				}
				if (dat.SuppressedNavControlVisibility.fade) {
					SuppressedNavControlVisibility.fade = VBI.Types.string2bool(dat.SuppressedNavControlVisibility.fade);
				}
			}
			if (SuppressedNavControlVisibility.move && SuppressedNavControlVisibility.zoom) {
				scene.m_bNavControlVisible = false;
			}
		}

		// Scale
		if (dat.scaleVisible) {
			scene.m_bScaleVisible = VBI.Types.string2bool(dat.scaleVisible);
		}
		if (scene.m_Ctx.moThumbnail) {
			scene.m_SuppressedNavControlVisibility = SuppressedNavControlVisibility;
		} else if (scene.m_bNavControlVisible) {
			scene.m_NavControl = new VBI.NavigationControl(SuppressedNavControlVisibility);
		}
		if (scene.m_bScaleVisible && !scene.m_Ctx.moThumbnail) {
			scene.m_Scale = new VBI.Scale(scene);
		}

		if (dat.rectZoom && VBI.Types.string2bool(dat.rectZoom)) {
			scene.m_nInitialTrackingMode = VBI.InputModeRectZoom;
		} else if (dat.rectSelect && VBI.Types.string2bool(dat.rectSelect)) {
			scene.m_nInitialTrackingMode = VBI.InputModeRectSelect;
		} else if (dat.lassoSelect && VBI.Types.string2bool(dat.lassoSelect)) {
			scene.m_nInitialTrackingMode = VBI.InputModeRectSelect;
		} else {
			scene.m_nInitialTrackingMode = VBI.InputModeDefault;
		}

		return false; // no merge -> no reawake required
	};

	// ........................................................................//
	// scene controlling interface............................................//

	scene.SetInputMode = function(val) {
		// trace current input mode............................................//
		if (VBI.m_bTrace) {
			VBI.Trace("SetInputMode: " + this.m_nInputMode);
		}

		if (this.m_nInputMode == val) {
			return; // input mode did not change..........//
		}
		// process removal of existing input mode..............................//
		switch (this.m_nInputMode) {
			case VBI.InputModeTrackMap:
				scene.SetInputModeTrackMap(false);
				break;
			default:
				break;
		}

		// process setting of new input mode...................................//
		switch (val) {
			case VBI.InputModeTrackMap:
				scene.SetInputModeTrackMap(true);
				break;
			default:
				break;
		}

		// store input mode....................................................//
		this.m_nInputMode = val;
	};

	// ........................................................................//
	// set the tooltip on the canvas..........................................//

	scene.SetToolTip = function(tt, visibility, clientX, clientY) {
		var oCanvas = scene.m_Canvas[scene.m_nLabelIndex];

		if (tt instanceof sap.ui.core.TooltipBase) {
			// In case of RichTooltip, act based on visibility
			if (visibility == true && !tt._getPopup().isOpen()) {
				// open RichTooltip if it is not already open
				var sOffset = (clientX) + " " + (clientY + 20);
				tt.setMyPosition(sap.ui.core.Popup.Dock.BeginTop);
				tt.setAtPosition(sap.ui.core.Popup.Dock.BeginTop);
				tt.setOffset(sOffset);
				tt.setCollision("fit fit");
				tt.openPopup(tt.getParent());
				oCanvas.title = "";
			} else if (visibility == false && tt._getPopup().isOpen()) {
				// close RichTooltip if it is open
				tt.closePopup();
			}
		} else if (oCanvas.title != tt) {
			oCanvas.title = tt;
		}
	};

	scene.SetCursor = function(cc) {
		var oCanvas = scene.m_Canvas[scene.m_nLabelIndex];
		if (oCanvas.style.cursor != cc) {
			oCanvas.style.cursor = cc;
		}
	};

	scene.RenderAsync = function(bForceRecluster) {
		if (bForceRecluster != false) {
			scene.bForceRecluster = true;
		}

		if (!scene.m_RenderRequestID) {
			scene.m_RenderRequestID = window.requestAnimationFrame(scene.DoRender);
		}
	};

	scene.DoRender = function() {
		scene.Render(!scene.bForceRecluster);
	};

	scene.Render = function(suppressReclustering) {
		scene.m_RenderRequestID = 0;
		scene.bForceRecluster = false;
		// render the overlay..................................................//
		if (scene.m_Canvas.length) {
			scene.InternalRenderLayer(scene.m_Canvas[scene.m_nOverlayIndex], false, true, suppressReclustering != true, scene.m_Canvas[0].m_nExactLOD);
		}
	};

	scene.GoToInitialStart = function() {
		if (scene.m_nMaxLodVisualBorder < Math.ceil(scene.GetMinLOD())) {
			scene.m_nMaxLodVisualBorder = Math.ceil(scene.GetMinLOD()); // resolve inconsistant state
		}
		if (!scene.ZoomToGeoPosition(scene.m_startPointLonLat, scene.m_startLOD, true, false, true)) {
			// the target point is outside the allowed are
			var minP = VBI.MathLib.RadToDeg(scene.m_nBorderMinPoint);
			var maxP = VBI.MathLib.RadToDeg(scene.m_nBorderMaxPoint);
			var lons = [
				minP[0], maxP[0]
			];
			var lats = [
				minP[1], maxP[1]
			];

			scene.ZoomToMultiplePositions(lons, lats, 1.1, true);
		}
		scene.RenderAsync(true);
	};

	scene.GetDistance = function(ptStart, ptEnd) {
		var GeoStart = scene.GetPosFromVPPoint(ptStart);
		var GeoEnd = scene.GetPosFromVPPoint(ptEnd);
		return VBI.MathLib.Distance(VBI.MathLib.DegToRad(GeoStart), VBI.MathLib.DegToRad(GeoEnd));

	};
	scene.GetTargetPointForDistance = function(dist, ptStart) {
		var ptGeoStart = VBI.MathLib.DegToRad(scene.GetPosFromVPPoint(ptStart));


		var angle = 90 * Math.PI / 180;

		var lat = Math.asin(Math.sin(ptGeoStart[1]) * Math.cos(dist / VBI.MathLib.earthradius) + Math.cos(ptGeoStart[1]) * Math.sin(dist / VBI.MathLib.earthradius) * Math.cos(angle));
		var lon = ptGeoStart[0] + Math.atan2(Math.sin(angle) * Math.sin(dist / VBI.MathLib.earthradius) * Math.cos(ptGeoStart[1]), Math.cos(dist / VBI.MathLib.earthradius) - Math.sin(ptGeoStart[1]) * Math.sin(lat));
		// double dB_lon = dA_lon + atan2(sin(fYawAngle)*sin(dDistance/EARTH_RADIUS)*cos(dA_lat),
		// cos(dDistance/EARTH_RADIUS)-sin(dA_lat)*sin(dB_lat));
		return (scene.GetPointFromGeo([
			lon, lat
		], false));
	};

	scene.ZoomToMultiplePositions = function(lons, lats, corr, bSuppressRendering) {
		var minMaxX = [];
		var minMaxY = [];
		if (lons.length != lats.length) {
			return;
		}
		var nJ;
		for (nJ = 0; nJ < lons.length; nJ++) {
			var fLon = (parseFloat(lons[nJ]));
			if (fLon < 0) {
				fLon += 360;
			}
			minMaxX.push(fLon);
			minMaxY.push(parseFloat(lats[nJ]));
		}
		if (minMaxX.length != minMaxY.length || !minMaxX.length) {
			return;
		}
		// sort the arrays
		minMaxX.sort(function(a, b) {
			return a - b;
		});
		minMaxY.sort(function(a, b) {
			return a - b;
		});

		var minX = 0, maxX = 0, minY, maxY;
		minY = minMaxY[0];
		maxY = minMaxY[minMaxY.length - 1];
		var dist, from, to, tmp;
		from = minMaxX[minMaxX.length - 1];
		// find the largest distance between two points ( only x-axis )
		for (nJ = 0; nJ < minMaxX.length; nJ++) {
			to = minMaxX[nJ];
			tmp = (to < from ? (to + 360 - from) : (to - from));
			if (dist == undefined || tmp > dist) {
				dist = tmp;
				minX = (to < from ? to + 360 : to);
				maxX = from;
			}
			from = to;
		}
		scene.ZoomToArea(minX, maxX, minY, maxY, corr ? corr : 1.0, true, bSuppressRendering);
	};

	scene.ZoomToAreas = function(areaList, corr) {
		var xLOD = Math.log(scene.m_nDivWidth / (scene.m_MapManager.m_tileWidth * scene.m_nXSizeVisualBorder)) * Math.LOG2E;

		// we call getSurroundingBox with maxXDistShownSeparate == 0, so it adapts to DIV and LOD
		var tg = VBI.MathLib.GetSurroundingBox(areaList, 0, xLOD, scene.CalculateYMinLod, scene.m_bObjCanvasMode == 1 ? 0.5 : 0);

		scene.ZoomToArea(tg[0], tg[1], tg[2], tg[3], corr, true);

		var ts = new Date().getTime(); // overwrite LastZoomArea so ZoomToAreas() may be repeated
		scene.m_LastZoomArea = [
			ts, "Areas", areaList, corr
		];

		return true;
	};

	scene.ZoomTo = function(areaIds, corr) {

		var lat = [], lon = [];

		var zoomToAreaId = function(dataElementValues, vo, lon, lat, areaid) {
			dataElementValues.forEach(getValueofElements.bind(this, areaid, vo, lon, lat));
		 };

		 var getValueofElements = function(areaId, vo, lon, lat, value) {
			 if (areaId === value.m_Value) {
					if (vo.m_Pos) {
						 var pos = vo.m_Pos.GetValueVector(this.m_Ctx);
						 for (var k = 0; k < pos.length / 3; ++k) {
							  lon.push(pos[k * 3 + 0]);
							  lat.push(pos[k * 3 + 1]);
						 }
					}
			   }
		 };

		for (var i = 0; i < this.m_VOS.length; ++i) {
			  var vo = this.m_VOS[i];
			  var node = vo.m_DataSource.GetCurrentNode(this.m_Ctx);
			  if (node && node.m_dataelements.length) {
				   for (var j = 0; j < node.m_dataelements.length; ++j) {

						vo.m_DataSource.Select(j);

						var dataElementValues = node.m_dataelements[j].m_dataattributes;
						areaIds.forEach(zoomToAreaId.bind(this, dataElementValues, vo, lon, lat));
				   }
			  }
		 }
		 if (lon.length) {
			  scene.ZoomToMultiplePositions(lon, lat, corr);
		 }
		 return true;
	};


	//Collects all points from all VO's then calc combined bounding box and then zoome to it
	//corr is the correction factor, if corr is set to 1.0 the bounding box points are exactly on the visible boder of the new area / used for rectangular zoom
	//supressRendering supress the call for async render the map after zoom
	scene.ZoomToAll = function(corr, supressRendering) {
		var lat = [], lon = [];

		for (var i = 0; i < scene.m_VOS.length; ++i) {
			var vo = scene.m_VOS[i];
			var node = vo.m_DataSource ? vo.m_DataSource.GetCurrentNode(scene.m_Ctx) : null; //data provider can be absent

			if (node && node.m_dataelements.length) {
				for (var j = 0; j < node.m_dataelements.length; ++j) {
					vo.m_DataSource.Select(j);

					if (vo.m_Pos) { //array of position(s)
						var pos = vo.m_Pos.GetValueVector(scene.m_Ctx);

						for (var k = 0; k < pos.length / 3; ++k) {
							lon.push(pos[k * 3 + 0]);
							lat.push(pos[k * 3 + 1]);
						}
					} else if (vo.m_PosM) { //multi array of position(s)
						var pos = vo.m_PosM.GetValueVector(scene.m_Ctx);

						for (var k = 0; k < pos.length; ++k) {
							for (var m = 0; m < pos[k].length; ++m) {
								for (var n = 0; n < pos[k][m].length / 3; ++n) {
									lon.push(pos[k][m][n * 3 + 0]);
									lat.push(pos[k][m][n * 3 + 1]);
								}
							}
						}
					}
				}
			}
		}
		if (lon.length) {
			scene.ZoomToMultiplePositions(lon, lat, corr, supressRendering);
		}
	};

	scene.CalculateYMinLod = function(minY, maxY) {
		if (minY == maxY) {
			return 1000;
		}

		var ucsMin = [
			256, 256
		];
		var ucsMax = [
			256, 256
		];

		scene.m_Proj.LonLatToUCS(VBI.MathLib.DegToRad([
			0, minY
		]), ucsMin);
		scene.m_Proj.LonLatToUCS(VBI.MathLib.DegToRad([
			0, maxY
		]), ucsMax);
		var lodY = scene.m_nDivHeight / Math.abs(ucsMax[1] - ucsMin[1]);
		lodY = Math.log(lodY) * Math.LOG2E;

		return lodY;
	};

	scene.ZoomToArea = function(minX, maxX, minY, maxY, corr, bRoundDown, bSuppressRendering) {
		// by standard this method zooms in a way that both points are in the visible area
		// with a distance of 10% to the borders ( corr = 0.9 )
		// if corr is set to 1.0 the points are exactly on the visible boder of the new area / used for rectangular zoom

		var nTileWidth = 256, nTileHeight = 256;
		if (scene.m_MapManager) {
			nTileWidth = scene.m_MapManager.m_tileWidth;
			nTileHeight = scene.m_MapManager.m_tileHeight;
		}

		var theoHeight = scene.m_nDivHeight ? scene.m_nDivHeight : nTileHeight;
		var theoWidth = scene.m_nDivWidth ? scene.m_nDivWidth : nTileWidth;
		var bInsideRectangle;
		var pixelShift;

		if (jQuery.type(corr) == 'array') {
			if (corr.length >= 4) {
				var xCorr = corr[0] + corr[2];
				var yCorr = corr[1] + corr[3];
				if ((xCorr < theoWidth) && (yCorr < theoHeight)) {
					if ((corr[0] != corr[2]) || (corr[1] != corr[3])) {
						pixelShift = [
							(corr[2] - corr[0]) / 2, (corr[3] - corr[1]) / 2
						];
					}
					theoWidth -= xCorr;
					theoHeight -= yCorr;
					bInsideRectangle = ((xCorr < 0) || (yCorr < 0));
				}
			}
		} else {
			theoHeight *= corr;
			theoWidth *= corr;
			bInsideRectangle = (corr > 1.0);
		}
		// calculate midpoint to zoom in
		if (maxX < minX) {
			maxX += 360;
		}

		while (minX > 180) {
			minX -= 360;
		}
		while (maxX > 180) {
			maxX -= 360;
		}

		var min = [
			minX, minY
		];
		var max = [
			maxX, maxY
		];
		min = VBI.MathLib.DegToRad(min);
		max = VBI.MathLib.DegToRad(max);

		var ucsMin = [
			nTileWidth, nTileHeight
		];
		var ucsMax = [
			nTileWidth, nTileHeight
		];
		scene.m_Proj.LonLatToUCS(min, ucsMin);
		scene.m_Proj.LonLatToUCS(max, ucsMax);

		var ucsMiddleX = ucsMin[0] + ucsMax[0] + (ucsMax[0] < ucsMin[0]) * nTileWidth;
		var ucsMiddleY = ucsMin[1] + ucsMax[1];
		var ucsZoomPoint = [
			ucsMiddleX / nTileWidth - 1, ucsMiddleY / nTileHeight - 1
		];
		var zoomPoint = [
			1, 1
		];
		scene.m_Proj.UCSToLonLat(ucsZoomPoint, zoomPoint);

		// calculate the requested lod
		var lodY = 14, lodX = 14; // default value
		if (maxY != minY) {
			lodY = theoHeight / Math.abs(ucsMax[1] - ucsMin[1]);
			lodY = Math.log(lodY) * Math.LOG2E;
		}
		if (maxX != minX) {
			lodX = theoWidth / Math.abs((ucsMax[0] - ucsMin[0]) + (ucsMax[0] <= ucsMin[0]) * nTileWidth);
			lodX = Math.log(lodX) * Math.LOG2E;
		}
		var resultLod = (bInsideRectangle) ? Math.max(lodX, lodY) : Math.min(lodX, lodY);
		if (bRoundDown) {
			resultLod = Math.floor(resultLod);
		}
		scene.ZoomToGeoPosition(zoomPoint, resultLod, false, false, bSuppressRendering, pixelShift);
		if (resultLod != Math.floor(resultLod)) {
			setTimeout(function() {
				scene.AnimateZoomToGeo(zoomPoint, Math.floor(resultLod), 5);
			}, 20);
		}

		var ts = new Date().getTime();
		scene.m_LastZoomArea = [
			ts, "Area", minX, maxX, minY, maxY, corr
		];

	};

	scene.getInfoForCluster = function(ident, type) {
		var params = JSON.parse(ident);
		var clustering = scene.m_Ctx.m_Clustering;

		return clustering.getInfoForCluster(params, type, scene);
	};

	scene.AdaptOtherCanvas = function(uxy, lod, lodDist, nExactLodDist) {
		// adapts the canvas to the new scenario if possible, so we can blend over on filling canvas 1 afterwards and togling
		// if this is not possible, canvas is cleared and 0 is returned so we continue on canvas 0

		var nTarget = lodDist ? 1 : 0; // if stretching fails, target will remain canvas [0]
		var otherCanvas = scene.m_Canvas[1 - nTarget];

		if ((lodDist <= 1) && (lodDist >= -2)) { // we can not stretch the canvas that far to deal with lodDist = 2.
			var otherLodDist = lod - otherCanvas.m_nCurrentLOD;
			var lodFactor = Math.pow(2, -otherLodDist);
			var poslodFactor = Math.max(1, lodFactor);

			var pl = otherCanvas.getPixelLeft(), pt = otherCanvas.getPixelTop();
			var pw = otherCanvas.getPixelWidth(), ph = otherCanvas.getPixelHeight();

			var nOldStretchFactor = pw / scene.m_nWidthCanvas; // equal in other dimension
			var oldUxy = [
				(this.m_MapManager.m_tileWidth * otherCanvas.m_nCurrentX + (scene.m_nDivWidth / 2 - pl) / nOldStretchFactor), (this.m_MapManager.m_tileHeight * otherCanvas.m_nCurrentY + (scene.m_nDivHeight / 2 - pt) / nOldStretchFactor)
			];
			var deltaUxy = [
				oldUxy[0] - lodFactor * uxy[0], oldUxy[1] - lodFactor * uxy[1]
			];

			if ((Math.abs(deltaUxy[0]) < poslodFactor * scene.m_nWidthCanvas) && (Math.abs(deltaUxy[1]) < poslodFactor * scene.m_nHeightCanvas)) {
				var nDistortion = Math.pow(2, nExactLodDist);
				var newpl = nDistortion * (pl - scene.m_nDivWidth / 2 + nOldStretchFactor * deltaUxy[0]) + scene.m_nDivWidth / 2;
				var newpt = nDistortion * (pt - scene.m_nDivHeight / 2 + nOldStretchFactor * deltaUxy[1]) + scene.m_nDivHeight / 2;
				this.MoveCanvas(otherCanvas, newpl, newpt, pw * nDistortion, ph * nDistortion);
				return nTarget;
			}
		}

		return 0; // we target 0 now.
	};

	scene.ZoomToGeoPosition = function(lonlat, lod, doNotCorrectInvalidPositions, bSuppressEvents, bSuppressRendering, pixelShift) {
		if ((lonlat.pixelShift != undefined) && (pixelShift == undefined)) {
			pixelShift = lonlat.pixelShift;
		}
		if (scene.m_Canvas[scene.m_nNonDomIndex].m_bCanvasValid) { // in rare cases the move switch is not yet done so do it
			scene.SwitchTmpCanvasToActive();
		}
		var xShift = 0, yShift = 0;
		var canvas = scene.m_Canvas[0];
		var oldLOD = canvas.m_nExactLOD;
		var nTileWidth = scene.m_MapManager.m_tileWidth;
		var nTileHeight = scene.m_MapManager.m_tileHeight;

		var nExactLod = Math.min(Math.max(lod, scene.GetMinLOD()), scene.GetMaxLOD());
		lod = Math.floor(nExactLod);
		var nRemainingFactor = Math.pow(2, nExactLod - lod);
		var nLodDist = (1 << lod);
		if (pixelShift != undefined) {
			xShift = pixelShift[0] / nRemainingFactor;
			yShift = pixelShift[1] / nRemainingFactor;
		}

		// the zooming position should be in the center of the viewport........//
		// determine the position in pixel space...............................//
		var uxy = [
			nLodDist * nTileWidth, nLodDist * nTileHeight
		];
		scene.m_Proj.LonLatToUCS(lonlat, uxy);

		// determine left upper corner point in pixel space
		var luPoint = [
			uxy[0] - scene.m_nDivWidth / 2 + xShift, uxy[1] - scene.m_nDivHeight / 2 + yShift
		];
		var ucsMinX = scene.m_Proj.m_nUCSMin * nLodDist;

		var nTargetCanvas = scene.AdaptOtherCanvas(uxy, lod, lod - canvas.m_nCurrentLOD, nExactLod - canvas.m_nExactLOD);
		// determine the left top tile number of the canvas....................//
		var newXPos = Math.round(luPoint[0] / nTileWidth - scene.m_nCanvasStdXPos - ucsMinX);
		var newYPos = Math.round(luPoint[1] / nTileHeight - scene.m_nCanvasStdYPos);

		// determine the coordinate in canvas space............................//
		var nUnstretchedLeft = -Math.floor(luPoint[0] - (newXPos + ucsMinX) * nTileWidth);
		var nUnstretchedTop = -Math.floor(luPoint[1] - newYPos * nTileHeight);

		var newLeft = Math.round(nUnstretchedLeft + ((nRemainingFactor - 1) * (nUnstretchedLeft - scene.m_nDivWidth / 2)));
		var newTop = Math.round(nUnstretchedTop + ((nRemainingFactor - 1) * (nUnstretchedTop - scene.m_nDivHeight / 2)));

		var newWidth = Math.round(scene.m_nWidthCanvas * nRemainingFactor);
		var newHeight = Math.round(scene.m_nHeightCanvas * nRemainingFactor);

		// for zoom out we have to check whether we run out of north/south limits. if we would
		// do so we have to adapt newTop and (eventually) newYPos, so we zoom exactly to the limit
		var uxyLU = [
			nLodDist, nLodDist
		];
		var uxyRL = [
			nLodDist, nLodDist
		];
		scene.m_Proj.LonLatToUCS(scene.m_nBorderMinPoint, uxyLU);
		scene.m_Proj.LonLatToUCS(scene.m_nBorderMaxPoint, uxyRL);

		var nNewStretch = newHeight / scene.m_nHeightCanvas;
		var nTargetDistanceToNorthernBorder = nTileHeight * (newYPos - uxyLU[1]) * nNewStretch - newTop;
		var nTargetDistanceToSouthernBorder = nTileHeight * (newYPos - uxyRL[1]) * nNewStretch + scene.m_nDivHeight - newTop;
		var nPosCorrection;

		var bTopChanged = true;
		if (nTargetDistanceToNorthernBorder < -scene.m_nMaxPixelBeyondPoles) {
			newTop = nTileHeight * (newYPos - uxyLU[1]) * nNewStretch + scene.m_nMaxPixelBeyondPoles;
		} else if (nTargetDistanceToSouthernBorder > scene.m_nMaxPixelBeyondPoles) {
			newTop = nTileHeight * (newYPos - uxyRL[1]) * nNewStretch + scene.m_nDivHeight - scene.m_nMaxPixelBeyondPoles;
		} else {
			bTopChanged = false;
		}

		if (bTopChanged) { // Top has changed, but we have to check whether it is still in the allowed range
			// or whether we have to change the position
			if (doNotCorrectInvalidPositions) {
				return false;
			}

			var unstretchedTop = (newTop + (nRemainingFactor - 1) * scene.m_nDivHeight / 2) / nRemainingFactor;
			nPosCorrection = -Math.round(scene.m_nCanvasStdYPos + unstretchedTop / nTileHeight);
			newYPos += nPosCorrection;
			newTop += nRemainingFactor * nPosCorrection * nTileHeight;
		}

		if (scene.m_bXBorderExists) {
			var nTargetDistanceToWestBorder = nTileWidth * (newXPos - uxyLU[0]) * nNewStretch - newLeft;
			var nTargetDistanceToEastBorder = nTileWidth * (newXPos - uxyRL[0]) * nNewStretch + scene.m_nDivWidth - newLeft;

			var bLeftChanged = true;
			if (nTargetDistanceToWestBorder < -scene.m_nMaxPixelBeyondPoles) {
				newLeft = nTileWidth * (newXPos - uxyLU[0]) * nNewStretch + scene.m_nMaxPixelBeyondPoles;
			} else if (nTargetDistanceToEastBorder > scene.m_nMaxPixelBeyondPoles) {
				newLeft = nTileWidth * (newXPos - uxyRL[0]) * nNewStretch + scene.m_nDivWidth - scene.m_nMaxPixelBeyondPoles;
			} else {
				bLeftChanged = false;
			}

			if (bLeftChanged) { // Top has changed, but we have to check whether it is still in the allowed range
				// or whether we have to change the position
				if (doNotCorrectInvalidPositions) {
					return false;
				}

				var unstretchedLeft = (newLeft + (nRemainingFactor - 1) * scene.m_nDivWidth / 2) / nRemainingFactor;
				nPosCorrection = -Math.round(scene.m_nCanvasStdXPos + unstretchedLeft / nTileHeight);
				newXPos += nPosCorrection;
				newLeft += nRemainingFactor * nPosCorrection * nTileWidth;
			}
		}

		var bJustSmallMove = ((canvas.m_nCurrentX == newXPos) && (canvas.m_nCurrentY == newYPos) && (canvas.m_nCurrentLOD == lod));
		if (bJustSmallMove) {
			scene.MoveCanvas(canvas, newLeft, newTop, newWidth, newHeight);
			canvas.m_nExactLOD = nExactLod;
		} else {
			// Clear/Invalidate second canvas as it is outdated anyway
			scene.InvalidateCanvas(scene.m_Canvas[1]);
			if (nTargetCanvas == 0) {
				var context = canvas.getContext("2d");
				context.clearRect(0, 0, canvas.width, canvas.height);
			}

			// we fill canvas 1 in case we can blend over, otherwise canvas 0 directly.
			var canvasNew = scene.m_Canvas[nTargetCanvas];
			// request new tiles into the current canvas...........................//
			scene.MoveCanvas(canvasNew, newLeft, newTop, newWidth, newHeight);
			scene.m_MapManager.RequestTiles(canvasNew, scene.m_MapLayerStack, newXPos, newYPos, scene.m_nTilesX, scene.m_nTilesY, 0, 0, 0, 0, lod, false);

			canvasNew.m_nExactLOD = nExactLod;

			if (nTargetCanvas == 1) {
				scene.ToggleCanvas(scene);
			}
		}
		if (bSuppressRendering != true) {
			scene.InternalRenderLayer(scene.m_Canvas[scene.m_nOverlayIndex], false, !bJustSmallMove, !bJustSmallMove, nExactLod); // if exact lod
		}
		// changed we may
		// re-render

		scene.m_LastDefinedCenterPos = pixelShift ? undefined : lonlat;

		scene.InternalOnMoveLayer(canvas, bSuppressEvents);
		// call internal function to be able to do additional default behavior...//
		if (nExactLod != oldLOD) {
			scene.InternalOnZoomLayer(scene.m_Canvas[scene.m_nOverlayIndex], bSuppressEvents);
		}

		// notify NavControl.................................................//
		if (scene.m_bNavControlVisible && scene.m_NavControl) {
			scene.m_NavControl.AdjustScrollPoint(nExactLod);
		}

		return true;
	};

	scene.RefreshMapLayerStack = function() {
		var name = scene.m_RefMapLayerStack ? scene.m_RefMapLayerStack.m_Name : scene.m_MapLayerStack.m_Name;
		if (name) {
			scene.SetMapLayerStack(name);
			scene.AddCopyright();
		}
	};

	scene.SetMapLayerStack = function(name) {
		var item = scene.m_Ctx.m_MapLayerStackManager.GetMapLayerStack(name);

		if (item == null) {
			return; // do nothing
		}

		if (scene.m_Canvas[scene.m_nNonDomIndex].m_bCanvasValid) {
			scene.SwitchTmpCanvasToActive();
		}
		// set the new layer stack.............................................//
		scene.m_MapLayerStack = item;
		// request new tiles into the current visible canvas...................//
		var canvas = scene.m_Canvas[0];
		scene.m_MapManager.RequestTiles(canvas, scene.m_MapLayerStack, canvas.m_nCurrentX, canvas.m_nCurrentY, scene.m_nTilesX, scene.m_nTilesY, 0, 0, 0, 0, canvas.m_nCurrentLOD, false);
		// set the map layer stack by name.....................................//
		scene.InternalRenderLayer(scene.m_Canvas[scene.m_nOverlayIndex], false, true, true, canvas.m_nCurrentLOD);
	};

	scene.ZoomToZoomlevel = function(lonlat, newZoomLevel, bSuppressEvents) {
		var rectDiv = scene.GetInternalDivClientRect();
		if ((rectDiv.width != scene.m_nDivWidth) || (rectDiv.height != scene.m_nDivHeight)) {
			scene.resizeCanvas(0);
		}

		scene.ZoomToGeoPosition(lonlat, newZoomLevel, false, bSuppressEvents);
	};

	scene.GetMapLayerStack = function() {
		// just return the map layer stack.....................................//
		return scene.m_MapLayerStack;
	};

	scene.GetMinLOD = function() {
		var nSpace = Math.max(scene.m_nDivWidth / (scene.m_MapManager.m_tileWidth * scene.m_nXSizeVisualBorder), scene.m_nDivHeight / (scene.m_MapManager.m_tileHeight * scene.m_nYSizeVisualBorder));
		var nTheoMinimumLod = Math.log(nSpace) * Math.LOG2E;

		var mls = scene.m_MapLayerStack;
		var nCustMinLod = Math.max(scene.m_nMinLodVisualBorder - scene.m_nOffsetMinLod, mls ? mls.GetMinLOD() : 0);

		var act = Math.max(nTheoMinimumLod, nCustMinLod);
		if (scene.m_fMaxMinLODFraction != undefined && (act - Math.floor(act) > scene.m_fMaxMinLODFraction)) {
			return Math.ceil(act);
		}
		return act;

	};

	scene.GetMinLODForWidth = function(width) {
		var nSpace = width / scene.m_MapManager.m_tileWidth;
		var nTheoMinimumLod = Math.log(nSpace) * Math.LOG2E;

		var mls = scene.m_MapLayerStack;
		var nCustMinLod = Math.max(scene.m_nMinLodVisualBorder, mls ? mls.GetMinLOD() : 0) - scene.m_nOffsetMinLod;
		return Math.max(nTheoMinimumLod, nCustMinLod);
	};

	scene.GetMaxLOD = function() {
		var mls = scene.m_MapLayerStack;
		return Math.min(mls ? mls.GetMaxLOD() : 20, scene.m_nMaxLodVisualBorder);
	};

	scene.GetCurrentZoomlevel = function() {
		return scene.m_Canvas[0].m_nExactLOD;
	};

	scene.GetCenterPos = function() {
		// determine the center position on the viewport.......................//
		// in a geo scene this returned in lonlat and radians..................//

		// if available we use the last exact position
		if (scene.m_LastDefinedCenterPos != undefined) {
			return scene.m_LastDefinedCenterPos;
		}
		var cv = scene.getCanvas();
		var point = [
			scene.m_nDivWidth / 2 - cv.getPixelLeft(), scene.m_nDivHeight / 2 - cv.getPixelTop()
		];
		return (scene.GetGeoFromPoint(point));
	};

	// ........................................................................//
	// .internal functions.....................................................//

	scene.InternalRenderVisualObjects = function(canvas, dc, clusterData) {
		// iterate through objects and render them.............................//
		var ts1 = Date.now();
		var aVO = scene.m_VOS;
		var aVOLen = aVO.length;
		var cnt;
		scene.m_nNumOfScalingVOInst = 0;
		VBI.Utilities.BackupFont(dc);
		var shadow, dcs;
		if (clusterData) {
			if (scene.m_nShadowIndex != undefined) {
				shadow = scene.m_Canvas[scene.m_nShadowIndex];
				dcs = shadow.getContext('2d');
				dcs.clearRect(0, 0, shadow.width, shadow.height);
			}
		}
		scene.BuildCacheDataObj();

		for (var nj = 0; nj < aVOLen; ++nj) {
			aVO[nj].Init4Render();
		}

		for (var nJ = 0; nJ < aVOLen; ++nJ) {
			var curVO = aVO[nJ];
			if (curVO.m_Label && curVO.m_Label.length) {
				for (var nK = 0; nK < curVO.m_Label.length; ++nK) {
					curVO.m_Label[nK].clear();
				}
			}
			curVO.m_Label = [];
			if (clusterData) {
				var preData = clusterData.base[nJ];
				curVO.m_nPreDataIndex = nJ;
				cnt = curVO.Render(canvas, dc, preData);
				for (var nC = preData.clusterings.length; nC--;) {
					cnt += curVO.Render(canvas, dc, clusterData.clust[preData.clusterings[nC].i], shadow, dcs, true);
				}
			} else {
				cnt = curVO.Render(canvas, dc);
			}
			if (cnt != undefined) {
				scene.m_nNumOfScalingVOInst += cnt;
			}
		}
		this.InvalidateInvisibleHots();

		// when there is a design vo, we render it on top of everyting else....//
		if (scene.m_DesignVO) {
			scene.m_DesignVO.Render(canvas, dc);
		}
		var labelCanvas = scene.m_Canvas[scene.m_nLabelIndex];
		var dcl = labelCanvas.getContext('2d');
		VBI.Utilities.BackupFont(dcl);
		dcl.clearRect(0, 0, labelCanvas.width, labelCanvas.height);
		scene.InternalRenderLabels(labelCanvas, dcl);

		VBI.Utilities.RestoreFont(dcl);
		VBI.Utilities.RestoreFont(dc);
		scene.DestroyCacheDataObj();
		scene.m_nLastRenderingTime = Date.now() - ts1;
		if (scene.m_Ctx.moThumbnail) {
			scene.Copy2Thumbnail();

		}
		// VBI.Trace("Renderingstep required "+(Date.now()-ts1)+" ms.");
	};

	scene.TriggerReRenderTimer = function(nTime) {
		window.clearInterval(scene.m_ReRenderTimer); // ZooMap is no more guaranteed rendering, so we trigger an asynchronous
		scene.m_ReRenderTimer = window.setInterval( // rendering 100 ms after the last change
		function() {
			window.clearInterval(scene.m_ReRenderTimer);
			scene.m_ReRenderTimer = null;
			if (!scene.m_bNonIntPosStable) {
				scene.m_bNonIntPosStable = Date.now();
			}
			scene.RenderAsync(true);
			if (scene.m_bLineAnimationRunning) {
				scene.TriggerReRenderTimer(15);
			}
		}, nTime);
	};

	scene.AddThumbnailText = function(canvas, thb) {
		var xPos, yPos, xAlign, yAlign;
		var dc = canvas.getContext('2d');
		switch (thb.nFontPos) { // evaluating x-part
			case 2:
			case 3:
			case 4:
				xPos = canvas.width;
				xAlign = "right";
				break;
			case 0:
			case 1:
			case 5:
				xPos = canvas.width / 2;
				xAlign = "center";
				break;
			default: // 6,7,8
				xPos = 0;
				xAlign = "left";
				break;
		}
		switch (thb.nFontPos) { // evaluating y-part
			case 4:
			case 5:
			case 6:
				yPos = canvas.height;
				yAlign = "bottom";
				break;
			case 7:
			case 0:
			case 3:
				yPos = canvas.height / 2;
				yAlign = "middle";
				break;
			default: // case 6 to 8 remains on top
				yPos = 0;
				yAlign = "top";
				break;

		}
		var aCol = VBI.Types.string2rgba(thb.strCol);
		dc.font = thb.strFont;
		dc.fillStyle = dc.strokeStyle = VBI.Utilities.RgbToHex(aCol[0], aCol[1], aCol[2]);
		dc.textAlign = xAlign;
		dc.textBaseline = yAlign;

		dc.fillText(thb.strText, xPos, yPos);
	};

	scene.GetOverlayPicture = function(iMode) {
		var sCanvas;
		var retVal;
		var objCorr = scene.GetStretchFactor4Mode();
		var tmpCanvas = VBI.Utilities.CreateGeoSceneCanvas("temporarynondomlayer", scene.m_nDivWidth, scene.m_nDivHeight, 0, 2);
		var tmpctx = tmpCanvas.getContext("2d");
		if (iMode & 2) { // try to include map canvas
			sCanvas = scene.m_Canvas[0];
			var mapCorr = scene.GetCurrentZoomFactors();
			tmpctx.drawImage(sCanvas, -sCanvas.m_pixelLeft / mapCorr[0], -sCanvas.m_pixelTop / mapCorr[1], scene.m_nDivWidth / mapCorr[0], scene.m_nDivHeight / mapCorr[1], 0, 0, scene.m_nDivWidth, scene.m_nDivHeight);
		}

		sCanvas = scene.m_Canvas[scene.m_nOverlayIndex];
		tmpctx.drawImage(sCanvas, -sCanvas.m_pixelLeft / objCorr[0], -sCanvas.m_pixelTop / objCorr[1], scene.m_nDivWidth / objCorr[0], scene.m_nDivHeight / objCorr[1], 0, 0, scene.m_nDivWidth, scene.m_nDivHeight);

		if (iMode & 1) {
			sCanvas = scene.m_Canvas[scene.m_nLabelIndex];
			tmpctx.drawImage(sCanvas, -sCanvas.m_pixelLeft / objCorr[0], -sCanvas.m_pixelTop / objCorr[1], scene.m_nDivWidth / objCorr[0], scene.m_nDivHeight / objCorr[1], 0, 0, scene.m_nDivWidth, scene.m_nDivHeight);
		}

		try {
			retVal = tmpCanvas.toDataURL("png");
		} catch (e) {
			VBI.Trace(e.message);
			return "";
		}

		return retVal;
	};

	scene.Copy2Thumbnail = function() {
		var thumbnailCanvas = scene.m_Canvas[scene.m_nThumbnailIndex];
		var sCanvas = scene.m_Canvas[0];
		var thctx = thumbnailCanvas.getContext("2d");
		var mapCorr = scene.GetCurrentZoomFactors();
		var objCorr = scene.GetStretchFactor4Mode();
		thctx.clearRect(0, 0, thumbnailCanvas.width, thumbnailCanvas.height);
		thctx.drawImage(sCanvas, -sCanvas.m_pixelLeft / mapCorr[0], -sCanvas.m_pixelTop / mapCorr[1], scene.m_Ctx.moThumbnail.nOrgWidth / mapCorr[0], scene.m_Ctx.moThumbnail.nOrgHeight / mapCorr[1], 0, 0, thumbnailCanvas.clientWidth, thumbnailCanvas.clientHeight);
		sCanvas = scene.m_Canvas[scene.m_nOverlayIndex];
		thctx.drawImage(sCanvas, -sCanvas.m_pixelLeft / objCorr[0], -sCanvas.m_pixelTop / objCorr[1], scene.m_Ctx.moThumbnail.nOrgWidth / objCorr[0], scene.m_Ctx.moThumbnail.nOrgHeight / objCorr[1], 0, 0, thumbnailCanvas.clientWidth, thumbnailCanvas.clientHeight);

		var thb = scene.m_Ctx.moThumbnail;
		if (thb.strFont && thb.nFontPos != undefined && thb.strText) {
			scene.AddThumbnailText(thumbnailCanvas, thb);
		}
		// Labelcanvas not copied to improve visibility
		// sCanvas = scene.m_Canvas[scene.m_nLabelIndex ];
		// thctx.drawImage(sCanvas, -sCanvas.m_pixelLeft/objCorr[0], -sCanvas.m_pixelTop/objCorr[1],
		// parseInt(scene.m_Ctx.moThumbnail.nOrgWidth)/objCorr[0],
		// parseInt(scene.m_Ctx.moThumbnail.nOrgHeight)/objCorr[1], 0, 0, thumbnailCanvas.clientWidth, thumbnailCanvas.clientHeight);
	};

	scene.CopyCanvasAway = function(canvas, target) {
		var labelCanvasDc = target.getContext('2d');
		labelCanvasDc.clearRect(0, 0, target.width, target.height);
		labelCanvasDc.drawImage(canvas, 0, 0, canvas.width, canvas.height);
	};

	scene.UpdatePreData4Selected = function(VOIndex, InstanceIndex) {
		var clustering = scene.m_Ctx.m_Clustering;
		if ((VOIndex != undefined) && clustering) {
			clustering.VerifyCurrentSelection(scene.m_VOS, scene.m_PreassembledData, scene.m_Ctx);
			clustering.AddSingle2Selected(VOIndex, scene.m_VOS, InstanceIndex, scene.m_PreassembledData, scene.m_Ctx);
		}
	};

	scene.UpdatePreData4SelArray = function(selectionArray) {
		var clustering = scene.m_Ctx.m_Clustering;
		if (clustering) {
			clustering.VerifyCurrentSelection(scene.m_VOS, scene.m_PreassembledData, scene.m_Ctx);
			clustering.AddMultiple2Selected(selectionArray, scene.m_VOS, scene.m_PreassembledData, scene.m_Ctx);
		}
	};

	VBI.addSceneLabelFunctions(scene);

	scene.InvalidatePreassembledData = function(clustering, lod) {
		var hotVO = scene.m_HotItem.m_VO;
		var lastHotCluster;
		if (hotVO != undefined && hotVO.IsClusterable()) {
			lastHotCluster = hotVO.SwitchHotItemToStandard();
		}
		scene.m_PreassembledData = undefined;

		if (scene.m_nShadowIndex != undefined) {
			scene.DisableShadowLayer();
		}

		return lastHotCluster;
	};

	scene.DisableShadowLayer = function() {
		var shadow = scene.m_Canvas[scene.m_nShadowIndex];
		var dcs = shadow.getContext('2d');
		dcs.clearRect(0, 0, shadow.width, shadow.height);

		scene.clearCanvas(scene.m_nShadowIndex);
		scene.m_Canvas.splice(scene.m_nShadowIndex, 1);
		scene.m_nShadowIndex = undefined;
	};

	scene.SwitchCanvasSize = function(canvas, newWidth, newHeight) {
		var dims = [
			newWidth, newHeight
		];
		var nSize = dims[0] * dims[1] / 1024;
		if (scene.m_nCanvasMaxPixel < nSize) {
			var fFakt = Math.sqrt(nSize / scene.m_nCanvasMaxPixel);
			dims[0] = Math.floor(dims[0] / fFakt);
			dims[1] = Math.floor(dims[1] / fFakt);
			scene.m_bObjCanvasMode = 2;
		} else {
			scene.m_bObjCanvasMode = 1;
		}

		canvas.width = scene.m_Canvas[scene.m_nLabelIndex].width = dims[0];
		canvas.height = scene.m_Canvas[scene.m_nLabelIndex].height = dims[1];

		if (scene.m_nShadowIndex) {
			scene.m_Canvas[scene.m_nShadowIndex].width = dims[0];
			scene.m_Canvas[scene.m_nShadowIndex].height = dims[1];
		}

		canvas.setPixelWidth(canvas.width);
		canvas.setPixelHeight(canvas.height);

		return dims;
	};

	scene.InternalRenderLayer = function(canvas, bClearLayer, bForceRender, bForceClustering, nNewExactLod, source) {
		var canvas0 = scene.m_Canvas[0];
		var lastHotCluster; // Preserve Info on Hot Item if it is an artifical cluster element
		var clustering = scene.m_Ctx.m_Clustering;
		var clusteringEnabled = ((clustering != undefined) && clustering.m_Clusters.length);
		if ((scene.m_PreassembledData != undefined) && !clusteringEnabled) {
			lastHotCluster = scene.InvalidatePreassembledData(clustering, canvas0.m_nCurrentLOD);
		}
		if ((bForceRender == false) && (nNewExactLod != undefined)) { // we have to check whether rendering is applicable
			var newLOD = Math.floor(nNewExactLod);
			if (nNewExactLod == scene.m_nLastRenderLOD) {
				return; // no zoom step at all -> nothing to be done
			}
			if ((newLOD == Math.floor(scene.m_nLastRenderLOD)) && (nNewExactLod != newLOD && (nNewExactLod > (scene.GetMinLOD() + 0.001)))) {
				var nLodDiff = Math.abs(nNewExactLod - scene.m_nLastRenderLOD);
				if (nLodDiff < scene.m_nLastRenderingTime / scene.m_nRenderTimeTarget) {
					return;
				}
			}
		}
		// whenever the overlay layer is rendered, reset the overlay image data//
		// scene.m_OverlayImageData = null;
		scene.m_OverlayImage = null;

		scene.m_nLastRenderLOD = (nNewExactLod == undefined) ? -1 : nNewExactLod;

		// canvas is the object layer canvas...................................//
		var newX, oldX = canvas.getPixelWidth();
		var newY, oldY = canvas.getPixelHeight();
		if (scene.m_bObjCanvasMode) {
			var newDims = scene.SwitchCanvasSize(canvas, oldX, oldY);
			scene.m_StretchFactors = [
				oldX / newDims[0], oldY / newDims[1]
			];
			scene.m_ZoomFactors = [
				newDims[0] / scene.m_nWidthCanvas, newDims[1] / scene.m_nHeightCanvas
			];
			newX = oldX;
			newY = oldY;
		} else {
			newX = scene.m_nWidthCanvas;
			newY = scene.m_nHeightCanvas;
			canvas.setPixelWidth(newX);
			canvas.setPixelHeight(newY);
			scene.m_ZoomFactors = [
				1, 1
			];
			scene.m_StretchFactors = [
				oldX / scene.m_nWidthCanvas, oldY / scene.m_nHeightCanvas
			];
		}

		var dc = canvas.getContext('2d');

		if (bClearLayer) {
			dc.clearRect(0, 0, canvas.width, canvas.height);

			// resize again.....................................................//
			canvas.setPixelWidth(oldX);
			canvas.setPixelHeight(oldY);
			return;
		}
		var bSwitchOnShadowCanvas = false;
		if (clusteringEnabled) {
			this.SetLastHotItem(scene.m_HotItem);
			var ts1 = Date.now();
			scene.m_PreassembledData = clustering.DoClustering(this, canvas0.m_nCurrentLOD, canvas0.m_nCurrentX, canvas0.m_nCurrentY, scene.m_nTilesX, scene.m_nTilesY, scene.m_VOS, scene.m_Ctx, lastHotCluster, bForceRender, bForceClustering, scene.m_nDataVersion);
			this.CheckHotItem();
			if (scene.m_PreassembledData.config.bNeedsShadowLayer && (scene.m_nShadowIndex == undefined)) {
				scene.m_nShadowIndex = scene.m_Canvas.length;
				scene.m_Canvas.push(VBI.Utilities.CreateGeoSceneCanvas(scene.m_TargetName + "-" + scene.m_ID + "-shadow", newX, newY)); // shadow
				// insert layer
				scene.InitializeCanvas(scene.m_Canvas[scene.m_nShadowIndex], scene.m_Canvas[scene.m_nOverlayIndex]);
				bSwitchOnShadowCanvas = true;
			}
			if (!scene.m_PreassembledData.config.bNeedsShadowLayer && (scene.m_nShadowIndex != undefined)) {
				scene.DisableShadowLayer();
			}

			scene.m_nLastClusteringTime = Date.now() - ts1;
		}
		// render all visual objects in the layer..............................//
		dc.clearRect(0, 0, canvas.width, canvas.height);

		scene.InternalRenderVisualObjects(canvas, dc, scene.m_PreassembledData);
		if (scene.m_bObjCanvasMode != 1) {
			canvas.setPixelWidth(oldX);
			canvas.setPixelHeight(oldY);
		}
		if (bSwitchOnShadowCanvas) {
			scene.MoveCanvas2ObjectCanvas(scene.m_Canvas[scene.m_nShadowIndex]);
		}
		// call event relevant function........................................//
		scene.InternalOnRenderLayer(canvas);
		if (scene.m_Scale) {
			scene.m_Scale.Update();
		}

		if (scene.m_bSwitch2OldCanvasMode && canvas0.m_nExactLOD == Math.round(canvas0.m_nExactLOD)) {
			scene.m_bSwitch2OldCanvasMode = undefined;
			scene.m_bObjCanvasMode = 0;
			VBI.Trace("Switching back to old object canvas rendering style due to performance issues ");
		}
	};

	scene.InternalOnMoveLayer = function(canvas, bSuppressEvents) {
		// a move is done notify windows about the move........................//
		scene.m_Ctx.m_Windows.NotifySceneMove(this);

		// check for subscribed action and raise it............................//
		var actions;
		if ((actions = scene.m_Ctx.m_Actions) && (bSuppressEvents != true)) {
			// check if action is subscribed....................................//
			var action = actions.findAction("CenterChanged", scene, "Map");
			if (action) {
				// determine the boundaries......................................//
				var cv = scene.m_Canvas[scene.m_nOverlayIndex];
				var nPixelWidth = cv.getPixelWidth();
				var nPixelHeight = cv.getPixelHeight();

				// get geo positions of corner points.............................//
				var lt = scene.GetPosFromPoint([
					0, 0
				]);
				var rb = scene.GetPosFromPoint([
					nPixelWidth, nPixelHeight
				]);
				if (!scene.m_Proj.m_bIsIsogonal) { // then we have to check the other corner points also
					var rt = scene.GetPosFromPoint([
						nPixelWidth, 0
					]);
					var lb = scene.GetPosFromPoint([
						0, nPixelHeight
					]);
					lt = [
						Math.min(lt[0], lb[0]), Math.min(lt[1], rt[1])
					];
					rb = [
						Math.max(rt[0], rb[0]), Math.max(lb[1], rb[1])
					];
				}
				// get geo positions for viewport corner points
				var rect = scene.GetInternalDivClientRect();
				var vpOffsetLeft = -cv.getPixelLeft();
				var vpOffsetTop = -cv.getPixelTop();
				var vlt = scene.GetPosFromPoint([
					vpOffsetLeft, vpOffsetTop
				]);
				var vrb = scene.GetPosFromPoint([
					vpOffsetLeft + rect.width, vpOffsetTop + rect.height
				]);

				var params = {
					level: scene.GetCurrentZoomlevel().toString(),
					min: lt[0].toString() + ";" + lt[1].toString() + ";0",
					max: rb[0].toString() + ";" + rb[1].toString() + ";0",
					vpmin: vlt[0].toString() + ";" + vlt[1].toString() + ";0",
					vpmax: vrb[0].toString() + ";" + vrb[1].toString() + ";0"
				};

				scene.m_Ctx.FireAction(action, scene, this, null, params);
			}
		}

		// call into publish subscribe mechanism...............................//
		this.m_EvtCont.fire("onMove", {
			canvas: canvas
		});

		// call into event subscriptions.......................................//
		scene.m_Ctx.onMoveLayer(canvas);
	};

	scene.InternalOnZoomLayer = function(canvas, clickCoords) {
		// a move is done notify windows about the move........................//
		scene.m_Ctx.m_Windows.NotifySceneZoom(this);

		// check if the standard subscription is done and raise the submit.....//
		// event...............................................................//

		// check for subscribed action and raise it............................//
		if (clickCoords != true) { // suppress event mode
			var actions = scene.m_Ctx.m_Actions;
			if (actions) {
				// check if action is subscribed....................................//
				var action = actions.findAction("ZoomChanged", scene, "Map");
				if (action) {
					// determine the boundaries......................................//
					var cv = scene.m_Canvas[scene.m_nOverlayIndex];
					var nPixelWidth = cv.getPixelWidth();
					var nPixelHeight = cv.getPixelHeight();

					// get geo positions of corner points.............................//
					var lt = scene.GetPosFromPoint([
						0, 0
					]);
					var rt = scene.GetPosFromPoint([
						nPixelWidth, 0
					]);
					var lb = scene.GetPosFromPoint([
						0, nPixelHeight
					]);
					var rb = scene.GetPosFromPoint([
						nPixelWidth, nPixelHeight
					]);

					// get geo positions for viewport corner points
					var rect = scene.GetInternalDivClientRect();
					var vpOffsetLeft = -cv.getPixelLeft();
					var vpOffsetTop = -cv.getPixelTop();
					var vlt = scene.GetPosFromPoint([
						vpOffsetLeft, vpOffsetTop
					]);
					var vrb = scene.GetPosFromPoint([
						vpOffsetLeft + rect.width, vpOffsetTop + rect.height
					]);

					var params = {
						level: scene.GetCurrentZoomlevel().toString(),
						min: Math.min(lt[0], lb[0]).toString() + ";" + Math.min(lt[1], rt[1]).toString() + ";0",
						max: Math.max(rb[0], rt[0]).toString() + ";" + Math.max(lb[1], rb[1]).toString() + ";0",
						vpmin: vlt[0].toString() + ";" + vlt[1].toString() + ";0",
						vpmax: vrb[0].toString() + ";" + vrb[1].toString() + ";0"
					};

					if (clickCoords != undefined && clickCoords != false) {
						params.x = clickCoords.x.toString() - rect.left;
						params.y = clickCoords.y.toString() - rect.top;
					}

					scene.m_Ctx.FireAction(action, scene, this, null, params);
				}
			}
		}

		// call into publish subscribe mechanism...............................//
		this.m_EvtCont.fire("onZoom", {
			canvas: canvas
		});

		// call into direct event subscriptions................................//
		scene.m_Ctx.onZoomLayer(canvas);
	};

// .......................................................................//
// scene events and their default implementation..........................//

	scene.InternalOnRenderLayer = function(canvas) {
		// call into event subscriptions.......................................//
		scene.m_Ctx.onRenderLayer(canvas);

		// do some default implementation......................................//
		if (scene.GetHomeLocation) {
			// canvas is the object layer canvas................................//
			var oldX = canvas.getPixelWidth();
			var oldY = canvas.getPixelHeight();

			var lonlat = [
				0, 0
			];
			var homeloc = scene.GetHomeLocation();

			lonlat[0] = homeloc[0];
			lonlat[1] = homeloc[1];

			var xy = scene.GetPointFromGeo(lonlat);

			canvas.setPixelWidth(scene.m_nWidthCanvas);
			canvas.setPixelHeight(scene.m_nHeightCanvas);

			var context = canvas.getContext('2d');
			context.clearRect(0, 0, canvas.width, canvas.height);

			// draw a circle position...........................................//
			context.fillStyle = 'yellow';
			context.beginPath();
			context.arc(xy[0], xy[1], 5, 0, Math.PI * 2, true);
			context.closePath();
			context.fill();

			var image = null;
			if (scene.m_Ctx) {
				image = scene.m_Ctx.GetImage("dummy", scene.RenderAsync.bind());
			}

			if (image) {
				context.drawImage(image, xy[0] - image.naturalWidth / 2, xy[1] - image.naturalHeight);
			}
			// resize again.....................................................//
			canvas.setPixelWidth(oldX);
			canvas.setPixelHeight(oldY);
		}
	};

// .......................................................................//
// helper move functions..................................................//

	scene.MoveObject = function(o, x, y, width, height) {
		o.m_pixelLeft = Math.round(x);
		o.m_pixelTop = Math.round(y);
		o.style.left = o.m_pixelLeft.toString() + "px";
		o.style.top = o.m_pixelTop.toString() + "px";
		if (width !== undefined) {
			o.m_pixelWidth = Math.round(width);
			o.style.width = o.m_pixelWidth.toString() + "px";
		}
		if (height !== undefined) {
			o.m_pixelHeight = Math.round(height);
			o.style.height = o.m_pixelHeight.toString() + "px";
		}
	};

	scene.InvalidateCanvas = function(canvas) {
		var context = canvas.getContext("2d");
		context.fillStyle = 'white';
		context.clearRect(0, 0, canvas.width, canvas.height);
		canvas.m_bInvalid = true;
	};

	scene.MoveCanvas = function(canvas, x, y, width, height) {
		scene.MoveObject(scene.m_Canvas[scene.m_nOverlayIndex], x, y, width, height);
		scene.MoveObject(scene.m_Canvas[scene.m_nLabelIndex], x, y, width, height);
		if (scene.m_nShadowIndex != undefined) {
			scene.MoveObject(scene.m_Canvas[scene.m_nShadowIndex], x, y, width, height);
		}

		scene.MoveObject(canvas, x, y, width, height);
	};

	scene.MoveOnlyThisCanvas = function(canvas, x, y, width, height) {
		scene.MoveObject(canvas, x, y, width, height);
	};

	scene.MoveCanvas2ObjectCanvas = function(canvas) {
		var c2 = scene.m_Canvas[scene.m_nOverlayIndex];
		scene.MoveObject(canvas, c2.m_pixelLeft, c2.m_pixelTop, c2.m_pixelWidth, c2.m_pixelHeight);
	};

	scene.MoveMap = function(dx, dy) {
		if (VBI.m_bTrace) {
			VBI.Trace("MoveMap" + " DX:" + dx + " DY:" + dy);
		}

		var tmpCanvas = scene.m_Canvas[scene.m_nNonDomIndex];
		var canvas = scene.m_Canvas[0];
		var currentCanvas = (tmpCanvas.m_bCanvasValid ? tmpCanvas : canvas);

		var mapMan = scene.m_MapManager;

		var nPixelWidth = currentCanvas.getPixelWidth();
		var nPixelHeight = currentCanvas.getPixelHeight();
		var nPosX = currentCanvas.getPixelLeft() + dx;
		var nPosY = currentCanvas.getPixelTop() + dy;

		var tw = mapMan.m_tileWidth, th = mapMan.m_tileHeight;

		// width of a current tile...........................................//
		var nCurrentTilePixelWidth = nPixelWidth / scene.m_nTilesX;
		var nCurrentTilePixelHeight = nPixelHeight / scene.m_nTilesY;

		var nStretch = nPixelHeight / scene.m_nHeightCanvas;

		// Check whether move goes too far North or too far South
		var nLodDist = (1 << canvas.m_nCurrentLOD);
		var uxyLU = [
			nLodDist, nLodDist
		];
		var uxyRL = [
			nLodDist, nLodDist
		];
		scene.m_Proj.LonLatToUCS(scene.m_nBorderMinPoint, uxyLU);
		scene.m_Proj.LonLatToUCS(scene.m_nBorderMaxPoint, uxyRL);

		if ((dy > 0 && ((th * nStretch * (currentCanvas.m_nCurrentY - uxyLU[1]) - nPosY) < -scene.m_nMaxPixelBeyondPoles)) || (dy < 0 && ((th * nStretch * (currentCanvas.m_nCurrentY - uxyRL[1]) + scene.m_nDivHeight - nPosY) > scene.m_nMaxPixelBeyondPoles))) {
			if (dx == 0) {
				return;
			}
			dy = 0; // on diagonal moves we eliminate just the y-component
			nPosY = currentCanvas.getPixelTop();
		}

		if (scene.m_bXBorderExists && ((dx > 0 && ((tw * nStretch * (currentCanvas.m_nCurrentX - uxyLU[0]) - nPosX) < -scene.m_nMaxPixelBeyondPoles)) || (dx < 0 && ((tw * nStretch * (currentCanvas.m_nCurrentX - uxyRL[0]) + scene.m_nDivWidth - nPosX) > scene.m_nMaxPixelBeyondPoles)))) {
			if (dy == 0) {
				return;
			}
			dx = 0;
			nPosX = currentCanvas.getPixelLeft();
		}

		var nOffsetX = 0;
		var nOffsetY = 0;
		var nTemp;
		//
		// First we determine whether a tile shift is required
		//
		if ((dx > 0) && (nTemp = nPosX + scene.m_nMapMoveXPreLoad) > 0) { // left side is missing tiles, calc number of missed tiles //
			nOffsetX = Math.ceil(nTemp / nCurrentTilePixelWidth);
		} else if ((dx < 0) && ((nTemp = scene.m_nMapMoveXPreLoad + scene.m_nDivWidth - (nPosX + nPixelWidth)) > 0)) { // right side is missing tiles
			// ... //
			nOffsetX = -Math.ceil(nTemp / nCurrentTilePixelWidth);
		}
		var newLeft = currentCanvas.m_nCurrentX - nOffsetX;

		if ((dy > 0) && (nTemp = nPosY + scene.m_nMapMoveYPreLoad) > 0) { // top side is missing tiles ... //
			nOffsetY = Math.ceil(nTemp / nCurrentTilePixelHeight);
		} else if ((dy < 0) && (nTemp = (scene.m_nMapMoveYPreLoad + scene.m_nDivHeight - (nPosY + nPixelHeight))) > 0) { // bottom side is missing
			// tiles ... //
			nOffsetY = -Math.ceil(nTemp / nCurrentTilePixelHeight);
		}
		var newTop = currentCanvas.m_nCurrentY - nOffsetY;

		// then we execute the move
		// to do so we determine one column block and/or one row block which has to be requested newly
		// the remaining part is copied from old position to new position
		// in case of iphone we simply request the tiles as the copy process does not work well on it
		//
		var mls = scene.m_MapLayerStack;
		var bSingleBMP = mls ? mls.m_bSingleBMP : false;
		if (nOffsetX || nOffsetY) {
			var nPendingOffsetX = 0, nPendingOffsetY = 0;
			// if not yet done, invalidate the second canvas as we would have to request here also
			if (!scene.m_Canvas[1].m_bInvalid) {
				scene.InvalidateCanvas(scene.m_Canvas[1]);
			}

			scene.MoveCanvas(canvas, canvas.getPixelLeft() + dx, canvas.getPixelTop() + dy);
			if (tmpCanvas.m_bCanvasValid) {
				if (tmpCanvas.m_nTilesBefSwitch < tmpCanvas.m_nForceSwitchLimit) {
					scene.SwitchTmpCanvasToActive();
				} else {
					nPendingOffsetX = tmpCanvas.m_nOffsetX;
					nPendingOffsetY = tmpCanvas.m_nOffsetY;
				}
			}

			tmpCanvas.m_nTilesBefSwitch = (bSingleBMP || Math.abs(nOffsetX) >= scene.m_nTilesX || Math.abs(nOffsetY) >= scene.m_nTilesY) ? 1 : (scene.m_nTilesX - Math.abs(nOffsetX)) * (scene.m_nTilesY - Math.abs(nOffsetY));
			tmpCanvas.m_nForceSwitchLimit = Math.ceil(tmpCanvas.m_nTilesBefSwitch / 2);
			tmpCanvas.m_nOffsetX = nOffsetX + nPendingOffsetX;
			tmpCanvas.m_nOffsetY = nOffsetY + nPendingOffsetY;
			scene.MoveOnlyThisCanvas(tmpCanvas, nPosX - nOffsetX * nCurrentTilePixelWidth, nPosY - nOffsetY * nCurrentTilePixelHeight, nPixelWidth, nPixelHeight);

			var context = tmpCanvas.getContext("2d");
			context.clearRect(0, 0, canvas.getPixelWidth(), canvas.getPixelHeight());
			if (mapMan.RequestTiles(tmpCanvas, scene.m_MapLayerStack, newLeft, newTop, scene.m_nTilesX, scene.m_nTilesY, 0, 0, 0, 0, canvas.m_nCurrentLOD, false)) {
				tmpCanvas.m_bCanvasValid = true;
			} else {
				scene.SwitchTmpCanvasToActive();
			}
		} else {
			// just set the new positions.......................................//
			scene.MoveCanvas(canvas, canvas.getPixelLeft() + dx, canvas.getPixelTop() + dy);
			scene.MoveObject(scene.m_Canvas[1], scene.m_Canvas[1].getPixelLeft() + dx, scene.m_Canvas[1].getPixelTop() + dy);
			if (tmpCanvas.m_bCanvasValid) {
				scene.MoveOnlyThisCanvas(tmpCanvas, nPosX, nPosY);
			}
		}

		var aVO = scene.m_VOS;
		var bRerender = false;
		for (var nI = 0, len = aVO.length; nI < len; ++nI) {
			if (aVO[nI].m_Label.length > 0 && aVO[nI].CalculateLabelPos) {
				bRerender = true;
				break;
			}

		}
		if (bRerender) {
			var ctx = scene.m_Canvas[scene.m_nLabelIndex].getContext("2d");
			ctx.clearRect(0, 0, scene.m_Canvas[scene.m_nLabelIndex].width, scene.m_Canvas[scene.m_nLabelIndex].height);
			VBI.Utilities.BackupFont(ctx);
			scene.InternalRenderLabels(scene.m_Canvas[scene.m_nLabelIndex], ctx);
			VBI.Utilities.RestoreFont(ctx);
		}

		scene.InternalOnMoveLayer(scene.m_Canvas[scene.m_nOverlayIndex]);
		scene.m_LastDefinedCenterPos = undefined;

	};

	scene.AdaptZoomFactor = function(canvas, factor, xOffset, yOffset, targetedTicks) {
		var result = {};
		result.bZoomNotPossible = true; // set to false if all checks are passed successfully

		var nMaxTiles = (1 << canvas.m_nCurrentLOD);

		if ((canvas.m_nCurrentY < 0) && (yOffset < -canvas.m_nCurrentY * (canvas.getPixelHeight() / scene.m_nTilesY))) {
			return result; // GeoPos is above northpole
		}
		if (((canvas.m_nCurrentY + scene.m_nTilesY) > nMaxTiles) && (yOffset > (nMaxTiles - canvas.m_nCurrentY) * (canvas.getPixelHeight() / scene.m_nTilesY))) {
			return result; // GeoPos is beyond southpole
		}
		if (factor < 1) {
			var nNumberOfVisibleEarths = Math.max((scene.m_nDivWidth / (canvas.getPixelWidth() * scene.m_nXSizeVisualBorder)) * (scene.m_nTilesX / nMaxTiles), (scene.m_nDivHeight / (canvas.getPixelHeight() * scene.m_nYSizeVisualBorder)) * (scene.m_nTilesY / nMaxTiles));
			if (factor < nNumberOfVisibleEarths) { // means NumEarths / factor would have result > 1
				if ((nNumberOfVisibleEarths >= 1) && (factor != 0)) {
					return result; // no zoom or zoom in wrong direction required -> skip
				}
				factor = nNumberOfVisibleEarths; // change factor to max, so that we see exactly one earth.
				// bAdaptToEvenLod = false;
			}
		}
		var bAdaptToEvenLod = targetedTicks && (scene.m_nZoomMode || (factor == scene.m_nLodFactorZoomIn) || (factor == scene.m_nLodFactorZoomOut));
		var exactLod = canvas.m_nExactLOD + Math.log(factor) * Math.LOG2E;
		var minLOD = scene.GetMinLOD();
		if ((minLOD != Math.round(minLOD)) && (factor != 1.0) && (canvas.m_nExactLOD <= Math.ceil(minLOD)) && (Math.round(targetedTicks * exactLod) == Math.round(targetedTicks * minLOD))) { // only
			bAdaptToEvenLod = false;
		}

		if (bAdaptToEvenLod && Math.round(targetedTicks * exactLod) != targetedTicks * exactLod) {
			exactLod = Math.round(targetedTicks * exactLod) / targetedTicks;
			factor = Math.pow(2, exactLod - canvas.m_nExactLOD);
		} else if (exactLod < minLOD) {
			exactLod = minLOD;
			factor = Math.pow(2, exactLod - canvas.m_nExactLOD);
		}
		result.factor = factor;
		result.nNewLod = Math.floor(exactLod);
		result.lodFallsOnInteger = (Math.round(exactLod) == exactLod);

		result.bZoomNotPossible = ((exactLod > scene.GetMaxLOD()) || (exactLod < minLOD));

		return result;
	};

// ........................................................................//
// map zoom occured.......................................................//

	scene.ZoomMap = function(factor, xOffset, yOffset, targetedTicks, bSuppressEvent) {
		scene.m_bNonIntPosStable = false;
		if (scene.m_Canvas[scene.m_nNonDomIndex].m_bCanvasValid) {
			scene.SwitchTmpCanvasToActive();
		}

		var canvas = scene.m_Canvas[0];
		var otherCanvas = scene.m_Canvas[1];
		var mapMan = scene.m_MapManager;
		var tw = mapMan.m_tileWidth, th = mapMan.m_tileHeight;
		var nTilesX, nTilesY, nPosX = 0, nPosY = 0;

		// get old canvas settings
		var oldLeft = canvas.getPixelLeft(), oldTop = canvas.getPixelTop();
		var oldWidth = canvas.getPixelWidth(), oldHeight = canvas.getPixelHeight();
		var otherPixelWidth = otherCanvas.getPixelWidth();

		// Adapt factor to MinimalLod and to even lod if required and check whether we can continue
		var zoomData = scene.AdaptZoomFactor(canvas, factor, xOffset, yOffset, targetedTicks);
		if (zoomData.bZoomNotPossible) {
			return;
		}
		factor = zoomData.factor; // corrected zoom factor
		var nNewLod = zoomData.nNewLod;
		if (VBI.m_bTrace) {
			VBI.Trace("Zoom by " + factor + " to " + xOffset + "/" + yOffset);
		}

		// Moving current canvas accordingly
		var newWidth = Math.round(oldWidth * factor);
		var newHeight = Math.round(newWidth * canvas.height / canvas.width);
		var newLeft = Math.round(oldLeft - ((factor - 1) * xOffset));
		var newTop = Math.round(oldTop - ((factor - 1) * yOffset));

		if (factor < 1) { // for zoom out we have to check whether we run out of north/south limits
			// if we would do so we have to adapt yOffset so we zoom exactly to the limit
			var nLodDist = (1 << canvas.m_nCurrentLOD);

			var uxyLU = [
				nLodDist, nLodDist
			];
			var uxyRL = [
				nLodDist, nLodDist
			];
			scene.m_Proj.LonLatToUCS(scene.m_nBorderMinPoint, uxyLU);
			scene.m_Proj.LonLatToUCS(scene.m_nBorderMaxPoint, uxyRL);

			var nNewStretch = newHeight / scene.m_nHeightCanvas;
			var nTargetDistanceToNorthernBorder = (canvas.m_nCurrentY - uxyLU[1]) * th * nNewStretch - newTop;

			if (nTargetDistanceToNorthernBorder < -scene.m_nMaxPixelBeyondPoles) {
				newTop = Math.round(th * (canvas.m_nCurrentY - uxyLU[1]) * nNewStretch + scene.m_nMaxPixelBeyondPoles);
				yOffset = (oldTop - newTop) / (factor - 1);
			} else { // no zoom out can violate against both conditions as MaxPixelBeyondPoles and MinLod are set accordingly
				var nTargetDistanceToSouthernBorder = th * (canvas.m_nCurrentY - uxyRL[1]) * nNewStretch + scene.m_nDivHeight - newTop;
				if (nTargetDistanceToSouthernBorder > scene.m_nMaxPixelBeyondPoles) {
					newTop = Math.round(th * (canvas.m_nCurrentY - uxyRL[1]) * nNewStretch + scene.m_nDivHeight - scene.m_nMaxPixelBeyondPoles);
					yOffset = (oldTop - newTop) / (factor - 1);
				}
			}
			if (scene.m_bXBorderExists) {
				var nTargetDistanceToWestBorder = (canvas.m_nCurrentX - uxyLU[0]) * tw * nNewStretch - newLeft;
				if (nTargetDistanceToWestBorder < -scene.m_nMaxPixelBeyondPoles) {
					newLeft = Math.round(tw * (canvas.m_nCurrentX - uxyLU[0]) * nNewStretch + scene.m_nMaxPixelBeyondPoles);
					xOffset = (oldLeft - newLeft) / (factor - 1);
				}
				var nTargetDistanceToEastBorder = (canvas.m_nCurrentX - uxyRL[0]) * tw * nNewStretch + scene.m_nDivWidth - newLeft;
				if (nTargetDistanceToEastBorder > scene.m_nMaxPixelBeyondPoles) {
					newLeft = Math.round(tw * (canvas.m_nCurrentX - uxyRL[0]) * nNewStretch + scene.m_nDivWidth - scene.m_nMaxPixelBeyondPoles);
					xOffset = (oldLeft - newLeft) / (factor - 1);
				}
			}
		}

		scene.MoveCanvas(canvas, newLeft, newTop, newWidth, newHeight);

		var newTilePixelWidth = newWidth / scene.m_nTilesX;
		var newTilePixelHeight = newHeight / scene.m_nTilesY;

		// we request new tiles if LOD changes or we run out of viewport
		var bRequestNewTiles = false;
		if (nNewLod == canvas.m_nCurrentLOD) { // no lod switch..........................//
			if (!otherCanvas.m_bInvalid) {
				// we have to correct position of second canvas as it might be visible also
				var otherCanvasWidth = Math.round(otherPixelWidth * factor);
				var otherCanvasHeight = Math.round(otherCanvas.getPixelHeight() * factor);
				// if we have enought memory we can stretch, otherwise we clear
				if ((otherCanvasWidth <= scene.m_nMaxCanvasDimension) && (otherCanvasHeight <= scene.m_nMaxCanvasDimension)) {
					var otherPixelLeft = otherCanvas.getPixelLeft();
					var otherPixelTop = otherCanvas.getPixelTop();

					var otherCanvasLeft = Math.round(otherPixelLeft - ((factor - 1) * (xOffset + oldLeft - otherPixelLeft)));
					var otherCanvasTop = Math.round(otherPixelTop - ((factor - 1) * (yOffset + oldTop - otherPixelTop)));
					scene.MoveObject(otherCanvas, otherCanvasLeft, otherCanvasTop, Math.round(otherPixelWidth * factor), Math.round(otherCanvas.getPixelHeight() * factor));
				} else {
					scene.InvalidateCanvas(scene.m_Canvas[1]);
				}
			}
			canvas.m_nExactLOD = canvas.m_nCurrentLOD + Math.log(newTilePixelWidth / tw) * Math.LOG2E;

			// when we run out of the viewport then correct it..................//
			if (newLeft > 0 || newTop > 0 || (newLeft + newWidth < scene.m_nDivWidth) || (newTop + newHeight < scene.m_nDivHeight)) {
				bRequestNewTiles = true;

				nTilesX = -Math.ceil(newLeft / newTilePixelWidth);
				nTilesY = -Math.ceil(newTop / newTilePixelHeight);

				nPosX = newLeft + nTilesX * newTilePixelWidth;
				nPosY = newTop + nTilesY * newTilePixelHeight;
				newLeft = canvas.m_nCurrentX + nTilesX;
				newTop = canvas.m_nCurrentY + nTilesY;

				if (VBI.m_bTrace) {
					VBI.Trace("run out viewport newTop=" + newTop + " nTilesY=" + nTilesY + " nPosY=" + nPosY + " yOffset=" + yOffset + "\n");
				}
			}
		} else { // LOD changes
			bRequestNewTiles = true;

			var nLodDistance = Math.pow(2, canvas.m_nCurrentLOD - nNewLod);
			var nCurrentStretch = oldHeight / scene.m_nHeightCanvas;

			// Viewport Middle is calculated in unstretched pixels now. We "move" from origin to offset point which remains fix
			// then we go back to origin by zoomed offset followed by zoomed (left + div/2) to new middle point
			var newViewportMidX = xOffset / nCurrentStretch + (nLodDistance * (scene.m_nDivWidth / 2 - oldLeft - xOffset));
			var newViewportMidY = yOffset / nCurrentStretch + (nLodDistance * (scene.m_nDivHeight / 2 - oldTop - yOffset));

			if (nNewLod > canvas.m_nCurrentLOD) { // Zoom in
				nTilesX = Math.round(newViewportMidX / nLodDistance / tw - scene.m_nTilesX / 2);
				nTilesY = Math.round(newViewportMidY / nLodDistance / th - scene.m_nTilesY / 2);

				nPosX = Math.ceil(newLeft + nTilesX * newTilePixelWidth * nLodDistance);
				nPosY = Math.ceil(newTop + nTilesY * newTilePixelHeight * nLodDistance);
			} else { // Zoom Out
				var nOddPartOfX = ((canvas.m_nCurrentX % nLodDistance) + nLodDistance) % nLodDistance;
				var nOddPartOfY = ((canvas.m_nCurrentY % nLodDistance) + nLodDistance) % nLodDistance;

				nTilesX = Math.round((newViewportMidX / tw + nOddPartOfX) / nLodDistance - scene.m_nTilesX / 2);
				nTilesY = Math.round((newViewportMidY / th + nOddPartOfY) / nLodDistance - scene.m_nTilesY / 2);

				// calculate the new position and align when necessary..............//
				nPosX = newLeft + newTilePixelWidth * (nTilesX * nLodDistance - nOddPartOfX);
				nPosY = newTop + newTilePixelHeight * (nTilesY * nLodDistance - nOddPartOfY);
			}

			newLeft = Math.floor(canvas.m_nCurrentX / nLodDistance + nTilesX);
			newTop = Math.floor(canvas.m_nCurrentY / nLodDistance + nTilesY);
			newWidth = zoomData.lodFallsOnInteger ? (tw * scene.m_nTilesX) : Math.ceil(newWidth * nLodDistance);
			newHeight = zoomData.lodFallsOnInteger ? (th * scene.m_nTilesY) : Math.ceil(newHeight * nLodDistance);
		}

		var newExactLod = nNewLod + Math.log(newWidth / scene.m_nWidthCanvas) * Math.LOG2E;
		if (bRequestNewTiles) { // if lod changes or we are running out of viewport, new request is done
			otherCanvas.m_nExactLOD = newExactLod;
			scene.MoveCanvas(otherCanvas, nPosX, nPosY, newWidth, newHeight);

			// set properties of new canvas.....................................//
			scene.m_MapManager.RequestTiles(scene.m_Canvas[1], scene.m_MapLayerStack, newLeft, newTop, scene.m_nTilesX, scene.m_nTilesY, 0, 0, 0, 0, nNewLod, true);
			canvas.m_Scene.ToggleCanvas(canvas.m_Scene);
		}
		scene.InternalRenderLayer(scene.m_Canvas[scene.m_nOverlayIndex], false, bRequestNewTiles, bRequestNewTiles, newExactLod);
		// if new tiles are requested we always render, optherwise its up to the engine

		// update the current lod in the navigation control (for mobile devices)
		if (scene.m_bNavControlVisible && scene.m_NavControl) {
			scene.m_NavControl.AdjustScrollPoint(newExactLod);
		}

		scene.InternalOnMoveLayer(canvas, bSuppressEvent);

		// call internal functionto be able to do additional default behavior...//
		scene.InternalOnZoomLayer(scene.m_Canvas[scene.m_nOverlayIndex], bSuppressEvent);
		scene.m_LastDefinedCenterPos = scene.m_LastZoomArea = undefined;
	};

	scene.ZoomOtherCanvas = function(otherCanvas, canvas, factor, xOffset, yOffset) {

		var newLeft = Math.round(otherCanvas.getPixelLeft() - ((factor - 1) * xOffset));
		var newTop = Math.round(otherCanvas.getPixelTop() - ((factor - 1) * yOffset));

		var otherCanvasWidth = Math.round(otherCanvas.getPixelWidth() * factor);
		var otherCanvasHeight = Math.round(otherCanvas.getPixelHeight() * factor);

		scene.MoveObject(otherCanvas, newLeft, newTop, otherCanvasWidth, otherCanvasHeight);
	};

	scene.AnimationStep = function() {
		var currentLod = scene.m_Canvas[0].m_nExactLOD;
		var rc = scene.m_Canvas[0].getBoundingClientRect();
		if (currentLod != scene.AnimZoomTarget) {
			var animPos = Math.min((Date.now() - scene.AnimZoomTimestamp) / scene.AnimZoomDuration, 1);
			var f = Math.min(animPos * (2 - animPos), 1); // easing out animation
			var zoomFactor = Math.pow(2, scene.AnimZoomOrigin + (scene.AnimZoomTarget - scene.AnimZoomOrigin) * f) / Math.pow(2, currentLod);
			scene.ZoomMap(zoomFactor, scene.AnimZoomClientX - rc.left, scene.AnimZoomClientY - rc.top, animPos < 1 ? 0 : 1, true);

			if (animPos < 1) {// request next animation step
				scene.m_AnimZoomRequestID = window.requestAnimationFrame(scene.AnimationStep);
				return;
			}
		}

		// animation has finished.............................

		scene.ZoomMap(1, scene.AnimZoomClientX - rc.left, scene.AnimZoomClientY - rc.top, 1, true);

		scene.InternalOnMoveLayer(scene.m_Canvas[scene.m_nOverlayIndex], scene.AnimZoomClickCoords);
		scene.InternalOnZoomLayer(scene.m_Canvas[scene.m_nOverlayIndex], scene.AnimZoomClickCoords);

		scene.m_AnimZoomRequestID = 0;
		scene.AnimZoomClientX = scene.AnimZoomClientY = scene.AnimZoomClickCoords = undefined;
		scene.AnimZoomTimestamp = scene.AnimZoomDuration = scene.AnimZoomOrigin = scene.AnimZoomTarget = undefined;
	};

	// do an animated zoom to a specific location.............................//
	scene.AnimateZoom = function(zoomIn, clientX, clientY, interval, event) {
		var clickCoords = ((event != undefined && event.clientX != undefined) ? {
			x: event.clientX,
			y: event.clientY
		} : undefined);

		scene.AnimZoomClientX = clientX;
		scene.AnimZoomClientY = clientY;
		scene.AnimZoomClickCoords = clickCoords;
		scene.AnimZoomOrigin = scene.m_Canvas[0].m_nExactLOD;
		scene.AnimZoomTarget = Math.round(scene.AnimZoomTarget ? scene.AnimZoomTarget : scene.AnimZoomOrigin) + (zoomIn ? 1 : -1);
		scene.AnimZoomTimestamp = Date.now();
		scene.AnimZoomDuration = Math.pow(Math.abs(scene.AnimZoomTarget - scene.AnimZoomOrigin), 0.8) * 300;

		if (scene.m_AnimZoomRequestID) {
			window.cancelAnimationFrame(scene.m_AnimZoomRequestID);
		}
		scene.m_AnimZoomRequestID = window.requestAnimationFrame(scene.AnimationStep);
	};

	scene.AnimationToGeoStep = function(correctedInterval, lonlat, nTargetLod, nSourceLod, targetedTicksInALod) {
		if (--scene.m_nAnimOpenTicks) {
			scene.ZoomToZoomlevel(lonlat, nTargetLod - (scene.m_nAnimOpenTicks - 1) * (nTargetLod - nSourceLod) / (scene.m_nAnimTicks - 1), true);
			var temp = Date.now(), corr = correctedInterval;
			if (scene.m_AnimTimestamp) {
				var delta = Math.max(0, temp - scene.m_AnimTimestamp);
				corr = Math.max(10, 2 * correctedInterval - delta);
			}
			scene.m_AnimTimestamp = temp;
			scene.m_AnimZoomTimer = window.setTimeout(function() {
				scene.AnimationToGeoStep(correctedInterval, lonlat, nTargetLod, nSourceLod, targetedTicksInALod);
			}, corr);
			return;
		}

		scene.InternalOnZoomLayer(scene.m_Canvas[scene.m_nOverlayIndex]);

		// clear the animation zoom timer.............................
		if (scene.m_AnimZoomTimer) {
			scene.m_nAnimOpenTicks = scene.m_nAnimationTicks = undefined;
			window.clearInterval(scene.m_AnimZoomTimer);
			scene.m_AnimZoomTimer = null;
			scene.InternalRenderLayer(scene.m_Canvas[scene.m_nOverlayIndex], false, false, false, scene.m_Canvas[0].m_nExactLOD);
		}
	};

	scene.AnimateZoomToGeo = function(lonlat, GeoZoomToLOD, interval) {
		var nCurrentLOD = scene.m_Canvas[0].m_nExactLOD;
		if (nCurrentLOD == GeoZoomToLOD) {
			return;
		}
		scene.m_bNonIntPosStable = false;
		var targetedTicksInALod = 2 * scene.m_nTicksInALod;

		if (scene.m_AnimZoomTimer) {
			window.clearInterval(scene.m_AnimZoomTimer);
		}

		scene.m_nAnimTicks = 2 + Math.abs(Math.round((nCurrentLOD - GeoZoomToLOD) * targetedTicksInALod));
		scene.m_nAnimOpenTicks = scene.m_nAnimTicks;
		var nSourceLod = nCurrentLOD;
		var nTargetLod = GeoZoomToLOD;

		var correctedInterval = interval * targetedTicksInALod / scene.m_nAnimTicks;
		scene.m_AnimZoomTimer = window.setTimeout(function() {
			scene.AnimationToGeoStep(correctedInterval, lonlat, nTargetLod, nSourceLod, targetedTicksInALod);
		}, correctedInterval);
	};

	// ........................................................................//
	// multi selection .......................................................//
	// ........................................................................//

	scene.PerFormMultiSelect = function(e, oTrack) {
		if (scene.m_nInputMode != VBI.InputModeLassoSelect && scene.m_nInputMode != VBI.InputModeRectSelect) {
			return;
		}

		var bShift, bCtrl;
		if ((e.type.indexOf("touch") >= 0) || (e.type.indexOf("pointer") >= 0)) {
			bShift = bCtrl = false;
		} else {
			bCtrl = e.ctrlKey;
			bShift = e.shiftKey;
		}

		var lenVOS = scene.m_VOS.length;
		var selectionChanged = false;
		var hitsPerVO = [], orgHits = [];
		var nK, nM, node, ele, ds, vo;
		var bFound = false;
		for (var nJ = 0; nJ < lenVOS; ++nJ) {
			orgHits[nJ] = [];
			hitsPerVO = [];
			if (scene.m_nInputMode == VBI.InputModeLassoSelect && !scene.m_VOS[nJ].LassoSelect) {
				continue;
			}
			if (scene.m_nInputMode == VBI.InputModeLassoSelect) {
				bFound = scene.m_VOS[nJ].LassoSelect(oTrack.m_PosMoves, hitsPerVO, orgHits[nJ]);
			} else {
				bFound = scene.m_VOS[nJ].RectSelect(oTrack.selectionRect, hitsPerVO, orgHits[nJ]);
			}
			if (bFound) {

				vo = scene.m_VOS[nJ];
				if (!(ds = vo.m_DataSource)) {
					continue;
				}
				if (!bShift && !bCtrl && ds) {
					// selection without key modifier
					if ((node = ds.GetCurrentNode(scene.m_Ctx))) {
						for (nM = 0; nM <= 1; nM++) {
							// do this twice to make sure that a selection or deselection that could not be done in the first loop because of
							// cardinality
							// ( 1:N ) can be done in the second loop!!
							for (nK = 0; nK < node.m_dataelements.length; ++nK) {
								ds.Select(nK);
								if ((ele = ds.GetIndexedElement(scene.m_Ctx, nK))) {
									if (vo.IsSelected(scene.m_Ctx)) {
										if (VBI.IndexOf(hitsPerVO, nK) == -1) {
											vo.Select(ele, scene.m_Ctx, false);
											selectionChanged = true;
										}
									} else if (VBI.IndexOf(hitsPerVO, nK) != -1) {
										vo.Select(ele, scene.m_Ctx, true);
										selectionChanged = true;
									}
								}
							}

						}
					}
				} else if (bShift) {
					// add selection
					for (nK = 0; nK < hitsPerVO.length; nK++) {
						ds.Select(hitsPerVO[nK]);
						if ((ele = ds.GetIndexedElement(scene.m_Ctx, hitsPerVO[nK]))) {
							if (!vo.IsSelected(scene.m_Ctx)) {
								vo.Select(ele, scene.m_Ctx, true);
								selectionChanged = true;
							}
						}
					}
				} else if (bCtrl) {
					var select = [];
					for (nK = 0; nK < hitsPerVO.length; nK++) {
						// collect all items that are affected
						ds.Select(hitsPerVO[nK]);
						var sel = {};
						if (vo.IsSelected(scene.m_Ctx)) {
							sel.toSelect = false;
						} else {
							sel.toSelect = true;
						}
						sel.idx = nK;
						select.push(sel);
					}
					for (nM = 0; nM <= 1; nM++) {
						// do this twice to make sure that a selection or deselection that could not be done in the first loop because of cardinality
						// ( 1:N ) can be done in the second loop!!
						for (nK = 0; nK < select.length; nK++) {
							ds.Select(hitsPerVO[select[nK]]);
							if ((ele = vo.m_DataSource.GetIndexedElement(scene.m_Ctx, hitsPerVO[select[nK].idx]))) {
								if (nM == 0 && select[nK].toSelect) {
									vo.Select(ele, scene.m_Ctx, true);
									selectionChanged = true;
								}
								if (nM == 1 && !select[nK].toSelect) {
									vo.Select(ele, scene.m_Ctx, false);
									selectionChanged = true;
								}
							}
						}
					}
				}
			}
		}
		if (scene.m_PreassembledData && orgHits.length) {
			scene.UpdatePreData4SelArray(orgHits);
		}
		// fire selection event when subscribed.............................//
		var actions;
		if (selectionChanged && (actions = scene.m_Ctx.m_Actions)) {
			var action;
			if ((action = actions.findAction("Select", scene, "General"))) {
				// todo: add event parameters
				scene.m_Ctx.FireAction(action, scene, "General", null, null);

			}
		}

	};

	scene.endTrackingMode = function() {
		if (scene.m_nInputMode == VBI.InputModeRectSelect || scene.m_nInputMode == VBI.InputModeLassoSelect || scene.m_nInputMode == VBI.InputModeRectZoom) {
			scene.m_DesignVO.ExitMode();
		}
	};

// ........................................................................//
// helper functions.......................................................//

	scene.GetViewport = function() {
		var zsf = scene.GetStretchFactor4Mode();
		var rc = scene.GetInternalDivClientRect();
		var rcWidth = rc.width / zsf[0];
		var rcHeight = rc.height / zsf[1];
		var PosX = scene.m_Canvas[0].getPixelLeft() / zsf[0];
		var PosY = scene.m_Canvas[0].getPixelTop() / zsf[1];

		return [
			-PosX, -PosY, -PosX + rcWidth, -PosY + rcHeight
		];

	};

	scene.IsTransparent = function(clientX, clientY) {
		// check if the applied coordinate is on a transparent pixel...........//
		// the coordinates are client relative and are transformed here to.....//
		// canvas relative coords..............................................//
		var oCanvas = scene.m_Canvas[scene.m_nOverlayIndex];
		if (!oCanvas) {
			return false;
		}
		var ctx = oCanvas.getContext("2d");
		var rect = oCanvas.getBoundingClientRect();

		var ts = Date.now();
		var pixelImage = ctx.getImageData(Math.round(clientX - rect.left), Math.round(clientY - rect.top), 1, 1);
		if (scene.m_bObjCanvasMode && VBI.m_bIsMyChromeTest && (oCanvas.width != scene.m_nlstWidth || oCanvas.height != scene.m_nlstHeight)) {
			var delta = Date.now() - ts;
			scene.m_nlstWidth = oCanvas.width;
			scene.m_nlstHeight = oCanvas.height;
			if (delta > 40) {
				scene.m_nGetImageDataIncidents++;
				if (scene.m_nGetImageDataIncidents > 2 || delta > 200) {
					scene.m_bSwitch2OldCanvasMode = true;
				}
			}
		}

		var alpha = pixelImage.data[3];
		return alpha ? false : true;
	};

	scene.GetCurrentZoomFactors = function() {
		// for performance reasons we use the pre calculated factors...........//
		return [
			scene.m_StretchFactors[0] * scene.m_ZoomFactors[0], scene.m_StretchFactors[1] * scene.m_ZoomFactors[1]
		];
	};

	scene.GetStretchFactor4Mode = function() {
		return scene.m_StretchFactors;
	};

	scene.GetZoomFactor4Mode = function() {
		return scene.m_ZoomFactors;
	};

	scene.ToggleCanvas = function(scene) {
		// toggle canvas.......................................................//
		var tmp = scene.m_Canvas[0];
		scene.m_Canvas[0] = scene.m_Canvas[1];
		scene.m_Canvas[1] = tmp;

		// new Canvas 0 becomes active (opacity transition 0 -> 1)
		scene.m_Canvas[0].className = "vbi-geoscenecanvas vbi-map-inactive"; // make new foreground canvas transparent
		//switch order in DOM for right z-order (Canvas 1 behind Canvas 0)
		scene.m_MapsLayerDiv.insertBefore(scene.m_Canvas[1], scene.m_Canvas[0]);
		// make a delayed call to ensure styling is applyed to have a real transition
		jQuery.sap.delayedCall(0, this, function(time){
			scene.m_Canvas[0].className = "vbi-geoscenecanvas vbi-map-active"; // make foreground canvas opaque using a transition
		});
	};

	VBI.addScenePositioningFunctions(scene);

	scene.getCanvas = function() {
		return scene.m_Canvas[0];
	};

	scene.SetEdgeTransition = function(myArray, edge, corner1, otherEdge, corner2, nextEdge, edge2test) {
		myArray[edge + 9 * otherEdge] = 1; // to the other edge we must cross the div

		myArray[edge + 9 * corner1] = edge2test;
		myArray[edge + 9 * corner2] = edge2test;
		myArray[corner1 + 9 * edge] = edge2test;
		myArray[corner2 + 9 * edge] = edge2test;

		myArray[edge + 9 * nextEdge] = edge2test;
		myArray[nextEdge + 9 * edge] = edge2test;
	};

	scene.SetCornerTransition = function(myArray, source, target, edges2test) {
		myArray[source + 9 * target] = edges2test;
		myArray[target + 9 * source] = edges2test;
	};

	scene.BuildQuarterTransistionTable = function() {

		// Quarters (Please note: 6 is South, 3 is North as Projection is reversed)
		//
		// 7 | 6 | 8
		// --+---+---
		// 1 | 0 | 2
		// --+---+---
		// 4 | 3 | 5
		//
		// index of transition is "source + 9 * target"
		// 0: no point of route is visible; 1: route must cross 0-area (canvas);
		// Bigger returns the possible edges in a bitarray:
		// edges: 2 : left edge, 4 : top edge, 8 : right edge, 16 : bottom edge

		var result = [];
		var i;
		for (i = 0; i < 81; ++i) {
			result.push(0); // 0 means not visible
		}
		for (i = 0; i < 9; ++i) {
			result[i] = 1; // 1 means definitely visible
			result[9 * i] = 1;
		}

		scene.SetEdgeTransition(result, 3, 7, 6, 8, 2, 16); // bottom edge
		scene.SetEdgeTransition(result, 2, 4, 1, 7, 6, 8); // right edge
		scene.SetEdgeTransition(result, 6, 4, 3, 5, 1, 4); // top edge
		scene.SetEdgeTransition(result, 1, 5, 2, 8, 3, 2); // left edge

		scene.SetCornerTransition(result, 4, 8, 18); // left-bottom <-> right-top, we test bottom & left edge
		scene.SetCornerTransition(result, 5, 7, 24); // right-bottom <> left-top, we test bottom & right edge

		return result;

		// all other connections can not cross the canvas
	};

// .......................................................................//
// the following does the killing and genesis of the scene................//

	scene.clearTimers = function() {
		// clear the animation timer if active.................................//
		if (scene.m_AnimZoomTimer) {
			window.clearInterval(scene.m_AnimZoomTimer);
			scene.m_AnimZoomTimer = null;
		}
	};

	scene.clearCanvas = function(nJ) {
		scene.m_Canvas[nJ].m_Scene = null;
		scene.m_Canvas[nJ] = null;
	};

	scene.clearCanvases = function() {
		// clear the canvas-scene references...................................//
		for (var nJ = 0, nLen = scene.m_Canvas.length; nJ < nLen; ++nJ) {
			scene.clearCanvas(nJ);
		}
		scene.m_Canvas = [];
	};

	scene.Remove = function() {
		// remove the dom elements.............................................//
		if (scene.m_Div) {
			// remove potential event listeners from document...................//
			scene.SetInputMode(VBI.InputModeDefault);

			// remove all childs of out div.....................................//
			while (scene.m_Div.firstChild) {
				scene.m_Div.removeChild(scene.m_Div.firstChild);
			}

			// reset div reference..............................................//
			scene.m_Div.parentElement.removeChild(scene.m_Div);
			scene.m_Div = null;

			// clear any timers.................................................//
			scene.clearTimers();
			scene.clearCanvases();
		}

		if (scene.m_Target) {
			while (scene.m_Target.firstChild) {
				scene.m_Target.removeChild(scene.m_Target.firstChild);
			}

			scene.m_Target = null;
		}
	};

	scene.AddCopyright = function() {
		// return immediately when the maplayerstack is empty..................//
		if (!scene.m_MapLayerStack) {
			return;
		}

		if (!scene.m_DivCopyright) {
			var CopyrightElement = VBI.Utilities.CreateGeoSceneDivCSS(scene.m_Target.id + "-copyright", "vbi-copyright");
			CopyrightElement.m_VBIType = "C";
			scene.m_MapDecoDiv.appendChild(CopyrightElement);
			scene.m_DivCopyright = CopyrightElement;
		}
		var sCopyright = scene.m_MapLayerStack.GetCopyright();
		if (sCopyright) {
			scene.m_DivCopyright.innerHTML = sCopyright;
		} else {
			scene.m_DivCopyright.style.paddingRight = 0;
			scene.m_DivCopyright.style.paddingLeft = 0;
		}
	};

	scene.ReAwake = function() {
		scene.m_MapLayerStack = scene.m_RefMapLayerStack;
		scene.AddCopyright();
		scene.resizeCanvas(0, true);
	};

	scene.Awake = function(target, mapmanager, maplayerstack) {
		scene.m_Target = VBI.Utilities.GetDOMElement(target);
		if (!scene.m_Target) {
			scene.m_Target = VBI.Utilities.CreateDOMElement(target, "1px", "1px");
		}

		// reuse scene parts...................................................//
		if (scene.m_Div) {

			//IE corner case, DOM elements which were removed from DOM tree lost their relative hierarchy
			//so everything in this case have to be recreated!
			if (!scene.m_Div.children || !scene.m_Div.children.length) {
				scene.m_awakeFrame = {
					pos: scene.GetCenterPos(),
					lod: scene.GetCurrentZoomlevel()};
			} else {
				// when the scenes div's parent is still the place holder, then.....//
				// everything is still fine and we can return.......................//
				if (scene.m_Div.parentNode == scene.m_Target) {
					return;
				}
				// the scenes div is already but the parent is no longer the........//
				// placeholder. In this case we add again the div as a child element//
				scene.m_Target.appendChild(scene.m_Div);

				if (scene.m_bNavControlVisible && scene.m_NavControl) {
					// scene.m_NavControl.Awake( scene, target );
					scene.m_NavControl.AttachEvents();
				}
				return;
			}
		}
		// assign scene information............................................//
		scene.m_TargetName = target;

		scene.m_MapManager = typeof mapmanager !== 'undefined' ? mapmanager : VBI.MapManager;
		scene.m_MapLayerStack = typeof maplayerstack !== 'undefined' ? maplayerstack : scene.m_RefMapLayerStack;

		// create the viewport.................................................//
		scene.m_Div = VBI.Utilities.CreateGeoSceneDivCSS(target + "-geoscene-viewport", "vbi-viewport");
		// set the viewport div as a child of the target................................//
		scene.m_Target.appendChild(scene.m_Div);

		// add a moveable layer to the viewport
		scene.m_MoveableLayer = VBI.Utilities.CreateGeoSceneDivCSS(target + "-geoscene-moveable-layer", "vbi-moveable-layer");
		scene.m_Div.appendChild(scene.m_MoveableLayer);

		// Populate the moveable layer with the content which should move with it
		// add a layer div for all map elements (maps + VOs)
		scene.m_MapsLayerDiv = VBI.Utilities.CreateGeoSceneDivCSS(target + "-geoscene-mapslayer", "vbi-map-layer");
		scene.m_MoveableLayer.appendChild(scene.m_MapsLayerDiv);

		// Add viewport content which is either fixed or moves relative to it
		// add a layer div for map deco like scale and copyright
		scene.m_MapDecoDiv = VBI.Utilities.CreateGeoSceneDivCSS(target + "-geoscene-decolayer", "vbi-structure-layer");
		scene.m_Div.appendChild(scene.m_MapDecoDiv);

		// add a layer div for legend windows
		scene.m_LegendLayerDiv = VBI.Utilities.CreateGeoSceneDivCSS(target + "-geoscene-legendlayer", "vbi-structure-layer");
		scene.m_Div.appendChild(scene.m_LegendLayerDiv);

		// add a layer div for VBI detail window elements
		scene.m_WindowLayerDiv = VBI.Utilities.CreateGeoSceneDivCSS(target + "-geoscene-winlayer", "vbi-structure-layer");

		if (VBI.m_bIsPhone) {
			// on phones the detail window sits statically on the bottom of the screen
			scene.m_Div.appendChild(scene.m_WindowLayerDiv);
		} else {
			// on normal devices detail windows belong to the moveable layer and move with the map
			scene.m_MoveableLayer.appendChild(scene.m_WindowLayerDiv);
		}
		// activate
		// the awakening of the canvases requires the div sizes, if they are not provided
		// behvaiour might be strange. To support a future implementation of a lazy awakening
		// when the div sizes come late this part is put into an own function which may be called
		// from resize also.
		scene.DoAwake(target);
	};

	scene.setProjection = function() {
		if (!scene.m_RefMapLayerStack || !scene.m_RefMapLayerStack.m_MapLayerArray || !scene.m_RefMapLayerStack.m_MapLayerArray.length) {
			return new VBI.MercatorProjection();
		}

		var layerArray = scene.m_RefMapLayerStack.m_MapLayerArray;
		var nProj = layerArray[0].GetMapProvider().m_nProjection;
		for (var i = 2; i < layerArray.length; ++i) {
			if (layerArray[i].GetMapProvider().m_nProjection != nProj) {
				if (VBI.m_bTrace) {
					VBI.Trace("projection of layer " + i + " is inconsistent to base layer. Choosing projection of base layer");
				}
			}
		}

		switch (nProj) {
			case 1:
				return new VBI.MercatorProjection();
			case 2:
				return new VBI.LinearProjection();
			case 3:
				return new VBI.ElliMercatorProjection();
			default:
				return new VBI.MercatorProjection();
		}
	};

	scene.DoAwake = function(target) {
		// create the viewport.................................................//
		scene.CalculateCanvasDimensions();
		scene.CreateCanvases();
		// append copyright
		if (!scene.m_Ctx.moThumbnail) {
			scene.AddCopyright();
		}
		// attach overlay canvas to scene handled events.......................//
		var oCanvas = scene.m_Canvas[scene.m_nLabelIndex];
		// do event subscriptions..............................................//
		if (scene.m_Events) {
			scene.m_Events.clear();
		}

		scene.m_Events = new VBI.SceneEvent(this, oCanvas.parentElement);

		// awake Navigation Control
		if (scene.m_bNavControlVisible && scene.m_NavControl) {
			scene.m_NavControl.Awake(scene, target);
		}

		// awake Scale Control
		if (scene.m_bScaleVisible && scene.m_Scale) {
			scene.m_Scale.Awake(scene, target);
		}

		// now go to StartPosition
		var exactMinLod = scene.GetMinLOD();
		if (scene.m_startLOD < exactMinLod) {
			var firstIntLOD = Math.ceil(exactMinLod);
			scene.m_startLOD = (firstIntLOD - exactMinLod) < 0.6 ? firstIntLOD : exactMinLod;
		}

		if (scene.m_bObjCanvasMode && VBI.m_bIsMyChromeTest && !scene.m_bObjCanvasModeChecked) {
			scene.ChromePerformanceCheck(oCanvas);
		}

		if (scene.m_awakeFrame) {
			scene.ZoomToGeoPosition(scene.m_awakeFrame.pos, scene.m_awakeFrame.lod, true, false, true);
			scene.RenderAsync(true);
			scene.m_awakeFrame = null;
		} else {
			scene.GoToInitialStart();
		}

		if (scene.m_nInitialTrackingMode == VBI.InputModeRectSelect) {
			new scene.RectSelection();
		} else if (scene.m_nInitialTrackingMode == VBI.InputModeLassoSelect) {
			new scene.LassoSelection();
		} else if (scene.m_nInitialTrackingMode == VBI.InputModeRectZoom) {
			new scene.RectangularZoom();
		}
		scene.m_nInitialTrackingMode = VBI.InputModeDefault;
	};

	scene.ChromePerformanceCheck = function(oCanvas) {
		var bTestFailed = false;
		var d = [
			855, 672, 1512, 240, 801, 901, 1222, 1392, 1023, 1024
		]; // just any number
		var oldW = oCanvas.width, oldH = oCanvas.height;
		var somePixel;
		var ctx = oCanvas.getContext("2d");
		oCanvas.width = oCanvas.height = 1024;
		somePixel = ctx.getImageData(500, 500, 1, 1); // exclude first getImage
		var ts1, ts0 = Date.now();
		for (var i = 0; i < 10; ++i) {
			ts1 = Date.now();
			oCanvas.width = oCanvas.height = d[i];
			somePixel = ctx.getImageData(500, 500, 1, 1);
			if (Date.now() - ts1 > 60) {
				bTestFailed = true;
				break;
			}
		}
		oCanvas.width = oldW;
		oCanvas.height = oldH;
		if (bTestFailed || (Date.now() - ts0 > 80)) {
			scene.m_bObjCanvasMode = 0;
			var resStr = bTestFailed ? "(" + (Date.now() - ts1) + " ms peak)" : "(" + ((Date.now() - ts0) / 10) + " ms average)";
			VBI.Trace("Setting Object Canvas Mode to Old Style due to Performance issues " + resStr);
			if (VBI.m_bTrace) {
				VBI.Trace("Some Pixel was " + somePixel);
			}
		} else {
			VBI.Trace("Chrome Performance Test passed with " + ((Date.now() - ts0) / 10) + " ms average time.");
		}
		scene.m_bObjCanvasModeChecked = true;
	};

// canvas dimensions...................................................//
	scene.CalcCanvasWidth = function(width, tileWidth) {
		return (Math.floor(width / tileWidth + scene.m_nCanvasXOversize)) * tileWidth;
	};
	scene.CalcCanvasHeight = function(height, tileHeight) {
		return (Math.floor(height / tileHeight + scene.m_nCanvasYOversize)) * tileHeight;
	};

	scene.GetInternalDivWidth = function() {
		if (this.m_Ctx.moThumbnail && this.m_Ctx.moThumbnail.nOrgWidth) {
			return this.m_Ctx.moThumbnail.nOrgWidth;
		}
		var rect = scene.m_Div.parentNode.getBoundingClientRect();
		return rect.width ? rect.width : scene.m_Div.clientWidth;
	};

	scene.GetInternalDivHeight = function() {
		if (this.m_Ctx.moThumbnail && this.m_Ctx.moThumbnail.nOrgHeight) {
			return this.m_Ctx.moThumbnail.nOrgHeight;
		}
		var rect = scene.m_Div.parentNode.getBoundingClientRect();
		return rect.height ? rect.height : scene.m_Div.clientHeight;
	};

	scene.GetPreviewImage = function(mapLayerStack, callback) {
		var layerStack = mapLayerStack;
		//If the map config consists of preview position then use it's values
		if (layerStack.m_PreviewPosition){
			scene.m_MapManager.GetPreviewImage(layerStack.m_PreviewPosition.longitude,layerStack.m_PreviewPosition.latitude,layerStack.m_PreviewPosition.lod,layerStack,scene, callback);
		} else {
			//If map config doesn't consist of preview position use initial zoom and initial position.
			var pos = scene.m_Ctx.m_Control.getInitialPosition(); //format 0,0,0:x,y,z. z always = 0.
			var lod = scene.m_Ctx.m_Control.getInitialZoom(); //lod value
			var position = pos.split(";");
			scene.m_MapManager.GetPreviewImage(position[0],position[1],lod,layerStack,scene,callback);
		}
	};

	scene.CalculateCanvasDimensions = function() {
		var nDummy = scene.m_Target.offsetWidth; // to force browser to have consistent state

		var mapMan = scene.m_MapManager;

		var divWidth = scene.GetInternalDivWidth();
		var divHeight = scene.GetInternalDivHeight();
		if ((divWidth == scene.m_nDivWidth) && (divHeight == scene.m_nDivHeight)) {
			return; // nothing changed
		}

		scene.m_nDivWidth = divWidth;
		scene.m_nDivHeight = divHeight;
		scene.m_nWidthCanvas = scene.CalcCanvasWidth(divWidth, mapMan.m_tileWidth);
		scene.m_nHeightCanvas = scene.CalcCanvasHeight(divHeight, mapMan.m_tileHeight);
		scene.m_nTilesX = scene.m_nWidthCanvas / mapMan.m_tileWidth;
		scene.m_nTilesY = scene.m_nHeightCanvas / mapMan.m_tileHeight;

		mapMan.m_requestTileWidth = mapMan.m_tileWidth;
		mapMan.m_requestTileHeight = mapMan.m_tileHeight;

		var layerStack = scene.m_MapLayerStack;
		if (layerStack.m_nMaxSquare && layerStack.m_MapLayerArray.length) {
			var nLowestResolution = 0;
			for (var i = 0; i < layerStack.m_MapLayerArray.length; ++i) {
				if (!i || (layerStack.m_MapLayerArray[i].m_refMapProvider.m_nResolution < nLowestResolution)) {
					nLowestResolution = parseInt(layerStack.m_MapLayerArray[i].m_refMapProvider.m_nResolution, 10);
				}
			}
			var nMaxPixels = layerStack.m_nMaxSquare * nLowestResolution;
			if ((scene.m_nTilesX * mapMan.m_tileWidth > nMaxPixels) || (scene.m_nTilesY * mapMan.m_tileHeight > nMaxPixels)) {
				var newSize = Math.floor(nMaxPixels / Math.max(scene.m_nTilesX, scene.m_nTilesY));
				mapMan.m_requestTileWidth = newSize;
				mapMan.m_requestTileHeight = newSize;
			}
		}

		if (VBI.m_bTrace) {
			VBI.Trace("Setting Canvas Size to (" + scene.m_nWidthCanvas + "," + scene.m_nHeightCanvas + ") on div with size (" + divWidth + "," + divHeight + "). Dummy is " + nDummy);
		}

		// Preload is the number of pixel from the absolute border which triggers a col or row shift in a move
		scene.m_nMapMoveXPreLoad = Math.min(120, mapMan.m_tileWidth * (scene.m_nTilesX - 1) - divWidth);
		scene.m_nMapMoveYPreLoad = Math.min(120, mapMan.m_tileHeight * (scene.m_nTilesY - 1) - divHeight);

		scene.m_nCanvasStdXPos = (scene.m_nWidthCanvas - scene.m_nDivWidth) / mapMan.m_tileWidth / 2;
		scene.m_nCanvasStdYPos = (scene.m_nHeightCanvas - scene.m_nDivHeight) / mapMan.m_tileHeight / 2;

		scene.m_nMaxPixelBeyondPoles = 0;
	};

	scene.SwitchTmpCanvasToActive = function() {
		var dest = scene.m_Canvas[0], source = scene.m_Canvas[scene.m_nNonDomIndex];

		var destCtx = dest.getContext('2d');
		destCtx.clearRect(0, 0, dest.getPixelWidth(), dest.getPixelHeight());
		destCtx.drawImage(scene.m_Canvas[scene.m_nNonDomIndex], 0, 0);
		scene.MoveCanvas(dest, dest.getPixelLeft() - source.m_nOffsetX * dest.getPixelWidth() / scene.m_nTilesX, dest.getPixelTop() - source.m_nOffsetY * dest.getPixelHeight() / scene.m_nTilesY);

		dest.m_nCurrentX = source.m_nCurrentX;
		dest.m_nCurrentY = source.m_nCurrentY;

		source.m_bCanvasValid = false;
		source.m_CanvasRedirect = dest;
		source.m_CanvasRedirRequest = source.m_nRequest;
		source.m_nOffsetX = source.m_nOffsetY = 0;
		source.m_nTilesBefSwitch = undefined;

		scene.InternalRenderLayer(scene.m_Canvas[scene.m_nOverlayIndex], false, true, true, dest.m_nExactLOD);
	};

	scene.InitializeCanvas = function(canvas, nextSibling) {
		// set the scene reference..........................................//
		canvas.m_Scene = scene;

		// set current lod..................................................//
		canvas.m_nCurrentLOD = 2;
		canvas.m_nExactLOD = 2;
		canvas.m_nCurrentX = undefined;
		canvas.m_nCurrentY = undefined;
		canvas.m_nAppliedRequest = 0;

		canvas.m_bInvalid = false;

		// set the canvas as a child of the div.............................//
		if (canvas.m_bNotInDOM != 2) {
			if (!nextSibling) {
				scene.m_MapsLayerDiv.appendChild(canvas);
			} else {
				scene.m_MapsLayerDiv.insertBefore(canvas, nextSibling);
			}
		}
	};

	scene.AttachCanvasesToDOM = function() {
		var thisChild = scene.m_Div.firstChild, nextChild;
		while (thisChild) {
			var childType = thisChild.m_VBIType;
			nextChild = thisChild.nextSibling;
			if (childType == "L" || childType == "N" || childType == "S" || childType == "C") {
				scene.m_Div.removeChild(thisChild);
			} else if (thisChild.m_VBIHidden) {
				thisChild.m_VBIHidden = false;
				thisChild.style.display = thisChild.m_VBIOrgDiplay;
			}
			thisChild = nextChild;
		}
		for (var i = 0; i < scene.m_Canvas.length; ++i) {
			if (scene.m_Canvas[i].m_bNotInDOM != 2) {
				scene.m_Canvas[i].m_bNotInDOM = !scene.m_Canvas[i].m_bNotInDOM;
			}
		}
		scene.m_bThumbnailedCanvases = false;

		if (scene.m_bNavControlVisible) {
			scene.m_NavControl = new VBI.NavigationControl(scene.m_SuppressedNavControlVisibility);
			scene.m_NavControl.AttachEvents();
			scene.m_NavControl.Awake(scene, scene.m_TargetName);
		}

		if (scene.m_bScaleVisible) {
			scene.m_Scale = new VBI.Scale(scene);
			scene.m_Scale.Awake(scene, scene.m_TargetName);
		}
		scene.AddCopyright();

	};

	scene.DetachCanvasesFromDOM = function() {
		for (var i = 0; i < scene.m_Canvas.length; ++i) {
			if (scene.m_Canvas[i].m_bNotInDOM != 2) {
				scene.m_Canvas[i].m_bNotInDOM = !scene.m_Canvas[i].m_bNotInDOM;
			}
		}
		var idPrefix = scene.m_TargetName + "-" + scene.m_ID + "-";

		var thisChild = scene.m_Div.firstChild, nextChild;
		while (thisChild) {
			var childType = thisChild.m_VBIType;
			nextChild = thisChild.nextSibling;
			if (childType == "L" || childType == "N" || childType == "S" || childType == "C") {
				scene.m_Div.removeChild(thisChild);
			} else {
				thisChild.m_VBIHidden = true;
				thisChild.m_VBIOrgDiplay = thisChild.style.display;
				thisChild.style.display = 'none';
			}
			thisChild = nextChild;
		}

		var thumbnailCanvas;
		if (scene.m_nThumbnailIndex) {
			thumbnailCanvas = scene.m_Canvas[scene.m_nThumbnailIndex];
			thumbnailCanvas.width = scene.m_Div.clientWidth;
			thumbnailCanvas.setPixelWidth(thumbnailCanvas.width);
			thumbnailCanvas.height = scene.m_Div.clientHeight;
			thumbnailCanvas.setPixelHeight(thumbnailCanvas.height);

		} else {
			thumbnailCanvas = VBI.Utilities.CreateGeoSceneCanvas(idPrefix + "thumbnail", scene.m_Div.clientWidth, scene.m_Div.clientHeight, 0, false);
			scene.m_ThumbnaiEvents = new VBI.ThumbnailEvent(this, thumbnailCanvas);
			scene.m_Canvas.push(thumbnailCanvas);
			scene.m_nThumbnailIndex = scene.m_Canvas.length - 1;
		}
		scene.m_Div.appendChild(thumbnailCanvas);
		scene.m_bThumbnailedCanvases = true;

		if (scene.m_NavControl) {
			scene.m_SuppressedNavControlVisibility = scene.m_NavControl.suppressedVisibility;
			scene.m_NavControl.clear();
			scene.m_NavControl = null;
		}

		if (scene.m_Scale) {
			scene.m_Scale.clear();
			scene.m_Scale = null;
		}
		scene.m_DivCopyright = null;
	};

	scene.CreateCanvases = function() {
		// create the switchable......................................//
		var idPrefix = scene.m_TargetName + "-" + scene.m_ID + "-";
		var bThumbnailMode = false;

		if (scene.m_Ctx.moThumbnail) {
			bThumbnailMode = true;
			if (!scene.m_Ctx.moThumbnail.bThumbnailed) {
				scene.m_Ctx.DoMinimize(scene);
			}
		}
		scene.clearCanvases(); //remove old canvases first

		// Note: A tabindex of -1 prevents the element from getting the focus
		scene.m_Canvas.push(VBI.Utilities.CreateGeoSceneCanvas(idPrefix + "layer1", scene.m_nWidthCanvas, scene.m_nHeightCanvas, /* tabindex= */-1, bThumbnailMode, "vbi-map-active"));
		// map toggle layer
		scene.m_Canvas.push(VBI.Utilities.CreateGeoSceneCanvas(idPrefix + "layer2", scene.m_nWidthCanvas, scene.m_nHeightCanvas, /* tabindex= */-1, bThumbnailMode, "vbi-map-inactive"));
		// map toggle layer
		// shadow layer is created on demand and inserted before object layer
		scene.m_Canvas.push(VBI.Utilities.CreateGeoSceneCanvas(idPrefix + "objectlayer", scene.m_nWidthCanvas, scene.m_nHeightCanvas, /* tabindex= */-1, bThumbnailMode));
		// object layer
		scene.m_Canvas.push(VBI.Utilities.CreateGeoSceneCanvas(idPrefix + "labellayer", scene.m_nWidthCanvas, scene.m_nHeightCanvas, /* tabindex= */0, bThumbnailMode));
		// label layer
		scene.m_Canvas.push(VBI.Utilities.CreateGeoSceneCanvas(idPrefix + "nondomlayer", scene.m_nWidthCanvas, scene.m_nHeightCanvas, /* tabindex= */-1, 2));
		// nondom layer
		if (bThumbnailMode) {
			scene.m_Canvas.push(VBI.Utilities.CreateGeoSceneCanvas(idPrefix + "thumbnail", scene.m_Div.clientWidth, scene.m_Div.clientHeight, 0, false));
			// map toggle layer
			scene.m_nThumbnailIndex = scene.m_Canvas.length - 1;
			scene.m_ThumbnaiEvents = new VBI.ThumbnailEvent(this, scene.m_Canvas[scene.m_nThumbnailIndex]);
			scene.m_bThumbnailedCanvases = true;
		}
		scene.m_nShadowIndex = undefined;

		for (var nJ = 0; nJ < scene.m_Canvas.length; ++nJ) {
			scene.InitializeCanvas(scene.m_Canvas[nJ]);
		}
		scene.ToggleCanvas(scene);
		if (scene.m_Ctx.moThumbnail) {
			scene.DetachCanvasesFromDOM();
		}
		if (scene.m_nCanvasMaxPixel == undefined) {
			var estimate = 8192; // IE
			if (VBI.m_bIsMyChromeTest) {
				estimate = 32767; // Chrome supports more
			}
			if (VBI.m_bIsIDevice) {
				estimate = 5120;
			}
			if (VBI.m_bIsAndroid) {
				estimate = 16384;
			}
			scene.m_nCanvasMaxPixel = scene.CalculateCanvasMaxPixel(scene.m_Canvas[2], estimate, 16384);
		}
	};

	scene.CalculateCanvasMaxPixel = function(canvas, minVal, maxVal) {
		var oldWidth = canvas.width;
		var oldHeight = canvas.height;
		if (minVal > maxVal - 100) {
			return minVal;
		}
		var ctx = canvas.getContext("2d");
		if (scene.CanvasSizeTest(canvas, ctx, Math.floor(minVal * 1.05))) {
			while (maxVal - minVal > 50) {
				var middleVal = Math.floor((minVal + maxVal) / 2);
				if (scene.CanvasSizeTest(canvas, ctx, middleVal)) {
					minVal = middleVal;
				} else {
					maxVal = middleVal;
				}
			}
		}
		canvas.width = oldWidth;
		canvas.height = oldHeight;

		return minVal;
	};

	scene.CanvasSizeTest = function(canvas, ctx, val) {
		canvas.height = 1024;
		canvas.width = val;
		ctx.fillStyle = "#050000";
		ctx.fillRect(val - 1, 1023, 1, 1);
		var p = ctx.getImageData(val - 1, 1023, 1, 1).data;

		return (p[0] + 256 * (p[1] + 256 * p[2]) == 5);
	};

	scene.DivIsAlive = function() {
		var rect = scene.m_Div.getBoundingClientRect();
		return (rect.width != 0 || rect.height != 0);
	};

	scene.resizeCanvas = function(event, bForce, bSuppressLodAjust) {

		if (!scene.DivIsAlive()) { // suppress resizing when div dimension is 0x0
			return;
		}

		if (!scene.m_Canvas.length) { // no wake done yet, do it now
			scene.DoAwake();
			return;
		}

		if (scene.m_Canvas[scene.m_nNonDomIndex].m_bCanvasValid) {
			scene.SwitchTmpCanvasToActive();
		}

		var mapMan = scene.m_MapManager;
		var canvas = scene.m_Canvas[0];
		var oldWidth = scene.m_nDivWidth;
		var oldHeight = scene.m_nDivHeight;
		var oldMinLod = scene.GetMinLODForWidth(oldWidth);
		var stretchFactor = canvas.getPixelWidth() / scene.m_nWidthCanvas;

		scene.m_nLastRenderLOD = -1; // to force Re-Rendering

		scene.CalculateCanvasDimensions();

		if (scene.m_Ctx.moThumbnail) {
			if (!scene.m_bThumbnailedCanvases) {
				scene.DetachCanvasesFromDOM();
			} else {
				var thumbnailCanvas = scene.m_Canvas[scene.m_nThumbnailIndex];
				thumbnailCanvas.width = scene.m_Div.clientWidth;
				thumbnailCanvas.height = scene.m_Div.clientHeight;
				thumbnailCanvas.setPixelWidth(scene.m_Div.clientWidth);
				thumbnailCanvas.setPixelHeight(scene.m_Div.clientHeight);
			}
		} else if (scene.m_bThumbnailedCanvases) {
			scene.AttachCanvasesToDOM();
		} else if ((!bForce) && (scene.m_nDivWidth == oldWidth) && (scene.m_nDivHeight == oldHeight)) {
			return;
		}

		if (VBI.m_bTrace) {
			VBI.Trace("Resizing (" + (oldWidth) + "," + (oldHeight) + ") to (" + (scene.m_nDivWidth) + "," + (scene.m_nDivHeight) + ")");
		}

		var oldCurrentX = canvas.m_nCurrentX;
		var oldCurrentY = canvas.m_nCurrentY;
		var lod = canvas.m_nCurrentLOD;

		// new dimensions for canvas 0
		var newPixelLeft = canvas.getPixelLeft() + (scene.m_nDivWidth - oldWidth) / 2;
		var xDistToMean = Math.round((-newPixelLeft / mapMan.m_tileWidth - scene.m_nCanvasStdXPos) / stretchFactor);
		newPixelLeft += stretchFactor * xDistToMean * mapMan.m_tileWidth;

		var newPixelTop = canvas.getPixelTop() + (scene.m_nDivHeight - oldHeight) / 2;
		var yDistToMean = Math.round((-newPixelTop / mapMan.m_tileHeight - scene.m_nCanvasStdYPos) / stretchFactor);
		newPixelTop += stretchFactor * yDistToMean * mapMan.m_tileHeight;

		for (var i = 0; i < scene.m_Canvas.length; ++i) {
			if (i != scene.m_nThumbnailIndex) {
				if (scene.m_Canvas[i].width != scene.m_nWidthCanvas) {
					scene.m_Canvas[i].width = scene.m_nWidthCanvas;
				}
				if (scene.m_Canvas[i].height != scene.m_nHeightCanvas) {
					scene.m_Canvas[i].height = scene.m_nHeightCanvas;
				}
			}
		}

		scene.InvalidateCanvas(scene.m_Canvas[1]);
		scene.MoveCanvas(canvas, newPixelLeft, newPixelTop, stretchFactor * scene.m_nWidthCanvas, stretchFactor * scene.m_nHeightCanvas);
		scene.m_MapManager.RequestTiles(canvas, scene.m_MapLayerStack, oldCurrentX + xDistToMean, oldCurrentY + yDistToMean, scene.m_nTilesX, scene.m_nTilesY, 0, 0, 0, 0, lod, false);
		var lza = scene.m_LastZoomArea; // must be stored before ZoomMap may be able to destroy it
		var bAreaZoomExecuted = false;
		if (lza != undefined) {
			var timeNow = new Date().getTime();
			if ((timeNow - lza[0]) < 3000) {
				switch (lza[1]) {
					case "Area":
						scene.ZoomToArea(lza[2], lza[3], lza[4], lza[5], lza[6]);
						bAreaZoomExecuted = true;
						break;
					case "Areas":
						scene.ZoomToAreas(lza[2], lza[3]);
						bAreaZoomExecuted = true;
						break;
					default:
						break;
				}
			}
		}
		if (!bAreaZoomExecuted) {
			var newMinLod = scene.GetMinLOD();
			if (canvas.m_nExactLOD < newMinLod) {
				scene.ZoomMap(Math.pow(2, newMinLod - canvas.m_nExactLOD) * 1.000001, scene.m_nDivWidth / 2 - newPixelLeft, scene.m_nDivHeight / 2 - newPixelTop);
			} else if (!bSuppressLodAjust && canvas.m_nExactLOD != Math.floor(canvas.m_nExactLOD)) {
				scene.AnimateZoomToGeo(scene.GetCenterPos(), Math.floor(canvas.m_nExactLOD), 5);
			} else {
				scene.InternalRenderLayer(scene.m_Canvas[scene.m_nOverlayIndex], false, true, true, canvas.m_nExactLOD);
				scene.InternalOnMoveLayer(scene.m_Canvas[scene.m_nOverlayIndex]);
			}
			var newMaxLod = scene.GetMaxLOD();
			if (canvas.m_nExactLOD > newMaxLod) {
				scene.ZoomMap(Math.pow(2, newMaxLod - canvas.m_nExactLOD), scene.m_nDivWidth / 2 - newPixelLeft, scene.m_nDivHeight / 2 - newPixelTop);
			}
		}

		if ((bForce || (scene.GetMinLOD() != oldMinLod)) && scene.m_NavControl) { // if width has changed and minLOD is not set directly it will
			// change
			scene.m_NavControl.AdaptMinMaxLOD(scene);
		}

		if (scene.m_bNavControlVisible && scene.m_NavControl) {
			scene.m_NavControl.AdjustScrollPoint(scene.m_Canvas[0].m_nExactLOD); // "canvas" might be [1], now so we use scene.m_Canvas[0]
		}

		scene.InternalRenderLayer(scene.m_Canvas[scene.m_nOverlayIndex], false, false, true, scene.m_Canvas[0].m_nExactLOD); // will re-render if
		// none of the above
		// triggered a render
	};

	VBI.addSceneLassoTrackingFunctions(scene);
	VBI.addSceneRectangularTrackingFunctions(scene);
	scene.m_TransitionTable = scene.BuildQuarterTransistionTable();

	// when a target is already specified, awake the scene to be alive........//
	if (target) {
		scene.Awake(target, mapmanager, maplayerstack);
	}

	return scene;
};
﻿// ...........................................................................//
// utilities object..........................................................//

// Author: Ulrich Roegelein

// ...........................................................................//
// this module is just a utility collection..................................//

VBI.Utilities = VBI.Utilities || {};
/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
// ...........................................................................//
// HTMLCanvasElement element prototyes.......................................//
HTMLCanvasElement.prototype.getPixelWidth = function() {
	"use strict";
	if (this.m_pixelWidth) {
		return this.m_pixelWidth;
	}

	if (this.style.pixelWidth !== undefined) {
		return this.style.pixelWidth;
	}
	return parseInt(this.style.width, 10); // due to ff
};

HTMLCanvasElement.prototype.getPixelHeight = function() {
	"use strict";
	if (this.m_pixelHeight) {
		return this.m_pixelHeight;
	}

	if (this.style.pixelHeight !== undefined) {
		return this.style.pixelHeight;
	}

	return parseInt(this.style.height, 10); // due to ff
};

HTMLCanvasElement.prototype.getPixelLeft = function() {
	"use strict";
	if (this.m_pixelLeft) {
		return this.m_pixelLeft;
	}
	if (this.style.pixelLeft !== undefined) {
		return this.style.pixelLeft;
	}
	return parseInt(this.style.left, 10); // due to ff
};

HTMLCanvasElement.prototype.getPixelTop = function() {
	"use strict";
	if (this.m_pixelTop) {
		return this.m_pixelTop;
	}

	if (this.style.pixelTop !== undefined) {
		return this.style.pixelTop;
	}

	return parseInt(this.style.top, 10); // due to ff
};

HTMLCanvasElement.prototype.setPixelWidth = function(val) {
	"use strict";
	this.m_pixelWidth = val;

	if (this.style.pixelWidth !== undefined) {
		this.style.pixelWidth = val;
	} else {
		this.style.width = val + 'px';
	}
};

HTMLCanvasElement.prototype.setPixelHeight = function(val) {
	"use strict";
	this.m_pixelHeight = val;

	if (this.style.pixelHeight !== undefined) {
		this.style.pixelHeight = val;
	} else {
		this.style.height = val + 'px';
	}
};

HTMLCanvasElement.prototype.setPixelLeft = function(val) {
	"use strict";
	this.m_pixelLeft = val;

	if (this.style.pixelLeft !== undefined) {
		this.style.pixelLeft = val;
	} else {
		this.style.left = val + 'px';
	}
};

HTMLCanvasElement.prototype.setPixelTop = function(val) {
	"use strict";
	this.m_pixelTop = val;
	if (this.style.pixelTop !== undefined) {
		this.style.pixelTop = val;
	} else {
		this.style.top = val + 'px';
	}
};

// ...........................................................................//
// create a dummy element....................................................//

VBI.Utilities.CreateWifiObject = function() {
	"use strict";
	var newElement = document.createElement('object');
	if (!newElement) {
		return null;
	}

	newElement.classid = "CLSID:00100000-2013-0070-2000-651572487E69";
	return newElement;
};

VBI.Utilities.CreateDOMElement = function(type, id, width, height) {
	"use strict";
	var newElement = document.createElement(type);
	newElement.style.height = width ? width : "1px";
	newElement.style.width = height ? height : "1px";
	newElement.id = id;

	return newElement;
};

VBI.Utilities.GetDOMElement = function(args) {
	"use strict";
	var elements = [];

	for (var i = 0, len = arguments.length; i < len; i++) {
		var element = arguments[i];
		if (typeof element == 'string') {
			element = document.getElementById(element);
		}
		if (arguments.length == 1) {
			return element;
		}
		elements.push(element);
	}
	return elements;
};

// ...........................................................................//
// create a new DOM element..................................................//

VBI.Utilities.CreateDOMVBIDivElement = function(id, width, height) {
	"use strict";
	// <div id="myDiv" style="overflow:hidden;position:absolute;left:0px;top:0px;width:300px;height:300px">

	var newElement = document.createElement('div');
	newElement.id = id;
	newElement.style.height = "300x";
	newElement.style.width = "300px";
	newElement.style.overflow = "hidden";
	newElement.style.position = "absolute";
	newElement.style.left = "0px";
	newElement.style.top = "0px";

	return newElement;
};

VBI.Utilities.Create3DSceneDiv = function(id) {
	"use strict";
	var newElement = document.createElement('div');

	newElement.id = id;
	newElement.style.left = "0px";
	newElement.style.top = "0px";
	newElement.style.width = "100%";
	newElement.style.height = "100%";
	newElement.style.position = "relative";
	newElement.style.overflow = "hidden";

	return newElement;
};

VBI.Utilities.Create3DSceneCanvas = function(id, width, height, zindex, tabindex, isNonDOM) {
	"use strict";
	var newElement = document.createElement('canvas');

	newElement.id = id;

	newElement.m_pixelLeft = newElement.m_pixelTop = 0;
	newElement.width = newElement.m_pixelWidth = width ? width : 512;
	newElement.height = newElement.m_pixelHeight = height ? height : 512;

	newElement.style.left = newElement.style.top = "0px";
	newElement.style.width = newElement.m_pixelWidth + "px";
	newElement.style.height = newElement.m_pixelHeight + "px";
	newElement.style.position = "absolute";
	newElement.style.zIndex = zindex;
	newElement.style.touchaction = "none";
	newElement.className = "vbi-3Dscenecanvas";

	newElement.m_bNotInDOM = (isNonDOM != undefined ? isNonDOM : false);
	newElement.m_CanvasValid = !newElement.m_bNotInDOM; // nonDomCanvases must be set to valid explicitely

	if (newElement.m_bNotInDOM) {
		newElement.m_nMoveCount = 0;
	}

	if (tabindex != undefined) {
		newElement.tabIndex = tabindex;
	}
	return newElement;
};

VBI.Utilities.CreateGeoSceneCanvas = function(id, width, height, tabindex, isNonDOM, addClasses) {
	"use strict";
	var newElement = document.createElement('canvas');

	newElement.id = id;

	newElement.m_pixelLeft = newElement.m_pixelTop = 0;
	newElement.width = newElement.m_pixelWidth = width ? width : 512;
	newElement.height = newElement.m_pixelHeight = height ? height : 512;

	newElement.style.left = newElement.style.top = "0px";
	newElement.style.width = newElement.m_pixelWidth + "px";
	newElement.style.height = newElement.m_pixelHeight + "px";
	newElement.style.position = "absolute";
	newElement.style.touchaction = "none";
	newElement.className = "vbi-geoscenecanvas";
	if (addClasses) {
		newElement.className += " " + addClasses;
	}

	newElement.m_bNotInDOM = (isNonDOM != undefined ? isNonDOM : false);
	newElement.m_CanvasValid = !newElement.m_bNotInDOM; // nonDomCanvases must be set to valid explicitely
	newElement.m_VBIType = "L";

	if (newElement.m_bNotInDOM) {
		newElement.m_nMoveCount = 0;
	}

	if (tabindex != undefined) {
		newElement.tabIndex = tabindex;
	}

	return newElement;
};

// ...........................................................................//
// 2D element creators.......................................................//

// mapping of align values...................................................//
VBI.Utilities.Align = [
	'', 'left', 'center', '', 'right'
];

VBI.Utilities.CreateCaption = function(id, text, left, top, right, bottom, tooltip, design, level, align) {
	"use strict";
	// create the frame.......................................................//
	var newElement = document.createElement('div');
	newElement.id = id;
	newElement.style.left = left + "px";
	newElement.style.top = top + "px";
	newElement.style.width = (right - left).toString() + "px";
	newElement.style.height = (bottom - top).toString() + "px";
	newElement.style.textAlign = VBI.Utilities.Align[align];
	newElement.style.title = tooltip;

	// dependent on design and level the font size and bold state changes.....//
	switch (level) {
		// zu tun: add other styles..............................................//
		case 3:
			newElement.style.fontSize = "14px";
			newElement.style.fontWeight = "bold";
			break;
	}

	newElement.className = "vbi-2d-caption vbi-2d-common";
	newElement.innerHTML = text;
	return newElement;
};

VBI.Utilities.CreateLabel = function(id, text, left, top, right, bottom, tooltip, align) {
	"use strict";
	// create the frame.......................................................//
	var newElement = document.createElement('div');
	newElement.id = id;
	newElement.style.left = left + "px";
	newElement.style.top = top + "px";
	newElement.style.width = (right - left).toString() + "px";
	newElement.style.height = (bottom - top).toString() + "px";
	newElement.style.textAlign = VBI.Utilities.Align[align];
	newElement.style.title = tooltip;
	newElement.className = "vbi-2d-label vbi-2d-common";
	newElement.innerHTML = text;
	return newElement;
};

VBI.Utilities.CreateLink = function(id, text, left, top, right, bottom, href, tooltip, align) {
	"use strict";
	// create the frame.......................................................//
	var newElement = document.createElement('a');
	newElement.id = id;
	newElement.style.left = left + "px";
	newElement.style.top = top + "px";
	newElement.style.width = (right - left).toString() + "px";
	newElement.style.height = (bottom - top).toString() + "px";
	newElement.style.textAlign = VBI.Utilities.Align[align];
	newElement.className = "vbi-2d-link vbi-2d-common";
	newElement.href = href ? href : "javascrip" + "t:void(0)"; // separated to fool ESLint
	newElement.title = tooltip;
	newElement.innerHTML = text;
	return newElement;
};

VBI.Utilities.CreateImage = function(id, img, left, top, right, bottom, tooltip, align) {
	"use strict";
	// image is assumed to be a dom element located in the resources..........//
	// var newElement = document.createElement('img');
	var newElement = img.cloneNode(true);
	newElement.id = id;
	newElement.style.left = left + "px";
	newElement.style.top = top + "px";
	newElement.style.width = (right - left).toString() + "px";
	newElement.style.height = (bottom - top).toString() + "px";
	newElement.style.textAlign = VBI.Utilities.Align[align];
	newElement.className = "vbi-2d-image vbi-2d-common";
	newElement.title = tooltip;
	return newElement;
};

VBI.Utilities.CreateButton = function(id, text, left, top, right, bottom, tooltip, align) {
	"use strict";
	// create the frame.......................................................//
	var newElement = document.createElement('button');
	newElement.id = id;
	newElement.style.left = left + "px";
	newElement.style.top = top + "px";
	newElement.style.width = (right - left).toString() + "px";
	newElement.style.height = (bottom - top).toString() + "px";
	newElement.style.textAlign = VBI.Utilities.Align[align];
	newElement.className = "vbi-2d-button vbi-2d-common";
	newElement.innerHTML = text;
	newElement.title = tooltip;
	return newElement;
};

VBI.Utilities.CreateContainer = function(id, key, left, top, width, height, tooltip, bOmitClass) {
	"use strict";
	// create the container...................................................//
	var newElement = document.createElement('div');
	newElement.id = id;
	newElement.style.left = left + "px";
	newElement.style.top = top + "px";
	newElement.title = tooltip;
	newElement.style.position = "absolute";
	if (!bOmitClass) {
		newElement.className = "vbi-container-vo";
	}
	newElement.m_Key = key;

	return newElement;
};

// ...........................................................................//
// callout container.........................................................//
VBI.Utilities.CreateDetailPhone = function(id, left, top, width, height, titletext, padding) {
	"use strict";
	// create the detail frame................................................//
	var detail = document.createElement('div');
	detail.id = id;
	detail.style.left = left + "px";
	detail.style.top = top + "px";

	var paddingPhone = 12;
	var spacingPhone = 6;
	var headerFontSizePhone = 14;
	paddingPhone = VBI.Utilities.RemToPixel(0.750);
	spacingPhone = VBI.Utilities.RemToPixel(0.375);
	headerFontSizePhone = VBI.Utilities.RemToPixel(0.875);

	if (height) {
		detail.style.minHeight = height + headerFontSizePhone + 4 + spacingPhone + 2 * paddingPhone + "px";
	}

	detail.className = ".vbi-detail vbi-detail-phone";

	// create the header,.....................................................//
	var header = document.createElement('div');
	header.id = id + "-window-header";
	header.className = "vbi-detail-header-phone";
	detail.appendChild(header);

	// create the title......................................................//
	var title = document.createElement('div');
	title.id = id + "-window-title";
	title.className = "vbi-detail-title-phone";
	title.innerHTML = titletext;
	header.appendChild(title);

	// create the close.......................................................//
	var close = document.createElement('div');
	close.id = id + "-window-close";
	close.className = "vbi-detail-closebutton vbi-detail-closebutton-tablet";
	header.appendChild(close);

	// create the content.....................................................//
	var content = document.createElement('div');
	content.id = id + "-window-content";
	content.className = "vbi-detail-content";
	content.style.fontSize = VBI.Utilities.RemToPixel(0.875) + "px";
	// content.style.width = "100%";
	detail.appendChild(content);

	// return the created elements............................................//
	return {
		// add members................................................//
		m_Div: detail,
		m_Content: content,
		m_CloseButton: close,
		m_Arrow: null,
		GetAnchorPoint: null
	};

};

VBI.Utilities.CreateDetail = function(id, left, top, width, height, titletext, padding) {
	"use strict";
	if (VBI.m_bIsPhone) {
		return (VBI.Utilities.CreateDetailPhone(id, left, top, width, height, titletext, padding));
	}

	// create the detail frame................................................//
	var detail = document.createElement('div');
	detail.id = id;
	detail.style.left = left + "px";
	detail.style.top = top + "px";

	// ask whether phone or not
	var bPhone = VBI.m_bIsPhone;
	// add the size of the decorators.........................................//
	if (!bPhone) {
		var paddingDesktop = 16;
		var spacingDesktop = 16;
		var headerFontSize = 16;
		paddingDesktop = VBI.Utilities.RemToPixel(1);
		spacingDesktop = VBI.Utilities.RemToPixel(1);
		headerFontSize = VBI.Utilities.RemToPixel(1);
		if (width) {
			detail.style.width = width + 2 * paddingDesktop + "px";
		}
		if (height) {
			detail.style.minHeight = height + headerFontSize + 4 + spacingDesktop + 2 * paddingDesktop + "px";
		}
	} else {
		var paddingPhone = 12;
		var spacingPhone = 6;
		var headerFontSizePhone = 14;
		paddingPhone = VBI.Utilities.RemToPixel(0.750);
		spacingPhone = VBI.Utilities.RemToPixel(0.375);
		headerFontSizePhone = VBI.Utilities.RemToPixel(0.875);

		if (height) {
			detail.style.minHeight = height + headerFontSizePhone + 4 + spacingPhone + 2 * paddingPhone + "px";
		}
	}

	detail.className = "vbi-detail vbi-detail-border";

	// create the header,.....................................................//
	var header = document.createElement('div');
	header.id = id + "-window-header";
	header.className = "vbi-detail-header";
	detail.appendChild(header);

	// create the title......................................................//
	var title = document.createElement('div');
	title.id = id + "-window-title";
	title.className = "vbi-detail-title";
	title.innerHTML = titletext;
	header.appendChild(title);

	// create the close.......................................................//
	var close = document.createElement('div');
	close.id = id + "-window-close";
	var oResourceBundle = sap.ui.getCore().getLibraryResourceBundle("sap.ui.vbm.i18n");
	close.title = oResourceBundle.getText("WINDOW_CLOSE");

	close.className = "vbi-detail-closebutton vbi-detail-closebutton-" + (VBI.m_bIsMobile ? "tablet" : "desktop");
	header.appendChild(close);

	// create the content.....................................................//
	var content = document.createElement('div');
	content.id = id + "-window-content";
	content.className = "vbi-detail-content";
	// content.style.width = "100%";
	detail.appendChild(content);

	// set arrows.............................................................//
	var newB = document.createElement('b');
	newB.className = "vbi-detail-arrow vbi-detail-left vbi-detail-border-arrow";
	if (!bPhone) {
		detail.appendChild(newB);
	}
	var newBArrow;
	newBArrow = document.createElement('b');
	newBArrow.className = "vbi-detail-arrow vbi-detail-left";
	if (!bPhone) {
		detail.appendChild(newBArrow);
	}

	// return the created elements............................................//
	return {
		// add members................................................//
		m_Div: detail,
		m_Content: content,
		m_CloseButton: close,
		m_Arrow: newBArrow,

		// append a calculation function to get the offsets to the....//
		// anchor point...............................................//
		GetAnchorPoint: function() {
			if (VBI.m_bIsRtl) {
				return [
					this.m_Arrow.offsetLeft + this.m_Arrow.offsetWidth + 2, this.m_Arrow.offsetTop + this.m_Arrow.offsetHeight / 2
				];
			} else {
				return [
					this.m_Arrow.offsetLeft, this.m_Arrow.offsetTop + this.m_Arrow.offsetHeight / 2
				];
			}
			// return [ -this.m_Arrow.offsetLeft, -this.m_Arrow.offsetTop ];
		}
	};
};

VBI.Utilities.CreateLegendPhone = function(id, left, top, width, height, titletext, padding) {
	"use strict";

};

VBI.Utilities.CreateLegend = function(id, top, titletext, padding, bClickRow) {
	"use strict";
	// if (VBI.m_bIsPhone)
// return ( VBI.Utilities.CreateLegendPhone( id, right, top, titletext, padding ) );
	// create the legend frame................................................//
	var legend = document.createElement('div');
	legend.id = id;
	if (VBI.m_bIsRtl) {
		legend.style.left = "0px";
		legend.style.right = "";
	} else {
		legend.style.right = "0px";
		legend.style.left = "";
	}
	// legend.style.right = right + "px";
	legend.style.top = top + "px";

// var paddingDesktop = 16;
// var spacingDesktop = 16;
// var headerFontSize = 16;
// paddingDesktop = VBI.Utilities.RemToPixel( 1 );
// spacingDesktop = VBI.Utilities.RemToPixel( 1 );
// headerFontSize = VBI.Utilities.RemToPixel( 1 );

	legend.className = "vbi-legend";
	var oResourceBundle = sap.ui.getCore().getLibraryResourceBundle("sap.ui.vbm.i18n");

	// create the buttons to collapse/expand the legend .......................//
	var bt1 = document.createElement('div');
	bt1.id = id + "-button-collapse";
	bt1.title = oResourceBundle.getText("LEGEND_COLLAPSE");

	bt1.className = "vbi-legend-button vbi-legend-button-col";
	legend.appendChild(bt1);

	var bt2 = document.createElement('div');
	bt2.id = id + "-button-expand";
	bt2.title = oResourceBundle.getText("LEGEND_EXPAND");

	bt2.className = "vbi-legend-button vbi-legend-button-exp";
	legend.appendChild(bt2);
	bt2.style.visibility = 'hidden';

	// create the header,.....................................................//
	var header = document.createElement('div');
	header.id = id + "-header";
	header.className = "vbi-legend-header";
	legend.appendChild(header);

	// create the title......................................................//
	var title = document.createElement('div');
	title.id = id + "-title";
	title.className = "vbi-legend-title";
	title.innerHTML = titletext;
	header.appendChild(title);

	// create the content.....................................................//
	var content = document.createElement('div');
	content.id = id + "-content";
	content.className = "vbi-legend-content";
	legend.appendChild(content);
	var table = document.createElement('table');
	table.id = id + "-table";
	table.className = bClickRow ? "vbi-legend-table vbi-legend-table-click" : "vbi-legend-table";
	content.appendChild(table);

	// return the created elements............................................//
	return {
		// add members................................................//
		m_Div: legend,
		m_Header: header,
		m_Content: content,
		m_Table: table,
		m_ButtonCol: bt1,
		m_ButtonExp: bt2
	};
};

VBI.Utilities.CreateGeoSceneDivCSS = function(id, classname, title) {
	"use strict";
	var newElement = document.createElement('div');

	newElement.id = id;
	if (classname) {
		newElement.className = classname;
	}
	if (title) {
		newElement.title = title;
	}
	return newElement;
};

VBI.Utilities.CreateDOMColorShiftedImageFromData = function(data, imgType, rhls1, rhls2, lcb) {
	"use strict";
	// the function will create an image......................................//
	// the lcb is the load callback...........................................//
	// it is required for hue shifted images..................................//
	// the rhls1 is usually the select color shift............................//
	// the rhls2 is usually the hue color shift...............................//

	var rgba1 = null, hls1 = rhls1 ? VBI.Types.string2rhls(rhls1) : null;
	if (!hls1) {
		rgba1 = rhls1 ? VBI.Types.string2rgba(rhls1) : null;
	}

	var rgba2 = null, hls2 = rhls2 ? VBI.Types.string2rhls(rhls2) : null;
	if (!hls2) {
		rgba2 = rhls2 ? VBI.Types.string2rgba(rhls2) : null;
	}

	var tmp = document.createElement('img');
	var img = document.createElement('img');
	if (lcb) {
		tmp.onload = function() {
			if (typeof lcb === 'function') {
				lcb(tmp);
			}

			this.onload = null;
		};

		img.onload = function() {
			// create a canvas and raw the image into it........................//
			var cv = document.createElement("canvas");
			var ctx = cv.getContext("2d");
			cv.width = img.width;
			cv.height = img.height;
			ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, 0, 0, img.width, img.height);

			// get the data.....................................................//
			var pxls = ctx.getImageData(0, 0, img.width, img.height);
			var data = pxls.data;

			function applypixelcolor(data, offset, hlsa, rgba) {
				var r = data[offset];
				var g = data[offset + 1];
				var b = data[offset + 2];
				var a = data[offset + 3];

				if (hlsa) {
					var hls = VBI.Utilities.RGB2HLS(r, g, b);
					var rgb = VBI.Utilities.HLS2RGB(hls[0] + hlsa[0], hls[1] * hlsa[1], hls[2] * hlsa[2]);
					data[offset] = Math.min(Math.round(rgb[0]), 255);
					data[offset + 1] = Math.min(Math.round(rgb[1]), 255);
					data[offset + 2] = Math.min(Math.round(rgb[2]), 255);
					data[offset + 3] = Math.min(Math.round(hlsa[3] * a), 255);
				} else if (rgba) {
					data[offset] = rgba[0];
					data[offset + 1] = rgba[1];
					data[offset + 2] = rgba[2];
					if (data[offset + 3]) {
						data[offset + 3] = rgba[4] ? Math.floor(Math.min(rgba[3] * 255, 255)) : 255;
					}
				}
			}

			for (var nJ = 0, len = (img.width * img.height); nJ < len; ++nJ) {
				var offset = nJ * 4;

				// apply rhls1 first.............................................//
				if (hls1 || rgba1) {
					applypixelcolor(data, offset, hls1, rgba1);
				}

				// apply rhls2 second............................................//
				if (hls2 || rgba2) {
					applypixelcolor(data, offset, hls2, rgba2);
				}
			}

			ctx.putImageData(pxls, 0, 0);
			tmp.src = cv.toDataURL("image/png");

			this.onload = null;
		};
	}
	// check if data is already a data url....................................//
	img.src = ((data.indexOf("data:image") == 0) ? data : ("data:image" + imgType + ";base64," + data));

	return tmp;
};

VBI.Utilities.CreateDOMImageFromData = function(data, imgType, lcb) {
	"use strict";
	// the function will create an image......................................//
	// the lcb is the load callback...........................................//

	var img = document.createElement('img');
	if (lcb) {
		img.onload = function() {
			if (typeof lcb === 'function') {
				lcb(img);
			}
			this.onload = null;
		};
	}

	// check if data is already a data url....................................//
	img.src = ((data.indexOf("data:image") == 0) ? data : ("data:image" + imgType + ";base64," + data));
	return img;
};

VBI.Utilities.GetTransparentImage = function() {
	"use strict";
	// the function will create a one pixel transparent image.................//
	// the lcb is the load callback...........................................//

	var transparentPixelData = "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=";
	if (!this.m_TransparentImage) {
		this.m_TransparentImage = VBI.Utilities.CreateDOMImageFromData(transparentPixelData, '/png', /* scene.RenderAsync.bind( ) */null);
		this.m_TransparentImage.id = "TransparentImage";
	}
	return this.m_TransparentImage;
};

// ...........................................................................//
// rectangle functions.......................................................//

VBI.Utilities.PtOnRect = function(pt, rect) {
	"use strict";
	return ((pt[0] >= rect[0]) && (pt[0] <= rect[2]) && (pt[1] >= rect[1]) && (pt[1] <= rect[3])) ? true : false;
};

VBI.Utilities.PtInRect = function(pt, rect) {
	"use strict";
	return ((pt[0] > rect[0]) && (pt[0] < rect[2]) && (pt[1] > rect[1]) && (pt[1] < rect[3])) ? true : false;
};

VBI.Utilities.RectIntersect = function(rc1, rc2) {
	"use strict";
	// determine whether the two provided rectangles intersect each other.....//
	return !(rc2[0] > rc1[2] || rc2[2] < rc1[0] || rc2[3] < rc1[1] || rc2[1] > rc1[3]);
};

VBI.Utilities.RectOffset = function(rc, nX, nY) {
	"use strict";
	rc[0] += nX;
	rc[1] += nY;
	rc[2] += nX;
	rc[3] += nY;
};

VBI.Utilities.cImg;
VBI.Utilities.GetImagePixelData = function(img) {
	"use strict";

	if (!VBI.Utilities.cImg) {
		VBI.Utilities.cImg = document.createElement('canvas');
	}
	VBI.Utilities.cImg.width = img.naturalWidth;
	VBI.Utilities.cImg.height = img.naturalHeight;
	VBI.Utilities.cImg.style.width = (img.naturalWidth + "px");
	VBI.Utilities.cImg.style.height = (img.naturalHeight + "px");
	VBI.Utilities.cImg.style.top = "0px";
	VBI.Utilities.cImg.style.left = "0px";
	VBI.Utilities.cImg.style.position = "absolute";
	var ctx = VBI.Utilities.cImg.getContext("2d");
	ctx.drawImage(img, 0, 0);
	var imgData = ctx.getImageData(0, 0, VBI.Utilities.cImg.width, VBI.Utilities.cImg.height);
	return imgData;
};

VBI.Utilities.pointOnLine = function(poly, x, y, dist, closed) {
	"use strict";
	// check if a point is near the line, it returns the segment that fits....//
	// when no segment fits the returned object has edge set to -1............//
	// when no node fits the returned object has node set to -1...............//
	// the return is an object which contains the edge and the node...........//
	// when the closed parameter is set, the segment between the start and....//
	// endpoint are getting checked as well...................................//

	function sqDist(v1, v2) {
		return ((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
	}

	var ret = -1, node = -1, sqdist = dist * dist, sqtemp = sqdist;
	var tmp, v1, v2;
	var funcSqDist = VBI.Utilities.sqDistance;
	var nJ, len;

	for (nJ = 0, len = poly.length - 1; nJ < len; ++nJ) {
		v1 = poly[nJ];
		v2 = poly[nJ + 1];

		if ((tmp = funcSqDist(v1[0], v1[1], v2[0], v2[1], x, y)) < sqdist) {
			sqdist = tmp;
			ret = nJ;
		}
	}

	// check if the two points to detect the node where the click is..........//
	if (ret >= 0) {
		// check the anchor points of segment..................................//
		if ((tmp = sqDist([
			x, y
		], poly[ret])) < sqtemp) {
			sqtemp = tmp;
			node = ret;
		}
		if (sqDist([
			x, y
		], poly[ret + 1]) < sqtemp) {
			sqtemp = tmp;
			node = ret + 1;
		}
	}

	if (closed && (len > 0)) { // a closed line is expected.................//
		v1 = poly[0];
		v2 = poly[len];

		if ((tmp = funcSqDist(v1[0], v1[1], v2[0], v2[1], x, y)) < sqdist) {
			sqdist = tmp;
			ret = nJ;
		}

		// check if the two points to detect the node where the click is..........//
		if (ret >= 0) {
			// check the anchor points of segment..................................//
			if ((tmp = sqDist([
				x, y
			], poly[ret])) < sqtemp) {
				sqtemp = tmp;
				node = ret;
			}
			if (sqDist([
				x, y
			], poly[0]) < sqtemp) {
				sqtemp = tmp;
				node = 0;
			}
		}
	}

	return {
		m_edge: ret,
		m_node: node
	};
};

VBI.Utilities.polyInPolygon = function(outerPoly, innerPoly, iO) {
	"use strict";
	// instance offsets are applied for innerPoly

	var bHit = false, bIntersect = false;
	for (var nI = iO.length - 1; nI >= 0; --nI) {
		// loop for round world instances
		var off = iO[nI];
		bHit = false;
		// check if one point of polygon lies inside lasso
		if ((VBI.Utilities.pointInPolygon(outerPoly, innerPoly[0][0] + off, innerPoly[0][1]))) {
			bHit = true;
			// check if outer and inner polygon have no intersection
			for (var nK = 0; nK < innerPoly.length && bHit && !bIntersect; ++nK) {
				var ptI1 = [
					innerPoly[nK][0] + off, innerPoly[nK][1]
				];
				var ptI2 = (nK + 1 == innerPoly.length) ? [
					innerPoly[0][0] + off, innerPoly[0][1]
				] : [
					innerPoly[nK + 1][0] + off, innerPoly[nK + 1][1]
				];
				var ptO1, ptO2;
				bIntersect = false;
				for (var nM = 0; nM < outerPoly.length; ++nM) {
					ptO1 = outerPoly[nM];
					ptO2 = (nM + 1 == outerPoly.length) ? outerPoly[0] : outerPoly[nM + 1];
					if ((VBI.Utilities.LineLineIntersection(ptI1, ptI2, ptO1, ptO2, true))) {
						bIntersect = true;
					}
				}
			}
		}
		if (bHit && !bIntersect) {
			break;
		}
	}
	return (bHit && !bIntersect);

};

VBI.Utilities.pointInPolygon = function(poly, x, y) {
	"use strict";
	// We expect poly to have up to three dimensions [shape + exclusions][points][coords] -> multi parts to be treated separately (external)
	// We treat them recursively
	var v1, v2, len = poly.length;
	var c, nJ, l, hit, nK, nI;
	if (jQuery.type(poly[0]) == 'array') {
		if (jQuery.type(poly[0][0]) == 'array') {
			// shapes ( + exclusivion )
			c = this.pointInPolygon(poly[0], x, y); // first check for hit on base shape
			if (c) {
				for (hit = false, nI = 1, len = poly.length; !hit && nI < len; ++nI) { // check that hit is not on any exclusion
					hit = this.pointInPolygon(poly[nI], x, y);
					if (hit) {
						c = false; // hit on exclusion -> no hit on shape
					}
				}
			}
		} else { // single shape
			for (c = false, nJ = -1, l = len, nK = l - 1; ++nJ < l; nK = nJ) {
				v1 = poly[nJ];
				v2 = poly[nK];
				if (((v1[1] <= y && y < v2[1]) || (v2[1] <= y && y < v1[1])) && (x < (v2[0] - v1[0]) * (y - v1[1]) / (v2[1] - v1[1]) + v1[0])) {
					c = !c;
				}
			}
		}
	} else {
		for (c = false, nJ = 0, l = len, nK = l - 2; nJ <= l - 2; nJ += 2) {
			v1 = [
				poly[nJ], poly[nJ + 1]
			];
			v2 = [
				poly[nK], poly[nK + 1]
			];
			if (((v1[1] <= y && y < v2[1]) || (v2[1] <= y && y < v1[1])) && (x < (v2[0] - v1[0]) * (y - v1[1]) / (v2[1] - v1[1]) + v1[0])) {
				c = !c;
			}
			nK = nJ;
		}
	}
	return c;
};

VBI.Utilities.pointInTriangle = function(tri, pt) {
	"use strict";
	var vx0 = tri[2][0] - tri[0][0]; // first plane spanning vector
	var vy0 = tri[2][1] - tri[0][1];
	var vx1 = tri[1][0] - tri[0][0]; // second plane spanning vector
	var vy1 = tri[1][1] - tri[0][1];
	var vx2 = pt[0] - tri[0][0]; // vector from points
	var vy2 = pt[1] - tri[0][1];

	// create cross products
	var d00 = vx0 * vx0 + vy0 * vy0;
	var d01 = vx0 * vx1 + vy0 * vy1;
	var d02 = vx0 * vx2 + vy0 * vy2;
	var d11 = vx1 * vx1 + vy1 * vy1;
	var d12 = vx1 * vx2 + vy1 * vy2;

	var norm = 1 / (d00 * d11 - d01 * d01);
	var u = (d11 * d02 - d01 * d12) * norm;
	var v = (d00 * d12 - d01 * d02) * norm;

	return ((u >= 0) && (v >= 0) && (u + v < 1));
};

VBI.Utilities.INSIDE = 0; // 0000
VBI.Utilities.LEFT = 1; // 0001
VBI.Utilities.RIGHT = 2; // 0010
VBI.Utilities.BOTTOM = 4; // 0100
VBI.Utilities.TOP = 8; // 1000

VBI.Utilities.ComputeOutCode = function(x, y, rc) {
	"use strict";
	var xmin = rc[0]; // left
	var xmax = rc[2]; // right
	var ymin = rc[1]; // top;
	var ymax = rc[3]; // bottom;

	var code = VBI.Utilities.INSIDE;

	if (x < xmin) {
		code |= VBI.Utilities.LEFT;
	} else if (x > xmax) {
		code |= VBI.Utilities.RIGHT;
	}
	if (y < ymin) {
		code |= VBI.Utilities.BOTTOM;
	} else if (y > ymax) {
		code |= VBI.Utilities.TOP;
	}
	return code;
};

// given a line by two points and a rect
// find the intersection point(s) or points inside the rect and return true
// if outside the rect return false
// uses Cohen–Sutherland algorithm
VBI.Utilities.LineIntersectRect = function(x0, y0, x1, y1, rc) {
	"use strict";
	var oRet = {};
	var xmin = rc[0]; // left;
	var xmax = rc[2]; // right;
	var ymin = rc[1]; // top;
	var ymax = rc[3]; // bottom;

	var nOutcode0 = VBI.Utilities.ComputeOutCode(x0, y0, rc);
	var nOutcode1 = VBI.Utilities.ComputeOutCode(x1, y1, rc);
	var bAccept = false;

	var bContinueLoop = true;
	while (bContinueLoop) {
		if (!(nOutcode0 | nOutcode1)) {
			bAccept = true;
			break;
		} else if (nOutcode0 & nOutcode1) {
			break;
		} else {
			var x, y;

			var nOutcodeOut = nOutcode0 ? nOutcode0 : nOutcode1;

			if (nOutcodeOut & VBI.Utilities.TOP) {
				x = x0 + (x1 - x0) * (ymax - y0) / (y1 - y0);
				y = ymax;
			} else if (nOutcodeOut & VBI.Utilities.BOTTOM) {
				x = x0 + (x1 - x0) * (ymin - y0) / (y1 - y0);
				y = ymin;
			} else if (nOutcodeOut & VBI.Utilities.RIGHT) {
				y = y0 + (y1 - y0) * (xmax - x0) / (x1 - x0);
				x = xmax;
			} else if (nOutcodeOut & VBI.Utilities.LEFT) {
				y = y0 + (y1 - y0) * (xmin - x0) / (x1 - x0);
				x = xmin;
			}

			if (nOutcodeOut == nOutcode0) {
				x0 = x;
				y0 = y;
				nOutcode0 = VBI.Utilities.ComputeOutCode(x0, y0, rc);
			} else {
				x1 = x;
				y1 = y;
				nOutcode1 = VBI.Utilities.ComputeOutCode(x1, y1, rc);
			}
		}
	}
	oRet.bReturn = false;
	if (bAccept) {
		// copy computed points
		oRet.x0 = x0;
		oRet.y0 = y0;
		oRet.x1 = x1;
		oRet.y1 = y1;
		oRet.bReturn = true;
	}

	return oRet;
};

VBI.Utilities.LineLineIntersection = function(p1, p2, q1, q2, bSegmentOnly) {
	"use strict";
	var A1 = p2[1] - p1[1];
	var B1 = p1[0] - p2[0];
	var C1 = A1 * p1[0] + B1 * p1[1];

	var A2 = q2[1] - q1[1];
	var B2 = q1[0] - q2[0];
	var C2 = A2 * q1[0] + B2 * q1[1];

	var det = A1 * B2 - A2 * B1;
	if (!det) {
		return null;
	}
	var nIntersect = [
		(B2 * C1 - B1 * C2) / det, (A1 * C2 - A2 * C1) / det
	];
	if (bSegmentOnly) {
		var sp1 = [], sp2 = [], sq1 = [], sq2 = [];
		for (var nJ = 0; nJ <= 1; ++nJ) {
			if (p1[nJ] < p2[nJ]) {
				sp1[nJ] = p1[nJ];
				sp2[nJ] = p2[nJ];
			} else {
				sp1[nJ] = p2[nJ];
				sp2[nJ] = p1[nJ];
			}
			if (q1[nJ] < q2[nJ]) {
				sq1[nJ] = q1[nJ];
				sq2[nJ] = q2[nJ];
			} else {
				sq1[nJ] = q2[nJ];
				sq2[nJ] = q1[nJ];
			}
		}
		if (nIntersect[0] >= sp1[0] && nIntersect[0] <= sp2[0] && nIntersect[0] >= sq1[0] && nIntersect[0] <= sq2[0] && nIntersect[1] >= sp1[1] && nIntersect[1] <= sp2[1] && nIntersect[1] >= sq1[1] && nIntersect[1] <= sq2[1]) {
			return true;
		} else {
			return false;
		}

	}
	return [
		(B2 * C1 - B1 * C2) / det, (A1 * C2 - A2 * C1) / det
	];

};

VBI.Utilities.IsClockwise = function(pointlist) {
	"use strict";
	var length = pointlist.length;
	if (pointlist.length % 2) {
		length -= 1;
	}
	var x1, x2, y1, y2, z;
	z = 0;
	x1 = pointlist[length - 2];
	y1 = pointlist[length - 1];
	for (var nJ = 0; nJ < length; nJ += 2) {
		x2 = pointlist[nJ];
		y2 = pointlist[nJ + 1];
		z += (x2 - x1) * (y2 + y1);
		x1 = x2;
		y1 = y2;
	}
	return (z < 0);
};

// GetClippedPolygon gives precise result only for convex polygons
VBI.Utilities.GetClippedPolygon = function(pointarray, Xoffset, rcviewport) {
	"use strict";

	var offset = Xoffset;
	var outputlist = pointarray.slice(0);
	var inputlist = [];
	var intersection;

	for (var nJ = 0; nJ <= 3; ++nJ, offset = 0) {
		inputlist = outputlist.slice(0);
		outputlist = [];
		var tmp = [
			inputlist[inputlist.length - 2], inputlist[inputlist.length - 1]
		];
		var S = [
			tmp[0] + offset, tmp[1]
		];

		for (var nK = 0; nK <= inputlist.length - 2; nK += 2) {
			tmp = [
				inputlist[nK], inputlist[nK + 1]
			];
			var E = [
				tmp[0] + offset, tmp[1]
			];
			var bEInside = false;
			var bSInside = false;
			var clipEdge = [];
			switch (nJ) {
				case 0: // top
					bEInside = (E[1] > rcviewport[1]);
					bSInside = (S[1] > rcviewport[1]);
					clipEdge = [
						[
							rcviewport[0], rcviewport[1]
						], [
							rcviewport[2], rcviewport[1]
						]
					];
					break;
				case 1: // right
					bEInside = (E[0] < rcviewport[2]);
					bSInside = (S[0] < rcviewport[2]);
					clipEdge = [
						[
							rcviewport[2], rcviewport[1]
						], [
							rcviewport[2], rcviewport[3]
						]
					];
					break;
				case 2: // bottom
					bEInside = (E[1] < rcviewport[3]);
					bSInside = (S[1] < rcviewport[3]);
					clipEdge = [
						[
							rcviewport[0], rcviewport[3]
						], [
							rcviewport[2], rcviewport[3]
						]
					];
					break;
				case 3: // left
					bEInside = (E[0] > rcviewport[0]);
					bSInside = (S[0] > rcviewport[0]);
					clipEdge = [
						[
							rcviewport[0], rcviewport[1]
						], [
							rcviewport[0], rcviewport[3]
						]
					];
					break;
				default:
					break;
			}
			if (bEInside) {
				if (!bSInside) {
					intersection = VBI.Utilities.LineLineIntersection(S, E, clipEdge[0], clipEdge[1], false);
					if (intersection) {
						outputlist.push(intersection[0], intersection[1]);
					}
				}
				outputlist.push(E[0], E[1]);
			} else if (bSInside) {
				intersection = VBI.Utilities.LineLineIntersection(S, E, clipEdge[0], clipEdge[1], false);
				if (intersection) {
					outputlist.push(intersection[0], intersection[1]);
				}
			}
			S = [
				E[0], E[1]
			];
		}
	}
	return outputlist;
};

VBI.Utilities.GetBarycenterForPolygon = function(pointarray, offset) {
	"use strict";
	var pa = pointarray.slice(0);
	var pt1 = [
		pa[0], pa[1]
	];
	var ptlast = [
		pa[pa.length - 2], pa[pa.length - 1]
	];

	if (pt1 != ptlast) {
		pa.push(pa[0], pa[1]);
	}

	var N = pa.length - 2;

	var sum = 0;
	var A = 0;
	var centerX;
	var centerY;
	for (var nI = 0; nI < N; nI += 2) {
		sum += ((pa[nI] + offset) * pa[nI + 3] - (pa[nI + 2] + offset) * pa[nI + 1]);
	}
	A = sum / 2;
	if (A) {
		sum = 0;
		for (var nJ = 0; nJ < N; nJ += 2) {
			sum += (pa[nJ] + offset + pa[nJ + 2] + offset) * ((pa[nJ] + offset) * pa[nJ + 3] - (pa[nJ + 2] + offset) * pa[nJ + 1]);
		}
		centerX = sum / (A * 6);

		sum = 0;
		for (var nK = 0; nK < N; nK += 2) {
			sum += (pa[nK + 1] + pa[nK + 3]) * ((pa[nK] + offset) * pa[nK + 3] - (pa[nK + 2] + offset) * pa[nK + 1]);
		}
		centerY = sum / (A * 6);
	}
	if (centerX && centerY) {
		return [
			centerX, centerY
		];
	}

	return null;

};

VBI.Utilities.GetMidpointForPolygon = function(pointarray, bb, Xoffset, rcviewport) {
	"use strict";
	var offset = Xoffset;
	var labelPositions = [];
	var lt = bb[0];
	var rb = bb[1];
	var ltinRc = VBI.Utilities.PtInRect([
		lt[0] + offset, lt[1]
	], rcviewport);
	var rbinRc = VBI.Utilities.PtInRect([
		rb[0] + offset, rb[1]
	], rcviewport);

	if (!ltinRc || !rbinRc) {
		// calculate clipping polygon
		pointarray = VBI.Utilities.GetClippedPolygon(pointarray, offset, rcviewport);
		offset = 0;
	}
	var labelPosition = VBI.Utilities.GetBarycenterForPolygon(pointarray, offset);
	if (labelPosition) {
		var labelPoint = VBI.Utilities.getNextPoint(labelPosition[0], labelPosition[1], pointarray, offset);
		labelPositions.push(labelPoint);
		return {
			max: 0,
			aPos: labelPositions
		};
	}
	return null;

};

VBI.Utilities.GetClippedPolygons = function(pointarray, offset, rcviewport) {
	"use strict";

	var outputlist = [];
	var pointlist = pointarray.slice(0);
	var nStartViewportList = pointlist.length;
	var nLastIdxPtList = nStartViewportList - 2;

	var z = VBI.Utilities.IsClockwise(pointarray);
	if (z > 0) {
		pointlist.push(rcviewport[0], rcviewport[1], rcviewport[2], rcviewport[1], rcviewport[2], rcviewport[3], rcviewport[0], rcviewport[3]);
	} else {
		pointlist.push(rcviewport[0], rcviewport[1], rcviewport[0], rcviewport[3], rcviewport[2], rcviewport[3], rcviewport[2], rcviewport[1]);
	}
	var nStartIntersectionList = pointlist.length;
	var EI = [];
	var LI = [];
	var indexChainP = [];
	var indexChainR = [];
	for (var nI = 0; nI < nStartViewportList; nI += 2) {
		indexChainP.push(nI);
	}
	var polyPt1, polyPt2, rectPt1, rectPt2;
	var l;
	polyPt1 = [
		pointlist[nLastIdxPtList] + offset, pointlist[nLastIdxPtList + 1]
	];
	// for (var nI = nLastIdxPtList, nJ = 0; nJ <= nLastIdxPtList; nJ += 2) {
	for (var nJ = 0; nJ <= nLastIdxPtList; nJ += 2) {
		polyPt2 = [
			pointlist[nJ] + offset, pointlist[nJ + 1]
		];
		var bRet = VBI.Utilities.LineIntersectRect(polyPt1[0], polyPt1[1], polyPt2[0], polyPt2[1], rcviewport);
// var out0 = [
// bRet.x0, bRet.y0
// ];
// var out1 = [
// bRet.x1, bRet.y1
// ];
		// var nEnteringIS = null;
		if (bRet.bReturn == true) {
// console.log("in=" + polyPt1 + " / " + polyPt2 + "; out=" + out0 + " / " + out1);
			if ((bRet.x0 != polyPt1[0] || bRet.y0 != polyPt1[1]) && (bRet.x1 != polyPt2[0] || bRet.y1 != polyPt2[1])) { // two intersection points
				if (!(bRet.x0 == bRet.x1 && bRet.y0 == bRet.y1)) {
					var f = pointlist.push(bRet.x0, bRet.y0);
					l = pointlist.push(bRet.x1, bRet.y1);
					EI.push(f - 2);
					LI.push(l - 2);
// console.log("added entering and leaving is");
					var I = indexChainP.indexOf(nJ);
					indexChainP.splice(I, 0, f - 2, l - 2);
				}
			} else if (bRet.x0 != polyPt1[0] || bRet.y0 != polyPt1[1]) { // pt1In != pt1Out -> pt1Out is an entering intersection
				if (bRet.x0 != polyPt2[0] || bRet.y0 != polyPt2[1]) { // pt1Out is not equal pt2in
					l = pointlist.push(bRet.x0, bRet.y0);
					EI.push(l - 2);
// console.log("added entering is");
					var II = indexChainP.indexOf(nJ);
					indexChainP.splice(II, 0, l - 2);
				}
			} else if (bRet.x1 != polyPt2[0] || bRet.y1 != polyPt2[1]) { // pt2In != pt2Out -> pt2Out is a leaving intersection
				l = pointlist.push(bRet.x1, bRet.y1);
				LI.push(l - 2);
// console.log("added leaving is");
				var III = indexChainP.indexOf(nJ);
				indexChainP.splice(III, 0, l - 2);
			}
		}
		polyPt1 = polyPt2;
		// nI = nJ;
	} // all intersections found in polygon array

	for (var nJ1 = nStartViewportList, count = 0; count < 4; nJ1 += 2, ++count) { // start search for intersections in rect array
		var sortarr = [];
		indexChainR.push(nJ1);
		rectPt1 = [
			pointlist[nJ1], pointlist[nJ1 + 1]
		];
		if (count == 3) {
			rectPt2 = [
				pointlist[nStartViewportList], pointlist[nStartViewportList + 1]
			];
		} else {
			rectPt2 = [
				pointlist[nJ1 + 2], pointlist[nJ1 + 3]
			];
		}
		var dir = (rectPt1[0] == rectPt2[0]) ? 1 : 0;
		var eq = dir ? 0 : 1;
		for (var nK = nStartIntersectionList; nK <= pointlist.length - 2; nK += 2) { // consider all intersection points for this side
			if (pointlist[nK + eq] == rectPt1[eq]) {
				sortarr.push({
					pt: pointlist[nK + dir],
					idx: nK
				});
			}
		}
		if (count < 2) {
			sortarr.sort(VBI.Utilities.StandardSort1);
		} else {
			sortarr.sort(VBI.Utilities.StandardSort2);
		}
		for (var nL = 0; nL < sortarr.length; ++nL) {
			indexChainR.push(sortarr[nL].idx);
		}

		rectPt1 = rectPt2;

	} // rectangle chainlist is also finished

	for (var nJJ = nStartViewportList; nJJ <= pointlist.length - 2; nJJ += 2) {
		// remove offset for all viewport and intersection points
		pointlist[nJJ] -= offset;
	}

	// capture clipped polygons
	for (var nJK = 0; nJK < EI.length; ++nJK) {// loop over all entering vertices
		var outputpolygon = [];
		var start = EI[nJK];
		var currentIdx = indexChainP.indexOf(EI[nJK]);
		var currentChainlist = indexChainP;
		var otherChainlist = indexChainR;
		var currentISList = LI;
		var otherISList = EI;
		outputpolygon.push(pointlist[EI[nJK]], pointlist[EI[nJK] + 1]);
		var swapcount = 0;
		var bContinueLoop = true;
		while (bContinueLoop) {
			currentIdx++;
			if (currentIdx > currentChainlist.length - 1) {
				currentIdx = 0;
			}
			if (currentChainlist[currentIdx] == start) {
				outputlist.push(outputpolygon);
				break;
			}

			outputpolygon.push(pointlist[currentChainlist[currentIdx]], pointlist[currentChainlist[currentIdx] + 1]);
			var I2 = currentISList.indexOf(currentChainlist[currentIdx]);
			if (I2 > -1) {
				swapcount++;
// if ( swapcount > 20 )
// console.log("swapcount!! = " + swapcount);
				currentIdx = otherChainlist.indexOf(currentChainlist[currentIdx]);
				// intersectionpoint reached -> swap lists
				var tmp = currentChainlist;
				currentChainlist = otherChainlist;
				otherChainlist = tmp;
				tmp = currentISList;
				currentISList = otherISList;
				otherISList = tmp;
			}
		}
	}
	return outputlist;
};

VBI.Utilities.StandardSort1 = function(a, b) {
	"use strict";
	return a.pt - b.pt;
};

VBI.Utilities.StandardSort2 = function(a, b) {
	"use strict";
	return b.pt - a.pt;
};

VBI.Utilities.GetMidpointsForPolygon = function(pointarray, bb, Xoffset, rcviewport) {
	"use strict";
	var polylist = [];
	var offset = Xoffset;
	var labelPositions = [];
	var lt = bb[0];
	var rb = bb[1];

	// check whether rcviewport and bounding box overlap
	if (VBI.Utilities.RectIntersect([
		lt[0] + offset, lt[1], rb[0] + offset, rb[1]
	], rcviewport)) {
		var ltonRc = VBI.Utilities.PtOnRect([
			lt[0] + offset, lt[1]
		], rcviewport);
		var rbonRc = VBI.Utilities.PtOnRect([
			rb[0] + offset, rb[1]
		], rcviewport);
		if (!ltonRc || !rbonRc) {
			// calculate clipping polygon
			polylist = VBI.Utilities.GetClippedPolygons(pointarray, offset, rcviewport);
			if (!polylist.length) {
				var mid = [
					rcviewport[0] + (rcviewport[2] - rcviewport[0]) / 2, rcviewport[1] + (rcviewport[3] - rcviewport[1]) / 2
				];
				if (VBI.Utilities.pointInPolygon(pointarray, mid[0], mid[1])) {
					labelPositions.push(mid); // no clipping found but the midpoint of the viewport lies within the polygon -> place label here
				}
			}
		} else {
			polylist.push(pointarray);
		}

		for (var nJ = 0; nJ < polylist.length; ++nJ) {

			var labelPosition = VBI.Utilities.GetBarycenterForPolygon(polylist[nJ], offset);
			if (labelPosition) {
				var labelPoint = VBI.Utilities.getNextPoint(labelPosition[0], labelPosition[1], polylist[nJ], offset);
				labelPositions.push(labelPoint);

			}
		}
		if (labelPositions.length > 0) {
			return {
				max: 0,
				aPos: labelPositions
			};
		}
	}
	return null;

};

VBI.Utilities.GetMidpointsForLine = function(pointarray, offset, rcviewport) {
	"use strict";
	var labelPositions = [];
	var bRet = {};
	var ptLastEnd = [
		Number.MAX_VALUE, Number.MAX_VALUE
	];
	var bOpen = false;
	var vSection;
	var vSections = [];

	if (pointarray.length > 5) {
		for (var nJ = 0; nJ <= pointarray.length - 6; nJ += 3) {
			var x1 = pointarray[nJ];
			var y1 = pointarray[nJ + 1];
			var x2 = pointarray[nJ + 3];
			var y2 = pointarray[nJ + 4];

			bRet = VBI.Utilities.LineIntersectRect(x1 + offset, y1, x2 + offset, y2, rcviewport);
			if (bRet.bReturn == true) {
				if (vSection && bOpen && (bRet.x0 != ptLastEnd[0] || bRet.y0 != ptLastEnd[1])) {
					// finish section
					vSections.push(vSection);
					bOpen = false;
				}
				if (!bOpen) {
					vSection = [];
					vSection.push(bRet.x0);
					vSection.push(bRet.y0);
					bOpen = true;
				}
				vSection.push(bRet.x1);
				ptLastEnd[0] = bRet.x1;
				vSection.push(bRet.y1);
				ptLastEnd[1] = bRet.y1;
			} else if (bOpen) {
				vSections.push(vSection);
				bOpen = false;
			}
		}
		if (bOpen) {
			vSections.push(vSection);
			bOpen = false;
		}

	}

	var max = 0;
	var nMaxIdx = 0;

	for (var nI = 0; nI < vSections.length; nI++) {
		var sec = vSections[nI];
		if (sec.length > 3) {

			var fTotalLength = 0.0;
			var fLength;
			var vLengths = [];

			for (var nN = 0; nN <= sec.length - 4; nN += 2) {
				// calculate the midpoint of this section
				fLength = Math.sqrt(Math.pow(sec[nN + 2] - sec[nN], 2) + Math.pow(sec[nN + 3] - sec[nN + 1], 2));

				fTotalLength += fLength;
				vLengths.push(fLength);
			}

			var fL = fTotalLength;

			var fHalfLength = fTotalLength / 2;
			var nIdx = -1;
			var fMultiplicator = 0.0;

			for (var nM = vLengths.length - 1; nM >= 0; nM--) {
				fTotalLength -= vLengths[nM];
				if (fTotalLength <= fHalfLength) {
					fMultiplicator = fHalfLength - fTotalLength;
					nIdx = nM;
					break;
				}
			}

			if (nIdx > -1) {
				var pt = [
					sec[nIdx * 2 + 2] - sec[nIdx * 2], sec[nIdx * 2 + 3] - sec[nIdx * 2 + 1]
				];
				// vector length
				var tmp = Math.sqrt(Math.pow(pt[0], 2) + Math.pow(pt[1], 2));
				// normalize
				var ptNorm = [
					pt[0] / tmp, pt[1] / tmp
				];
				// scale
				var ptScale = [
					ptNorm[0] * fMultiplicator, ptNorm[1] * fMultiplicator
				];
				labelPositions.push([
					sec[nIdx * 2] + parseInt(ptScale[0], 10), sec[nIdx * 2 + 1] + parseInt(ptScale[1], 10)
				]);
				if (fL > max) {
					max = fL;
					nMaxIdx = nI;
				}
			}
		}
	}
	return {
		max: nMaxIdx,
		aPos: labelPositions
	};
};

VBI.Utilities.updateBoundRect = function(oArray, rect) {
	"use strict";
	// update bounding box....................................................//
	// using the new array of coords and calculating new values...............//

	var xyz, nCount = oArray.length;
	var minX = rect[0];
	var maxX = rect[2];
	var minY = rect[1];
	var maxY = rect[3];
	for (var nJ = 0; nJ < nCount; ++nJ) {
		xyz = oArray[nJ];
		if (minX > xyz[0]) {
			minX = xyz[0];
		}
		if (maxX < xyz[0]) {
			maxX = xyz[0];
		}
		if (minY > xyz[1]) {
			minY = xyz[1];
		}
		if (maxY < xyz[1]) {
			maxY = xyz[1];
		}
	}

	// set the new values.....................................................//
	rect[0] = minX;
	rect[2] = maxX;
	rect[1] = minY;
	rect[3] = maxY;
};

VBI.Utilities.inflateRect = function(rect, val) {
	"use strict";
	// inflate the rectangle..................................................//
	rect[0] -= val;
	rect[1] -= val;
	rect[2] += val;
	rect[3] += val;
};

// calculates the square distance between a point and a line.................//
// x1,y1,x2,y2 are points of the line........................................//
// x3, y3 is the point to be measuresd.......................................//

VBI.Utilities.sqDistance = function(x1, y1, x2, y2, x3, y3) {
	"use strict";
	// vector between points..................................................//
	var px = x2 - x1;
	var py = y2 - y1;

	// squared length of p....................................................//
	var sqlp = px * px + py * py;
	if (!sqlp) {
		return (x3 - x1) * (x3 - x1) + (y3 - y1) * (y3 - y1);
	}
	var u = ((x3 - x1) * px + (y3 - y1) * py) / sqlp;

	// process raise conditions
	if (u > 1) {
		u = 1;
	} else if (u < 0) {
		u = 0;
	}

	var dx = x1 + u * px - x3;
	var dy = y1 + u * py - y3;

	return dx * dx + dy * dy;
};

// nearest point from a point and a polygon .................................//
// poly is the polygon [x0,y0,x1,y1....xn,yn] ...............................//
// x, y is the point to be measured .........................................//

VBI.Utilities.getNextPoint = function(x, y, poly, offset) {
	"use strict";
	var v1, v2, len = poly.length;
	var pts = [];
	var distances = [];
	var c = false;
	for (var nJ = 0, l = len, nK = l - 2; nJ <= l - 2; nJ += 2) {
		v1 = [
			poly[nJ] + offset, poly[nJ + 1]
		];
		v2 = [
			poly[nK] + offset, poly[nK + 1]
		];

		// ///// calculate distpoint and dist ///////////////////////
		var sqdist = 0;
		var resultPt = [];
		var A = x - v1[0];
		var B = y - v1[1];
		var C = v2[0] - v1[0];
		var D = v2[1] - v1[1];

		var dot = A * C + B * D;
		var len_sq = C * C + D * D;
		if (!len_sq) {
			sqdist = (x - v1[0]) * (x - v1[0]) + (y - v1[1]) * (y - v1[1]);
			resultPt = [
				v1[0], v1[1]
			];
		} else {
			var param = dot / len_sq;
			if (param < 0) {
				resultPt = [
					v1[0], v1[1]
				];
			} else if (param > 1) {
				resultPt = [
					v2[0], v2[1]
				];
			} else {
				resultPt = [
					v1[0] + param * C, v1[1] + param * D
				];
			}
			var dx = x - (v1[0] + param * C);
			var dy = y - (v1[1] + param * D);
			sqdist = (dx * dx + dy * dy);
		}
		pts.push(resultPt);
		distances.push(sqdist);

		// //////////////////// calculate inside/outside ///////////////
		if (((v1[1] <= y && y < v2[1]) || (v2[1] <= y && y < v1[1])) && (x < (v2[0] - v1[0]) * (y - v1[1]) / (v2[1] - v1[1]) + v1[0])) {
			c = !c;
		}
		// /////// get the next point /////////////////////
		nK = nJ;
	}

	if (c) { // incoming point is inside polygon
		return [
			x, y
		];
	} else {
		var min = 10000;
		var idx = -1;
		if (distances.length) {
			for (var nk = 0; nk < distances.length; ++nk) {
				if (distances[nk] < min) {
					idx = nk;
					min = distances[nk];
				}
			}
			if (idx > -1) {
				return (pts[idx]);
			}
		}
		return ([
			poly[0] + offset, poly[1]
		]);
	}
};

// ...........................................................................//
// drawing methods...........................................................//

VBI.Utilities.DrawSelectIndicator = function(ctx, p) {
	"use strict";
	var r = 4;

	// fill corner arcs....................................................//
	ctx.lineWidth = 1;
	ctx.strokeStyle = 'rgba( 0, 0, 0, 1.0 )';
	ctx.fillStyle = 'rgba( 10, 10, 255, 1.0 )';
	ctx.beginPath();
	ctx.arc(p[0], p[1], r, 0, 2 * Math.PI);
	ctx.closePath();
	ctx.fill();
	ctx.stroke();
};

VBI.Utilities.DrawDesignRect = function(ctx, handles, p1, p2, p3, p4) {
	"use strict";
	// handles is an array of values tat specify the visibility of the drag...//
	// box handles............................................................//
	var x, y, r = 3, bDash = ctx.setLineDash ? true : false;

	ctx.save(); // store context state
	ctx.lineWidth = 1;
	ctx.strokeStyle = 'rgba( 0, 0, 0, 1.0 )';

	if (typeof p1 == 'object') {
		var w = p1[2] - p1[0];
		var h = p1[3] - p1[1];
		var wh = w / 2;
		var hh = h / 2;

		// assume array object.................................................//
		if (bDash) {
			ctx.setLineDash([
				1, 2
			]);
		}
		ctx.strokeRect(p1[0], p1[1], w, h);

		// fill corner arcs....................................................//
		var fill = 'rgba( 255, 255, 255, 1.0 )';
		var filldisabled = 'rgba( 128, 128, 128, 1.0 )';

		// assume array object.................................................//
		if (bDash) {
			ctx.setLineDash([
				0, 0
			]);
		}

		ctx.fillStyle = fill;
		for (x = 0; x < 3; ++x) {
			for (y = 0; y < 3; ++y) {
				// skip rendering the circle when not movable....................//
				ctx.fillStyle = (handles[y * 3 + x] ? fill : filldisabled);

				if (x == 1 && y == 1) {
					continue;
				}
				ctx.beginPath();
				ctx.arc(p1[0] + x * wh, p1[1] + y * hh, r, 0, 2 * Math.PI);
				ctx.closePath();
				ctx.fill();
				ctx.stroke();
			}
		}
	} else {
		// assume coordinates..................................................//
		ctx.strokeRect(p1 - 1, p2 - 1, p3 - p1, p4 - p2);
		ctx.strokeStyle = 'rgba( 255, 255, 255, 1.0 )';
		ctx.strokeRect(p1, p2, p3 - p1, p4 - p2);
	}

	ctx.restore(); // restore context state
};

VBI.Utilities.DrawFrameRect = function(ctx, col, p1, p2, p3, p4) {
	"use strict";

	ctx.lineWidth = 1;
	ctx.strokeStyle = col;

	if (typeof p1 == 'object') {
		// assume array object.................................................//
		ctx.strokeRect(p1[0], p1[1], p1[2] - p1[0], p1[3] - p1[1]);
	} else {
		// assume coordinates..................................................//
		ctx.strokeRect(p1, p2, p3 - p1, p4 - p2);
	}
};

VBI.Utilities.AssembleCopyrightString = function(Copyright, CopyrightLink, CopyrightImage) {
	"use strict";

	var regex1 = /\{LINK\|IMG\}/;
	var regex2 = /\{IMG\}/;
	var regex3 = /\{LINK\|([^\}]+)\}/;

	if (Copyright) {
		var tmp = Copyright.replace(regex1, "<a href='" + CopyrightLink + "'><img src='" + CopyrightImage + "' width='10' height='10' border='none'></a>");
		tmp = tmp.replace(regex2, "<img src='" + CopyrightImage + "' width='10' height='10' border='none' >");
		return tmp.replace(regex3, "<a  href='" + CopyrightLink + "'>$1</a>");
	}
	return Copyright;
};

VBI.Utilities.DrawTrackingRect = function(ctx, p1, p2, p3, p4) {
	"use strict";

	ctx.save();
	ctx.strokeStyle = 'black';
	ctx.lineWidth = 1;
	if (ctx.setLineDash) {
		ctx.setLineDash([
			1, 2
		]);
	}
	ctx.beginPath();
	ctx.rect(p1, p2, p3 - p1, p4 - p2);
	ctx.stroke();
	ctx.fillStyle = 'rgba( 0, 192, 192, 0.2 )';
	ctx.fill();
	ctx.restore();
};

VBI.Utilities.DrawTrackingLasso = function(ctx, aPos) {
	"use strict";

	ctx.save();
	ctx.strokeStyle = 'black';
	ctx.lineWidth = 1;
	if (ctx.setLineDash) {
		ctx.setLineDash([
			1, 2
		]);
	}
	ctx.beginPath();
	ctx.moveTo(aPos[0][0], aPos[0][1]);
	for (var nJ = 1; nJ < aPos.length; ++nJ) {
		ctx.lineTo(aPos[nJ][0], aPos[nJ][1]);
	}
	ctx.closePath();
	ctx.stroke();
	ctx.fillStyle = 'rgba( 0, 192, 192, 0.2 )';
	ctx.fill();
	ctx.restore();
};

// ...........................................................................//
// color conversion routines.................................................//

VBI.Utilities.RGB2HLS = function(red, green, blue) {
	"use strict";

	red /= 255.0;
	green /= 255.0;
	blue /= 255.0; // normalize to [0,1]

	var max = Math.max(red, green, blue);
	var min = Math.min(red, green, blue);

	var hue = 0, sat, lum = (max + min) / 2;
	if (max == min) {
		hue = sat = 0; // achromatic
	} else {
		var d = max - min;
		sat = lum > 0.5 ? d / (2 - max - min) : d / (max + min);
		switch (max) {
			case red:
				hue = (green - blue) / d + (green < blue ? 6 : 0);
				break;
			case green:
				hue = (blue - red) / d + 2;
				break;
			case blue:
				hue = (red - green) / d + 4;
				break;
		}
		hue /= 6;
	}
	return [
		hue, lum, sat
	];
};

VBI.Utilities.HLS2RGB = function(hue, lum, sat) {
	"use strict";
	var red = 0, green = 0, blue = 0;
	if (sat == 0) {
		red = green = blue = lum;
	} else {
		var q = lum < 0.5 ? lum * (1 + sat) : lum + sat - lum * sat;
		var p = 2 * lum - q;
		red = VBI.Utilities.HUE2RGB(p, q, hue + 1 / 3);
		green = VBI.Utilities.HUE2RGB(p, q, hue);
		blue = VBI.Utilities.HUE2RGB(p, q, hue - 1 / 3);
	}

	return [
		Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255)
	];
};

VBI.Utilities.HUE2RGB = function(p, q, t) {
	"use strict";
	if (t < 0) {
		t += 1;
	} else if (t > 1) {
		t -= 1;
	}

	if (t < 1 / 6) {
		return p + (q - p) * 6 * t;
	}
	if (t < 1 / 2) {
		return q;
	}
	if (t < 2 / 3) {
		return p + (q - p) * (2 / 3 - t) * 6;
	}
	return p;
};

// get the pixel value of 1rem
VBI.Utilities.RemToPixel = function(value) {
	"use strict";
	// Returns a number
	return value * parseFloat(
	// of the computed font-size, so in px
	getComputedStyle(
	// for the root <html> element
	document.documentElement).fontSize);
};

VBI.Utilities.ColorHex2rgba = function(sHC) {
	"use strict";
	var sColor = sHC.charAt(0) === "#" ? sHC.substring(1, 7) : sHC;
	return 'rgba(' + parseInt(sColor.substring(0, 2), 16) + ',' + parseInt(sColor.substring(2, 4), 16) + ',' + parseInt(sColor.substring(4, 6), 16) + ',1.0)';
};

VBI.Utilities.String2VBColor = function(s) {
	"use strict";
	var aCol = VBI.Types.string2rgba(s);
	if (aCol[4] === 1) {
		return "RGBA(" + aCol[0] + ";" + aCol[1] + ";" + aCol[2] + ";" + parseInt(aCol[3] * 255, 10) + ")";
	} else {
		return "RGB(" + aCol[0] + ";" + aCol[1] + ";" + aCol[2] + ")";
	}
};

VBI.Utilities.CompToHex = function(c) {
	"use strict";

	var hex = c.toString(16);
	return hex.length == 1 ? "0" + hex : hex;
};

VBI.Utilities.RgbToHex = function(r, g, b) {
	"use strict";

	return "#" + VBI.Utilities.CompToHex(r) + VBI.Utilities.CompToHex(g) + VBI.Utilities.CompToHex(b);
};
﻿// ...........................................................................//
// this module defines the clustering ...................................//

// Author: Jürgen Gatter for Grid based Clustering,
// Dimitar Vangelovski for Distance based Clustering

VBI.Clustering = function(target) {
	"use strict";
	/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
	var clustering = {};
	var Delaunay = {};
	var EPSILON = 1.0 / 1048576.0;

	clustering.m_Clusters = []; // array of clusters
	clustering.m_Clustergroups = [];
	clustering.m_loadCount = 0; // to verify whether preassembled data is still valid
	clustering.m_Parser = VBI.Parser();
	clustering.m_nClustertypes = 5; // 0 :=: no Clustering 3 :=: Distance Based
	// 1 :=: Grid Based 4 :=: Tree Based
	// 2 :=: Grid Based Group
	clustering.clear = function() {
		clustering.m_Clusters = []; // array of clusters
	};

	clustering.load = function(dat, ctx) {
		// load the json delta data............................................//
		if (dat.Set) {
			clustering.clear();
			clustering.m_Parser.clear();
			clustering.m_loadCount++;

			var cluster, res = dat.Set.Cluster;

			if (jQuery.type(res) == 'object') {
				cluster = new VBI.Clustering.Cluster();
				cluster.load(res, ctx, clustering.m_Clusters.length); // load the cluster...//
				clustering.m_Clusters.push(cluster);
				clustering.UpdateAutomaticClusterGroup(cluster.m_groupID);
			} else if (jQuery.type(res) == 'array') {
				var index = clustering.m_Clusters.length;
				// load from array...............................................//
				for (var nJ = 0, len = res.length; nJ < len; ++nJ) {
					cluster = new VBI.Clustering.Cluster();
					cluster.load(res[nJ], ctx, index++); // load the cluster...//
					clustering.m_Clusters.push(cluster);
					clustering.UpdateAutomaticClusterGroup(cluster.m_groupID);
				}
			}
			for (var nK = 0; nK < clustering.m_Clustergroups.length; ++nK) {
				clustering.m_Clusters.push(clustering.m_Clustergroups.shift());
			}
		}
	};

	clustering.UpdateAutomaticClusterGroup = function(groupID) {
		if (groupID == "") {
			return;
		}

		var insertedCluster = clustering.m_Clusters[clustering.m_Clusters.length - 1];
		var nGroupIndex, nOtherIndex, elte, groupCluster;

		for (var nI = 0; nI < clustering.m_Clustergroups.length; ++nI) {
			elte = clustering.m_Clustergroups[nI];
			if (elte.m_id == groupID) {
				nGroupIndex = nI;
			}
		}

		if (nGroupIndex != undefined) {
			groupCluster = clustering.m_Clustergroups[nGroupIndex];
			groupCluster.m_limit = Math.min(insertedCluster.m_limitOnSum, groupCluster.m_limit);
			insertedCluster.m_bPartOfGrp = true;
		} else {
			for (var nJ = 0, len = clustering.m_Clusters.length - 1; nJ < len; ++nJ) {
				elte = clustering.m_Clusters[nJ];
				if ((elte.m_type == "grid") && (elte.m_groupID == groupID)) {
					nOtherIndex = nJ;
				}
			}
			if (nOtherIndex != undefined) {
				var otherCluster = clustering.m_Clusters[nOtherIndex];
				groupCluster = new VBI.Clustering.Cluster();
				groupCluster.m_type = "clustergroup";
				groupCluster.m_nType = 2;
				groupCluster.m_id = groupID;
				groupCluster.m_dividerX = otherCluster.m_dividerX;
				groupCluster.m_dividerY = otherCluster.m_dividerY;
				groupCluster.m_limit = Math.min(insertedCluster.m_limitOnSum, otherCluster.m_limitOnSum);
				groupCluster.initializeFunctions();
				clustering.m_Clustergroups.push(groupCluster);
				insertedCluster.m_bPartOfGrp = otherCluster.m_bPartOfGrp = true;
			}
		}

	};

	clustering.PreassembleDataForVO = function(scene, vResult, index, vo, ctx) {
		var node;
		var baseLod = vResult.config.m_BaseLod;
		var fLod = clustering.tw * ((baseLod >= 0) ? (1 << baseLod) : 1 / (1 << -baseLod));

		if ((node = vo.m_DataSource.GetCurrentNode(ctx))) {
			var mID = vo.m_ID;
			var myArray = vResult.base[index];
			if (node.m_dataelements.length) {
				vo.m_DataSource.Select(0);
				var ele = vo.m_DataSource.GetIndexedElement(ctx, 0);
				var id = ele.GetPath();
				var myKeyLen = ele.GetKeyValue().length;
				myArray.strDataPath = id.substring(0, id.length - myKeyLen);
				for (var nL = 0; nL < node.m_dataelements.length; ++nL) {
					var ucsPos = [
						fLod, fLod
					];
					vo.m_DataSource.Select(nL);
					ele = vo.m_DataSource.GetIndexedElement(ctx, nL);
					var orgPos = vo.m_Pos.GetValueVector(ctx);
					scene.m_Proj.LonLatToUCS(VBI.MathLib.DegToRad(orgPos), ucsPos);
					var nCl = clustering.m_Parser.evaluate(vo, index, ctx);

					if (nCl >= 0) {
						ucsPos.t = clustering.m_Clusters[nCl].m_nType;
						(myArray.targets[nCl])++;
					} else {
						ucsPos.t = -1;
					}

					ucsPos.h = vo.BaseIsHot(nL, ctx);
					ucsPos.hscale = vo.GetHotScale(ctx);
					ucsPos.hcol = vo.m_HotDeltaColor.GetValueString(ctx);

					if ((ucsPos.s = vo.IsSelected(ctx))) {
						ucsPos.scol = vo.m_SelectColor.GetValueString(ctx);
						ucsPos.simag = vo.m_ImageSelected.GetValueString(ctx);
						vResult.m_SelectedVOs.unshift({
							m_vo: index,
							m_index: myArray.length,
							m_dataIndex: nL
						});

					}
					if (ucsPos.im == undefined) {
						ucsPos.im = vo.m_Image.GetValueString(ctx);
					}

					ucsPos.ic = vo.m_Icon.GetValueString(ctx);
					ucsPos.tx = vo.m_Text.GetValueString(ctx);
					ucsPos.ctcol = vo.m_ContentColor.GetValueString(ctx); // color of content ( icon or text )
					ucsPos.ctoffs = vo.m_ContentOffset.GetValueVector(ctx); // offset of content ( icon or text )
					ucsPos.ctfont = vo.m_ContentFont.GetValueString(ctx); // font of content ( icon or text )
					ucsPos.ctsz = vo.m_ContentSize.GetValueLong(ctx); // size in px of content ( text )
					ucsPos.sc = vo.m_Scale.GetValueVector(ctx);
					ucsPos.al = vo.m_Alignment.GetValueString(ctx);
					ucsPos.m_ID = mID;
					ucsPos.nI = nL;
					ucsPos.b2Ignore = false;
					ucsPos.cI = nCl;
					ucsPos.vI = index;
					ucsPos.key = ele.GetKeyValue();

					ucsPos.label = vo.GetLabel(ctx);
					myArray.push(ucsPos);
				}
			}
			for (var nK = myArray.targets.length; nK--;) {
				var tType = clustering.m_Clusters[nK].m_nType;
				myArray.targTypes[tType] += myArray.targets[nK];
				vResult.base.targTypes[tType] += myArray.targets[nK];
			}
		}
	};

	clustering.InitializeResultVector = function(mapMan, numVOs, lod, x, y, nx, ny, nDataVersion) {
		clustering.tw = mapMan.m_tileWidth;
		clustering.th = mapMan.m_tileHeight;

		var ResultData = {};

		var nClusters = clustering.m_Clusters.length;
		ResultData.base = [];
		ResultData.hotItem = {};
		var i, j, elem;

		for (i = 0; i < numVOs; ++i) {
			elem = [];
			elem.clusterings = [];
			elem.m_lodOffset = 1;
			elem.m_BaseX = x;
			elem.m_BaseY = y;
			ResultData.base.push(elem);
			elem.targets = [];
			elem.targTypes = [];
			elem.hotItem = ResultData.hotItem;
			for (j = nClusters; j--;) {
				elem.targets.push(0);
			}
			for (j = clustering.m_nClustertypes; j--;) {
				elem.targTypes.push(0);
			}
			elem.m_nNumIgnore = 0;
		}
		ResultData.base.targTypes = [];
		for (j = clustering.m_nClustertypes; j--;) {
			ResultData.base.targTypes.push(0);
		}

		ResultData.clust = [];
		for (var nJ = 0; nJ < nClusters; ++nJ) {
			elem = [];
			elem.cI = nJ;
			elem.m_lodOffset = 1;
			elem.m_BaseX = x;
			elem.m_BaseY = y;
			elem.hotItem = ResultData.hotItem;
			elem.m_nRecalcs = 0;
			ResultData.clust.push(elem);
		}

		ResultData.config = {};
		var conf = ResultData.config;
		conf.m_version = clustering.m_loadCount;
		conf.bNeedsShadowLayer = false;

		conf.m_lod = lod;
		conf.m_lodOffset = 1;
		conf.m_x = x;
		conf.m_y = y;
		conf.m_nx = nx;
		conf.m_ny = ny;
		conf.m_nData = nDataVersion;
		conf.m_calcMode = 2;

		conf.m_BaseX = x * clustering.tw;
		conf.m_BaseY = y * clustering.tw;
		conf.m_BaseLod = lod;

		ResultData.hotItem = {};

		ResultData.m_SelectedVOs = [];

		return ResultData;
	};

	clustering.CheckNonClusteredVOs = function(ResultData, ClusterData) {
		if (!ResultData.base.targTypes[1]) { // only relevant for grid clustered VOs
			return;
		}

		for (var nI = 0; nI < ResultData.base.length; ++nI) {
			var vos = ResultData.base[nI];
			if (!vos.targTypes[1]) { // only relevant for grid clustered VOs
				continue;
			}
			var nJ, vl, cnt = 0;
			for (nJ = 0, vl = vos.length; nJ < vl; ++nJ) {
				var elem = vos[nJ];
				if (!elem.isCl) {
					if ((elem.cI != undefined) && (elem.sq != undefined) && (ClusterData[elem.cI])[elem.sq].b2Cluster) {
						vos.m_nNumIgnore++;
						elem.b2Ignore = true;
					}
					if (!elem.b2Ignore) {
						elem.bbInd = cnt;
						cnt++;
					}
				}
			}
			vos.m_NumVisVOs = cnt;
		}
	};

	clustering.FetchClusterVOData = function(scene, vos, ctx) {
		var clust = clustering.m_Clusters;
		var cl = clust.length;

		var result = [];
		for (var k = 0; k < cl; ++k) {
			result.push({});
		}

		var nl = vos.length;
		for (var i = 0; i < nl; ++i) {
			for (var j = 0; j < cl; ++j) {
				if (vos[i].m_ID == clust[j].m_VO) {
					result[j].m_index = i;
					result[j].m_image = vos[i].m_Image != undefined ? vos[i].m_Image.GetValueString(ctx) : "";
					result[j].m_scale = vos[i].m_Scale != undefined ? vos[i].m_Scale.GetValueVector(ctx) : [
						1, 1, 1
					];
					result[j].m_hotscale = vos[i].m_HotScale != undefined ? vos[i].m_HotScale.GetValueVector(ctx) : [
						1, 1, 1
					];
					result[j].m_hotcol = vos[i].m_HotDeltaColor != undefined ? vos[i].m_HotDeltaColor.GetValueString(ctx) : "";
					result[j].m_alignment = vos[i].m_Alignment != undefined ? vos[i].m_Alignment.GetValueString(ctx) : 0;
				}
			}
		}

		return result;
	};

	clustering.FetchClusterGroupData = function() {
		var clust = clustering.m_Clusters;
		var cl = clust.length;
		var result = [];
		for (var i = 0; i < cl; ++i) {
			var sources = [];
			if (clust[i].m_type == "clustergroup") {
				for (var j = 0; j < cl; ++j) {
					if ((i != j) && (clust[i].m_id == clust[j].m_groupID)) {
						sources.push({
							index: j,
							limit: clust[j].m_limit
						});
					}
				}
			}
			result.push(sources);
		}
		return result;
	};

	clustering.AdaptOffsets = function(preData, posDiff, lod, xPos, yPos, nX, nY) {
		preData.config.m_calcMode = 1;

		var lodDelta = (lod - preData.config.m_BaseLod);
		var fLodOffset = (lodDelta >= 0) ? (1 << lodDelta) : 1 / (1 << -lodDelta);
		var elem;

		for (var i = preData.base.length - 1; i >= 0; --i) {
			elem = preData.base[i];
			elem.m_lodOffset = fLodOffset;
			elem.m_BaseX = xPos;
			elem.m_BaseY = yPos;
		}

		for (var j = preData.clust.length - 1; j >= 0; --j) {
			elem = preData.clust[j];
			elem.m_lodOffset = fLodOffset;
			elem.m_BaseX = xPos;
			elem.m_BaseY = yPos;
		}
		preData.config.m_lod = lod;
		preData.config.m_x = xPos;
		preData.config.m_y = yPos;
		preData.config.m_nx = nX;
		preData.config.m_ny = nY;
		preData.config.m_lodOffset = fLodOffset;
	};

	clustering.DetermineChanges = function(oldPreData, lod, xPos, yPos, nX, nY, nData) {
		var r = {};

		r.bPosChanged = true;
		r.bDataChanged = true;
		r.bClusteringChanged = true;
		r.lodDiff = 0;
		r.lodFactor = 1;
		r.posDiff = [
			0, 0
		];

		if (oldPreData != undefined) {
			var config = oldPreData.config;
			r.lodDiff = lod - config.m_lod;
			if (r.lodDiff == 0) {
				r.lodFactor = 1 << (r.lodDiff);
				r.posDiff = [
					clustering.tw * (xPos - r.lodFactor * config.m_x), clustering.th * (yPos - r.lodFactor * config.m_y)
				];
			} else if (r.lodDiff > 0) {
				r.lodFactor = 1 << (r.lodDiff);
				r.posDiff = [
					clustering.tw * (xPos - r.lodFactor * config.m_x), clustering.th * (yPos - r.lodFactor * config.m_y)
				];
			} else {
				r.lodFactor = 1 / (1 << (-r.lodDiff));
				r.posDiff = [
					clustering.tw * (xPos - r.lodFactor * config.m_x), clustering.th * (yPos - r.lodFactor * config.m_y)
				];
			}

			if (config.m_nData == nData) {
				r.bDataChanged = false;
			}
			if (config.m_version == clustering.m_loadCount) {
				r.bClusteringChanged = false;
			}
			if (!r.lodDiff && (config.m_x == xPos) && (config.m_y == yPos) && (config.m_nx == nX) && (config.m_ny == nY)) {
				r.bPosChanged = false;
			}
		}

		r.bNothingChanged = !r.bDataChanged && !r.bPosChanged && !r.bClusteringChanged;

		return r;
	};

	clustering.InvalidateOutdatedClustering = function(ResultData, changes) {
		var bGeneralRemove = changes.bDataChanges || changes.bClusteringChanged;
		var bSomethingOutdated = bGeneralRemove;
		for (var i = 0; i < ResultData.base.length; ++i) {
			var voBase = ResultData.base[i];
			for (var j = voBase.clusterings.length - 1; j >= 0; --j) {
				var crossRef = voBase.clusterings[j];
				var b2BeRemoved = true;
				switch (crossRef.t) {
					case 0:
						b2BeRemoved = true;
						break;
					case 1:
						b2BeRemoved = bGeneralRemove || (changes.lodDiff != 0);
						break;
					case 2:
						b2BeRemoved = bGeneralRemove;
						break;
				}
				if (b2BeRemoved) {
					voBase.clusterings.splice(j, 1);
					var myArr = ResultData.clust[crossRef.i];
					myArr.m_nRecalcs++;
					myArr.splice(0, myArr.length);
					bSomethingOutdated = true;
				}
			}
		}

		return bSomethingOutdated;
	};

	clustering.ClearTreeClusterNode = function(node) {
		if (node.bw) {
			for (var i = node.bw.length; i--;) {
				clustering.ClearTreeClusterNode(node.bw[i]);
			}
			for (var j = node.bw.length; j--;) {
				node.bw[j] = undefined;
			}
			node.bw = undefined;
		}
		node.e = undefined;
		node.c = undefined;
	};

	clustering.ClearClusterFromPreData = function(clust, index) {
		if (clust[index].m_TreeFatherNode != undefined) {
			clustering.ClearTreeClusterNode(clust[index].m_TreeFatherNode);
		}
		clust[index] = undefined;
	};

	clustering.ClearPreassembledData = function(scene) {
		var preData = scene.m_PreassembledData;
		var i;
		if (preData == undefined) {
			return;
		}

		for (i = preData.clust.length; i--;) {
			clustering.ClearClusterFromPreData(preData.clust, i);
		}
		preData.clust = undefined;
		for (i = preData.base.length; i--;) {
			preData.base[i] = undefined;
		}
		scene.m_PreassembledData = undefined;
	};

	clustering.getEdge = function(edgeRef, edgeTable) {
		if (edgeRef[1] != undefined) {
			return edgeRef;
		}
		var e1 = edgeTable[edgeRef];
		var e2 = edgeTable[edgeRef + 1];
		return [
			[
				e1.c[0], e1.c[1]
			], [
				e2.c[0], e2.c[1]
			]
		];

	};

	clustering.createEdgeIndex = function(edgeTable, edges) {
		var i, ei = [];
		var edge;
		for (i = edges.length; i--;) {
			edge = clustering.getEdge(edges[i], edgeTable);
			edge[0].ot = edge[1];
			edge[0].i = i;
			edge[1].ot = edge[0];
			edge[1].i = -i;
			var elte1 = {};
			elte1.i = i;
			elte1.c = 0;
			elte1.p = edge[0];
			edge[0].li = elte1;
			ei.push(elte1);
			var elte2 = {};
			elte2.p = edge[1];
			elte2.i = -i;
			elte2.c = 1;
			edge[1].li = elte2;
			ei.push(elte2);
		}

		ei.sort(function(i, j) {
			var x = i.p[0] - j.p[0];
			return x ? x : i.p[1] - j.p[1];
		});

		for (i = 0; i < ei.length; i += 2) {
			ei[i].ot = i + 1;
			ei[i + 1].ot = i;
		}

		return ei;
	};

	clustering.getTreeClusterIndex = function(node) {
		var myNode = node;
		while (myNode.c != undefined) {
			myNode = myNode.c;
		}
		return myNode.cI;
	};

	clustering.getNodeIdent = function(preData, node, cI) {
		if (node.bw != undefined) {
			return clustering.getClusterIdent(preData, cI, node.nJ);
		} else {
			return preData.base[node.vI].strDataPath + node.key;
		}
	};

	clustering.getClusterIdent = function(preData, cI, nI) {
		if (!preData) {
			return "";
		}
		var preDataConfig = preData.config;
		var clust = preData.clust[cI];
		if (!clust) {
			return "";
		}
		return "[" + preDataConfig.m_version + "," + preDataConfig.m_nData + "," + clust.m_nRecalcs + "," + cI + "," + nI + "]";
	};

	clustering.getClusterArea = function(scene, node) {
		if (!node.bo) {
			return undefined;
		}

		var preData = scene.m_PreassembledData;
		var xOff = scene.m_Canvas[0].m_nCurrentX * scene.m_MapManager.m_tileWidth;
		var yOff = scene.m_Canvas[0].m_nCurrentY * scene.m_MapManager.m_tileHeight;
		var nLod = preData.config.m_lodOffset;
		var ucsLU = [
			nLod * node.bo[0] - xOff, nLod * node.bo[1] - yOff
		];
		var ucsRL = [
			nLod * node.bo[2] - xOff, nLod * node.bo[3] - yOff
		];
		var posLU = VBI.MathLib.RadToDeg(scene.GetGeoFromPoint(ucsLU));
		var posRL = VBI.MathLib.RadToDeg(scene.GetGeoFromPoint(ucsRL));
		return posLU[0].toString() + ';' + posLU[1].toString() + ';' + posRL[0].toString() + ';' + posRL[1].toString();
	};

	clustering.getClusterPosition = function(scene, node) {
		var preData = scene.m_PreassembledData;
		var xOff = scene.m_Canvas[0].m_nCurrentX * scene.m_MapManager.m_tileWidth;
		var yOff = scene.m_Canvas[0].m_nCurrentY * scene.m_MapManager.m_tileHeight;
		var nLod = preData.config.m_lodOffset;
		var ucsLU = [
			nLod * node[0] - xOff, nLod * node[1] - yOff
		];
		return VBI.MathLib.RadToDeg(scene.GetGeoFromPoint(ucsLU));
	};

	clustering.getInfoForCluster = function(params, type, scene) {
		var preData = scene.m_PreassembledData;
		var preDataConfig = preData.config;
		var cI;
		var clust = preData.clust[params[3]];
		var retList = [];
		if (preDataConfig.m_version == params[0] && preDataConfig.m_nData == params[1] && clust.m_nRecalcs == params[2]) {
			var node = clust[params[4]];
			if (type == 10) {
				var bws = node.bw ? node.bw.length : 0;
				return {
					pos: clustering.getClusterPosition(scene, node),
					bb: clustering.getClusterArea(scene, node),
					image: node.im,
					lod: node.lod,
					ulod: node.c ? node.c.lod : undefined,
					cnt: node.cnt,
					subs: bws,
					type: node.isCl
				};
			}
			if (node.bw) {
				switch (type) {
					case 0:
						clustering.collectNodes(retList, node, preData);
						break;
					case 1:
						cI = clustering.getTreeClusterIndex(node);
						for (var i = 0; i < node.bw.length; ++i) {
							retList.push(clustering.getNodeIdent(preData, node.bw[i], cI));
						}
						break;
					case 2:
						cI = clustering.getTreeClusterIndex(node);
						if (node.c) {
							retList.push(clustering.getNodeIdent(preData, node.c, cI));
						}
						break;
					case 11:
						cI = clustering.getTreeClusterIndex(node);
						return clustering.collectEdges(scene, node, preData.clust[cI].m_edges);
				}
			}
		}
		retList.sort();
		return retList;
	};

	clustering.collectEdges = function(scene, node, edgeTable) {
		var edgeList = [];
		if (!node.e || !node.e.length) {
			return [];
		}
		var pList = clustering.createEdgeIndex(edgeTable, node.e);
		var preData = scene.m_PreassembledData;
		var xOff = scene.m_Canvas[0].m_nCurrentX * scene.m_MapManager.m_tileWidth;
		var yOff = scene.m_Canvas[0].m_nCurrentY * scene.m_MapManager.m_tileHeight;
		var nLod = preData.config.m_lodOffset;

		var p0 = pList[0].p, p1, l0, l1, numEdges = node.e.length - 1;
		edgeList.push(VBI.MathLib.RadToDeg(scene.GetGeoFromPoint([
			nLod * p0[0] - xOff, nLod * p0[1] - yOff
		])));
		for (var i = numEdges; i--;) {
			p1 = p0.ot;
			edgeList.push(VBI.MathLib.RadToDeg(scene.GetGeoFromPoint([
				nLod * p1[0] - xOff, nLod * p1[1] - yOff
			])));
			l1 = p1.li;
			l0 = pList[l1.ot];
			p0 = l0.p;
		}

		return edgeList;
	};

	clustering.collectNodes = function(retList, node, preData) {
		if (node.bw != undefined) {
			for (var i = 0; i < node.bw.length; ++i) {
				clustering.collectNodes(retList, node.bw[i], preData);
			}
		} else {
			var myVO = preData.base[node.vI];
			retList.push(myVO.strDataPath + node.key);
		}

	};

	clustering.DoClustering = function(scene, lod, orgXPos, yPos, nX, nY, vos, ctx, lastHotCluster, bForceRender, bForceClustering, nDataVersion) {
		var completeX = (1 << lod);
		var xPos = orgXPos;
		while (xPos < 0) {
			xPos += completeX;
		}
		while (xPos > completeX) {
			xPos -= completeX;
		}
		var changes = clustering.DetermineChanges(scene.m_PreassembledData, lod, xPos, yPos, nX, nY, nDataVersion);
		var ResultData;

		if (changes.bNothingChanged) {
			scene.m_PreassembledData.config.m_calcMode = 0;
			return scene.m_PreassembledData;
		}

		var nJ;
		var clusterVOData = clustering.FetchClusterVOData(scene, vos, ctx);
		var groupConnections = clustering.FetchClusterGroupData();
		clustering.m_Parser.verifyAttributes(vos, ctx);

		var ClusterData = clustering.InitializeClusterData(scene, lod, xPos, yPos, nX, nY);

		if (changes.bDataChanged || changes.bClusteringChanged) {
			clustering.ClearPreassembledData(scene);
			ResultData = clustering.InitializeResultVector(scene.m_MapManager, vos.length, lod, xPos, yPos, nX, nY, nDataVersion);
			for (nJ = 0; nJ < vos.length; ++nJ) {
				var vo = vos[nJ];
				if (vo.IsClusterable()) {
					clustering.PreassembleDataForVO(scene, ResultData, nJ, vo, ctx);
				}
			}
		} else {
			ResultData = scene.m_PreassembledData;
			clustering.AdaptOffsets(ResultData, changes.posDiff, lod, xPos, yPos, nX, nY);
			if (!clustering.InvalidateOutdatedClustering(ResultData, changes)) {
				return ResultData;
			}
		}

		for (nJ = 0; nJ < clustering.m_Clusters.length; ++nJ) {
			clustering.m_Clusters[nJ].ClusterPass1(nJ, ResultData, ClusterData, changes);
		}
		for (nJ = 0; nJ < clustering.m_Clusters.length; ++nJ) {
			clustering.m_Clusters[nJ].ClusterPass2(nJ, ResultData, ClusterData, groupConnections);
		}

		for (nJ = 0; nJ < clustering.m_Clusters.length; ++nJ) {
			clustering.m_Clusters[nJ].DecisionPass(scene, nJ, ResultData, ClusterData, clusterVOData, groupConnections, changes);
		}

		clustering.CheckNonClusteredVOs(ResultData, ClusterData);

		return ResultData;
	};

	clustering.InitializeClusterData = function(scene, lod, xPos, yPos, nX, nY) {
		var ClusterData = [];

		var numTiles = (1 << lod);
		// normalize complete dimension on current LOD.........................//
		ClusterData.numTiles = numTiles;
		ClusterData.completeX = numTiles * scene.m_nWidthCanvas / scene.m_nTilesX;
		ClusterData.completeY = numTiles * scene.m_nHeightCanvas / scene.m_nTilesY;
		ClusterData.minLOD = scene.GetMinLOD();

		for (var nJ = 0; nJ < clustering.m_Clusters.length; ++nJ) {
			var clust = clustering.m_Clusters[nJ];
			var nGridcellsX = (nX + 2) * clust.m_dividerX;
			var nGridcellsY = (nY + 2) * clust.m_dividerY;
			ClusterData.push(clust.InitializeClusterData(scene, nJ, xPos - 1, yPos - 1, nGridcellsX, nGridcellsY));
		}

		return ClusterData;
	};

	clustering.VerifyCurrentSelection = function(vos, ResultData, ctx) {
		for (var i = ResultData.m_SelectedVOs.length - 1; i >= 0; --i) {
			var selElte = ResultData.m_SelectedVOs[i];
			var vo = vos[selElte.m_vo];
			vo.m_DataSource.Select(selElte.m_dataIndex);
			if (!vo.IsSelected(ctx)) { // in case the entity is no more selected we have to reset it.
				var vArray = (selElte.cI != undefined ? ResultData.clust[selElte.cI] : ResultData.base[selElte.m_vo]);
				vArray[selElte.m_index].s = false;
				ResultData.m_SelectedVOs.splice(i, 1);
			}
		}
	};

	clustering.AddSingle2Selected = function(voIndex, vos, instIndex, ResultData, ctx) {
		var vo = vos[voIndex];
		if (vo.IsClusterable()) { // the new one is the only one possibly added
			var vArray = (instIndex.cI != undefined ? ResultData.clust[instIndex.cI] : ResultData.base[voIndex]);
			var elte = vArray[instIndex.i];
			vo.m_DataSource.Select(elte.nI);
			if (vo.IsSelected(ctx)) {
				ResultData.m_SelectedVOs.unshift({
					m_vo: voIndex,
					m_index: instIndex.i,
					m_dataIndex: elte.nI,
					cI: instIndex.cI
				});
				elte.scol = vo.m_SelectColor.GetValueString(ctx);
				elte.simag = vo.m_ImageSelected.GetValueString(ctx);
				elte.s = true;
			}
		}
	};

	clustering.AddMultiple2Selected = function(instArray, vos, ResultData, ctx) {
		for (var ni = 0; ni < instArray.length; ++ni) {
			var row = instArray[ni];
			var vo = vos[ni];
			if (vo.IsClusterable()) {
				for (var nj = 0; nj < row.length; ++nj) {
					clustering.AddSingle2Selected(ni, vos, vo.GetInternalIndex(row[nj]), ResultData, ctx);
				}
			}
		}
	};

	VBI.Clustering.Cluster = function() {
		var cluster = {};

		// additional properties array.........................................//
		cluster.m_additionalProperties = [];

		cluster.clear = function() {
			cluster.m_addProperties = null;
		};

		cluster.load = function(dat, ctx, index) {
			cluster.m_id = dat.id;
			cluster.m_type = dat.type;
			cluster.m_type2 = dat.type2;
			cluster.m_switch = parseInt(dat.typeswitch, 10);
			cluster.m_bPartOfGrp = false;
			cluster.m_VO = dat.VO;
			cluster.m_order = parseInt(dat.order, 10);
			cluster.m_dispOffsetX = parseInt(dat.offsetX, 10);
			if (isNaN(cluster.m_dispOffsetX)) {
				cluster.m_dispOffsetX = 0;
			}
			cluster.m_dispOffsetY = parseInt(dat.offsetY, 10);
			if (isNaN(cluster.m_dispOffsetY)) {
				cluster.m_dispOffsetY = 0;
			}
			clustering.m_Parser.addFormula(index, dat.rule == undefined ? "" : dat.rule);
			cluster.m_textcolor = dat.textcolor;
			if (cluster.m_textcolor == undefined) {
				cluster.m_textcolor = "rgba(0,0,0,0.7)";
			}
			cluster.m_textfont = dat.textfont;
			cluster.m_textfontscale = dat.textfontscale;
			cluster.m_textfontsize = dat.textfontsize;
			if (isNaN(cluster.m_textfontscale)) {
				cluster.m_textfontscale = 2.0;
			}
			cluster.m_textoffset = parseInt(dat.textoffset, 10);
			cluster.m_textoffsetY = parseInt(dat.textoffsetY, 10);
			if (isNaN(cluster.m_textoffset)) {
				cluster.m_textoffset = 0;
			}
			if (isNaN(cluster.m_textoffsetY)) {
				cluster.m_textoffsetY = 0;
			}
			cluster.m_spotcol = dat.spotcol;
			cluster.m_spotsize = parseInt(dat.spotsize, 10);
			cluster.m_bordersize = dat.areabordersize ? parseInt(dat.areabordersize, 10) : 2;
			cluster.m_bordercol = dat.areabordercol;

			if (cluster.m_type == "grid") {
				cluster.m_nType = 1;
				cluster.m_distanceX = ((dat.distanceX == undefined) || (dat.distanceX <= 0)) ? 256 : dat.distanceX;
				cluster.m_dividerX = Math.max(1, Math.round(256 / cluster.m_distanceX));
				cluster.m_distanceY = ((dat.distanceY == undefined) || (dat.distanceY <= 0)) ? 256 : dat.distanceY;
				cluster.m_dividerY = Math.max(1, Math.round(256 / cluster.m_distanceY));
				cluster.m_groupID = (dat.groupID == undefined ? "&" : dat.groupID) + cluster.m_dividerX + "_" + cluster.m_dividerY;
				cluster.m_omitEmpties = (dat.showEmpties != "true");
				cluster.m_fillcol = dat.areafillcol;
				cluster.m_permanentArea = (dat.areapermanent == "true");
			}
			if (cluster.m_type == "distance") {
				cluster.m_nType = 3;
				cluster.m_distance = dat.distance;
				if (cluster.m_distance == undefined || cluster.m_distance <= 0) {
					cluster.m_distance = 128; // default distance if undefined
				}
			}
			if (cluster.m_type == "tree") {
				cluster.m_nType = 4;
				cluster.m_distance = dat.distance;
				if (cluster.m_distance == undefined || cluster.m_distance <= 0) {
					cluster.m_distance = 16; // default distance if undefined
				}
				cluster.m_bordercol2 = dat.areabordercol2;
				cluster.m_bordercol3 = dat.areabordercol3;
				cluster.m_fillcol = dat.areafillcol;
				cluster.m_fillcol2 = dat.areafillcol2;
				cluster.m_fillcol3 = dat.areafillcol3;
				cluster.m_animated = dat.animation == "true" ? "2" : dat.animation;
				cluster.m_permanentArea = (dat.areapermanent == "true");
			}

			cluster.m_limit = parseInt(dat.limit, 10);
			cluster.m_limitOnSum = dat.limitOnSum == undefined ? 999999 : parseInt(dat.limitOnSum, 10);

			cluster.initializeFunctions();
		};

		cluster.initializeFunctions = function() {
			switch (cluster.m_type) {
				case "grid":
					cluster.InitializeClusterData = cluster.InitializeGridClusterData;
					cluster.ClusterPass1 = cluster.gridClusteringCounting;
					cluster.ClusterPass2 = cluster.NothingToDo;
					cluster.DecisionPass = cluster.gridBasedDecision;
					cluster.CheckClusterData = cluster.CheckSingleClusterData;
					break;
				case "clustergroup":
					cluster.InitializeClusterData = cluster.InitializeGridClusterData;
					cluster.ClusterPass1 = cluster.NothingToDo;
					cluster.ClusterPass2 = cluster.gridClustergroupCounting;
					cluster.DecisionPass = cluster.gridBasedDecision;
					cluster.CheckClusterData = cluster.CheckGroupClusterData;
					break;
				case "distance":
					cluster.InitializeClusterData = cluster.InitializeDistClusterData;
					cluster.ClusterPass1 = cluster.NothingToDo;
					cluster.ClusterPass2 = cluster.NothingToDo;
					cluster.DecisionPass = cluster.distanceBasedDecision;
					cluster.CheckClusterData = cluster.NothingToDo; // not applicable
					break;
				case "tree":
					cluster.InitializeClusterData = cluster.InitializeTreeClusterData;
					cluster.ClusterPass1 = cluster.NothingToDo;
					cluster.ClusterPass2 = cluster.NothingToDo;
					cluster.DecisionPass = cluster.treeBasedDecision;
					cluster.CheckClusterData = cluster.NothingToDo; // not applicable
					break;
			}
		};

		cluster.gridClusteringCounting = function(nI, ResultData, ClusterData, changes) {
			var myGrid = ClusterData[nI];
			var myResult = ResultData.clust[nI];
			var xSize = myGrid.nX;
			var ySize = myGrid.nY;
			var xMult = cluster.m_dividerX * ClusterData.numTiles / ClusterData.completeX;
			var yMult = cluster.m_dividerY * ClusterData.numTiles / ClusterData.completeX;
			var completeTiles = ClusterData.completeX / 256;

			var xGridPos, yGridPos, nPos;
			var myVO, elem;
			var baseX = clustering.th * myGrid.m_BaseX;
			var baseY = clustering.th * myGrid.m_BaseY;
			var lodOff = myResult.m_lodOffset;

			for (var nK = 0; nK < ResultData.base.length; ++nK) {
				myVO = ResultData.base[nK];
				for (var nJ = 0; nJ < myVO.length; ++nJ) {
					elem = myVO[nJ];
					if (elem.cI == nI) {
						if (elem.b2Ignore) {
							myVO.m_nNumIgnore--;
							elem.b2Ignore = false;
						}
						xGridPos = Math.floor((lodOff * elem[0] - baseX) * xMult);
						if (xGridPos < 0) {
							xGridPos += completeTiles; // we have to take a look on the next instance
						}

						yGridPos = Math.floor((lodOff * elem[1] - baseY) * yMult);
						if ((xGridPos >= 0) && (xGridPos < xSize) && (yGridPos >= 0) && (yGridPos < ySize)) {
							nPos = xGridPos + xSize * yGridPos;
							elem.sq = nPos;
							myGrid[nPos].numInst++;
							myGrid[nPos].bw.push(elem);
						}
					}
				}
			}
		};

		cluster.gridClustergroupCounting = function(nI, ResultData, ClusterData, groupConnections) {
			var myConnects = groupConnections[nI];
			var connects = myConnects.length;
			var myGrid = ClusterData[nI];

			for (var nK = 0; nK < myGrid.length; ++nK) {
				var cnt = 0;
				var cell = myGrid[nK];
				cell.bLimitExceeded = false;

				for (var nL = 0; nL < connects; ++nL) {
					var inst = myConnects[nL].index;
					var cGrid = ClusterData[inst];
					var newVal = cGrid[nK].numInst;
					cnt += newVal;
					if (newVal >= myConnects[nL].limit) {
						cell.bLimitExceeded = true;
					}
				}
				cell.numInst = cnt;
			}
		};

		cluster.distanceBasedDecision = function(scene, nJ, ResultData, ClusterData, clusterVOData, groupConnections, changes) {
			if (changes.lodDiff || changes.bDataChanged || changes.bClusteringChanged) {
				var clust = clustering.m_Clusters[nJ];
				var distClusters = cluster.doDistClustering(nJ, ResultData, clust.m_distance, ClusterData.completeX);
				cluster.distFillClusterData(scene, distClusters, ResultData, clusterVOData[nJ], nJ);
			}
		};

		cluster.treeBasedDecision = function(scene, nJ, ResultData, ClusterData, clusterVOData, groupConnections, changes) {
			if (changes.bDataChanged || changes.bClusteringChanged) {
				var clust = clustering.m_Clusters[nJ];
				var treeClusters = cluster.doTreeClustering(nJ, ResultData, clusterVOData[nJ], clust.m_distance, ClusterData.completeX);
				cluster.treeFillClusterData(scene, treeClusters, ResultData, clusterVOData[nJ], nJ, scene.GetMinLOD());
			}
		};

		cluster.gridBasedDecision = function(scene, nK, ResultData, ClusterData, clusterVOData, groupConnections, changes) {
			ResultData.config.bNeedsShadowLayer = cluster.fillClusterConfig(ResultData.clust[nK], ResultData.config, 0, false) || ResultData.config.bNeedsShadowLayer;

			var clust = clustering.m_Clusters[nK];
			if (!clust.m_bPartOfGrp) {
				var clustsq = ClusterData[nK];

				var myConnections = groupConnections[nK];
				if (myConnections.length) {
					for (var i = myConnections.length; i--;) {
						var con = myConnections[i].index;
						ResultData.base[clusterVOData[con].m_index].clusterings.push({
							i: con,
							t: 0
						});
					}
				} else {
					ResultData.base[clusterVOData[nK].m_index].clusterings.push({
						i: nK,
						t: 0
					});
				}
				for (var x = 0; x < clustsq.nX; ++x) {
					for (var y = 0; y < clustsq.nY; ++y) {
						var nJ = x + clustsq.nX * y;
						clust.CheckClusterData(ResultData, ClusterData, clustsq[nJ], nK, nJ, x, y, clusterVOData, myConnections);
					}
				}
			}
		};

		cluster.NothingToDo = function() {

		};

		cluster.ReturnFalse = function() {
			return false;
		};

		cluster.CheckSingleClusterData = function(ResultData, ClusterData, cellclust, nK, nJ, x, y, voData, connections) {
			if (cellclust.numInst >= cluster.m_limit) {
				var target = ClusterData[nK];
				clustering.m_Clusters[nK].FillClusterData(ResultData, target[nJ], x, y, target, voData[nK], nK, 1);
				return;
			}
			cellclust.b2Cluster = false;

			return;
		};

		cluster.CheckGroupClusterData = function(ResultData, ClusterData, cellclust, nK, nJ, x, y, voData, connections) {
			var i, target, groupCnt = 1;
			if (cellclust.bLimitExceeded || (cellclust.numInst >= cluster.m_limit)) {
				for (i = 0; i < connections.length; ++i) {
					var tg = connections[i].index;
					target = ClusterData[tg];
					groupCnt = clustering.m_Clusters[tg].FillClusterData(ResultData, target[nJ], x, y, target, voData[tg], tg, groupCnt);
				}
			} else {
				cellclust.b2Cluster = false;
				for (i = 0; i < connections.length; ++i) {
					target = ClusterData[connections[i].index];
					target[nJ].b2Cluster = false;
				}
			}

			return;
		};

		cluster.InitializeGridClusterData = function(scene, nJ, xPos, yPos, nX, nY) {
			var myGrid = [];

			myGrid.cI = nJ;
			myGrid.nX = nX;
			myGrid.nY = nY;
			myGrid.XPerTile = scene.m_nWidthCanvas / (scene.m_nTilesX * cluster.m_dividerX);
			myGrid.YPerTile = scene.m_nHeightCanvas / (scene.m_nTilesY * cluster.m_dividerY);

			var cnt = 0;
			for (var x = 0; x < nX; ++x) {
				for (var y = 0; y < nY; ++y) {
					var elem = {};
					elem.numInst = 0;
					elem.bw = [];
					elem.sq = cnt++;
					myGrid.push(elem);
				}
			}

			myGrid.m_BaseX = xPos;
			myGrid.m_BaseY = yPos;

			return myGrid;
		};

		cluster.InitializeDistClusterData = function(scene, nJ, xPos, yPos, nX, nY) {
			var elem = {};
			elem.numInst = 0;
			elem.type = cluster.m_type;
			elem.cI = nJ;

			return elem;
		};

		cluster.InitializeTreeClusterData = function(scene, nJ, xPos, yPos, nX, nY) {
			var elem = {};
			elem.numInst = 0;
			elem.type = cluster.m_type;

			return elem;
		};

		cluster.FillSquareEdges = function(elem, b2Times, bSize, x0, y0, x1, y1) {
			var ret = [];
			ret.push([
				[
					x0, y0
				], [
					x1, y0
				]
			]);
			ret.push([
				[
					x1, y0
				], [
					x1, y1
				]
			]);
			ret.push([
				[
					x1, y1
				], [
					x0, y1
				]
			]);
			ret.push([
				[
					x0, y1
				], [
					x0, y0
				]
			]);
			elem.e = ret;
			if (b2Times) {
				var ret2 = [];
				var xDiff = (x1 - x0) / 256 * Math.abs(bSize) / 2;
				var yDiff = (y1 - y0) / 256 * Math.abs(bSize) / 2;
				ret2.push([
					[
						x0 + xDiff, y0 + yDiff
					], [
						x1 - xDiff, y0 + yDiff
					]
				]);
				ret2.push([
					[
						x1 - xDiff, y0 + yDiff
					], [
						x1 - xDiff, y1 - yDiff
					]
				]);
				ret2.push([
					[
						x1 - xDiff, y1 - yDiff
					], [
						x0 + xDiff, y1 - yDiff
					]
				]);
				ret2.push([
					[
						x0 + xDiff, y1 - yDiff
					], [
						x0 + xDiff, y0 + yDiff
					]
				]);
				elem.ei = ret2;
			}

		};

		cluster.FillClusterData = function(ResultData, cellclust, x, y, myClusterData, voData, nK, groupCnt) { // Fills data and returns BOOL whether
			// grid has yet to be displayed
			var myResult = ResultData.clust[nK];
			var xPerTile = myClusterData.XPerTile;
			var yPerTile = myClusterData.YPerTile;
			var xBase = clustering.th * myClusterData.m_BaseX;
			var yBase = clustering.th * myClusterData.m_BaseY;

			if (cluster.m_omitEmpties && !cellclust.numInst) {
				cellclust.b2Cluster = false;
				return groupCnt;
			}
			cellclust.b2Cluster = true;
			var yMin = y * yPerTile;
			var yMax = yMin + yPerTile;
			var xMin = x * xPerTile;
			var xMax = xMin + xPerTile;
			var halfXSize = xPerTile / 2;
			var halfYSize = yPerTile / 2;
			var elem = [
				(xBase + xMin + halfXSize + cluster.m_dispOffsetX) / myResult.m_lodOffset, (yBase + yMin + halfYSize + cluster.m_dispOffsetY) / myResult.m_lodOffset, 0, 0
			];
			cluster.FillSquareEdges(elem, myResult.config.b2Times, myResult.config.bSize, (xBase + xMin) / myResult.m_lodOffset, (yBase + yMin) / myResult.m_lodOffset, (xBase + xMax) / myResult.m_lodOffset, (yBase + yMax) / myResult.m_lodOffset);
			elem.sq = cellclust.sq;
			elem.cI = myClusterData.cI;
			elem.h = elem.s = false;
			elem.im = voData.m_image;
			elem.sc = voData.m_scale;
			elem.hscale = voData.m_hotscale;
			elem.hcol = voData.m_hotcol;
			elem.al = voData.m_alignment;
			elem.cnt = cellclust.numInst;
			if (cluster.m_textfont != undefined) {
				elem.f = cluster.m_textfont;
				elem.fc = cluster.m_textcolor;
				elem.fs = cluster.m_textfontscale;
				elem.fz = cluster.m_textfontsize;
				elem.fo = cluster.m_textoffset;
				elem.foy = cluster.m_textoffsetY;
			}
			elem.isCl = 1;
			elem.nJ = myResult.length;
			elem.grI = groupCnt;
			elem.bw = cellclust.bw;
			myResult.push(elem);

			return groupCnt + 1;
		};

		cluster.doDistClustering = function(nK, ResultData, orgDistThreshold, completeX) {
			var i, j, a, b, ax;
			var aTemp = [];
			var eElem = {};
			var lodOffset = ResultData.clust[nK].m_lodOffset;
			var distThreshold = orgDistThreshold / lodOffset;

			// check which objects belong to nK cluster and create a temp list
			for (i = 0; i < ResultData.base.length; ++i) {
				eElem = ResultData.base[i];

				for (j = 0; j < eElem.length; ++j) {
					if (eElem[j].cI == nK) {
						aTemp.push(eElem[j]);
						if (eElem[j].b2Ignore) {
							eElem.m_nNumIgnore--;
							eElem[j].b2Ignore = false;
						}
						eElem[j].isGrouped = false;
					}
				}
			}

			if (!aTemp.length) {
				return [];
			}

			aTemp.sort(function(a, b) {
				return a[0] - b[0];
			}); // sort the objects on x coordinate

			// find the first gap between clusters from the left side
			var nn = aTemp.length - 1;
			var iGap = 0;
			var firstP = aTemp[0], lastP = aTemp[nn];
			var distGap = firstP[0] - lastP[0] + completeX;
			if (distGap <= distThreshold) {
				for (i = 0; i < nn; ++i) {
					a = aTemp[i];
					b = aTemp[i + 1];
					ax = b[0] - a[0];

					if (ax > distThreshold) {
						iGap = i + 1;
						break;
					}
				}
			}

			// ---------------------------------------------------------------------
			// distance clustering part

			var aGroups = [];
			var minY, maxY, xa, xb, im, jm;
			var nLn = aTemp.length + iGap;
			var nAll = aTemp.length;

			for (i = iGap; i < nLn; ++i) {
				im = i % nAll;

				a = aTemp[im];
				if (a.isGrouped) {
					continue;
				}

				xa = a[0];
				if (i > nAll - 1) {
					xa += completeX;
				}

				for (j = i + 1; j < nLn; ++j) {
					jm = j % nAll;

					b = aTemp[jm];
					if (b.isGrouped) {
						continue;
					}

					xb = b[0];
					if (j > nAll - 1) {
						xb += completeX;
					}

					if (xb - xa <= distThreshold) {
						if (a.isGrouped && aGroups.length > 0) {
							minY = aGroups[a.nGrp].minY;
							maxY = aGroups[a.nGrp].maxY;
						} else {
							minY = a[1];
							maxY = a[1];
						}

						if (Math.abs(b[1] - minY) <= distThreshold && Math.abs(b[1] - maxY) <= distThreshold) {

							if (a.isGrouped) {
								aGroups[a.nGrp].push(b);
								b.isGrouped = true;
								b.nGrp = a.nGrp;
								b.b2Ignore = true;
								ResultData.base[b.vI].m_nNumIgnore++;

								// update y borders
								if (b[1] < aGroups[a.nGrp].minY) {
									aGroups[a.nGrp].minY = b[1];
								}
								if (b[1] > aGroups[a.nGrp].maxY) {
									aGroups[a.nGrp].maxY = b[1];
								}

								// update x borders
								if (xb < aGroups[a.nGrp].minX) {
									aGroups[a.nGrp].minX = xb;
								}
								if (xb > aGroups[a.nGrp].maxX) {
									aGroups[a.nGrp].maxX = xb;
								}

								// add the X and Y coordinates for gravity center calc
								if (aGroups[a.nGrp].sumX == undefined) {
									aGroups[a.nGrp].sumX = xb;
								} else {
									aGroups[a.nGrp].sumX += xb;
								}

								if (aGroups[a.nGrp].sumY == undefined) {
									aGroups[a.nGrp].sumY = b[1];
								} else {
									aGroups[a.nGrp].sumY += b[1];
								}
							} else {
								var aGr = [];
								aGr.push(a);
								aGr.push(b);
								aGroups.push(aGr);

								var lg = aGroups.length - 1;
								a.isGrouped = true;
								a.nGrp = lg;
								a.b2Ignore = true;
								ResultData.base[a.vI].m_nNumIgnore++;
								b.isGrouped = true;
								b.nGrp = lg;
								b.b2Ignore = true;
								ResultData.base[b.vI].m_nNumIgnore++;

								// update y borders
								if (a[1] < b[1]) {
									aGroups[lg].minY = a[1];
									aGroups[lg].maxY = b[1];
								} else {
									aGroups[lg].minY = b[1];
									aGroups[lg].maxY = a[1];
								}

								// update x borders
								if (xa < xb) {
									aGroups[lg].minX = xa;
									aGroups[lg].maxX = xb;
								} else {
									aGroups[lg].minX = xb;
									aGroups[lg].maxX = xa;
								}

								// add the X and Y coordinates for gravity center calc
								if (aGroups[lg].sumX == undefined) {
									aGroups[lg].sumX = xa + xb;
								} else {
									aGroups[lg].sumX += xa + xb;
								}

								if (aGroups[lg].sumY == undefined) {
									aGroups[lg].sumY = a[1] + b[1];
								} else {
									aGroups[lg].sumY += a[1] + b[1];
								}
							}
						}
					} else {
						break;
					}
				}

			}

			return aGroups;
		};

		cluster.distFillClusterData = function(scene, distClusters, ResultData, voData, iClust) {
			for (var i = 0; i < distClusters.length; ++i) {
				var myCl = distClusters[i];
				var ll = myCl.length;
				var xc = myCl.sumX / ll;
				var yc = myCl.sumY / ll;
				var elem = [
					xc, yc, 0, 0
				];

				elem.bo = [
					myCl.minX, myCl.minY, myCl.maxX, myCl.maxY
				];
				elem.h = false;
				elem.hscale = voData.m_hotscale;
				elem.hcol = voData.m_hotcol;
				elem.al = voData.m_alignment;
				elem.s = false;
				elem.im = voData.m_image;
				elem.sc = voData.m_scale;
				elem.cnt = ll;
				if (cluster.m_textfont != undefined) {
					elem.f = cluster.m_textfont;
					elem.fc = cluster.m_textcolor;
					elem.fs = cluster.m_textfontscale;
					elem.fz = cluster.m_textfontsize;
					elem.fo = cluster.m_textoffset;
					elem.foy = cluster.m_textoffsetY;
				}
				elem.bw = myCl;
				elem.isCl = 3;
				elem.nJ = ResultData.clust[iClust].length;
				ResultData.clust[iClust].push(elem);
				elem.grI = 1;
				elem.cI = iClust;
			}
			ResultData.config.bNeedsShadowLayer = cluster.fillDistConfig(ResultData.clust[iClust], ResultData.config, ResultData) || ResultData.config.bNeedsShadowLayer;
			ResultData.base[voData.m_index].clusterings.push({
				i: iClust,
				t: 1
			});
			return true;
		};

		cluster.AddEdgeChain = function(nodes) {
			var retArray = [];
			var lastNode = nodes[0], node, len;
			var nNodes = nodes.length;
			for (var i = 1; i < nNodes; ++i) {
				node = nodes[i];
				// len = Math.abs(lastNode[0]-node[0]) + Math.abs(lastNode[1]-node[1]);
				len = Math.max(Math.abs(lastNode[0] - node[0]), Math.abs(lastNode[1] - node[1]));
				retArray.push({
					s: lastNode[2],
					d: node[2],
					l: len,
					c: undefined
				});
				lastNode = node;
			}

			return retArray;
		};

		cluster.doTreeClustering = function(nK, ResultData, voData, distThreshold, completeX) {
			var aTemp = [];
			var eElem = {};
			var i, j;

			// check which objects belong to nK cluster and create a temp list
			for (i = 0; i < ResultData.base.length; ++i) {
				eElem = ResultData.base[i];

				for (j = 0; j < eElem.length; ++j) {
					if (eElem[j].cI == nK) {
						var elte = eElem[j];
						while (elte[0] < 0) {
							elte[0] += completeX;
						}
						while (elte[0] > completeX) {
							elte[0] -= completeX;
						}
						elte.lod = 30;
						elte.cnt = 1;
						elte.e = [];
						aTemp.push(elte);
						elte.b2Ignore = true;
						eElem.m_nNumIgnore++;
						elte.vo = i;
					}
				}
			}

			var a, ax, b;
			aTemp.sort(function(a, b) {
				return a[0] != b[0] ? a[0] - b[0] : a[1] - b[1];
			}); // sort the objects on x coordinate

			// we have to enrich the selected VO data
			if (ResultData.m_SelectedVOs.length) {
				for (var ii = 0; ii < aTemp.length; ++ii) {
					if (aTemp[ii].s) {
						for (var jj = 0; jj < ResultData.m_SelectedVOs.length; jj++) {
							if (aTemp[ii].nI == ResultData.m_SelectedVOs[jj].m_dataIndex) {
								ResultData.m_SelectedVOs[jj].m_index = ii;
								ResultData.m_SelectedVOs[jj].cI = nK;
							}
						}
					}
				}
			}

			// find the first gap between clusters from the left side
			var nn = aTemp.length - 1;
			if (nn < 0) {
				return [];
			}
			var iGap = 0;

			var adTemp = [];
			var firstP = aTemp[0], lastP = aTemp[nn];
			var distGap = firstP[0] - lastP[0] + completeX;
			var gapThreshold = distThreshold * completeX / clustering.tw;

			if (distGap < gapThreshold) {
				for (i = 0; i < nn; ++i) {
					a = aTemp[i];
					b = aTemp[i + 1];
					ax = b[0] - a[0];

					if (ax > distGap) {
						iGap = i + 1;
						distGap = ax;
						if (distGap > gapThreshold) {
							break;
						}
					}
				}
			}
			VBI.Trace("iGap is " + iGap);
			var entities = aTemp.length;
			var lastEntity = iGap + entities;
			var lastIndex = -1, last;
			var zeroEdges = [];
			var x, y;
			for (i = iGap; i < lastEntity; ++i) {
				if (i >= entities) {
					j = i - entities;
					(aTemp[j])[0] += completeX;
				} else {
					j = i;
				}

				a = aTemp[j];
				a.bo = [
					a[0], a[1], a[0], a[1]
				];

				x = a[0];
				y = a[1];
				if (lastIndex != -1 && x === last[0] && y === last[1]) {
					zeroEdges.push({
						s: lastIndex,
						d: j,
						l: 0,
						z: 1,
						zero: true
					});
				} else {
					adTemp.push([
						x, y, j
					]);
					lastIndex = j;
					last = a;
				}
			}

			// do the Delaunay triangulation
			var temp = Delaunay.triangulate(adTemp);
			var triangles = temp[0];
			var virtualEdges = temp[1];
			if (triangles.length == 0) {
				triangles = cluster.AddEdgeChain(adTemp);
			}

			triangles.sort(function(a, b) { // sort by Length, source, Dest, -Virtual
				var diff = a.l - b.l;
				if (diff) {
					return diff;
				}
				diff = a.s - b.s;
				if (diff) {
					return diff;
				}
				diff = a.d - b.d;
				return diff ? diff : b.v - a.v;
			});

			var edges = zeroEdges.concat(triangles);
			var lodDist = (1 << ResultData.config.m_BaseLod);

			for (j = 0; j < aTemp.length; j++) {
				aTemp[j].nJ = j;
			}
			cluster.clcnt = aTemp.length;

			ResultData.config.m_0ref = cluster.buildTree(aTemp, nK, edges, voData, distThreshold, completeX);
			ResultData.config.m_ref = ResultData.config.m_0ref / lodDist;

			cluster.determineClusterPositions(aTemp.m_TreeFatherNode);

			cluster.assembleAreaInfo(aTemp, edges, virtualEdges);
			aTemp.m_edges = edges;
			return aTemp;
		};

		cluster.determineClusterPositions = function(node) {
			if (node.isCl) {
				var x = 0, y = 0, bw = node.bw, c;

				for (var i = bw.length; i--;) {
					c = cluster.determineClusterPositions(bw[i]);
					x += (c[0] * c[2]);
					y += (c[1] * c[2]);
				}
				node[0] = x / node.cnt;
				node[1] = y / node.cnt;
			}
			return [
				node[0], node[1], node.cnt
			];

		};

		cluster.AddVirtuals = function(node, index, virtuals) {
			var myNode = virtuals[index];
			if (myNode.executed == undefined) {
				var source = myNode.v0, dest;
				if (source) {
					for (var i = 0; i < myNode.length; ++i) {
						dest = myNode[i];
						node.e.push([
							[
								source.c[0], source.c[1]
							], [
								dest.c[0], dest.c[1]
							]
						]);
					}
				} else {
					source = myNode[0];
					dest = myNode[1];
					node.e.push([
						[
							source.c[0], source.c[1]
						], [
							dest.c[0], dest.c[1]
						]
					]);
				}
			}
		};

		cluster.AddEdge = function(node, e1, e2, virtuals, bSourceInCluster, bDestInCluster, eIndex) {
			if (!bSourceInCluster || !bDestInCluster) {
				// node.e.push( [ [ e1.c[0], e1.c[1] ], [ e2.c[0], e2.c[1] ] ] );
				node.e.push(eIndex);
			}

			if (e1.v) {
				if (bSourceInCluster) {
					cluster.AddVirtuals(node, e1.s, virtuals);
				}
				if (bDestInCluster) {
					cluster.AddVirtuals(node, e1.d, virtuals);
				}
			}
			return node.c;
		};

		cluster.MarkVirtuals = function(source, dest, virtuals) {
			virtuals[source].executed = true;
			virtuals[dest].executed = true;
		};

		cluster.assembleAreaInfo = function(nodes, edges, virtuals) {
			var e1, e2, n1, n2;
			var l = edges.length - 1;
			for (var i = 0; i <= l; ++i) {
				var bStopExec = false;
				e1 = edges[i];
				e2 = i < l ? edges[i + 1] : undefined;
				if (e1.l && e1.s >= 0 && e1.d >= 0) {
					n1 = nodes[e1.s];
					n2 = nodes[e1.d];
					if ((i < l) && (e1.s === e2.s) && (e1.d === e2.d)) { // inner edge, we connect the centers of the triangle circles
						while (n1 != undefined && bStopExec == false) {
							if (n1.lod < n2.lod) {
								n2 = cluster.AddEdge(n2, e1, e2, virtuals, false, true, i);
							} else if (n1.lod > n2.lod) {
								n1 = cluster.AddEdge(n1, e1, e2, virtuals, true, false, i);
							} else if (n1.nJ === n2.nJ) {
								if (e1.v) {
									n1 = cluster.AddEdge(n1, e1, e2, virtuals, true, true, i);
									n2 = n2.c;
								} else {
									bStopExec = true;
								}
							} else {
								n1 = cluster.AddEdge(n1, e1, e2, virtuals, true, false, i);
								n2 = cluster.AddEdge(n2, e1, e2, virtuals, false, true, i);
							}
						}
						i++; // skip second entity
					}
				}
				if (e1.v) {
					virtuals[e1.s].executed = true;
					virtuals[e1.d].executed = true;
				}
			}
		};

		cluster.recCheck = function(nodes, aNode1, eix1, eix1s, aNode2, eix2, eix2s, aboveLod, vo, edgeLod, log2ComplX, distThreshold, lvl) {
			var listBOs = [];
			var inserts = [
				0, 0
			];
			var eNode2 = aNode2[eix2];
			var bo1, bo2, i, elte;

			var res = cluster.analyzePath(listBOs, aNode1, eix1, eNode2, aboveLod, log2ComplX, distThreshold);
			if (res.nLod == aboveLod) {
				return inserts; // nothing to do here
			}

			var uNode1 = aNode1[res.i];

			if (res.nLod == res.oLod) {
				if (cluster.NodeMerge(res.nLod, aNode2, eix2, aNode1, res.i) && eix2) {
					inserts = cluster.recCheck(nodes, aNode1, res.i - 1, res.i - 1, aNode2, eix2 - 1, eix2 - 1, res.nLod, vo, edgeLod, log2ComplX, distThreshold, lvl + 1);
				}
			} else if (eNode2.lod > res.nLod) {
				cluster.Merge2NewNode(nodes, res.nLod, aNode1[res.i], eNode2, aNode1, res.i + 1, vo);
				inserts[1] = 1;
			} else {
				inserts = cluster.recCheck(nodes, aNode2, eix2, eix2s, aNode1, res.i, eix1s, eNode2.lod - 1, vo, edgeLod, log2ComplX, distThreshold, lvl + 1);
				if (listBOs.length > 1) {
					var rIndex = res.i + 1 + inserts[0];
					var rNode = aNode1[rIndex];
					var eix1PlusIns = eix1 + inserts[0];
					cluster.NodeMerge(rNode.lod, aNode2, eix2 + inserts[1], aNode1, rIndex);
					for (i = rIndex; i <= eix1s + inserts[0]; i++) {
						elte = aNode1[i];
						if (i < eix1PlusIns) {
							elte.bo = listBOs[eix1 + inserts[0] - i];
						} else {
							bo1 = elte.bo;
							bo2 = eNode2.bo;
							elte.bo = [
								Math.min(bo1[0], bo2[0]), Math.min(bo1[1], bo2[1]), Math.max(bo1[2], bo2[2]), Math.max(bo1[3], bo2[3])
							];
						}
						elte.cnt += (eNode2.cnt - uNode1.cnt);
					}
				}
				return [
					inserts[1], inserts[0]
				];
			}

			for (i = res.i; i <= eix1s; i++) {
				elte = aNode1[i + inserts[1]];
				elte.cnt += eNode2.cnt;
				if (i <= eix1) {
					elte.bo = listBOs[eix1 - i];
				} else {
					bo1 = elte.bo;
					bo2 = eNode2.bo;
					elte.bo = [
						Math.min(bo1[0], bo2[0]), Math.min(bo1[1], bo2[1]), Math.max(bo1[2], bo2[2]), Math.max(bo1[3], bo2[3])
					];
				}
			}

			return inserts;
		};

		cluster.buildTree = function(nodes, cI, edges, vo, distThreshold, completeX) {

			var dLog2 = 1 / Math.log(2);
			cluster.dLog2 = dLog2;
			var log2ComplX = dLog2 * Math.log(completeX / clustering.tw) + 4;
			var prev, bSwitchNodes, edgeLen, i;
			var eNode1, eNode2, e, eix1, eix2;
			for (e = 0; e < edges.length; ++e) {
				var entry = edges[e];
				if (prev && (entry.s == prev.s) && (entry.d == prev.d)) {
					continue; // virtual edge or same as edge before -> ignore
				}
				prev = entry;

				edgeLen = entry.l;

				var edgeLod = Math.floor(Math.min(24, dLog2 * Math.log(distThreshold / edgeLen) + log2ComplX));
				// var reference = distThreshold / Math.exp(-log2ComplX/dLog2);

				var aNode1 = [
					nodes[entry.s]
				];
				for (i = 0; aNode1[i].c != undefined; ++i) {
					aNode1[i + 1] = aNode1[i].c;
				}
				eNode1 = aNode1[i];

				var aNode2 = [
					nodes[entry.d]
				];
				for (i = 0; aNode2[i].c != undefined; ++i) {
					aNode2[i + 1] = aNode2[i].c;
				}
				eNode2 = aNode2[i];

// if (entry.v && aNode1[aNode1.length-1].nJ == aNode2[aNode2.length-1].nJ )
// continue; // do not connect sub levels over outer edges

				bSwitchNodes = false;
				if ((aNode1.length == 1) && (aNode2.length > 1)) { // to avoid one case we switch source and destination if source is atomic
					bSwitchNodes = true;
				} else if (aNode2.length > 1) {
					if ((eNode2.lod < eNode1.lod) || ((eNode2.lod == eNode1.lod) && (eNode2.cnt > eNode1.cnt))) {
						bSwitchNodes = true;
					}
				}

				eix1 = aNode1.length - 1;
				eix2 = aNode2.length - 1;
				var aboveLod = -1000;

				if (eNode1.nJ == eNode2.nJ) {
					do { // move upwards to the first difference which must exist
						aboveLod = eNode1.lod;
						eNode1 = aNode1[--eix1];
						eNode2 = aNode2[--eix2];
					} while (eNode1.nJ == eNode2.nJ);
				}

				if (bSwitchNodes) {
					cluster.recCheck(nodes, aNode2, eix2, eix2, aNode1, eix1, eix1, aboveLod, vo, edgeLod, log2ComplX, distThreshold, 0);
				} else {
					cluster.recCheck(nodes, aNode1, eix1, eix1, aNode2, eix2, eix2, aboveLod, vo, edgeLod, log2ComplX, distThreshold, 0);
				}
				// cluster.CheckNodeConsistency(undefined,aNode1,aNode2, log2ComplX, distThreshold);
			}

			if (nodes.length) {
				var fatherNode = nodes[0];
				while (fatherNode.c != undefined) {
					fatherNode = fatherNode.c;
				}
				fatherNode.cI = cI;
				nodes.m_TreeFatherNode = fatherNode;
			}

			return distThreshold / (2 * Math.exp(-log2ComplX / dLog2)); // return length reference
		};

		cluster.Merge2NewNode = function(nodes, lod, uNode, eNode, aNode, ii, vo) {
			var uNodeNext = uNode.c;
			var eNodeNext = eNode.c;

			var newNode = {
				lod: lod,
				nJ: cluster.clcnt++,
				isCl: 4,
				cnt: uNode.cnt,
				e: [],
				h: false,
				hscale: vo.m_hotscale,
				hcol: vo.m_hotcol,
				s: false,
				im: vo.m_image,
				sc: vo.m_scale,
				f: cluster.m_textfont,
				fc: cluster.m_textcolor,
				fs: cluster.m_textfontscale,
				fz: cluster.m_textfontsize,
				fo: cluster.m_textoffset,
				foy: cluster.m_textoffsetY,
				al: vo.m_alignment,
				grI: 1
			};
			newNode.bw = [
				uNode, eNode
			];
			uNode.c = newNode;
			eNode.c = newNode;
			aNode.splice(ii, 0, newNode);
			if (uNodeNext != undefined) {
				newNode.c = uNodeNext;
				cluster.ReplaceBWE(uNodeNext.bw, uNode.nJ, newNode);
			}
			if (eNodeNext != undefined) {
				cluster.RemoveBWE(eNodeNext.bw, eNode.nJ);
			}

			nodes.push(newNode);

			return newNode;
		};

		cluster.NodeMerge = function(nLod, list1, i1, list2, i2) {
			var retVal = false;
			var newParent = list2[i2];
			var newSon = list1[i1];
			var oldParent = newSon.c;
			if (nLod < newSon.lod) {
				newParent.bw.push(newSon);
				newSon.c = newParent;
			} else {
				var bwNode;
				for (var i = newSon.bw.length; i--;) {
					bwNode = newSon.bw[i];
					bwNode.c = newParent;
					newParent.bw.push(bwNode);
					newSon.bw[i] = undefined;
				}
				newSon.bInvalid = true;
				retVal = true;
			}
			if (oldParent != undefined) {
				cluster.RemoveBWE(oldParent.bw, newSon.nJ);
			}
			return retVal;
		};

		cluster.ReplaceBWE = function(myList, oldEntry, entry) {
			for (var i = myList.length; i--;) {
				if (myList[i].nJ == oldEntry) {
					if (entry == -1) {
						myList.splice(i, 1);
					} else {
						myList[i] = entry;
					}
				}
			}
		};

		cluster.RemoveBWE = function(myList, oldEntry) {
			for (var i = myList.length; i--;) {
				if (myList[i].nJ == oldEntry) {
					myList.splice(i, 1);
				}
			}
		};

// cluster.CheckNodeConsistency = function(newNode, aNode1, aNode2, log2ComplX, distThreshold)
// {
// // cluster.CheckConsistency(newNode, log2ComplX, distThreshold);
// for (var j=0; j< aNode1.length;++j)
// cluster.CheckConsistency(aNode1[j], log2ComplX, distThreshold);
// for (var j=0; j< aNode2.length;++j)
// cluster.CheckConsistency(aNode2[j], log2ComplX, distThreshold);
// };
//      
// cluster.CheckConsistency = function ( node, log2ComplX, distThreshold )
// {
// if ((node == -1)||(node.bw==undefined)||(node.bInvalid)||!node.bCluster) return;
// var cnt = 0;
// for (var i = 0; i < node.bw.length; ++i)
// if ( node.bInvalid != true )
// cnt += node.bw[i].cnt;
// if (node.cnt != cnt)
// VBI.Trace("Count Inconsistency found ");
//         
// var bo = node.bo;
// if (bo == undefined ){
// VBI.Trace("bo undefined issue");
// return;
// }
// // var myLen = bo[2] - bo[0] + bo[3] - bo[1];
// var myLen = Math.max(bo[2] - bo[0], bo[3] - bo[1] );
// // var myLod = Math.floor(Math.min(22, cluster.dLog2 * Math.log(distThreshold / myLen) + log2ComplX));
// var myLod = Math.floor(Math.min(22, cluster.dLog2 * Math.log( distThreshold / myLen) + log2ComplX));
//
// if (myLod != node.lod){
// VBI.Trace("["+bo[0]+","+bo[1]+","+bo[2]+","+bo[3]+"] evaluates to Len="+myLen+" with Dist="+distThreshold+" and logFactor="+log2ComplX);
// VBI.Trace("LOD Inconsistency found, expected LOD: "+myLod+", actual LOD: "+node.lod+" BO:["+bo[0]+","+bo[1]+","+bo[2]+","+bo[3]+"]");
// }
// };

		cluster.analyzePath = function(BOs, nodeChain, index, eNode2, aboveLod, log2ComplX, distThreshold) {
			var eNode1 = nodeChain[index];
			var bo1 = eNode1.bo, bo2 = eNode2.bo;
			var newBO = [
				Math.min(bo1[0], bo2[0]), Math.min(bo1[1], bo2[1]), Math.max(bo1[2], bo2[2]), Math.max(bo1[3], bo2[3])
			];

			// var myLod = edgeLod;
			var myLen = Math.max(newBO[2] - newBO[0], newBO[3] - newBO[1]);
			var myLod = Math.floor(Math.min(24, cluster.dLog2 * Math.log(distThreshold / myLen) + log2ComplX));

			if (myLod <= aboveLod) {
				return {
					i: index + 1,
					nLod: aboveLod,
					oLod: aboveLod
				};
			}

			BOs.push(newBO);
			if (index == 0 || myLod < eNode1.lod) {
				return {
					i: index,
					nLod: myLod,
					oLod: eNode1.lod
				};
			}
			return cluster.analyzePath(BOs, nodeChain, index - 1, eNode2, myLod, log2ComplX, distThreshold);
		};

		cluster.fillClusterConfig = function(myResult, baseConfig, minLOD, bAnimationAllowed) {
			var elte = {};
			elte.bCol = cluster.m_bordercol;
			elte.bSize = Math.abs(cluster.m_bordersize);
			if (cluster.m_bordersize < 0) {
				elte.b2Times = true;
			}
			elte.fCol = cluster.m_fillcol;
			elte.permArea = cluster.m_permanentArea;
			if (cluster.m_bordercol2) {
				elte.bCol2 = cluster.m_bordercol2;
			}
			if (cluster.m_bordercol3) {
				elte.bCol3 = cluster.m_bordercol3;
			}
			if (cluster.m_fillcol2) {
				elte.fCol2 = cluster.m_fillcol2;
			}
			if (cluster.m_fillcol3) {
				elte.fCol3 = cluster.m_fillcol3;
			}
			elte.sCol = cluster.m_spotcol;
			elte.sSize = cluster.m_spotsize;
			elte.anim = (!bAnimationAllowed) ? undefined : cluster.m_animated;
			elte.animLow = Math.ceil(minLOD);
			elte.baseConf = baseConfig;

			myResult.config = elte;
			return ((elte.bCol != undefined) || (elte.sCol && elte.sSize));
		};

		cluster.fillDistConfig = function(myResult, baseConfig, ResultData) {
			var elte = {};
			elte.baseConf = baseConfig;
			myResult.config = elte;
			if ((cluster.m_spotsize != undefined) && (cluster.m_spotsize != 0) && (cluster.m_spotcol != undefined)) {
				elte.sCol = cluster.m_spotcol;
				elte.sSize = cluster.m_spotsize;
				elte.base = ResultData.base;
				return true;
			}

			return false;
		};

		cluster.treeFillClusterData = function(scene, treeClusters, ResultData, voData, nJ, minLOD) {
			ResultData.clust[nJ] = treeClusters;
			ResultData.clust[nJ].hotItem = ResultData.hotItem;
			ResultData.clust[nJ].cI = nJ;
			ResultData.clust[nJ].m_lodOffset = 1;
			ResultData.clust[nJ].m_nRecalcs = 0;
			ResultData.base[voData.m_index].clusterings.push({
				i: nJ,
				t: 2
			});
			ResultData.config.bNeedsShadowLayer = cluster.fillClusterConfig(ResultData.clust[nJ], ResultData.config, minLOD, true) || ResultData.config.bNeedsShadowLayer;

			return true;
		};

		return cluster;
	};

	Delaunay = {

		supertriangle: function(vertices) {
			var xmin = Number.POSITIVE_INFINITY, ymin = Number.POSITIVE_INFINITY, xmax = Number.NEGATIVE_INFINITY, ymax = Number.NEGATIVE_INFINITY, i, dx, dy, dmax, xmid, ymid;

			for (i = vertices.length; i--;) {
				if (vertices[i][0] < xmin) {
					xmin = vertices[i][0];
				}
				if (vertices[i][0] > xmax) {
					xmax = vertices[i][0];
				}
				if (vertices[i][1] < ymin) {
					ymin = vertices[i][1];
				}
				if (vertices[i][1] > ymax) {
					ymax = vertices[i][1];
				}
			}

			dx = xmax - xmin;
			dy = ymax - ymin;
			dmax = Math.max(dx, dy);
			xmid = xmin + dx * 0.5;
			ymid = ymin + dy * 0.5;

			return [
				[
					xmid - 40 * dmax, ymid - dmax, -1
				], [
					xmid, ymid + 40 * dmax, -2
				], [
					xmid + 40 * dmax, ymid - dmax, -3
				]
			];
		},

		circumcircle: function(vertices, i, j, k) {
			var x1 = vertices[i][0], y1 = vertices[i][1], x2 = vertices[j][0], y2 = vertices[j][1], x3 = vertices[k][0], y3 = vertices[k][1], fabsy1y2 = Math.abs(y1 - y2), fabsy2y3 = Math.abs(y2 - y3), xc, yc, m1, m2, mx1, mx2, my1, my2, dx, dy;

// // Check for coincident points
// if(fabsy1y2 < EPSILON && fabsy2y3 < EPSILON)
// throw new Error("Eek! Coincident points!");

			if (fabsy1y2 < EPSILON) {
				m2 = -((x3 - x2) / (y3 - y2));
				mx2 = (x2 + x3) / 2.0;
				my2 = (y2 + y3) / 2.0;
				xc = (x2 + x1) / 2.0;
				yc = m2 * (xc - mx2) + my2;
			} else if (fabsy2y3 < EPSILON) {
				m1 = -((x2 - x1) / (y2 - y1));
				mx1 = (x1 + x2) / 2.0;
				my1 = (y1 + y2) / 2.0;
				xc = (x3 + x2) / 2.0;
				yc = m1 * (xc - mx1) + my1;
			} else {
				m1 = -((x2 - x1) / (y2 - y1));
				m2 = -((x3 - x2) / (y3 - y2));
				mx1 = (x1 + x2) / 2.0;
				mx2 = (x2 + x3) / 2.0;
				my1 = (y1 + y2) / 2.0;
				my2 = (y2 + y3) / 2.0;
				xc = (m1 * mx1 - m2 * mx2 + my2 - my1) / (m1 - m2);
				yc = (fabsy1y2 > fabsy2y3) ? m1 * (xc - mx1) + my1 : m2 * (xc - mx2) + my2;
			}

			dx = x2 - xc;
			dy = y2 - yc;
			return {
				i: i,
				j: j,
				k: k,
				x: xc,
				y: yc,
				r: dx * dx + dy * dy
			};
		},

		dedup: function(edges) {
			var i, j, a, b, m, n;

			for (j = edges.length; j;) {
				b = edges[--j];
				a = edges[--j];

				for (i = j; i;) {
					n = edges[--i];
					m = edges[--i];

					if ((a === m && b === n) || (a === n && b === m)) {
						edges.splice(j, 2);
						edges.splice(i, 2);
						break;
					}
				}
			}
		},

		assemble: function(open, closed, virtuals, vertices, n) {
			open.length = 0;
			var i;

			for (i = closed.length; i--;) {
				var numVirtual = (closed[i].i >= n) + (closed[i].j >= n) + (closed[i].k >= n);
				// var bVirtual = (closed[i].i >= n || closed[i].j >= n || closed[i].k >= n);
				var nodes = [
					closed[i].i, closed[i].j, closed[i].k
				];
				nodes.sort();
				var vi = vertices[nodes[0]], vj = vertices[nodes[1]], vk = vertices[nodes[2]];
				var ds1 = Math.max(Math.abs(vi[0] - vj[0]), Math.abs(vi[1] - vj[1]));
				var ds2 = Math.max(Math.abs(vi[0] - vk[0]), Math.abs(vi[1] - vk[1]));
				var ds3 = Math.max(Math.abs(vk[0] - vj[0]), Math.abs(vk[1] - vj[1]));
				var c = [
					closed[i].x, closed[i].y
				];
				// var c = [ ( vi[0]+vj[0]+vk[0] ) / 3, ( vi[1]+vj[1]+vk[1] ) / 3 ]
				var v0 = (vertices[nodes[0]])[2], v1 = (vertices[nodes[1]])[2], v2 = (vertices[nodes[2]])[2];

				if (v0 >= 0 && v1 >= 0) {
					open.push({
						s: v0,
						d: v1,
						l: ds1,
						c: c,
						v: numVirtual
					});
				}

				if (v0 >= 0 && v2 >= 0) {
					open.push({
						s: v0,
						d: v2,
						l: ds2,
						c: c,
						v: numVirtual
					});
				}

				if (v1 >= 0 && v2 >= 0) {
					open.push({
						s: v1,
						d: v2,
						l: ds3,
						c: c,
						v: numVirtual
					});
				}

				if (numVirtual) {
					if (v0 >= 0) {
						this.addToVirtual(virtuals, v0, v1, v2, c, numVirtual);
					}
					if (v1 >= 0) {
						this.addToVirtual(virtuals, v1, v0, v2, c, numVirtual);
					}
					if (v2 >= 0) {
						this.addToVirtual(virtuals, v2, v0, v1, c, numVirtual);
					}
				}

			}

			return open;
		},

		triangulate: function(vertices, key) {
			var n = vertices.length, i, j, indices, st, open, closed, edges, virtuals, dx, dy, a, b, c;

			// check if there are enough vertices to form any triangles
			if (n < 1) {
				return [];
			}

			// Slice out the actual vertices from the passed objects.
			// (Duplicate the array even if we don't, though, since we need to make a supertriangle later on!)
			vertices = vertices.slice(0);

			if (key) {
				for (i = n; i--;) {
					vertices[i] = vertices[i][key];
				}
			}

			// Make an array of indices into the vertex array, sorted by the vertices' x-position
			indices = new Array(n);

			for (i = n; i--;) {
				indices[i] = i;
			}

			indices.sort(function(i, j) {
				return vertices[j][0] - vertices[i][0];
			});

			// Next, find the vertices of the supertriangle (which contains all other triangles),
			// and append them onto the end of a (copy of) the vertex array
			st = this.supertriangle(vertices);
			vertices.push(st[0], st[1], st[2]);

			// Initialize the open list (containing the supertriangle and nothing else)
			// and the closed list (which is empty since we haven't processed any triangles yet)
			open = [
				this.circumcircle(vertices, n + 0, n + 1, n + 2)
			];
			closed = [];
			edges = [];
			virtuals = [];

			// Incrementally add each vertex to the mesh
			for (i = indices.length; i--; edges.length = 0) {
				c = indices[i];

				// For each open triangle, check to see if the current point is
				// inside it's circumcircle. If it is, remove the triangle and add
				// it's edges to an edge list
				for (j = open.length; j--;) {
					// If this point is to the right of this triangle's circumcircle,
					// then this triangle should never get checked again. Remove it
					// from the open list, add it to the closed list, and skip
					dx = vertices[c][0] - open[j].x;
					if (dx > 0.0 && dx * dx > open[j].r) {
						closed.push(open[j]);
						open.splice(j, 1);
						continue;
					}

					// If we're outside the circumcircle, skip this triangle
					dy = vertices[c][1] - open[j].y;
					if (dx * dx + dy * dy - open[j].r > EPSILON) {
						continue;
					}

					// Remove the triangle and add it's edges to the edge list
					edges.push(open[j].i, open[j].j, open[j].j, open[j].k, open[j].k, open[j].i);
					open.splice(j, 1);
				}

				// Remove any doubled edges
				this.dedup(edges);

				// Add a new triangle for each edge
				for (j = edges.length; j;) {
					b = edges[--j];
					a = edges[--j];
					open.push(this.circumcircle(vertices, a, b, c));
				}
			}

			// Copy any remaining open triangles to the closed list, and then
			// remove any triangles that share a vertex with the supertriangle,
			// building a list of triplets that represent triangles
			for (i = open.length; i--;) {
				closed.push(open[i]);
			}

			open = this.assemble(open, closed, virtuals, vertices, n);

			return [
				open, virtuals
			// , st
			];
		},

		addToVirtual: function(virtuals, v0, v1, v2, c, numVirtual) {
			var elte = {
				n1: v1,
				n2: v2,
				c: c,
				v: numVirtual
			};
			if (virtuals[v0] == undefined) {
				virtuals[v0] = [];
			}

			if (v1 < 0 && v2 < 0) {
				virtuals[v0].v0 = elte;
			} else {
				virtuals[v0].push(elte);
			}
		},

		contains: function(tri, p) {
			// Bounding box test first, for quick rejections
			if ((p[0] < tri[0][0] && p[0] < tri[1][0] && p[0] < tri[2][0]) || (p[0] > tri[0][0] && p[0] > tri[1][0] && p[0] > tri[2][0]) || (p[1] < tri[0][1] && p[1] < tri[1][1] && p[1] < tri[2][1]) || (p[1] > tri[0][1] && p[1] > tri[1][1] && p[1] > tri[2][1])) {
				return null;
			}

			var a = tri[1][0] - tri[0][0], b = tri[2][0] - tri[0][0], c = tri[1][1] - tri[0][1], d = tri[2][1] - tri[0][1], i = a * d - b * c;

			// Degenerate triangle
			if (i === 0.0) {
				return null;
			}
			var u = (d * (p[0] - tri[0][0]) - b * (p[1] - tri[0][1])) / i, v = (a * (p[1] - tri[0][1]) - c * (p[0] - tri[0][0])) / i;

			// check if we are outside the triangle
			if (u < 0.0 || v < 0.0 || (u + v) > 1.0) {
				return null;
			}
			return [
				u, v
			];
		}
	};

	return clustering;
};
﻿// ...........................................................................//
// this module does the vbicontext handling..................................//

// Author: Ulrich Roegelein

// ...........................................................................//
// the scene manager manages the scene instances in a component context......//

VBI.VBIContext = function(control) {
	"use strict";
	/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
	var vbcx = {};
	vbcx.vbiclass = "VBIContext";

	vbcx.m_bLoaded = false;
	vbcx.m_Resources = null;
	vbcx.m_Config = null;
	vbcx.m_DataTypeProvider = null;
	vbcx.m_DataProvider = null;
	vbcx.m_SceneManager = null;
	vbcx.m_MapProviders = null;
	vbcx.m_MapLayerStackManager = null;
	vbcx.m_Windows = null;
	vbcx.m_Actions = null;
	vbcx.m_Automations = null;
	vbcx.m_Menus = null;
	vbcx.m_Control = control;
	vbcx.m_deltacolTable = [];

	var now = new Date();
	vbcx.m_StartupTime = now.getTime();

	vbcx.clear = function() {
		// clear inner objects.................................................//
		if (vbcx.m_Resources) {
			vbcx.m_Resources.clear();
		}
		if (vbcx.m_Config) {
			vbcx.m_Config.clear();
		}
		if (vbcx.m_DataTypeProvider) {
			vbcx.m_DataTypeProvider.clear();
		}
		if (vbcx.m_DataProvider) {
			vbcx.m_DataProvider.clear();
		}
		if (vbcx.m_SceneManager) {
			vbcx.m_SceneManager.clear();
		}
		if (vbcx.m_MapProviders) {
			vbcx.m_MapProviders.clear();
		}
		if (vbcx.m_MapLayerStackManager) {
			vbcx.m_MapLayerStackManager.clear();
		}
		if (vbcx.m_Windows) {
			vbcx.m_Windows.clear();
		}
		if (vbcx.m_Actions) {
			vbcx.m_Actions.clear();
		}
		if (vbcx.m_Automations) {
			vbcx.m_Automations.clear();
		}
		if (vbcx.m_Menus) {
			vbcx.m_Menus.clear();
		}

		// reset back reference................................................//
		vbcx.m_Control = null;

		// zutun: reset inner references........................................//
		vbcx.m_Resources = null;
		vbcx.m_Config = null;
		vbcx.m_DataTypeProvider = null;
		vbcx.m_DataProvider = null;
		vbcx.m_SceneManager = null;
		vbcx.m_MapProviders = null;
		vbcx.m_MapLayerStackManager = null;
		vbcx.m_Windows = null;
		vbcx.m_Actions = null;
		vbcx.m_Automations = null;
		vbcx.m_Menus = null;
	};

	// helper functions.......................................................//
	vbcx.GetResources = function() {
		if (!vbcx.m_Resources) {
			vbcx.m_Resources = new VBI.Resources();
		}
		return (vbcx.m_Resources);
	};

	vbcx.GetConfig = function() {
		if (!vbcx.m_Config) {
			vbcx.m_Config = new VBI.Configurations();
		}
		return (vbcx.m_Config);
	};

	vbcx.GetMainScene = function() {
		// the main scene is the one that is displayed in the main window......//
		if (vbcx.m_Windows) {
			var wnd = vbcx.m_Windows.GetMainWindow();
			if (wnd) {
				var scene = wnd.GetScene();
				if (scene) {
					return scene;
				}
			}
		}

		return null; // no scene available...................................//
	};

	vbcx.FireAction = function(action, scene, vo, de, params, instanceDirect, allowPreventDefault) {
		// fire the submit data................................................//
		// zutun: create the xml or json dependent, on the subscription.........//
		// and fire the submit event, providing a valid json/xml string........//

		// the vo can be a string or an object.................................//
		// usually when the event is fired by the map, a string is specified...//
		var id = null;
		if (jQuery.type(vo) == 'object') {
			id = vo.m_ID;
		} else if (jQuery.type(vo) == 'string') {
			id = vo;
		}

		// create a new json object and fill it with data......................//

		var o = {};
		var oRoot = (o["SAPVB"] = {});
		oRoot["version"] = "2.0";
		oRoot["xmlns:VB"] = "VB";

		// store action........................................................//
		var oAction = (oRoot["Action"] = {});
		oAction.name = action.m_name; // name of action
		oAction.object = id; // id of the vo
		oAction.id = action.m_id; // id of the action

		// add the instance information to the event...........................//
		if (instanceDirect != undefined) {
			oAction.instance = instanceDirect;
		} else if (de) {
			oAction.instance = de.GetPath();
		}
		// event coordinates...................................................//
		// these are needed for the additional properties......................//
		var x = 0.0;
		var y = 0.0;
		var bMousePosAvailable = false;

		// add the parameters..................................................//
		if (params) {
			oAction.Params = {};
			oAction.Params.Param = [];

			// add the attributes and put them into an array....................//
			for ( var a in params) {
				var tmp = {};
				tmp["name"] = a;
				tmp["#"] = params[a];
				oAction.Params.Param.push(tmp);

				// get the coordinates from the parameters.......................//
				if (a == 'x') {
					x = params[a];
					bMousePosAvailable = true;
				}
				if (a == 'y') {
					y = params[a];
					bMousePosAvailable = true;
				}
			}
		}

		if (vo == "Thumbnail") {
			x *= (scene.GetInternalDivWidth() / scene.m_Div.clientWidth);
			y *= (scene.GetInternalDivHeight() / scene.m_Div.clientHeight);
		}

		// add modified datacontext data.......................................//
		if (vbcx.m_DataProvider) {
			vbcx.m_DataProvider.store(oRoot);
		}

		// add additional properties, this is done to be compatible to the c++.//
		// implementation......................................................//

		var len;
		if (action.m_additionalProperties && (len = action.m_additionalProperties.length)) {
			var apo = oAction.AddActionProperties = {}; // action properties object
			var apa = apo.AddActionProperty = []; // action property array

			for (var nJ = 0; nJ < len; ++nJ) {
				var pos, bws;
				switch (action.m_additionalProperties[nJ]) {
					case 'zoom':
						// add the current zoom level..............................//
						apa.push({
							name: 'zoom',
							'#': scene.GetCurrentZoomlevel().toString()
						});
						break;
					case 'centerpoint':
						// add the center position.................................//
						pos = VBI.MathLib.RadToDeg(scene.GetCenterPos());
						apa.push({
							name: 'centerpoint',
							'#': pos[0].toString() + ';' + pos[1].toString() + ';0.0'
						});
						break;
					case 'vos':
						// add the count of objects inside the cluster............//
						apa.push({
							name: 'vos',
							'#': de.cnt
						});
						break;
					case 'subclusters':
						// add the count of objects inside the cluster............//
						bws = (de.isCl == 4 && de.bw != undefined ? de.bw.length : -1);
						apa.push({
							name: 'subclusters',
							'#': bws
						});
						break;
					case 'clustersnextlod':
						if (de.isCl == 4 && de.bw != undefined) {
							bws = (scene.GetCurrentZoomlevel() == de.lod ? de.bw.length : 1);
						} else {
							bws = -1;
						}
						apa.push({
							name: 'clustersnextlod',
							'#': bws
						});
						break;
					case 'clusterarea':
						var bb = "";
						if (de.isCl == 4 && de.bo != undefined) {
							bb = this.m_Clustering.getClusterArea(scene, de);
						}
						apa.push({
							name: 'clusterarea',
							'#': bb
						});
						break;
					case 'pos':
						// add the current click position..........................//
						if (bMousePosAvailable) {
							pos = scene.GetPosFromVPPoint([
								x, y, 0
							]);
							apa.push({
								name: 'pos',
								'#': pos[0].toString() + ';' + pos[1].toString() + ';0.0'
							});
						}
						break;
					case 'pitch':
						// pitch is always 0 in flat scenes........................//
						apa.push({
							name: 'pitch',
							'#': '0.0'
						});
						break;
					case 'yaw':
						// yaw is always 0 in flat scenes..........................//
						apa.push({
							name: 'yaw',
							'#': '0.0'
						});
						break;
					default:
						break;
				}
			}
		}
		// convert to a json string............................................//
		var txt = JSON.stringify(oRoot, null, '  ');

		// raise the submit....................................................//
		if (vbcx.m_Control) {
			if (allowPreventDefault) {
				return vbcx.m_Control.fireEvent("submit", {data: txt}, true);
			}
			vbcx.m_Control.fireSubmit({data: txt});
		}
	};

	// ........................................................................//
	// low level event delegates..............................................//

	vbcx.onRenderLayer = function(canvas) {
		// this function is called when the overlay canvas can be rendered by..//
		// the application.....................................................//
		vbcx.m_Control.fireRender({
			canvas: canvas
		});
	};

	vbcx.onMoveLayer = function(canvas) {
		// this function is called when the overlay canvas is moved............//
		vbcx.m_Control.fireMove({
			canvas: canvas
		});
	};

	vbcx.onZoomLayer = function(canvas) {
		// this function is called when the overlay canvas is zoomed...........//
		vbcx.m_Control.fireZoom({
			canvas: canvas
		});
	};

	vbcx.onOpenWindow = function(id, div) {
		// this function is called when a new window is opened.................//
		vbcx.m_Control.fireOpenWindow({
			id: id,
			contentarea: div
		});
	};

	vbcx.onCloseWindow = function(id, div) {
		// this function is called when a window is closed.................//
		vbcx.m_Control.fireCloseWindow({
			id: id,
			contentarea: div
		});
	};
	
	vbcx.onOpenContainer = function(id, div) {
		// this function is called when a new container is opened.................//
		vbcx.m_Control.fireContainerCreated({
			id: id,
			contentarea: div
		});
	};

	vbcx.onCloseContainer = function(id, div) {
		// this function is called when a container is closed.................//
		vbcx.m_Control.fireContainerDestroyed({
			id: id,
			contentarea: div
		});
	};	

	vbcx.onChangeTrackingMode = function(mode, bSet) {
		// this function is called when a tracking mode has changed .................//
		vbcx.m_Control.fireChangeTrackingMode({
			mode: mode,
			bSet: bSet
		});
	};

	vbcx.DoMinimize = function(scene) {
		var thumbObj = vbcx.moThumbnail;
		var ctrl = this.m_Control;

		var bSizeNotChanged;
		if (!thumbObj.bThumbnailed) {
			thumbObj.strOrgWidth = this.m_Control.getWidth();
			thumbObj.strOrgHeight = this.m_Control.getHeight();
			thumbObj.nOrgWidth = thumbObj.nFullWidth ? thumbObj.nFullWidth : scene.m_nDivWidth;
			thumbObj.nOrgHeight = thumbObj.nFullHeight ? thumbObj.nFullHeight : scene.m_nDivHeight;
			thumbObj.bThumbnailed = true;
			bSizeNotChanged = ((thumbObj.nThumbWidth === scene.m_nDivWidth) && (thumbObj.nThumbHeight === scene.m_nDivHeight));
		} else {
			bSizeNotChanged = ((thumbObj.nThumbWidth === parseInt(ctrl.getWidth(), 10)) && (thumbObj.nThumbHeight === parseInt(ctrl.getHeight(), 10)));
			if (thumbObj.nFullWidth && thumbObj.nOrgWidth != thumbObj.nFullWidth) {
				thumbObj.nOrgWidth = thumbObj.nFullWidth;
				bSizeNotChanged = true;
			}
			if (thumbObj.nFullHeight && thumbObj.nOrgHeight != thumbObj.nFullHeight) {
				thumbObj.nOrgHeight = thumbObj.nFullHeight;
				bSizeNotChanged = true;
			}
		}

		if (thumbObj.nThumbWidth <= 0 && thumbObj.nOrgHeight > 0) {
			thumbObj.nThumbWidth = thumbObj.nOrgWidth / thumbObj.nOrgHeight * thumbObj.nThumbHeight;
		}

		if (thumbObj.nThumbHeight <= 0 && thumbObj.nOrgWidth > 0) {
			thumbObj.nThumbHeight = thumbObj.nOrgHeight / thumbObj.nOrgWidth * thumbObj.nThumbWidth;
		}

		ctrl.setWidth(thumbObj.nThumbWidth);
		ctrl.setHeight(thumbObj.nThumbHeight);

		if (bSizeNotChanged) {
			scene.resizeCanvas(0);
		} // otherwise ResizeHandler will trigger resize process
	};

	return vbcx;
};
// ...........................................................................//
// Menus namespace.........................................................//

// Author: Juergen Gatter

// ...........................................................................//
// helper functions..........................................................//

// ...........................................................................//
// menus provider..........................................................//
// ...........................................................................//

VBI.Menus = function() {
	"use strict";
	/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
	var menus = {};
	menus.m_menus = []; // array of menus
	menus.m_menucnt = 0;

	menus.clear = function() {
		for (var nJ = menus.m_menus.length - 1; nJ >= 0; --nJ) {
			menus.m_menus[nJ].destroy();
			menus.m_menus.pop();
		}

		menus.m_menus = [];
	};

	menus.loadMainMenu = function(dat, ctx) {
		var oMenuObject = new sap.ui.unified.Menu("vbimenu_i" + menus.m_menucnt);
		menus.loadMenu(oMenuObject, dat, ctx, "i" + menus.m_menucnt);
		menus.m_menucnt++;
		oMenuObject.vbi_data = {};
		oMenuObject.vbi_data.menuRef = dat.id;
		oMenuObject.vbi_data.VBIName = dat.name;

		oMenuObject.attachItemSelect(function(e) {
			var retval = {};
			retval.refid = e.mParameters.item.vbi_data.refid;
			retval.menu = oMenuObject;
			menus.OnSelected(retval);
		});
		menus.m_menus.push(oMenuObject);

		return oMenuObject;
	};

	menus.loadMenu = function(oMenu, dat, ctx, id) {
		var isObj = jQuery.type(dat.MenuItem) == 'object';
		var arrLength = (isObj ? 1 : dat.MenuItem.length);
		for (var ii = 0; ii < arrLength; ++ii) {
			var subdat = (isObj ? dat.MenuItem : dat.MenuItem[ii]);
			if (subdat.active == "false") {
				continue;
			}
			var subid;
			subid = id + "_" + ii;
			var sText = subdat.Separator == undefined ? subdat.text : "---------------------------";
			var oMenuItem = new sap.ui.unified.MenuItem("vbimi_" + subid, {
				text: sText
			});
			oMenuItem.vbi_data = {};
			if ((subdat.disabled == "true") || (subdat.Separator != undefined)) {
				oMenuItem.setEnabled(false);
			}
			oMenu.addItem(oMenuItem);
			if (subdat.icon) {
				oMenuItem.setIcon(subdat.icon);
			}
			if (VBI.m_bTrace) {
				VBI.Trace("Adding Menuitem: menuitem_" + subid + " with text " + sText);
			}
			if (subdat.MenuItem != undefined) {
				var oSubMenu = new sap.ui.unified.Menu("vbim_" + subid);
				oSubMenu.setAriaDescription("Menu " + subid);
				oMenuItem.setSubmenu(oSubMenu);
				menus.loadMenu(oSubMenu, subdat, ctx, subid);
			} else if (subdat.id != "") {
				oMenuItem.vbi_data.refid = subdat.id;
			}
		}
	};

	menus.deleteMenu = function(menuName) {
		var idx = menus.findMenuIdxByName(menuName);
		if (idx >= 0) {
			var lastIdx = menus.m_menus.length - 1;
			menus.m_menus[idx].destroy();
			if (idx != lastIdx) {
				menus.m_menus[idx] = menus.m_menus[lastIdx];
			}
			menus.m_menus.pop();
			return idx;
		}
		return -1;
	};

	menus.getMainScene = function(ctx) { // in case there is anyway only one scene we use this scene
		if (ctx.m_SceneManager.m_SceneArray.length == 1) {
			return ctx.m_SceneManager.m_SceneArray[0].m_ID;
		}
		return undefined;
	};

	menus.load = function(dat, ctx) {
		// lazy load sap.ui.unified library for using the Menu
		sap.ui.getCore().loadLibrary("sap.ui.unified");
		
		menus.m_context = ctx;

		// load the json delta data............................................//
		if (dat.Set) {
			if (dat.Set.name != undefined) {
				menus.deleteMenu(dat.Set.name);
			} else {
				menus.clear();
			}

			if (jQuery.type(dat.Set) == 'object') {
				if (dat.Set.Menu) {
					menus.loadMainMenu(dat.Set.Menu, ctx);
				}
			} else if (jQuery.type(dat.Set) == 'array') {
				// load an array of menus
				for (var nJ = 0; nJ < dat.Set.length; ++nJ) {
					if (dat.Set[nJ].Menu) {
						menus.loadMainMenu(dat.Set[nJ].Menu, ctx);
					}
				}
			}
		}
	};

	menus.findMenuByID = function(menuID) {
		if (menus.m_menus) {
			for (var ii = 0; ii < menus.m_menus.length; ++ii) {
				if (menus.m_menus[ii].vbi_data.menuRef == menuID) {
					return menus.m_menus[ii];
				}
			}
		}

		return null;
	};

	menus.findMenuIdxByName = function(menuName) {
		if (menus.m_menus) {
			for (var ii = 0; ii < menus.m_menus.length; ++ii) {
				if (menus.m_menus[ii].vbi_data.VBIName == menuName) {
					return ii;
				}
			}
		}

		return -1;
	};

	menus.OnSelected = function(retval) {
		var refObj = retval.menu.vbi_data.object;
		if (retval.refid == undefined) {
			return;
		}
		var scene = menus.m_context.m_SceneManager.GetSceneByName(retval.menu.vbi_data.scene);
		var actions = menus.m_context.m_Actions;
		if (actions) {
			if (actions.findAction("ContextMenu", scene, refObj)) {
				var action = new VBI.Actions.Action();
				action.m_name = "FCODE_SELECT";
				action.m_id = retval.refid;
				scene.m_Ctx.FireAction(action, scene, refObj, null, null, retval.menu.vbi_data.instance);
			}
		}
	};

	return menus;
};
// ...........................................................................//
// VisualObjects namespace...................................................//

// Author: Ulrich Roegelein

// ...........................................................................//
// visual objects are the items that can be placed in a scene................//
// they support full databinding to the visual business datacontext..........//
// ...........................................................................//

// jQuery.sap.declare("VBI.VisualObjects.Object");

// ...........................................................................//
// bindable functions for VOS................................................//

/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
VBI.Utilities.SceneBindDesignSpotBoxSize = function(ocb) {
	"use strict";
	var scene = this.m_Scene;

	// only when the scale is changeable......................................//
	if (ocb.m_Design && (ocb.m_Hit == VBI.HTBOXHANDLE) && this.m_Scale.IsChangeable(scene.m_Ctx)) {
		// lower handles are not supported, due they would modify the position.//
		// current implementation ensures that position is kept................//
		// precisely...........................................................//
		if (ocb.m_Handle > 6) {
			return;
		}

		// get the current non scaled values...................................//
		var zsf = scene.GetStretchFactor4Mode();
		var nsx = ocb.m_ClientX / zsf[0];
		var nsy = ocb.m_ClientY / zsf[0];

		// get the current bounding box........................................//
		var bb = ocb.m_DhOrig[0];
		var midX = (bb[0] + bb[2]) / 2.0;
		var wh = (bb[2] - bb[0]) / 2.0; // half of original width
		var h = (bb[3] - bb[1]); // height

		var fx = 1.0, fy = 1.0;
		switch (ocb.m_Handle) {
			case 1:
				fy = Math.abs(nsy - bb[3]) / h;
				break;
			case 2:
			case 5:
				if (ocb.m_Handle == 2) {
					fy = Math.abs(nsy - bb[3]) / h;
				}
				fx = Math.abs(nsx - midX) / wh;
				break;
			case 0:
			case 3:
				if (ocb.m_Handle == 0) {
					fy = Math.abs(nsy - bb[3]) / h;
				}
				fx = Math.abs(nsx - midX) / wh;
				break;
			default:
				break;
		}

		var scale = ocb.m_ScaleOrig.slice(0);
		scale[0] *= fx;
		scale[1] *= fy;

		// set the new scale...................................................//
		this.m_Scale.SetValueVector(scene.m_Ctx, scale);
	}
};

VBI.Utilities.SceneBindDesignBoxBoxSize = function(keepratio, ocb) {
	"use strict";
	var scene = this.m_Scene;

	// only when the scale is changeable................................//
	if (ocb.m_Design && (ocb.m_Hit == VBI.HTBOXHANDLE) && this.m_Scale.IsChangeable(scene.m_Ctx)) {
		// get the current non scaled values...................................//
		var zsf = scene.GetStretchFactor4Mode();
		var nsx = ocb.m_ClientX / zsf[0];
		var nsy = ocb.m_ClientY / zsf[0];

		// get the current bounding box........................................//
		var bb = ocb.m_DhOrig[0];
		var midX = (bb[0] + bb[2]) / 2.0;
		var midY = (bb[1] + bb[3]) / 2.0;
		var wh = (bb[2] - bb[0]) / 2.0; // half of original width
		var hh = (bb[3] - bb[1]) / 2.0; // height

		var fx = 1.0, fy = 1.0;
		switch (ocb.m_Handle) {
			case 0:
			case 2:
			case 6:
			case 8:
				fx = Math.abs(nsx - midX) / wh;
				fy = Math.abs(nsy - midY) / hh;
				// when keeping the ratio we use the max of both.................//
				if (keepratio) {
					fx = fy = Math.max(fx, fy);
				}
				break;
			case 1:
			case 7:
				fy = Math.abs(nsy - midY) / hh;
				if (keepratio) {
					fx = fy; // here we keep the ratio.............//
				}
				break;
			case 3:
			case 5:
				fx = Math.abs(nsx - midX) / wh;
				if (keepratio) {
					fy = fx; // here we keep the ratio.............//
				}
				break;
			default:
				break;
		}

		var scale = ocb.m_ScaleOrig.slice(0);
		scale[0] *= fx;
		scale[1] *= fy;

		// set the new scale...................................................//
		this.m_Scale.SetValueVector(scene.m_Ctx, scale);
	}
};

VBI.Utilities.SceneBindMeterRadiusDesignBoxSize = function(ocb) {
	"use strict";
	// determine a meter dimensioned radius...................................//
	var scene = this.m_Scene;
	if (ocb.m_Design) {
		// determine the center point information..............................//
		var center = this.m_Pos.GetValueVector(scene.m_Ctx);
		var cur = scene.GetPosFromPoint([
			ocb.m_ClientX, ocb.m_ClientY, 0
		]);

		// 0 1 2
		// 3 4 5
		// 6 7 8
		var r = 0;
		switch (ocb.m_Handle) {
			case 1:
			case 7:
				r = VBI.MathLib.Distance(VBI.MathLib.DegToRad(center), VBI.MathLib.DegToRad([
					center[0], cur[1]
				]));
				break;
			case 3:
			case 5:
				r = VBI.MathLib.Distance(VBI.MathLib.DegToRad(center), VBI.MathLib.DegToRad([
					cur[0], center[1]
				]));
				break;
			default:
				break;
		}

		// set the radius......................................................//
		this.m_Radius.SetValueFloat(scene.m_Ctx, Math.abs(r));
	}
};

VBI.Utilities.SceneBindRadiusDesignBoxSize = function(ocb) {
	"use strict";
	// determines a pixel size radius.........................................//
	var scene = this.m_Scene;
	if (ocb.m_Design) {
		// determine the center point information..............................//
		var centerpos = this.m_Pos.GetValueVector(scene.m_Ctx);
		var centerpt = scene.GetPointFromPos(centerpos);
		centerpt[0] += ocb.m_IO;

		// 0 1 2
		// 3 4 5
		// 6 7 8
		var r = 0;
		switch (ocb.m_Handle) {
			case 1:
			case 7:
				r = (centerpt[1] - ocb.m_ClientY); // zf[1]; // in non zoomed pixel space
				break;
			case 3:
			case 5:
				r = (centerpt[0] - ocb.m_ClientX); // zf[0]; // in non zoomed pixel space
				break;
			default:
				break;
		}

		// set the radius......................................................//
		this.m_Radius.SetValueFloat(scene.m_Ctx, Math.abs(r));
	}
};

VBI.Utilities.SceneBindPosArrayDesignBoxSize = function(ocb) {
	"use strict";
	var scene = this.m_Scene;
	if (ocb.m_Design) {
		// determine the new point information.................................//
		var pos = scene.GetPosFromPoint([
			ocb.m_ClientX - ocb.m_IO, ocb.m_ClientY, 0
		]);

		var minX = Number.MAX_VALUE;
		var maxX = -Number.MAX_VALUE;
		var minY = Number.MAX_VALUE;
		var maxY = -Number.MAX_VALUE;

		// determine min max from the original positions.......................//
		var apos = ocb.m_PosOrig.slice(0);
		var nJ, len = apos.length / 3, idx;
		for (nJ = 0; nJ < len; ++nJ) {
			idx = nJ * 3;
			if (minX > apos[idx]) {
				minX = apos[idx];
			}
			if (maxX < apos[idx]) {
				maxX = apos[idx];
			}
			if (minY > apos[idx + 1]) {
				minY = apos[idx + 1];
			}
			if (maxY < apos[idx + 1]) {
				maxY = apos[idx + 1];
			}
		}

		// 0,1,2
		// 3,4,5
		// 6,7,8

		// geo coordinate system goes from left to right but from bottom up....//
		var ax = 0, fx = 1;
		var ay = 0, fy = 1;
		switch (ocb.m_Handle) {
			case 0:
			case 1:
				if (ocb.m_Handle == 0) {
					ax = maxX;
					fx = (pos[0] - maxX) / (minX - maxX);
				}
				ay = minY;
				fy = (pos[1] - minY) / (maxY - minY);
				break;
			case 2:
			case 5:
				if (ocb.m_Handle == 2) {
					ay = minY;
					fy = (pos[1] - minY) / (maxY - minY);
				}
				ax = minX;
				fx = (pos[0] - minX) / (maxX - minX);
				break;
			case 6:
			case 3:
				if (ocb.m_Handle == 6) {
					ay = maxY;
					fy = (pos[1] - maxY) / (minY - maxY);
				}
				ax = maxX;
				fx = (pos[0] - maxX) / (minX - maxX);
				break;
			case 8:
			case 7:
				if (ocb.m_Handle == 8) {
					ax = minX;
					fx = (pos[0] - minX) / (maxX - minX);
				}
				ay = maxY;
				fy = (pos[1] - maxY) / (minY - maxY);
				break;
			default:
				break;
		}

		// all handles should be moved.........................................//
		for (nJ = 0; nJ < len; ++nJ) {
			idx = nJ * 3;
			apos[idx] = ax + (apos[idx] - ax) * fx;
			apos[idx + 1] = ay + (apos[idx + 1] - ay) * fy;
		}
		this.m_Pos.SetValueVector(scene.m_Ctx, apos);
	}
};

VBI.Utilities.BackupFont = function(dc) {
	"use strict";
	dc.m_BackupFont = [];

	dc.m_BackupFont.m_font = dc.m_font = dc.font;
	dc.m_BackupFont.m_fillStyle = dc.fillStyle;
	dc.m_BackupFont.m_strokeStyle = dc.strokeStyle;
	dc.m_BackupFont.m_textAlign = dc.textAlign;
	dc.m_BackupFont.m_textBaseline = dc.textBaseline;
};

VBI.Utilities.RestoreFont = function(dc) {
	"use strict";
	dc.m_font = dc.font = dc.m_BackupFont.m_font;
	dc.fillStyle = dc.m_BackupFont.m_fillStyle;
	dc.strokeStyle = dc.m_BackupFont.m_strokeStyle;
	dc.textAlign = dc.m_BackupFont.m_textAlign;
	dc.textBaseline = dc.m_BackupFont.m_textBaseline;
};

VBI.Utilities.SetTextAttributes = function(dc, newFont, newFillStyle, newStrokeStyle, newAlign, newTextBaseline) {
	"use strict";
	if ((newFont != undefined) && (dc.m_font != newFont)) {
		dc.m_font = dc.font = newFont;
	}
	var aCol;
	if (newFillStyle) {
		aCol = VBI.Types.string2rgba(newFillStyle);
		dc.fillStyle = VBI.Utilities.RgbToHex(aCol[0], aCol[1], aCol[2]);
	}
	if (newStrokeStyle) {
		aCol = VBI.Types.string2rgba(newStrokeStyle);
		dc.strokeStyle = VBI.Utilities.RgbToHex(aCol[0], aCol[1], aCol[2]);
	}
	dc.textAlign = newAlign;
	dc.textBaseline = newTextBaseline;
};

VBI.Utilities.SetFont = function(dc, newFont) {
	"use strict";
	if ((newFont != undefined) && (dc.m_font != newFont)) {
		dc.m_font = dc.font = newFont;
	}
};

VBI.DnDInfo = function() {
	"use strict";
	var dndInfo = {}; // create the object
	dndInfo.m_datasource = null;
	dndInfo.m_boundtype = null;
	dndInfo.m_type = [];

	dndInfo.clear = function() {
		for (var nJ = 0; nJ < dndInfo.m_type.length; ++nJ) {
			dndInfo.m_type[nJ].clear();
		}
		if (dndInfo.m_boundtype) {
			dndInfo.m_boundtype.clear();
		}
		if (dndInfo.m_datasource) {
			dndInfo.m_datasource.clear();
		}
		dndInfo.m_datasource = null;
		dndInfo.m_boundtype = null;
		dndInfo.m_type = [];
	};

	// load from json parsed object
	dndInfo.load = function(dat, ctx, inst) {
		if (dat) {

			if (jQuery.type(dat) == 'array') {
				// load the vo array.............................................//
				for (var nJ = 0; nJ < dat.length; ++nJ) {
					if (jQuery.type(dat[nJ]) == 'object') {
						if (dat[nJ].datasource) {
							dndInfo.m_datasource = new VBI.NodeProperty(dat[nJ], 'datasource', inst.m_DataSource, ctx);
							dndInfo.m_boundtype = new VBI.AttributeProperty(dat[nJ], 'type', dndInfo.m_datasource, ctx);
						} else {
							dndInfo.m_type.push(new VBI.AttributeProperty(dat[nJ], 'type', null, ctx));
						}

					}
				}
			} else if (jQuery.type(dat) == 'object') {
				if (dat.datasource) {
					dndInfo.m_datasource = new VBI.NodeProperty(dat, 'datasource', inst.m_DataSource, ctx);
					dndInfo.m_boundtype = new VBI.AttributeProperty(dat, 'type', dndInfo.m_datasource, ctx);
				} else {
					dndInfo.m_type.push(new VBI.AttributeProperty(dat, 'type', null, ctx));
				}
			}
		}

	};
	dndInfo.getItemArray = function(ctx) {
		var aValue = [];
		var nS;
		if (dndInfo.m_datasource) {
			var ds = dndInfo.m_datasource;
			var nCurNde;
			if ((nCurNde = ds.GetCurrentNode(ctx))) {
				for (nS = 0; nS < nCurNde.m_dataelements.length; ++nS) {
					ds.Select(nS);
					aValue.push(dndInfo.m_boundtype.GetValueString(ctx));
				}
			}
		}
		if (dndInfo.m_type.length) {
			for (nS = 0; nS < dndInfo.m_type.length; ++nS) {
				aValue.push(dndInfo.m_type[nS].GetValueString(ctx));
			}
		}
		return aValue;
	};
	return dndInfo;
};

// ...........................................................................//
// vo properties.............................................................//

VBI.NodeProperty = function(dat, name, pnp, ctx) {
	"use strict";
	// a datanode can be bound or not.........................................//
	// in both cases a data node is referenced................................//
	var path = null;
	if (!(path = dat[name])) {
		path = dat[name + ".bind"];
	}

	this.m_NPath = path.split("."); // store the data source path...//
	this.m_Path = path.split("."); // store the original data path.//
	this.m_PNP = pnp; // store the parentnodeproperty.//
	this.m_nCurElement = 0; // current element index........//
	this.m_CurElement = null; // current element instance.....//

	// determine the real parent node for this node...........................//
	// and the relative path of this node to the parents node.................//

	// update members.........................................................//
	this.m_DTN = ctx.m_DataTypeProvider.FindTypeNodeFromPath(this.m_Path);

	// determine the real responsible node parent.............................//
	var tmp = this;
	while ((tmp = tmp.m_PNP)) {
		if (ctx.m_DataTypeProvider.isParentOf(tmp.m_DTN, this.m_DTN)) {
			// adjust the path..................................................//
			var nJ, tmppath = tmp.m_DTN.GetPath();
			for (nJ = 0; nJ < tmppath.length; ++nJ) {
				if (this.m_NPath[0] == tmppath[nJ]) {
					this.m_NPath.splice(0, 1); // remove first
				} else {
					break;
				}
			}
			break;
		}
	}
	this.m_PNP = tmp;

	// ........................................................................//
	// data change notification...............................................//

	this.NotifyDataChange = function(ctx) {
		// current element instance is lazy determined later, therefore reset..//
		// when data has changed...............................................//
		this.m_CurElement = null;

		// update members......................................................//
		this.m_DTN = ctx.m_DataTypeProvider.FindTypeNodeFromPath(this.m_Path);
	};

	this.clear = function() {
		// clear the node property.............................................//
		this.m_PNP = null; // reset parent node property
		this.m_CurElement = null; // reset current element reference
		this.m_DTN = null; // reset data type node reference
		this.m_NPath = null; // reset adjusted node path
		this.m_Path = null; // reset original node path
	};

	// ........................................................................//
	// helper functions.......................................................//

	this.GetCurrentElement = function(ctx) {
		if (this.m_CurElement) {
			return this.m_CurElement; // return the cached element.//
		}

		var dn = this.GetCurrentNode(ctx);
		if (!dn) {
			return null;
		}

		// cache the current iterated element..................................//
		this.m_CurElement = dn.m_dataelements[this.m_nCurElement];
		return (this.m_CurElement);
	};

	this.GetIndexedElement = function(ctx, idx) {
		var dn = this.GetCurrentNode(ctx);
		if (!dn) {
			return null;
		}
		return dn.m_dataelements[idx];
	};

	this.GetCurrentNode = function(ctx) {
		var dn = null;
		if (this.m_PNP) {
			// there is a parent, get the right index there.....................//
			var de = this.m_PNP.GetCurrentElement(ctx);
			dn = de.FindNodeFromPath(this.m_NPath);
		} else {
			// determine the datanode directly..................................//
			dn = ctx.m_DataProvider.FindNodeFromPath(this.m_NPath);
		}
		return dn;
	};

	// this is the selection iterator.........................................//
	// and is just set to be able to iterate over elements....................//

	this.Select = function(idx) {
		// reset current element first, determine the current element when.....//
		// necessary again.....................................................//
		this.m_CurElement = null;
		this.m_nCurElement = idx;
	};

	// edit mode handling.....................................................//
	// current edit mode state is stored on element level.....................//

	this.SetEditMode = function(ctx, mode) {
		var de;
		if ((de = this.GetCurrentElement(ctx))) {
			de.m_EditMode = mode;
		}
	};

	this.GetEditMode = function(ctx) {
		var de;
		if ((de = this.GetCurrentElement(ctx)) && (de.m_EditMode != undefined)) {
			return de.m_EditMode;
		}

		return VBI.EMHandle; // handle mode is the default...//
	};

	// diagnostics............................................................//

	this.IsElementSelected = function(ctx) {
		var de;
		if ((de = this.GetCurrentElement(ctx))) {
			return de.IsSelected();
		}

		return false;
	};

	this.SetSelected = function(ctx, bSelect) {
		// todo: set the selection state in the current selected item..........//
		return;
	};

	return this;
};

// ...........................................................................//
// bindable attribute object.................................................//

VBI.AttributeProperty = function(dat, name, pnp, ctx, def) {
	"use strict";
	var val;

	// store a default value..................................................//
	this.m_DefaultValue = def;

	if ((val = dat[name])) {
		// there is no binding, use the specified name.........................//
		this.m_Name = name;
		this.m_Value = val;
	} else if ((val = dat[name + ".bind"])) {
		this.m_PNP = pnp;
		this.m_Name = name;
		this.m_RelBind = val.split("."); // relative binding path............//
		this.m_AbsBind = val.split("."); // absoulte original binding path...//

		// determine the datatype attribute....................................//
		this.m_DTA = ctx.m_DataTypeProvider.FindTypeAttributeFromPath(this.m_AbsBind);

		// determine the real parent node and the relative the binding path....//
		var tmp = this;
		while ((tmp = tmp.m_PNP)) {
			if (ctx.m_DataTypeProvider.isParentOf(tmp.m_DTN, this.m_DTA)) {
				// adjust the path...............................................//
				var nJ, tmppath = tmp.m_DTN.GetPath();
				for (nJ = 0; nJ < tmppath.length; ++nJ) {
					if (this.m_RelBind[0] == tmppath[nJ]) {
						this.m_RelBind.splice(0, 1); // remove first
					} else {
						break;
					}
				}
				break;
			}
		}
		this.m_PNP = tmp;
	}

	// data change notification...............................................//

	this.NotifyDataChange = function(ctx) {
		// data in the datacontext has changed.................................//
		// determine the new datatype attribute when...........................//
		if (this.m_AbsBind) {
			this.m_DTA = ctx.m_DataTypeProvider.FindTypeAttributeFromPath(this.m_AbsBind);
		}
	};

	this.clear = function() {
		// clear the attribute properties......................................//
		this.m_PNP = null; // reset the parent
		this.m_DTA = null; // reset the type reference
		this.m_DefaultValue = null;

		// delete optional properties..........................................//
		if (this.m_Name) {
			this.m_Name = null;
		}
		if (this.m_Value) {
			this.m_Value = null;
		}
		if (this.m_PNP) {
			this.m_PNP = null;
		}
		if (this.m_RelBind) {
			this.m_RelBind = null;
		}
		if (this.m_AbsBind) {
			this.m_AbsBind = null;
		}
	};

	this.IsChangeable = function(ctx) {
		var attrib;
		if ((attrib = this.GetAttributeObject(ctx))) {
			return attrib.IsChangeable();
		}
		return false;
	};

	// ........................................................................//
	// data access............................................................//

	this.GetAttributeObject = function(ctx) {
		// this can only be called when binding is valid, in this case.........//
		// the data attribute is delivered.....................................//
		if (this.m_RelBind) {
			if (this.m_PNP) {
				// relative node property
				return this.m_PNP.GetCurrentElement(ctx).FindAttributeFromPath(this.m_RelBind);
			} else {
				return ctx.m_DataProvider.FindAttributeFromPath(this.m_RelBind);
			}
		}
		return null;
	};

	this.GetValueFloat = function(ctx) {
		// when this is an explicit property then return it immediately........//
		if (this.m_Value) {
			return VBI.Types.string2float(this.m_Value);
		}

		if (this.m_RelBind) {
			var attrib;
			if ((attrib = this.GetAttributeObject(ctx))) {
				if (attrib.m_dta.m_Type == VBI.Types.st_float) {
					return attrib.m_Value;
				}
				if (attrib.m_dta.m_Type == VBI.Types.st_string) {
					return VBI.Types.string2float(attrib.m_Value);
				}
				if (attrib.m_dta.m_Type == VBI.Types.st_long) {
					return VBI.Types.long2float(attrib.m_Value);
				}
				if (attrib.m_dta.m_Type == VBI.Types.st_bool) {
					return attrib.m_Value ? 1.0 : 0.0;
				}

				// todo: do other conversions here
			}
		}

		return this.m_DefaultValue;
	};

	this.GetValueString = function(ctx) {
		// when this is an explicit property then return it immediately........//
		if (this.m_Value) {
			return this.m_Value;
		}

		if (this.m_RelBind) {
			var attrib;
			if ((attrib = this.GetAttributeObject(ctx))) {
				if (attrib.m_dta.m_Type == VBI.Types.st_string) {
					return attrib.m_Value;
				} else {
					return attrib.GetStringValue();
				}
			}
		}

		return this.m_DefaultValue;
	};

	this.GetValueLong = function(ctx) {
		if (this.m_Value) {
			return VBI.Types.string2long(this.m_Value);
		}

		if (this.m_RelBind) {
			var attrib;
			if ((attrib = this.GetAttributeObject(ctx))) {
				if (attrib.m_dta.m_Type == VBI.Types.st_long) {
					return attrib.m_Value;
				}
				if (attrib.m_dta.m_Type == VBI.Types.st_bool) {
					return attrib.m_Value;
				}
				if (attrib.m_dta.m_Type == VBI.Types.st_string) {
					return VBI.Types.string2long(attrib.m_Value);
				}
				if (attrib.m_dta.m_Type == VBI.Types.st_float) {
					return VBI.Types.float2long(attrib.m_Value);
				}

				// todo: do other conversions here
			}

		}

		return this.m_DefaultValue;
	};

	this.GetValueBool = function(ctx) {
		if (this.m_Value) {
			return VBI.Types.string2bool(this.m_Value);
		}

		if (this.m_RelBind) {
			var attrib;
			if ((attrib = this.GetAttributeObject(ctx))) {
				if (attrib.m_dta.m_Type == VBI.Types.st_bool) {
					return attrib.m_Value;
				}
				if (attrib.m_dta.m_Type == VBI.Types.st_string) {
					return VBI.Types.string2bool(attrib.m_Value);
				}

				// todo: do other conversions here

			}
		}

		return this.m_DefaultValue;
	};

	this.GetValueVector = function(ctx) {
		// when this is an explicit property then return it immediately........//
		if (this.m_Value) {
			if (typeof (this.m_Value) === "string") {
				return VBI.Types.string2vector(this.m_Value);
			} else {
				return VBI.Types.stringarray2vectorarray(this.m_Value);
			}
		}
		if (this.m_RelBind) {
			var attrib;
			if ((attrib = this.GetAttributeObject(ctx))) {
				if ((attrib.m_dta.m_Type == VBI.Types.st_vector) || (attrib.m_dta.m_Type == VBI.Types.st_vectorarray) || (attrib.m_dta.m_Type == VBI.Types.st_vectorarraymulti)) {
					return attrib.m_Value;
				}
				if (attrib.m_dta.m_Type == VBI.Types.st_string) {
					return VBI.Types.string2vector(attrib.m_Value);
				}

				// todo: do other conversions here
			}
		}

		return this.m_DefaultValue;
	};

	this.GetValueColor = function(ctx) {
		// when this is an explicit property then return it immediately........//
		var rgba;
		if (this.m_Value) {
			rgba = VBI.Types.string2rgba(this.m_Value);
			return "rgba(" + rgba[0] + "," + rgba[1] + "," + rgba[2] + "," + rgba[3] + ")";
		}
		if (this.m_RelBind) {
			// assume that the data is already a color..........................//
			var attrib;
			if ((attrib = this.GetAttributeObject(ctx))) {
				if ((attrib.m_dta.m_Type == VBI.Types.st_color)) {
					return attrib.m_Value;
				}
				if (attrib.m_dta.m_Type == VBI.Types.st_string) {
					rgba = VBI.Types.string2rgba(attrib.m_Value);
					return "rgba(" + rgba[0] + "," + rgba[1] + "," + rgba[2] + "," + rgba[3] + ")";
				}

				// todo: do other conversions here
			}
		}

		return this.m_DefaultValue;
	};

	// ........................................................................//
	// modification functions.................................................//

	this.SetValueVector = function(ctx, val) {
		// when this is an explicit property then return it immediately........//
		if (this.m_Value) {
			return null; // only bound properties can be changed...........//
		}

		if (this.m_RelBind) {
			var attrib;
			if ((attrib = this.GetAttributeObject(ctx))) {
				if ((attrib.m_dta.m_Type == VBI.Types.st_vector) || (attrib.m_dta.m_Type == VBI.Types.st_vectorarray)) {
					attrib.set(val);
				}
				if (attrib.m_dta.m_Type == VBI.Types.st_string) {
					attrib.set(VBI.Types.float2string(val));
				}
			}
		}

		return null;
	};

	this.SetValueFloat = function(ctx, val) {
		// when this is an explicit property then return it immediately........//
		if (this.m_Value) {
			return null; // only bound properties can be changed...........//
		}

		if (this.m_RelBind) {
			var attrib;
			if ((attrib = this.GetAttributeObject(ctx))) {
				if ((attrib.m_dta.m_Type == VBI.Types.st_float)) {
					attrib.set(val);
				} else if ((attrib.m_dta.m_Type == VBI.Types.st_long)) {
					attrib.set(VBI.Types.float2long(val));
				} else if (attrib.m_dta.m_Type == VBI.Types.st_string) {
					attrib.set(VBI.Types.float2string(val));
				}
			}
		}

		return null;
	};

	// diagnostics............................................................//
	this.IsBound = function() {
		return this.m_RelBind ? true : false;
	};

	return this;
};
﻿// ...........................................................................//
// this module does the window handling......................................//

// Author: Ulrich Roegelein

// ...........................................................................//
// the scene manager manages the scene instances in a component context......//

VBI.Windows = function() {
	"use strict";
	/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
	var windows = {};
	windows.vbiclass = "Windows";
	windows.m_WindowArray = [];

	// ........................................................................//
	// helper functions.......................................................//

	windows.find = function(name) {
		// find the window by id...............................................//
		for (var nJ = 0, len = windows.m_WindowArray.length; nJ < len; ++nJ) {
			if (windows.m_WindowArray[nJ].m_ID == name) {
				return windows.m_WindowArray[nJ];
			}
		}

		return null;
	};

	windows.clear = function() {
		// clear the windows array.............................................//
		for (var nJ = 0; nJ < windows.m_WindowArray.length; ++nJ) {
			windows.m_WindowArray[nJ].clear();
		}

		// empty the windows array.............................................//
		windows.m_WindowArray = [];
	};

	windows.create = function(desc, ctx) {
		var wnd = null;

		switch (desc.type) {
			case 'callout':
				wnd = new VBI.CalloutWindow();
				break;
			case 'legend':
				wnd = new VBI.LegendWindow();
				break;
			default:
				wnd = new VBI.Window();
				break;
		}
		if (wnd) {
			wnd.load(desc, ctx);
		}
		return wnd;
	};

	// loading from the project file..........................................//
	windows.load = function(dat, ctx) {
		// process removal of windows first....................................//
		var a, nJ, len;
		if (dat.Remove) {
			if (jQuery.type(dat.Remove) == 'object') {
				// this is an object.............................................//
				if (dat.Remove.name) {
					windows.Remove(dat.Remove.name);
				}
			} else if (jQuery.type(dat.Remove) == 'array') {
				for (nJ = 0, len = dat.Remove.length; nJ < len; ++nJ) {
					if (dat.Remove[nJ].name) {
						windows.Remove(dat.Remove[nJ].name);
					}
				}
			}
		}

		// process set command to set new content..............................//
		if (dat.Set) {
			var wnd;

			if (jQuery.type(dat.Set) == 'object') {
				// this is an object.............................................//
				if (dat.Set.name) {
					// set a specific detail window...............................//
					wnd = windows.find(dat.Set.name);
					if (wnd) {
						wnd.load(dat.Set.Window, ctx);
						return;
					} else {
						wnd = windows.create(dat.Set.Window, ctx);
						windows.Add(wnd);
						return;
					}
				}

				// clear windows only when no set of names........................//
				windows.clear();

				if (dat.Set.Window) {
					if (jQuery.type(dat.Set.Window) == 'object') {
						wnd = windows.create(dat.Set.Window, ctx);
						windows.Add(wnd);
					} else if (jQuery.type(dat.Set.Window) == 'array') {
						a = dat.Set.Window;
						for (nJ = 0; nJ < a.length; ++nJ) {
							wnd = windows.create(a[nJ], ctx);
							windows.Add(wnd);
						}
						return;
					}
				}
			} else if (jQuery.type(dat.Set) == 'array') {
				// this is an array..............................................//
				// zutun: this is not yet supported
				a = dat.Set;
				for (nJ = 0; nJ < a.length; ++nJ) {
					var item = a[nJ];

					// this is an object containing name and window..............//
					if (item.name) {
						// set a specific detail window...........................//
						wnd = windows.find(item.name);
						if (wnd) {
							wnd.load(item.Window, ctx);
						} else {
							wnd = windows.create(item.Window, ctx);
							windows.Add(wnd);
						}
					}
				}
			}
		}
	};

	// ........................................................................//
	// functions..............................................................//
	windows.Add = function(wnd) {
		windows.m_WindowArray.push(wnd);
	};

	windows.Remove = function(name) {
		var wnd = null;

		// find the window by id...............................................//
		for (var nJ = 0, len = windows.m_WindowArray.length; nJ < len; ++nJ) {
			if ((wnd = windows.m_WindowArray[nJ]).m_ID == name) {
				// clear the window..............................................//
				wnd.clear();

				// remove it from array..........................................//
				windows.m_WindowArray.splice(nJ, 1);
				break;
			}
		}
	};

	// awake
	windows.Awake = function(target) {
		// zutun: awake the windows in the right parent child sequence..........//
		// current assumtion is, that sequence is right........................//
		for (var nJ = 0; nJ < windows.m_WindowArray.length; ++nJ) {
			windows.m_WindowArray[nJ].Awake(target);
		}
	};

	windows.GetMainWindow = function() {
		// currently first window without a parent is the main.................//
		for (var nJ = 0; nJ < windows.m_WindowArray.length; ++nJ) {
			if (windows.m_WindowArray[nJ].m_refParent == null) {
				return windows.m_WindowArray[nJ];
			}
		}
		return null; // no main window found
	};

	// notifications..........................................................//
	windows.NotifyDataChange = function() {
		// notify all windows about a data change..............................//
		var oA = windows.m_WindowArray;
		for (var nJ = 0; nJ < oA.length; ++nJ) {
			oA[nJ].NotifyDataChange();
		}

		return null;
	};

	windows.NotifyResize = function() {
		// notify all windows about a data change..............................//
		var oA = windows.m_WindowArray;
		for (var nJ = 0; nJ < oA.length; ++nJ) {
			oA[nJ].NotifyResize();
		}

		return null;
	};
	windows.NotifySceneMove = function(scene) {
		// notify all windows about a data change..............................//
		var oA = windows.m_WindowArray;
		for (var nJ = 0, len = oA.length; nJ < len; ++nJ) {
			oA[nJ].NotifySceneMove(scene);
		}

		return null;
	};

	windows.NotifySceneZoom = function(scene) {
		// notify all windows about a data change..............................//
		var oA = windows.m_WindowArray;
		for (var nJ = 0, len = oA.length; nJ < len; ++nJ) {
			oA[nJ].NotifySceneZoom(scene);
		}

		return null;
	};

	windows.Render = function() {
		// iterate through all windows and render them.........................//
		var oA = windows.m_WindowArray;
		for (var nJ = 0; nJ < oA.length; ++nJ) {
			oA[nJ].Render();
		}

		return null; // scene not known
	};

	windows.RenderAsync = function() {
		// iterate through all windows and render them.........................//
		var oA = windows.m_WindowArray;
		for (var nJ = 0; nJ < oA.length; ++nJ) {
			oA[nJ].RenderAsync(true);
		}

		return null; // scene not known
	};

	return windows;
};

// ...........................................................................//
// Window object.............................................................//

VBI.Window = function() {
	"use strict";

	this.vbiclass = "Window";
	this.m_ID = ""; // id of window
	this.m_Caption = ""; // caption of window
	this.m_Type = ""; // type of window
	this.m_bModal = true; // window should be modal
	this.m_refScene = null; // name of the scene that should be shown in the window
	this.m_refSceneInstance = null; // scene instance that should be shown in the window
	this.m_refParent = null; // parent window, null if in scene
	this.m_Width = null;
	this.m_Height = null;
	this.m_Div = null; // div where the window is placed
	this.m_Ctx = null; // reference to context

	// persisting members.....................................................//

	this.BaseLoad = function(inst, dat, ctx) {
		// loading window members
		if (dat.id) {
			inst.m_ID = dat.id;
		}
		if (dat.caption) {
			inst.m_Caption = dat.caption;
		}
		if (dat.refParent) {
			inst.m_refParent = dat.refParent;
		}
		if (dat.modal) {
			inst.m_bModal = (dat.ref == "true") ? true : false;
		}
		if (dat.width) {
			inst.m_Width = parseInt(dat.width, 10);
		}
		if (dat.height) {
			inst.m_Height = parseInt(dat.height, 10);
		}
		// store the context...................................................//
		inst.m_Ctx = ctx;

		// get the position....................................................//

		// zutun: load all properties of window
		if (dat.refScene) {
			inst.m_refScene = dat.refScene;
		} else if (VBI.m_bTrace) {
			VBI.Trace("Error: no scene assigned to window");
		}
	};

	this.BaseClear = function() {
		// delete the backreference of the scene when the window id cleared...//
		var scene = this.GetScene();
		if (scene) {
			scene.m_Parent = null;
		}

		// clear references...................................................//
		this.m_refParent = null;
		this.m_refScene = null;
		this.m_refSceneInstance = null;
		this.m_Ctx = null;
		this.m_Div = null;
	};

	// clear the window.......................................................//
	this.clear = function() {
		this.BaseClear();
	};

	this.load = function(dat, ctx) {
		this.BaseLoad(this, dat, ctx);
	};

	// delivers the scene that is hosted in this window.......................//
	this.GetScene = function() {
		if (this.m_refSceneInstance) {
			return this.m_refSceneInstance;
		}

		// lazy link the scene with the window................................//
		this.m_refSceneInstance = (this.m_Ctx && this.m_Ctx.m_SceneManager) ? this.m_Ctx.m_SceneManager.GetSceneByName(this.m_refScene) : null;

		// a callout with custom content has no associated scene..............//
		if (this.m_refSceneInstance) {
			this.m_refSceneInstance.m_Parent = this;
		}
		return this.m_refSceneInstance;
	};

	// delivers the scene where this window is hosted in......................//
	this.GetHostingScene = function() {
		// assign members......................................................//
		if (!this.m_refParent) {
			return null;
		}

		var wp = this.m_Ctx.m_Windows.find(this.m_refParent);
		if (wp) {
			return wp.GetScene();
		}

		return null;
	};

	// ........................................................................//
	// notifications..........................................................//

	this.NotifyDataChange = function() {
		var scene = this.GetScene();
		if (scene) {
			scene.NotifyDataChange();
		}
	};

	this.NotifyResize = function() {
		return;

	};
	this.NotifySceneMove = function(scene) {
		return;
	};

	this.NotifySceneZoom = function(scene) {
		return;
	};

	this.Render = function() {
		var scene = this.GetScene();
		if (scene) {
			scene.Render();
		}
	};

	this.RenderAsync = function() {
		var scene = this.GetScene();
		if (scene) {
			if (scene.RenderAsync) {
				scene.RenderAsync(true);
			} else {
				scene.Render();
			}
		}
	};

	// awake window...........................................................//
	this.Awake = function(target) {
		// the target is the id of the dom element tat should be used for......//
		// display.............................................................//
		var scene = this.GetScene();
		if (scene) {
			scene.Awake(target);
		} else if (VBI.m_bTrace) {
			VBI.Trace("Error: Awake no scene assigned to window");
		}
	};

	// ........................................................................//
	// internal functions.....................................................//

	this.Create = function(target) {
		// just do nothing.....................................................//
	};

	this.Destroy = function() {
		// if (this.m_Div) {
		// zutun: remove the elements........................................//
		// }
	};
};

// ...........................................................................//
// callout window............................................................//

VBI.CalloutWindow = function() {
	"use strict";

	var callout = new VBI.Window();

	// the callout object.....................................................//
	callout.m_oCallout = null; // callout object created in the utilities..//

	// ........................................................................//
	// overloaded members.....................................................//

	callout.load = function(dat, ctx) {
		callout.BaseLoad(callout, dat, ctx); // call base function...........//

		// load the position information.......................................//
		callout.m_Pos = new VBI.AttributeProperty(dat, 'pos', null, ctx);
		callout.m_OffsetX = new VBI.AttributeProperty(dat, 'offsetX', null, ctx, 0);
		callout.m_OffsetY = new VBI.AttributeProperty(dat, 'offsetY', null, ctx, 0);
	};

	callout.clear = function() {
		// unregister events...................................................//
		callout.UnRegisterEvents();

		// remove from dom.....................................................//
		callout.Remove();

		// call base function..................................................//
		callout.BaseClear();

		callout.m_oCallout = null;
	};

	// ........................................................................//
	// event handlers.........................................................//

	callout.processclosebuttonclick = function(event) {
		// call hook...........................................................//
		callout.m_Ctx.onCloseWindow(callout.m_ID, callout.m_oCallout.m_Content);

		// clear the callout...................................................//
		callout.clear();

		// no further routing should takes place................................//
		event.preventDefault();
		event.stopPropagation();
	};

	// ........................................................................//
	// helper functions.......................................................//

	callout.IsValid = function() {
		// the callout is valid when the object is there and the inner div.....//
		// is valid............................................................//
		return (callout.m_oCallout && callout.m_oCallout.m_Div) ? true : false;
	};

	callout.NotifySceneMove = function(scene) {
		callout.UpdatePosition();
	};

	callout.NotifySceneZoom = function(scene) {
		callout.UpdatePosition();
	};

	callout.CalcDivPosition = function() {
		if (!callout.IsValid()) {
			return undefined; // return immediately when callout is not valid............//
		}

		var bPhone = VBI.m_bIsPhone;
		if (bPhone) {
			return undefined;
		}
		// determine the pixel offset the detail window should have from the...//
		// position coordinate.................................................//

		var ox = callout.m_OffsetX.GetValueLong();
		var oy = callout.m_OffsetY.GetValueLong();

		var pos = callout.m_Pos.GetValueVector(callout.m_Ctx);
		var hs = callout.GetHostingScene();

		// we need the div relative position...................................//
		// therefore correct it here...........................................//
		var cv = hs.m_Canvas[hs.m_nOverlayIndex];
		var dx = cv.getPixelLeft();
		var dy = cv.getPixelTop();

		var fExactLod = hs.m_Canvas[0].m_nExactLOD;
		var worldPxOnLOD = parseInt(Math.pow(2, fExactLod) * hs.m_nWidthCanvas / hs.m_nTilesX * hs.m_Proj.m_nXYRatio, 10);
		var nLeftBorder = (hs.m_nDivWidth - worldPxOnLOD) / 2;
		var nRightBorder = hs.m_nDivWidth - nLeftBorder;

		// determine the position in the canvas for the coordinate.............//
		var tmppos = [];
		var nJ, len;
		var aOffsets;

		if (pos.length > 5) {
			var oldX = cv.getPixelWidth();
			var oldY = cv.getPixelHeight();
			cv.setPixelWidth(hs.m_nWidthCanvas);
			cv.setPixelHeight(hs.m_nHeightCanvas);
			hs.m_ZoomFactors[0] = oldX / hs.m_nWidthCanvas;
			hs.m_ZoomFactors[1] = oldY / hs.m_nHeightCanvas;

			var apos = hs.GetNearestPosArray(pos);

			var lt = hs.GetPointFromPos([
				apos.m_MinX, apos.m_MaxY, 0.0
			], false);
			var rb = hs.GetPointFromPos([
				apos.m_MaxX, apos.m_MinY, 0.0
			], false);

			aOffsets = hs.GetInstanceOffsets([
				lt[0], lt[1], rb[0], rb[1]
			]);
			var pointarray = aOffsets.length ? hs.GetPointArrayFromPosArray(apos, false) : null;
			var result;
			var rctest = hs.GetInternalDivClientRect();
			var rcWidth = rctest.width / hs.m_ZoomFactors[0];
			var rcHeight = rctest.height / hs.m_ZoomFactors[1];
			var PosXTest = dx / hs.m_ZoomFactors[0];
			var PosYTest = dy / hs.m_ZoomFactors[1];
			var rcviewport = [
				-PosXTest, -PosYTest, -PosXTest + rcWidth, -PosYTest + rcHeight
			];

			for (nJ = 0, len = aOffsets.length; nJ < len; ++nJ) {
				result = VBI.Utilities.GetMidpointsForLine(pointarray, aOffsets[nJ], rcviewport);
				if (result.aPos.length > result.max) {
					tmppos = result.aPos[result.max];
					tmppos[0] *= hs.m_ZoomFactors[0];
					tmppos[1] *= hs.m_ZoomFactors[1];
					break;
				}

			}
			cv.setPixelWidth(oldX);
			cv.setPixelHeight(oldY);
		} else {
			tmppos = hs.GetPointFromPos(pos, true);

			if (tmppos[0] + dx < nLeftBorder) {
				while (tmppos[0] + dx < nLeftBorder) {
					tmppos[0] += worldPxOnLOD;
				}
			} else if (tmppos[0] + dx > nRightBorder) {
				while (tmppos[0] + dx > nRightBorder) {
					tmppos[0] -= worldPxOnLOD;
				}
			}

		}

		// we need the div relative position...................................//
		// therefore correct it here...........................................//

		if (tmppos.length > 1) {

			tmppos[0] += dx;
			tmppos[1] += dy;

			// offset the callout..................................................//
			// using the specified values..........................................//
			tmppos[0] += ox;
			tmppos[1] += oy;

			// correct due to insets
			var ap = callout.m_oCallout.GetAnchorPoint();
			tmppos[0] -= ap[0];
			tmppos[1] -= ap[1];
		} else {
			tmppos.push(-1000, -1000);
		}
		return tmppos;
	};

	callout.UpdatePosition = function() {
		if (!callout.IsValid()) {
			return;
		}
		// calculate the callout position......................................//
		var pos = callout.CalcDivPosition();

		if (pos) {
			// move it there.......................................................//
			callout.m_oCallout.m_Div.style.left = Math.round(pos[0]) + "px";
			callout.m_oCallout.m_Div.style.top = Math.round(pos[1]) + "px";
			// console.log("CalcDivPosition; pt=" + pos[0] + "/ " + pos[1]);
		} else {
			callout.m_oCallout.m_Div.style.top = "";
			callout.m_oCallout.m_Div.style.left = "0px";
			callout.m_oCallout.m_Div.style.bottom = "0px";
		}
		callout.m_oCallout.m_Div.style.visibility = 'visible';
	};

	// ........................................................................//
	// internal functions.....................................................//

	callout.Create = function(target) {
		// assign members......................................................//
		if (callout.m_refParent && !callout.m_oCallout) {
			// get the hosting scene............................................//
			var hs = callout.GetHostingScene();
			if (hs) {
				// create the detail window......................................//
				// the id is mangled using the control id plus the window id.....//
				callout.m_oCallout = VBI.Utilities.CreateDetail(target + "-" + callout.m_ID, 0, 0, callout.m_Width, callout.m_Height, callout.m_Caption, 5);
				callout.m_oCallout.m_Div.style.visibility = 'hidden';

				// register event handlers.......................................//
				callout.RegisterEvents();

				// try to show it................................................//
				hs.m_WindowLayerDiv.appendChild(callout.m_oCallout.m_Div);

				// call hook.....................................................//
				callout.m_Ctx.onOpenWindow(callout.m_ID, callout.m_oCallout.m_Content);

				// update the callouts position..................................//
				callout.UpdatePosition();
			}
		}
	};

	callout.RegisterEvents = function() {
		// register event handlers that event context is the callout...........//
		var func = callout.processclosebuttonclick.bind(callout);
		// 
		callout.m_oCallout.m_CloseButton.onclick = func;
		callout.m_oCallout.m_CloseButton.ontouchend = func;
	};

	callout.UnRegisterEvents = function() {
		// unregister event handlers...........................................//
		if (!callout.m_oCallout || !callout.m_oCallout.m_CloseButton) {
			return;
		}
		callout.m_oCallout.m_CloseButton.onclick = null;
		callout.m_oCallout.m_CloseButton.ontouchend = null;
	};

	callout.Remove = function() {
		var co = callout.m_oCallout;
		if (!co || !co.m_Div) {
			return; // nothing to remove.......................................//
		}

		// remove the callout from dom.........................................//
		var cd = co.m_Div;
		while (cd.firstChild) {
			cd.removeChild(cd.firstChild);
		}

		// reset div reference.................................................//
		if (cd.parentElement) {
			cd.parentElement.removeChild(cd);
		}
		callout.m_oCallout = null;
	};

	// awake window...........................................................//
	callout.Awake = function(target) {
		if (this.m_refParent) {
			this.Create(target);
		}
		// the target is the id of the dom element tat should be used for......//
		// display.............................................................//
		var scene = this.GetScene();
		if (scene) {
			scene.m_Div = callout.m_oCallout.m_Content;
			scene.Awake(target);
		} else if (VBI.m_bTrace) {
			VBI.Trace("Error: Awake no scene assigned to window");
		}
	};

	return callout;
};

// / legend
// ...........................................................................//
// legend window ............................................................//

VBI.LegendWindow = function() {
	"use strict";

	var legend = new VBI.Window();

// the legend object.....................................................//
	legend.m_oLegend = null; // legend object created in the utilities..//
	legend.m_Props = [];
	legend.m_Data = [];
	legend.m_bRenew = false;
	legend.m_Position = [];
	legend.m_bCreated = false;

// ........................................................................//
// overloaded members.....................................................//

	legend.load = function(dat, ctx) {
		legend.BaseLoad(legend, dat, ctx); // call base function...........//

		legend.m_Props.push(legend.m_DataSource = new VBI.NodeProperty(dat, 'datasource', null, ctx));
		legend.m_Props.push(legend.m_Colors = new VBI.AttributeProperty(dat, 'colors', legend.m_DataSource, ctx));
		legend.m_Props.push(legend.m_Images = new VBI.AttributeProperty(dat, 'images', legend.m_DataSource, ctx));
		legend.m_Props.push(legend.m_Texts = new VBI.AttributeProperty(dat, 'texts', legend.m_DataSource, ctx));
		legend.m_Props.push(legend.m_Tooltips = new VBI.AttributeProperty(dat, 'tooltips', legend.m_DataSource, ctx));
		legend.m_Position = [];
		if (dat.top && dat.right) {
			legend.m_Position.push(parseInt(dat.right, 10));
			legend.m_Position.push(parseInt(dat.top, 10));
		}
	};

	legend.clear = function() {
		// unregister events...................................................//
		legend.UnRegisterEvents();

		// remove from dom.....................................................//
		legend.Remove();

		// call base function..................................................//
		legend.BaseClear();

		legend.m_oLegend = null;
		// call the clear on the properties.................................//
		if (legend.m_Props) {
			for (var nJ = 0; nJ < legend.m_Props.length; ++nJ) {
				legend.m_Props[nJ].clear();
			}
			// destroy the props array.......................................//
			legend.m_Props = [];
		}

		legend.m_Data = [];

	};

	legend.invalidate = function() {
		legend.m_bRenew = true;
	};

// ........................................................................//
// helper functions.......................................................//

	legend.IsValid = function() {
		// the legend is valid when the object is there and the inner div.....//
		// is valid............................................................//
		return (legend.m_oLegend && legend.m_oLegend.m_Div) ? true : false;
	};

	legend.NotifySceneMove = function(scene) {
	};

	legend.NotifySceneZoom = function(scene) {
	};

	legend.LegendChanged = function() {
		// var hs = legend.GetHostingScene();
		var node = legend.m_DataSource.GetCurrentNode(legend.m_Ctx);
		if (node) {
			var l = node.m_dataelements.length;
			if (l != legend.m_Data.length) {
				return true;
			}
			for (var nJ = 0; nJ < l; ++nJ) {
				legend.m_DataSource.Select(nJ);
				var text = legend.m_Texts.GetValueString(legend.m_Ctx);
				if (text != legend.m_Data[nJ].text) {
					return true;
				}
				if (legend.m_Data[nJ].type == 1) { // image
					if (legend.m_Data[nJ].value != legend.m_Images.GetValueString(legend.m_Ctx)) {
						return true;
					}
				} else if (legend.m_Data[nJ].type == 2) { // color
					if (legend.m_Data[nJ].value != legend.m_Colors.GetValueColor(legend.m_Ctx)) {
						return true;
					}
				}
			}
		} else {
			return true;
		}
		return false;
	};

	legend.ApplyData = function() {
		// var hs = legend.GetHostingScene();
		var node = legend.m_DataSource.GetCurrentNode(legend.m_Ctx);
		if (node) {
			var l = node.m_dataelements.length;
			for (var nJ = 0; nJ < l; ++nJ) {
				var col;
				var imageName;

				var obj = {};
				legend.m_DataSource.Select(nJ);
				obj.text = legend.m_Texts.GetValueString(legend.m_Ctx);
				if (obj.text) {
					obj.type = 0; // 0 = text; 1 = image; 2 = color
					imageName = legend.m_Images.GetValueString(legend.m_Ctx);
					if (imageName) {
						obj.type = 1;
						obj.value = imageName;
					} else {
						col = legend.m_Colors.GetValueColor(legend.m_Ctx);
						if (col) {
							obj.type = 2;
							obj.value = col;
						}
					}
					legend.m_Data.push(obj);
				}

			}
		}
	};

	legend.NotifyResize = function() {
		if (legend.m_bCreated) {
			legend.calcMaxHeight();
		}

	};

	legend.NotifyDataChange = function() {

		if (legend.m_Props) {
			for (var nJ = 0, len = legend.m_Props.length; nJ < len; ++nJ) {
				legend.m_Props[nJ].NotifyDataChange(legend.m_Ctx);
			}
		}

		if (legend.LegendChanged()) {
			legend.m_Data = [];

			if (legend.m_oLegend && legend.m_oLegend.m_Table) {
				while (legend.m_oLegend.m_Table.rows.length > 0) {
					legend.m_oLegend.m_Table.deleteRow(-1);
				}
				legend.ApplyData();
				legend.FillContent();
				legend.calcMaxHeight();
			}
		}
	};

	legend.Create = function(target) {
		//IE corner case: where we need to recreate DOM structure, but keep legend data unchanged
		//happens when map is placed in changing tabs for instance (DOM relative hierarchy gets lost in IE only)
		//looks like legend was properly created but parent DOM node is null!
		var updateDomOnly = (legend.m_oLegend && !legend.m_oLegend.m_Div.parentNode);

		if (legend.m_bRenew) {
			legend.m_Data = [];

			if (legend.m_oLegend && legend.m_oLegend.m_Table) {
				while (legend.m_oLegend.m_Table.rows.length > 0) {
					legend.m_oLegend.m_Table.deleteRow(-1);
				}
				legend.ApplyData();
				legend.FillContent();
			}
			legend.m_bRenew = false;
			// assign members......................................................//
		} else if (legend.m_refParent && !legend.m_oLegend || updateDomOnly) {
			// get the hosting scene............................................//
			var hs = legend.GetHostingScene();
			if (hs) {
				// create the legend window......................................//
				// the id is mangled using the control id plus the window id.....//

				var bClickRow = (this.m_Ctx.m_Actions.findAction("Click", hs, legend.m_ID)) ? true : false;
				legend.m_oLegend = VBI.Utilities.CreateLegend(target + "-" + legend.m_ID, 0, legend.m_Caption, 5, bClickRow);

				if (!updateDomOnly) {
					legend.ApplyData();
				}
				legend.FillContent();
				legend.m_Expanded = true;

				// register event handlers.......................................//
				legend.RegisterEvents();

				// try to show it................................................//
				legend.m_oLegend.m_Div = hs.m_LegendLayerDiv.appendChild(legend.m_oLegend.m_Div);
				if (legend.m_Position.length == 2) {
					if (!isNaN(legend.m_Position[0])) {
						legend.m_oLegend.m_Div.style.right = legend.m_Position[0] + "px";
						legend.m_oLegend.m_Div.style.left = '';
					}
					if (!isNaN(legend.m_Position[1])) {
						legend.m_oLegend.m_Div.style.top = legend.m_Position[1] + "px";
					}
				}
				legend.calcMaxHeight();
			}
		}
		legend.m_bCreated = true;
	};

	legend.getId = function(a, b) {
		return legend.m_oLegend.m_Table.id + '-' + b + '-' + a;
	};

	legend.FillContent = function() {
		if (!legend.m_Data.length) {
			return;
		}

		// var hs = legend.GetHostingScene();
		for (var nJ = 0; nJ < legend.m_Data.length; ++nJ) {
			var row = legend.m_oLegend.m_Table.insertRow(-1);
			row.id = legend.getId(nJ, 'content-tablerow');
			var cell_0 = row.insertCell(0);
			var obj = legend.m_Data[nJ];
			if (obj.type == 2) { // color
				var newdiv = VBI.Utilities.CreateGeoSceneDivCSS(legend.getId(nJ, 'content-celldiv'), 'vbi-legend-content-celldiv-square');
				newdiv.style.backgroundColor = obj.value;
				cell_0.appendChild(newdiv);
			} else if (obj.type == 1) { // image
				var image = legend.m_Ctx.GetResources().GetImage(obj.value, null, null, legend.invalidate.bind());
				if (image) {
					var img = image.cloneNode(true);
					img.className = 'vbi-legend-content-celldiv';
					img.id = legend.getId(nJ, 'content-celldiv');
					cell_0.appendChild(img);
				}
			} else {
				cell_0.className = "vbi-legend-content-celltext-group";
				cell_0.colSpan = 2;
				// cell_0.style.paddingLeft = "1rem";
				cell_0.innerHTML = obj.text;
			}
			if (obj.type > 0) {
				var cell_1 = row.insertCell(1);
				cell_1.className = "vbi-legend-content-celltext";
				cell_1.id = legend.getId(nJ, 'content-celltext');
				cell_1.innerHTML = obj.text;
			}
		}
	};

	legend.processtouchend = function(e) {
		document.removeEventListener('touchend', legend.processtouchend, true);
		document.removeEventListener('touchmove', legend.processtouchmove, true);
	};

	legend.processmouseup = function(e) {
		document.removeEventListener('mouseup', legend.processmouseup, true);
		document.removeEventListener('mousemove', legend.processmousemove, true);
	};

	legend.movelegend = function(pos) {
		var newpos = pos.slice(0);

		var hs = legend.GetHostingScene();

		if (newpos[0] < hs.m_Div.clientLeft) {
			newpos[0] = hs.m_Div.clientLeft;
		}

		if (newpos[0] + legend.m_oLegend.m_Div.clientWidth > hs.m_Div.clientLeft + hs.m_Div.clientWidth) {
			newpos[0] = hs.m_Div.clientLeft + hs.m_Div.clientWidth - legend.m_oLegend.m_Div.clientWidth;
		}

		if (newpos[1] < hs.m_Div.clientTop) {
			newpos[1] = hs.m_Div.clientTop;
		}

		if (newpos[1] + legend.m_oLegend.m_Header.clientHeight > hs.m_Div.clientTop + hs.m_Div.clientHeight) {
			newpos[1] = hs.m_Div.clientTop + hs.m_Div.clientHeight - legend.m_oLegend.m_Header.clientHeight;
		}

		jQuery(legend.m_oLegend.m_Div).css('top', newpos[1] + 'px');
		jQuery(legend.m_oLegend.m_Div).css('right', hs.m_Div.clientWidth - legend.m_oLegend.m_Div.clientWidth - newpos[0] + 'px');
		jQuery(legend.m_oLegend.m_Div).css('left', '');
		legend.calcMaxHeight();

	};

	legend.processtouchmove = function(e) {

		var touchobj = e.changedTouches[0]; // reference first touch point for this event
		var x = parseInt(touchobj.pageX, 10);
		var y = parseInt(touchobj.pageY, 10);
		var newpos = [
			x - legend.m_offset[0], y - legend.m_offset[1]
		];
		legend.movelegend(newpos);

	};

	legend.processmousemove = function(e) {
		if (e.which == 1) {
			var newmousepos = [
				e.pageX - legend.m_offset[0], e.pageY - legend.m_offset[1]
			];
			// check if legend is inside scene div
			legend.movelegend(newmousepos);
		}
	};

	legend.processmousedragstart = function(e) {
		if (e.which == 1) {
			legend.m_offset = [
				e.pageX - legend.m_oLegend.m_Div.offsetLeft, e.pageY - legend.m_oLegend.m_Div.offsetTop
			];
			document.addEventListener('mouseup', legend.processmouseup, true);
			document.addEventListener('mousemove', legend.processmousemove, true);

			e.preventDefault();
			e.stopPropagation();
		}
	};

	legend.processtouchdragstart = function(e) {

		var touchobj = e.changedTouches[0]; // reference first touch point
		var startx = parseInt(touchobj.pageX, 10); // get x coord of touch point
		var starty = parseInt(touchobj.pageY, 10); // get y coord of touch point
		legend.m_offset = [
			startx - legend.m_oLegend.m_Div.offsetLeft, starty - legend.m_oLegend.m_Div.offsetTop
		];
		document.addEventListener('touchend', legend.processtouchend, true);
		document.addEventListener('touchmove', legend.processtouchmove, true);

		e.preventDefault();
		e.stopPropagation();

	};

	legend.collapse = function(e) {
		if (legend.m_Expanded) {
			legend.m_oLegend.m_ButtonCol.style.visibility = 'hidden';
			legend.m_oLegend.m_ButtonExp.style.visibility = '';
			legend.m_oLegend.m_Content.style.display = 'none';
			legend.m_Expanded = false;
		}
	};

	legend.calcMaxHeight = function() {
		var scHeight = legend.GetHostingScene().m_Div.clientHeight;
		if (scHeight) {
			var lgHeaderHeight = legend.m_oLegend.m_Header.clientHeight;
			var lgTop = parseInt(legend.m_oLegend.m_Div.style.top, 10);
			var y1 = lgTop + lgHeaderHeight;
			// var scHeight = legend.GetHostingScene().m_Div.clientHeight;
			var diff = scHeight - y1;
			legend.m_oLegend.m_Content.style.maxHeight = diff + "px";
		}
	};

	legend.expand = function(e) {
		if (!legend.m_Expanded) {
			legend.m_oLegend.m_ButtonCol.style.visibility = '';
			legend.m_oLegend.m_ButtonExp.style.visibility = 'hidden';
			legend.m_oLegend.m_Content.style.display = '';
			legend.m_Expanded = true;

		}
	};

	legend.clickTable = function(e) {

		var sourceElement = e.target || e.srcElement;
		var rowNumber;

		var matches = sourceElement.id.match(/\d+/g);
		if (matches && matches.length) {
			rowNumber = matches[matches.length - 1];
		} else {
			matches = sourceElement.parentNode.id.match(/\d+/g);
			if (matches && matches.length) {
				rowNumber = matches[matches.length - 1];
			}

		}

		if (rowNumber) {
			var hs = legend.GetHostingScene();

			var params = {
				row: rowNumber,
				ctrlKey: e.ctrlKey,
				shiftKey: e.shiftKey,
				metaKey: e.metaKey,
				altKey: e.altKey
			};

			var action = null, actions = this.m_Ctx.m_Actions;
			if (hs && actions) {
				action = this.m_Ctx.m_Actions.findAction("Click", hs, legend.m_ID);
			}
			if (action) {
				this.m_Ctx.FireAction(action, hs.m_ID, action.m_refVO, null, params);
			}
		}
	};

	legend.RegisterEvents = function() {
		// register event handlers that event context is the legend...........//
		var funcDragMouse = legend.processmousedragstart.bind(legend);
		legend.m_oLegend.m_Header.onmousedown = funcDragMouse;

		var funcDragTouch = legend.processtouchdragstart.bind(legend);
		legend.m_oLegend.m_Header.ontouchstart = funcDragTouch;

		var funcCollapse = legend.collapse.bind(legend);
		legend.m_oLegend.m_ButtonCol.onclick = funcCollapse;

		var funcExpand = legend.expand.bind(legend);
		legend.m_oLegend.m_ButtonExp.onclick = funcExpand;

		var funcClickTable = legend.clickTable.bind(legend);
		legend.m_oLegend.m_Table.onclick = funcClickTable;

		legend.m_oLegend.m_Header.style.cursor = legend.m_oLegend.m_Table.style.cursor = 'pointer';
	};

	legend.UnRegisterEvents = function() {
		// unregister event handlers...........................................//
		if (!legend.m_oLegend) {
			return;
		}
		if (legend.m_oLegend.m_Header) {
			legend.m_oLegend.m_Header.onmousedown = null;
			legend.m_oLegend.m_Header.ontouchstart = null;
		}

		if (legend.m_oLegend.m_ButtonCol) {
			legend.m_oLegend.m_ButtonCol.onclick = null;
		}
		if (legend.m_oLegend.m_ButtonExp) {
			legend.m_oLegend.m_ButtonExp.onclick = null;
		}
		if (legend.m_oLegend.m_Table) {
			legend.m_oLegend.m_Table.onclick = null;
		}
	};

	legend.Remove = function() {
		var co = legend.m_oLegend;
		if (!co || !co.m_Div) {
			return; // nothing to remove.......................................//
		}

		// remove the legend from dom.........................................//
		var cd = co.m_Div;
		while (cd.firstChild) {
			cd.removeChild(cd.firstChild);
		}

		// reset div reference.................................................//
		if (cd.parentElement) {
			cd.parentElement.removeChild(cd);
		}
		legend.m_oLegend = null;
	};

	// awake window...........................................................//
	legend.Awake = function(target) {
		if (legend.m_refParent) {
			legend.Create(target);
		}
		// the target is the id of the dom element tat should be used for......//
		// display.............................................................//
		var scene = this.GetScene();
		if (scene) {
			// this.m_refScene.m_Div = legend.m_oLegend.m_Content;
			scene.Awake(target);
		} else if (VBI.m_bTrace) {
			VBI.Trace("Error: Awake no scene assigned to window");
		}
	};

	return legend;
};
jQuery.sap.declare('sap.ui.vbm.library-all');
jQuery.sap.declare('sap.ui.vbm.lib.sapactions'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapautomations'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapconfig'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapdataprovider'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapevents'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapgeolocation'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapgeomath'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapgeotool'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapheatmap'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.saplabels'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.saplassotrack'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapmaplayer'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapmapmanager'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapmapprovider'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapnavigation'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapparsing'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sappositioning'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapprojection'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.saprecttrack'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapresources'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapscale'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapscene'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.saputilities'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapvbcluster'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapvbicontext'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapvbmenu'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapvoutils'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapwindow'); // raw module, declared by SAPUI5 'AllInOne' Builder
if ( !jQuery.sap.isDeclared('sap.ui.vbm.ClusterRenderer') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

jQuery.sap.declare('sap.ui.vbm.ClusterRenderer'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/ClusterRenderer",function() {
	"use strict";

	/**
	 * @class Cluster renderer.
	 * @static
	 */
	var ClusterRenderer = {};

	/**
	 * Renders the HTML for the given control, using the provided {@link sap.ui.core.RenderManager}.
	 * 
	 * @param {sap.ui.core.RenderManager} oRm the RenderManager that can be used for writing to the render output buffer
	 * @param {sap.ui.core.Control} oControl an object representation of the control that should be rendered
	 */
	ClusterRenderer.render = function(oRm, oControl) {

		// write the HTML into the render manager
		oRm.write("<div align='center'");
		oRm.writeControlData(oControl);
		oRm.addClass("sapUiVbicluster-main");
		oRm.writeClasses(oControl);

		oRm.writeStyles();
		oRm.write(">"); // span element

		var Id1 = oControl.getId() + "-" + "backgroundcircle";
		var Id2 = Id1 + "-" + "innercircle";

		var col = oControl.getColor();
		var type = oControl.getType();
		sap.ui.core.IconPool.insertFontFaceStyle();
		var iiconVal = oControl.getIcon();
		var icon, icInfo;
		if (iiconVal) {
			icInfo = sap.ui.core.IconPool.getIconInfo(iiconVal);
		} else if (type == sap.ui.vbm.SemanticType.Error) {
			icInfo = sap.ui.core.IconPool.getIconInfo("status-negative");
		} else if (type == sap.ui.vbm.SemanticType.Warning) {
			icInfo = sap.ui.core.IconPool.getIconInfo("status-critical");
		} else if (type == sap.ui.vbm.SemanticType.Success) {
			icInfo = sap.ui.core.IconPool.getIconInfo("status-positive");
		} else {
			icInfo = sap.ui.core.IconPool.getIconInfo("status-inactive");
		}

		if (icInfo) {
			icon = icInfo.content;
		}
		var classOuter, classInner, classTextbox, classIcon;
		if (type == sap.ui.vbm.SemanticType.Error) {
			classOuter = "class = 'sapUiVbicluster-backgroundcircle sapUiVbicluster-border-error'";
			classInner = "class = 'sapUiVbicluster-innercircle sapUiVbicluster-background-error'";
			classIcon = "class = 'sapUiVbicluster-icon sapUiVbicluster-iconLight'";
			classTextbox = "class = 'sapUiVbicluster-textbox sapUiVbicluster-textbox-error'";
		} else if (type == sap.ui.vbm.SemanticType.Warning) {
			classOuter = "class = 'sapUiVbicluster-backgroundcircle sapUiVbicluster-border-warning'";
			classInner = "class = 'sapUiVbicluster-innercircle sapUiVbicluster-background-warning'";
			classIcon = "class = 'sapUiVbicluster-icon sapUiVbicluster-iconLight'";
			classTextbox = "class = 'sapUiVbicluster-textbox sapUiVbicluster-textbox-warning'";
		} else if (type == sap.ui.vbm.SemanticType.Success) {
			classOuter = "class = 'sapUiVbicluster-backgroundcircle sapUiVbicluster-border-success'";
			classInner = "class = 'sapUiVbicluster-innercircle sapUiVbicluster-background-success sapUiVbicluster-inner-light'";
			classIcon = "class = 'sapUiVbicluster-icon sapUiVbicluster-iconSuccess'";
			classTextbox = "class = 'sapUiVbicluster-textbox sapUiVbicluster-textbox-success'";
		} else if (type == sap.ui.vbm.SemanticType.None && col) {
			// not type but color
			classOuter = "class = 'sapUiVbicluster-backgroundcircle' style = 'border-color: " + col + "'";
			classInner = "class = 'sapUiVbicluster-innercircle sapUiVbicluster-inner-light' style = 'border-color: " + col + "'";
			classIcon = "class = 'sapUiVbicluster-icon' style = 'color: " + col + "'";
			classTextbox = "class = 'sapUiVbicluster-textbox' style = 'border-color: " + col + "'";
		} else {
			classOuter = "class = 'sapUiVbicluster-backgroundcircle sapUiVbicluster-border-default'";
			classInner = "class = 'sapUiVbicluster-innercircle sapUiVbicluster-background-default sapUiVbicluster-inner-light'";
			classIcon = "class = 'sapUiVbicluster-icon sapUiVbicluster-iconDefault'";
			classTextbox = "class = 'sapUiVbicluster-textbox sapUiVbicluster-textbox-default'";
		}

		oRm.write("<div id= " + Id1 + " " + classOuter + ">");
		oRm.write("<div id= " + Id2 + " " + classInner + ">");

		if (icon) {
			var IdIcon = oControl.getId() + "-" + "icon";
			oRm.write("<span id= " + IdIcon + " " + classIcon + ">" + icon);
			oRm.write("</span>");
		}

		oRm.write("</div>"); // end of cluster-innercircle
		if ((oControl.getText())) {
			var IdTextbox = oControl.getId() + "-" + "textbox";
			oRm.write("<div id= " + IdTextbox + " " + classTextbox + ">");
			oRm.write("<div>");
			oRm.writeEscaped(oControl.getText());
			oRm.write("</div>");
			oRm.write("</div>");
		}
		oRm.write("</div>"); // end of cluster-backgroundcircle
		oRm.write("</div>");

	};

	return ClusterRenderer;

}, /* bExport= */true);

}; // end of sap/ui/vbm/ClusterRenderer.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.VBIRenderer') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

jQuery.sap.declare('sap.ui.vbm.VBIRenderer'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/VBIRenderer",function() {
	"use strict";

	/**
	 * @class VBI renderer.
	 * @static
	 */
	var VBIRenderer = {};

	/**
	 * Renders the HTML for the given control, using the provided {@link sap.ui.core.RenderManager}.
	 * 
	 * @param {sap.ui.core.RenderManager} oRm the RenderManager that can be used for writing to the render output buffer
	 * @param {sap.ui.core.Control} oControl an object representation of the control that should be rendered
	 */
	VBIRenderer.render = function(oRm, oControl) {
		// console.log( "sap.ui.vbm.VBIRenderer.render.....\r\n");

		// write the HTML into the render manager
		oRm.write("<div");
		oRm.writeControlData(oControl);
		oRm.addClass("vbi-main");
		oRm.writeClasses(oControl);
		oRm.addStyle("width", oControl.getWidth());
		oRm.addStyle("height", oControl.getHeight());

		oRm.writeStyles();
		oRm.write(">"); // span element

		var id = oControl.getId();
		
		if (oControl.getPlugin()) {

			if (oControl.$oldContent.length === 0) {
				// for IE 11 do the regexp test........................................//
				if ((navigator.appName == "Microsoft Internet Explorer") || /(trident)\/[\w.]+;.*rv:([\w.]+)/i.test(navigator.userAgent)) {
					// write the object tag
					oRm.write("<object id='VBI" + id + "'" + " data-sap-ui-preserve='" + id + "' CLASSID='CLSID:00100000-2011-0070-2000-FC7214A1CD7B' " + "width='" + oControl.getWidth() + "' " + "height='" + oControl.getHeight() + "' " +

					">");

					// set a link to the native installer...............................//
					oRm.write("<a href='http://scn.sap.com/community/visual-business' > Get the Visual Business PlugIn.</a>");

					oRm.write("</object>");

				} else {
					// write the embed tag
					oRm.write("<embed id='VBI" + id + "'" + " data-sap-ui-preserve='" + id + "' type='application/x-visualbusiness' " + "width='" + oControl.getWidth() + "' " + "height='" + oControl.getHeight() + "' " + ">");

				}
				// render the information for using the native plugin
			}
		}
		
		oRm.write("<div class='vbi-hidden'>");
			this.renderDependants(oRm, oControl.m_renderList);
		oRm.write("</div>");
		oControl.m_renderList = [];

		oRm.write("</div>");

		// the config is not loaded here any more, due the set config will be.....//
		// called, then queueing or execution will take place.....................//
	};
	
	VBIRenderer.renderDependants = function(oRm, aList) {
		for (var i = 0, oEntry; i < aList.length; ++i) {
			oEntry = aList[i];
			// If the container item already exists, we do not render it anymore
			// We need to find a better solution because the real problem
			// is the fact that we fire the container creation event twice.
			if (!oEntry.control.getDomRef()) {
				oRm.write("<div data='" + oEntry.data + "'>");
				oRm.renderControl(oEntry.control);
				oRm.write("</div>");
			}
		} 
	};

	return VBIRenderer;

}, /* bExport= */true);

}; // end of sap/ui/vbm/VBIRenderer.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.lib.sapvobase') ) {
  jQuery.sap.declare('sap.ui.vbm.lib.sapvobase');
// ...........................................................................//
// VisualObjects namespace...................................................//

// Author: Ulrich Roegelein

// ...........................................................................//
// visual objects are the items that can be placed in a scene................//
// they support full databinding to the visual business datacontext..........//
// ...........................................................................//

// ...........................................................................//
// visual objects............................................................//
// for Utilities, NodeProperties, AttributeProperties and DNDInfo so voutils.//

/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
VBI.VisualObjects = function() {
	"use strict";
	// namespace constants....................................................//
	VBI.EMHandle = 0; // handle edit mode
	VBI.EMBox = 1; // box edit mode

	VBI.HTHANDLE = 0; // hit on design handle
	VBI.HTBOX = 1; // hit in box
	VBI.HTBOXHANDLE = 2; // hit on boxhandle

	var visualobjects = {};
	visualobjects.vbiclass = "VisualObjects";

	// ........................................................................//
	// class factory mapping for objects......................................//

	visualobjects.Factory = {
		"{00100000-2012-0004-B001-64592B8DB964}": function() {
			return new VBI.VisualObjects.Spot();
		},
		"{00100000-2012-0004-B001-C46BD7336A1A}": function() {
			return new VBI.VisualObjects.Route();
		},
		"{00100000-2013-0004-B001-7EB3CCC039C4}": function() {
			return new VBI.VisualObjects.Circle();
		}, // circle
		"{00100000-2013-0004-B001-686F01B57873}": function() {
			return new VBI.VisualObjects.CircleDist();
		}, // distant circle
		"{00100000-2012-0004-B001-383477EA1DEB}": function() {
			return new VBI.VisualObjects.Pie();
		},
		"{00100000-2012-0004-B001-BFED458C3076}": function() {
			return new VBI.VisualObjects.Box();
		},
		"{00100000-2012-0004-B001-F311DE491C77}": function() {
			return new VBI.VisualObjects.Area();
		}, // area
		"{00100000-2012-0004-B001-E180770E8A12}": function() {
			return new VBI.VisualObjects.HeatMap();
		}, // heatmap
		"{00100000-2012-0070-1000-35762CF28B6B}": function() {
			return new VBI.VisualObjects.Dummy();
		}, // collada
		"{00100000-2014-0004-B001-9F1B43BE944A}": function() {
			return new VBI.VisualObjects.Route();
		}, // ext link
		"{00100000-2014-0004-BDA8-87B904609063}": function() {
			return new VBI.VisualObjects.Area();
		}, // ext area
		"{00100000-2012-0004-B001-2297943F0CE6}": function() {
			return new VBI.VisualObjects.Container();
		}, // chartcontainer

		// 2D controls.........................................................//
		"{00100000-2013-1000-1100-50059A6A47FA}": function() {
			return new VBI.VisualObjects.Caption();
		}, // caption ( sectionheader )
		"{00100000-2013-1000-3700-AD84DDBBB31B}": function() {
			return new VBI.VisualObjects.Label();
		}, // label
		"{00100000-2013-1000-2400-D305F7942B98}": function() {
			return new VBI.VisualObjects.Link();
		}, // link
		"{00100000-2013-1000-2200-6B060A330B2C}": function() {
			return new VBI.VisualObjects.Image();
		}, // image
		"{00100000-2013-1000-1200-855B919BB0E9}": function() {
			return new VBI.VisualObjects.Button();
		} // button
	};

	// ........................................................................//
	// class factory mapping for objects......................................//

	visualobjects.Factory3D = {
		"{00100000-2012-0004-B001-BFED458C3076}": function() {
			return new VBI.VisualObjects.Box3D();
		},
		"{00100000-2012-0070-1000-35762CF28B6B}": function() {
			return new VBI.VisualObjects.Dummy();
		} // collada
	};

	// class factory instance creation........................................//
	visualobjects.Factory.CreateInstance = function(clsid) {
		return visualobjects.Factory[clsid]();
	};

	// class factory instance creation........................................//
	visualobjects.Factory3D.CreateInstance = function(clsid) {
		return visualobjects.Factory3D[clsid]();
	};

	// ........................................................................//
	// base class for visual objects..........................................//

	VBI.VisualObjects.Base = {
		// vo properties.......................................................//
		m_Scene: null, // scene backreference...................//

		m_BB: [], // bounding box of the master object.....//
		m_IO: [], // offsets of master for round world.....//

		m_colorHot: 'rgba( 240, 171, 0, 0.5 )', // hot color
		m_defaultColor: 'rgba( 255, 0, 0, 1.0 )', // default color
		m_defaultTooltip: '', // default tooltip

		// members for Labeltext ..............................................//
		m_defaultLabeltext: '', // default labeltext
		m_defaultLabelBgCol: 'rgba(200,200,200,1.0)',
		// m_Label : [],

		// design mode members.................................................//
		m_DH: [], // designmode handles....................//
		m_szHandle: 6, // designmode handle size
		m_Track: null, // track object

		// RichTooltip related members
		m_tt: "", // Tooltip content - string or RichTooltip
		m_pos: "", // position of hot VO - used to calculate RichTooltip visibility
		m_clientX: 0, // offset X - where the RichTooltip should be opened
		m_clientY: 0, // offset Y - where the RichTooltip should be opened

		m_nActiveSelections: 0,

		SetRichTooltip: function(hot) {
			var scene = this.m_Scene;
			var ctx = this.m_Scene.m_Ctx;
			var pos = (this.m_Pos != null) ? this.m_Pos.GetValueVector(ctx) : this.m_PosM.GetValueVector(ctx);

			// In case of RichTooltip, act based on hottness of vo instance
			if (this.m_tt instanceof sap.ui.core.TooltipBase) {

				if (hot) {
					if (this.m_tt != "" && this.m_pos == "") {
						// open RichTooltip
						scene.SetToolTip(this.m_tt, true, this.m_clientX, this.m_clientY);
						this.m_pos = pos;
					}
				} else if (JSON.stringify(this.m_pos) == JSON.stringify(pos)) {
					// close RichTooltip
					scene.SetToolTip(this.m_tt, false);
					this.m_pos = "";
				}

			}
		},

		SetClusteredRichTooltip: function(elem) {
			var scene = this.m_Scene;
			var pos = [
				elem[0], elem[1]
			];
			// In case of RichTooltip, act based on hottness of vo instance
			if (this.m_tt instanceof sap.ui.core.TooltipBase) {

				if (elem.h) {
					if (this.m_tt != "" && elem.m_pos == undefined) {
						// open RichTooltip
						scene.SetToolTip(this.m_tt, true, this.m_clientX, this.m_clientY);
						elem.m_pos = pos;
					}
				} else if (JSON.stringify(elem.m_pos) == JSON.stringify(pos)) {
					// close RichTooltip
					scene.SetToolTip(this.m_tt, false);
					elem.m_pos = undefined;
				}

			}
		},

		LoadDragDropInfo: function(dat, ctx, inst) {
			if (dat.DragSource && dat.DragSource.DragItem) {
				inst.m_DragSourceInfo = new VBI.DnDInfo();
				inst.m_DragSourceInfo.load(dat.DragSource.DragItem, ctx, inst);
			}
			if (dat.DropTarget && dat.DropTarget.DropItem) {
				inst.m_DropTargetInfo = new VBI.DnDInfo();
				inst.m_DropTargetInfo.load(dat.DropTarget.DropItem, ctx, inst);
			}

		},

		// base loading of common properties...................................//
		BaseLoad: function(dat, ctx, inst) {
			if (VBI.m_bTrace) {
				VBI.Trace("BaseLoad");
			}
			inst.m_Props.push(inst.m_HotScale = new VBI.AttributeProperty(dat, 'hotScale', inst.m_DataSource, ctx, [
				1.0, 1.0, 1.0
			]));
			inst.m_Props.push(inst.m_HotDeltaColor = new VBI.AttributeProperty(dat, 'hotDeltaColor', inst.m_DataSource, ctx, null));
			inst.m_Props.push(inst.m_SelectColor = new VBI.AttributeProperty(dat, 'selectColor', inst.m_DataSource, ctx, null));
			inst.m_Props.push(inst.m_NonSelectColor = new VBI.AttributeProperty(dat, 'nonSelectColor', inst.m_DataSource, ctx, null));
			inst.m_Props.push(inst.m_FxSize = new VBI.AttributeProperty(dat, 'fxsize', inst.m_DataSource, ctx, true));
			inst.m_Props.push(inst.m_FxDir = new VBI.AttributeProperty(dat, 'fxdir', inst.m_DataSource, ctx));
			inst.m_Props.push(inst.m_Entity = new VBI.AttributeProperty(dat, 'entity', inst.m_DataSource, ctx, null));

			inst.m_Props.push(inst.m_Labeltext = new VBI.AttributeProperty(dat, 'labelText', inst.m_DataSource, ctx, inst.m_defaultLabeltext));
			inst.m_Props.push(inst.m_LabelBgCol = new VBI.AttributeProperty(dat, 'labelBgColor', inst.m_DataSource, ctx, inst.m_defaultLabelBgCol));
			inst.m_Props.push(inst.m_LabelBrdrCol = new VBI.AttributeProperty(dat, 'labelBorderColor', inst.m_DataSource, ctx, null));
			inst.m_Props.push(inst.m_LabelArrow = new VBI.AttributeProperty(dat, 'labelArrow', inst.m_DataSource, ctx, false));
			inst.m_Props.push(inst.m_LabelRounded = new VBI.AttributeProperty(dat, 'labelRounded', inst.m_DataSource, ctx, false));
			inst.m_Props.push(inst.m_LabelPos = new VBI.AttributeProperty(dat, 'labelPos', inst.m_DataSource, ctx));
			inst.m_Props.push(inst.m_LabelOffset = new VBI.AttributeProperty(dat, 'labelOffset', inst.m_DataSource, ctx, [
				0, 0
			]));
			inst.m_Props.push(inst.m_LabelIcon = new VBI.AttributeProperty(dat, 'labelIcon', inst.m_DataSource, ctx));
			inst.m_Props.push(inst.m_LabelIcBgrdCol = new VBI.AttributeProperty(dat, 'labelIconBgrdCol', inst.m_DataSource, ctx));
			inst.m_Props.push(inst.m_LabelIcTextCol = new VBI.AttributeProperty(dat, 'labelIconTextCol', inst.m_DataSource, ctx));

			inst.m_Props.push(inst.m_DragData = new VBI.AttributeProperty(dat, 'dragdata', inst.m_DataSource, ctx, null));
			if (!VBI.m_bIsMobile) {
				this.LoadDragDropInfo(dat, ctx, inst);
			}
		},

		// .....................................................................//
		// common message handling base functions..............................//

		BaseMousemove: function(event) {
			if (VBI.m_bTrace) {
				VBI.Trace("BaseMousemove");
			}
			// do not handle mouse moves in tracking mode.......................//
			// to prevent from flickering.......................................//
			if (this.m_Track) {
				return false;
			}
			if (!this.GetHitArray) {
				return false;
			}
			if (this.m_Scene.vbiclass == "3DScene") {
				return false;
			}
			// determine the instances that are hit.............................//
			var hits = this.GetHitArray(event.offsetX, event.offsetY);

			var scene = this.m_Scene;
			// set the hot item.................................................//
			if (hits.length > 0) {
				// this can be a design handle as well...........................//
				scene.SetCursor('pointer');
				if (scene.InternalSetHotItem(this, hits[0])) {
					// when the instance has a tooltip then set it...............//
					if (!hits[0].m_Design && this.m_Tooltip) {
						// store tooltip content and offset to use later during VO rendering
						this.m_tt = this.getTooltip(scene.m_Ctx, hits[0]);

						if (VBI.m_bIsRtl) {
							var xy = scene.GetEventVPCoords(event);
							this.m_clientX = xy[0];
						} else {
							this.m_clientX = event.clientX;
						}
						this.m_clientY = event.clientY;

						var tmp = this.m_tt.split("#");
						if (tmp[0] == "rtt") {
							// In case of RichTooltip, save the object to use later
							var id = tmp[1];
							this.m_tt = sap.ui.vbm.VBI.RttMap[id];
						} else {
							// string tooltips will be handled at this point
							scene.SetToolTip(this.m_tt);
						}
					}

					// determine the current cursor dependent on the hit.........//
					var cursor;
					if ((cursor = this.DetailCursor(event, hits[0]))) {
						scene.SetCursor(cursor);
					}
				}
				if (this.m_DragSourceInfo) {
					scene.m_Canvas[scene.m_nLabelIndex].draggable = true;
				}
			} else if (scene.m_Canvas[scene.m_nLabelIndex].draggable == true) {
				scene.m_Canvas[scene.m_nLabelIndex].draggable = false;
			}

			return hits.length > 0 ? true : false;
		},

		BaseContextmenu: function(event) {
			if (VBI.m_bTrace) {
				VBI.Trace("BaseContextmenu");
			}
			if (!this.GetHitArray) {
				return false;
			}
			if (this.m_Scene.vbiclass == "3DScene") {
				return false; // check: handle the event
			}

			// determine the instances that are hit.............................//
			var hits = this.GetHitArray(event.offsetX, event.offsetY);

			// set the hot item.................................................//
			if (hits.length > 0) {
				var scene = this.m_Scene, hn = hits[0];
				var myIndex = this.GetDataIndex(hn.m_Index);
				var action, actions = scene.m_Ctx.m_Actions;
				var directInst; // to be filled for clusters
				var ele = this.m_DataSource.GetIndexedElement(scene.m_Ctx, myIndex);
				if (ele) {
					// check for design handle context menu subscription.............//
					if (actions && hn.m_Design && (hn.m_Hit == VBI.HTHANDLE)) {
						// check if action is subscribed..............................//
						if ((action = actions.findAction("HandleContextMenu", scene, this))) {
							var params = scene.GetEventVPCoordsObj(event);
							params.handle = hn.m_Handle.toString();
							this.m_Scene.m_Ctx.FireAction(action, scene, this, ele, params);

							// prevent from default handling...........................//
							event.preventDefault();
							return true;
						}
					}

					// before we can fire the context menu, check the instance for...//
					// click, a detailed contextmenu can be in an edge or a waypoint.//

					if (this.DetailContextmenu(event, ele, hits[0])) {
						event.preventDefault();
						return true;
					}
				} else {
					// we have an artifical element
					var refElte = this.m_BBRefs[hits[0].m_Index];
					directInst = scene.m_Ctx.m_Clustering.getClusterIdent(scene.m_PreassembledData, refElte.cI, refElte.i);
					ele = this.GetPreassembledElement(hits[0].m_Index);
				}

				// check for subscribed action and raise it......................//
				if (actions) {
					// check if action is subscribed..............................//
					if ((action = actions.findAction("ContextMenu", scene, this))) {
						this.m_Scene.m_Ctx.FireAction(action, scene, this, ele, scene.GetEventVPCoordsObjWithScene(event), directInst);
						event.preventDefault();
						return true;
					}
				}

				// always prevent from default handling when there was a hit.....//
				event.preventDefault();
			}

			return false;
		},

		// .....................................................................//
		// action finding......................................................//

		BaseFindAction: function(name) {
			// check if the edge click is subscribed............................//
			var scene = this.m_Scene, actions = scene.m_Ctx.m_Actions;
			return actions ? actions.findAction(name, scene, this) : null;
		},

		// .....................................................................//
		// common event raising................................................//

		BaseClick: function(event) {
			if (VBI.m_bTrace) {
				VBI.Trace("BaseClick");
			}
			if (!this.GetHitArray) {
				return false;
			}
			var scene = this.m_Scene;
			var hits = this.GetHitArray(event.offsetX, event.offsetY);

			if (scene.vbiclass == "3DScene") {
				return false; // check: handle the event
			}

			// set the hot item and raise click event...........................//
			if (!hits.length) {
				return false;
			}
			var myIndex = this.GetDataIndex(hits[0].m_Index);

			scene.RenderAsync(false); // trigger async rendering....................//

			// determine the data element of the instance that is hit...........//
			// and process selection............................................//
			// shift-key adds selection.........................................//
			// ctrl-key toggle selection........................................//
			// for touch events we always toggle selection state................//

			var ele;
			var directInst; // to be filled for clusters
			if (myIndex >= 0 && (ele = this.m_DataSource.GetIndexedElement(scene.m_Ctx, myIndex))) {
				// set the datanode iterator to the hit element....................//
				this.m_DataSource.Select(myIndex);

				if ((event.type.indexOf("touch") >= 0) || (event.type.indexOf("pointer") >= 0 || ((event.ctrlKey || event.metaKey) && !event.shiftKey))) {
					this.Select(ele, scene.m_Ctx, this.IsSelected(scene.m_Ctx) ? false : true);
				} else if (event.shiftKey) {
					// add it to the selection
					if (!this.IsSelected(scene.m_Ctx)) {
						this.Select(ele, scene.m_Ctx, true);
					}
				} else {
					// and select the single one..................................//
					this.m_nActiveSelections = ele.GlobalSingleSelect();
				}
				if (scene.m_PreassembledData) {
					scene.UpdatePreData4Selected(this.m_nPreDataIndex, this.GetInternalIndex(hits[0].m_Index));
				}
				if (hits[0].m_Handle >= 0) {
					// click on a handle is already fired with sapup event
					event.preventDefault();
					return true;
				} else if (this.IsPosChangeable(scene.m_Ctx)) {
					// when the position is changeable the click should toggle the......//
					// selection mode between box and handle, clicks are not fired......//
					// determine new edit mode.......................................//
					var em = this.m_DataSource.GetEditMode(scene.m_Ctx) == VBI.EMHandle ? VBI.EMBox : VBI.EMHandle;
					if (VBI.m_bTrace) {
						VBI.Trace("SetEditMode: " + em);
					}
					this.m_DataSource.SetEditMode(scene.m_Ctx, em);
					event.preventDefault();
					return true;
				}

				// before we can fire the click, check the instance for detailed....//
				// click, a detailed click can be a click in an edge or waypoint....//

				if (this.DetailClick(event, ele, hits[0])) {
					event.preventDefault();
					return true;
				}
			} else {
				// we have an artifical element
				var refElte = this.m_BBRefs[hits[0].m_Index];
				directInst = scene.m_Ctx.m_Clustering.getClusterIdent(scene.m_PreassembledData, refElte.cI, refElte.i);
				ele = this.GetPreassembledElement(hits[0].m_Index);
			}

			// check for subscribed action and fire event.......................//
			var actions;
			if ((actions = scene.m_Ctx.m_Actions)) {
				var action;
				if ((action = actions.findAction("Click", scene, this))) {
					this.m_Scene.m_Ctx.FireAction(action, scene, this, ele, scene.GetEventVPCoordsObj(event), directInst);
					event.preventDefault();
					return true;
				}
			}

			return false;
		},

		GetPreassembledElement: function(index) {
			return undefined;
		},

		// base routine for hit testing the bounding boxes in the right order..//
		// with taking care about round world behavior.........................//
		// the returned information is an array of hit information objects.....//
		BaseHitTest: function(nsx, nsy, ocb) {
			var tmp, hits = [];

			// returns an array of objects, containing the index and............//
			// other detailed hit data..........................................//
			// hit testing must be done in the reverse order....................//
			// a callback object is used to define the params of the detail hit.//
			// test.............................................................//
			var ptInRect = VBI.Utilities.PtInRect;

			// ..................................................................//
			// do hit testing on all design handles first.......................//
			// the ocb is filled with the required hit information..............//

			var hi = {}; // hit information...................................//
			if (this.BaseDesignHitTest(nsx, nsy, hi)) {
				// design handle hit found.......................................//
				hits.push(hi);
				return hits;
			}

			// check for label hit
			var aLabels = this.getLabelData(false);
			var nJ, nK;
			if (aLabels) {
				for (nJ = 0; nJ < aLabels.length; ++nJ) {
					var lb = aLabels[nJ];
					var rgba = VBI.Types.string2rgba(lb.m_BgColor);
					if (rgba[3] < 0.1 && rgba[4] == 1) {
						// transparent background
						continue; // not as hit considered
					}
					for (nK = 0; nK < lb.m_Pos.length; ++nK) {
						for (var nL = 0; nL < lb.m_Pos[nK].length; nL++) {
							var point = [
								nsx, nsy
							];
							var xPos = lb.m_Pos[nK][nL][0];
							var yPos = lb.m_Pos[nK][nL][1];
							var textRect = [
								xPos, yPos, xPos + lb.m_Width, yPos + lb.m_Height
							];

							if (VBI.Utilities.PtInRect(point, textRect) || (lb.m_Pos[nK][nL].tri && VBI.Utilities.pointInTriangle(lb.m_Pos[nK][nL].tri, point)) || (lb.m_Pos[nK][nL].rc && VBI.Utilities.PtInRect(point, lb.m_Pos[nK][nL].rc))) {
								hits.push({
									m_Index: lb.mIndex,
									m_Entity: this.GetEntity(lb.mIndex, this.m_Scene.m_Ctx)
								});
								return hits; // a label is hit -> no further event processing
							}
						}
					}
				}
			}

			for (nJ = this.m_BB.length - 1; nJ >= 0; --nJ) {
				// loop for data bound instances
				if ((tmp = this.m_BB[nJ])) {
					for (nK = this.m_IO[nJ].length - 1; nK >= 0; --nK) {
						// loop for round world instances
						var off = this.m_IO[nJ][nK];
						if (!ptInRect([
							nsx - off, nsy
						], tmp)) {
							continue;
						}

						// hit test fits..............................................//
						// do detail hittest using callback...........................//
						if (ocb) {
							// do call back, transform coord to master instance........//
							var ret = ocb.m_cb(ocb, nJ, nsx - off, nsy);

							if (ret && ret.m_hit > 0) {
								// this is a hit
								hits.push({
									m_Index: nJ,
									m_Entity: this.GetEntity(nJ, this.m_Scene.m_Ctx),
									m_Detail: ret,
									m_IO: off
								});
								if (ret.m_hit == 1) {
									// 1: true hit, 2: diffuse hit (e.g. transparent objects )
									return hits;
								}
							}
						}
					}
				}
			}
			return hits;
		},

		// clear the vo........................................................//
		clear: function() {
			// call the clear on the properties.................................//
			var nJ;
			if (this.m_Props) {
				for (nJ = 0; nJ < this.m_Props.length; ++nJ) {
					this.m_Props[nJ].clear();
				}
				// destroy the props array.......................................//
				this.m_Props = null;
			}

			// clear drag and drop info
			if (this.m_DragSourceInfo) {
				this.m_DragSourceInfo.clear();
				this.m_DragSourceInfo = null;
			}
			if (this.m_DropTargetInfo) {
				this.m_DropTargetInfo.clear();
				this.m_DropTargetInfo = null;
			}

			// reset the backreference..........................................//
			this.m_Scene = null;

			// reset objects....................................................//
			this.m_Track = null;

			// cleararrays......................................................//
			this.m_BB = null;
			this.m_IO = null;
			this.m_DH = null;

			if (this.m_Label) {
				for (nJ = 0; nJ < this.m_Label.length; ++nJ) {
					this.m_Label[nJ].clear();
				}
				this.m_Label = [];
			}
		},

		// load the basic properties of a visual object........................//
		// Base Impl: Needs to be called with suitable scope or will fail!
		load: function(dat, ctx) {
			// non bindable properties
			if (dat.id) {
				this.m_ID = dat.id;
			}
			// load generic properties here.....................................//
			this.m_Props = [];
			this.m_DragSourceInfo = null;
			this.m_DropTargetInfo = null;
		},

		NotifyDataChange: function(ctx) {
			// iterate through properties and update them due data has changed..//
			if (this.m_Props) {
				for (var nJ = 0, len = this.m_Props.length; nJ < len; ++nJ) {
					this.m_Props[nJ].NotifyDataChange(ctx);
				}
			}

			// set an additional marker for all vos even when not used..........//
			this.m_bChanged = true;

			this.m_nActiveSelections = undefined;
		},

		IsPosChangeable: function(ctx) {
			// determine if position is changeable..............................//
			if (VBI.m_bMouseSupported && this.m_Pos) {
				return this.m_Pos.IsChangeable(ctx);
			}
			return false;
		},

		IsSelected: function(ctx) {
			if (this.m_DataSource) {
				return this.m_DataSource.IsElementSelected(ctx);
			}
			return false;
		},

		GetNumActiveSelections: function(ctx) {
			if (this.m_nActiveSelections === undefined) {
				// DataChanged was called so we have to recalculate the # selections
				this.m_nActiveSelections = 0;
				var currElement = this.m_DataSource.m_nCurElement;
				var node = this.m_DataSource.GetCurrentNode(ctx);
				if (node) {
					for (var nJ = 0, len = node.m_dataelements.length; nJ < len; ++nJ) {
						this.m_DataSource.Select(nJ);
						if (this.IsSelected(ctx)) {
							this.m_nActiveSelections++;
						}
					}
				}
				this.m_DataSource.Select(currElement);
			}

			return this.m_nActiveSelections;
		},

		Select: function(ele, ctx, bSelect) {
			this.m_nActiveSelections = ele.Select(bSelect, this.GetNumActiveSelections(ctx));
		},

		IsHandleMode: function() {
			// checks the current state if handles should be displayed for......//
			// editing..........................................................//
			return this.m_DataSource.GetEditMode(this.m_Scene.m_Ctx) == VBI.EMHandle ? true : false;
		},

		IsBoxMode: function() {
			// checks the current state if a box should be displayed for........//
			// editing..........................................................//
			return this.m_DataSource.GetEditMode(this.m_Scene.m_Ctx) == VBI.EMBox ? true : false;
		},

		IsDataAccepted: function(event) {

			var scene = this.m_Scene;

			// do nothing when tracking is active...............................//
			if (this.m_Track) {
				if (VBI.m_bTrace) {
					VBI.Trace("Error: Track object should be already gone");
				}
				return false;
			}

			if (!this.GetHitArray) {
				return false;
			}
			// determine the instances that are hit.............................//
			var hit, hits = this.GetHitArray(event.offsetX, event.offsetY);

			if (hits.length && (hit = hits[0]).m_Design) {
				return false;
			}

			if (hits.length && scene.m_DragInfo) {
				this.m_DataSource.Select(hit.m_Index);
				if (this.m_DropTargetInfo) {
					var ctx = scene.m_Ctx;
					var aDropItems = this.m_DropTargetInfo.getItemArray(ctx);
					var aDragItems = scene.m_DragInfo.aItems;

					for (var nJ = 0; nJ < aDropItems.length; ++nJ) {
						if (aDragItems.indexOf(aDropItems[nJ]) != -1) {
							try {
								event.dataTransfer.dropEffect = 'copy';
								event.stopPropagation();
								event.preventDefault();

							} catch (err) {
								// just trace the message...........................................//
								if (VBI.m_bTrace) {
									VBI.Trace("Warning: sapvobase.IsDataAccepted exception occured: " + err.message);
								}
							}

							return hit;
						}
					}
				}
			}
			return false;
		},

		GetEntity: function(nIndex, ctx) {
			this.m_DataSource.Select(nIndex);
			return this.m_Entity.GetValueString(ctx);
		},

		IsHot: function(idx) {
			// returns true only when the object itself is hot..................//
			// when design handles are hit no hot state is reported.............//
			var scene = this.m_Scene, hi = scene.m_HotItem;

			// a VO is hot when there is an entity match........................//
			if (hi.m_Entity && hi.m_Entity == this.m_Entity.GetValueString(scene.m_Ctx)) {
				return true;
			}
			// the index does not fit...........................................//
			if (!hi.m_HitObj || hi.m_Index != idx) {
				return false;
			}
			// it is not a hot design handle....................................//
			if (hi.m_Design) {
				return false;
			}
			// the vo does not fit..............................................//
			if (hi.m_VO != this) {
				return false;
			}
			// when no action is subscribed we do not show it as hot............//
// if( !(actions = this.m_Scene.m_Ctx.m_Actions) || !actions.findAction( null, this.m_Scene, this ) )
// return false;

			return true;
		},

		InternalChangeHotItem: function(oldIndex, newIndex) {

		},

		IsClusterable: function() {
			return false;
		},

		GetDataIndex: function(BBIndex) {
			return BBIndex; // overwritten for clusterable VOs
		},

		GetInternalIndex: function(BBIndex) {
			return BBIndex; // overwritten for clusterable VOs
		},

		getTooltip: function(ctx, hitObj) {
			this.m_DataSource.Select(hitObj.m_Index);
			return this.m_Tooltip.GetValueString(ctx);
		},

		getLabelData: function(bRecalc) {
			if (!this.m_Label) {
				return null;
			}
			if (bRecalc) {
				for (var nJ = 0; nJ < this.m_Label.length; nJ++) {
					var lb = this.m_Label[nJ];
					if (lb.CalculateLabelPos && lb.m_PosArray.pa.length > 0) {
						lb.m_Pos = [];
						for (var nK = 0; nK < lb.m_aIO.length; nK++) {

							var aPositions = this.CalculateLabelPos(this.m_Scene, lb.m_PosArray, lb.m_aIO[nK]);
							if (aPositions && aPositions.length > 0) {
								lb.m_Pos.push(aPositions);
							}
						}
						lb.m_bAligned = false;
					}

				}

			}
			return this.m_Label;
		},

		SwitchPreDataRendering: function(bSetSwitch) {
			if (this.bUsePreData != bSetSwitch) {
				this.bUsePreData = bSetSwitch;
				if (bSetSwitch) {
					this.IsHot = this.PreDataIsHot;
					this.GetEntity = this.PreDataGetEntity;
				} else {
					this.IsHot = this.BaseIsHot;
					this.GetEntity = this.BaseGetEntity;
				}
			}
		},

		GetAnimClusterDistance: function(nLOD, fExactLod) {
			var scene = this.m_Scene;
			var nDist = nLOD - fExactLod;
			if (nDist && scene.m_bNonIntPosStable) {
				var ttarget = 1000 * nDist;
				var tm = Date.now() - scene.m_bNonIntPosStable;
				nDist *= (tm < ttarget ? (ttarget - tm) / ttarget : 0);
			}
			scene.m_bLineAnimationRunning = (nDist > 0);

			return nDist;
		},

		RenderTree: function(node, edges, conf, cI, cnt, lod, nDist, dc, dcs, lodF, xOff, yOff, bOmitLeafs) {
			var currentBB = [
				lodF * node.bo[0] - xOff, lodF * node.bo[1] - yOff, lodF * node.bo[2] - xOff, lodF * node.bo[3] - yOff
			];
			var aIO = this.m_Scene.GetInstanceOffsets(currentBB);

			if (aIO.length) { // if current BB is not on screen, all childs are not on screen either
				if (node.lod < lod) {
					for (var i = 0; i < node.bw.length; ++i) {
						cnt = this.RenderTree(node.bw[i], edges, conf, cI, cnt, lod, nDist, dc, dcs, lodF, xOff, yOff, bOmitLeafs);
					}
				} else if (node.isCl) {
					if (this.RenderThisInstance(node, edges, conf, cI, cnt, node.nJ, dc, dcs, lod, nDist, lodF, xOff, yOff, false)) {
						cnt++;
					}
				} else if (!bOmitLeafs) {
					var myVO = this.m_Scene.m_VOS[node.vo];
					myVO.RenderThisInstance(node, edges, conf, cI, myVO.m_BB.length, node.nJ, dc, dcs, lod, nDist, lodF, xOff, yOff, true);
					myVO.SetClusteredRichTooltip(node);
				}
			}
			return cnt;
		},

		Init4Render: function() {

		},

		StandardInit: function() {
			this.m_BB = [];
			this.m_IO = [];
			this.m_DH = [];
		},

		StandardInitWithLPs: function() {
			this.m_BB = [];
			this.m_IO = [];
			this.m_DH = [];
			this.m_LP = [];
		},

		// .....................................................................//
		// design mode rendering...............................................//

		BaseRender: function(canvas, dc) {
			// when there are no design handles to render, return immediately...//
			var ldh = this.m_DH.length;

			if (!ldh) {
				return; // return immediately, no design handles available......//
			}
			var tmp, tdx, tdy;
			var size = this.m_szHandle, hsize = size / 2, sqdistance = 1.5 * size * size;
			var fs = dc.fillStyle;
			var fillShared = 'rgba(232,205,30,0.7)'; // shared handle
			var fillUnique = 'rgba(188,54,24,0.7)'; // unique handle
			var fillHot = 'rgba(229, 66, 30, 1.0 )'; // hot handle

			var hi = this.m_Scene.m_HotItem;

			// render the design mode handles...................................//
			// only when subsequent handles are near a shared handle is rendered//
			// this is not correct in general due the handles should be arranged//
			// in a quadtree and aggregated there...............................//
			// to be done when the quadtree is working fine.....................//

			var aHandles, xy, bSharedHandle = false;
			for (var nJ = 0; nJ < ldh; ++nJ) {
				if (!(aHandles = this.m_DH[nJ])) {
					continue; // no design handles specified for this instance..//
				}
				// even for design handles respect round world behavior..........//
				for (var nK = 0, lio = this.m_IO[nJ].length; nK < lio; ++nK) {
					// transform to round world...................................//
					dc.setTransform(1.0, 0.0, 0.0, 1.0, this.m_IO[nJ][nK], 0.0);

					if (aHandles.m_EditMode == VBI.EMBox) {
						// render the design box...................................//
						if (aHandles.length == 1) {
							xy = aHandles[0]; // xy must be a box...........//
							VBI.Utilities.DrawDesignRect(dc, this.DesignGetActiveBoxHandles(nJ), xy);
						}
					} else {
						dc.fillStyle = fillUnique;
						dc.lineWidth = 1;

						// render the design handles...............................//
						tmp = null; // reset temp point

						if (bSharedHandle) {
							dc.fillStyle = fillUnique; // reset fill color
							bSharedHandle = false; // rest shared handle state
						}

						for (var nL = 0, lh = aHandles.length; nL < lh; ++nL) {
							xy = aHandles[nL];

							// first check for hot handle...........................//
							var hot = (hi.m_VO == this && hi.m_Index == nJ && hi.m_Design && hi.m_HitObj && hi.m_HitObj.m_Handle == nL);

							// when the distance is too small between projected.....//
							// points skip rendering................................//

							if (tmp && (((tdx = (tmp[0] - xy[0])) * tdx) + ((tdy = (tmp[1] - xy[1])) * tdy)) < sqdistance) {
								// rerender the last handle with a different fill....//
								// style using same coordinates......................//
								if (!bSharedHandle) {
									bSharedHandle = true;

									dc.fillStyle = hot ? fillHot : fillShared;
									dc.fill();
								}
								continue;
							}

							// the last rendered item was a shared handle, reset....//
							// props................................................//
							if (bSharedHandle) {
								dc.fillStyle = fillUnique;
								bSharedHandle = false;
							}

							// first check for hot handle...........................//
							if (hot) {
								dc.fillStyle = fillHot; // reset fill color
							}
							// render it............................................//
							dc.beginPath();
							dc.rect(xy[0] - hsize, xy[1] - hsize, size, size);
							dc.closePath();
							dc.fill();

							if (hot) {
								dc.fillStyle = fillUnique; // reset fill color
							}
							// store the tmp........................................//
							tmp = xy;
						}
					}
				}
			}

			// reset style and transforms.......................................//
			dc.fillStyle = fs;
			dc.setTransform(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
		},

		// .....................................................................//
		// design mode mouse processing........................................//

		BaseDesignHitTest: function(nsx, nsy, hi) {
			// hi ( hit info ) gets:
			// m_Index ( vo instance )
			// m_Handle ( handle index )
			// m_NsX ( non scaled x position )
			// m_NsY ( non scaled y position )
			// return true when hit is detected

			if (VBI.m_bTrace) {
				VBI.Trace("BaseDesignHitTest nsx:" + nsx + " nsy:" + nsy + " instance:" + this.m_ID);
			}
			var ldh = this.m_DH.length;
			if (!ldh) {
				return false; // no design handles at all..............//
			}
			var size = this.m_szHandle + 2, hsize = size / 2.0;
			var PtInRect = VBI.Utilities.PtInRect;

			// reset hi.........................................................//
			if (hi.m_Handle) {
				delete hi.m_Handle;
			}
			// check the design mode handles....................................//
			// start from the end, which is the reverse rendering sequence......//
			var aHandles, xy;
			for (var nJ = ldh; nJ >= 0; --nJ) {
				if (!(aHandles = this.m_DH[nJ])) {
					continue;
				}
				for (var nK = 0; nK < this.m_IO[nJ].length; ++nK) {
					var dx = this.m_IO[nJ][nK];

					// check with respect to round world behavior.................//
					if (aHandles.m_EditMode == VBI.EMHandle) {
						if (VBI.m_bTrace) {
							VBI.Trace("BaseDesignHitTest Handle");
						}
						for (var nL = 0, len = aHandles.length; nL < len; ++nL) {
							xy = aHandles[nL];
							if (PtInRect([
								nsx - dx, nsy
							], [
								xy[0] - hsize, xy[1] - hsize, xy[0] + hsize, xy[1] + hsize
							])) {
								if (VBI.m_bTrace) {
									VBI.Trace("BaseDesignHitTest Handle Hit! Index:" + nJ + " Handle: " + nL);
								}
								hi.m_Index = nJ;
								hi.m_Design = true; // flag indicating design handle hit
								hi.m_Hit = VBI.HTHANDLE; // hit on handle
								hi.m_Handle = nL;
								hi.m_NsX = nsx; // store current non scaled x
								hi.m_NsY = nsy; // store current non scaled y
								hi.m_IO = dx;
								return true;
							}
						}
					} else if (aHandles.m_EditMode == VBI.EMBox) {
						if (VBI.m_bTrace && (aHandles.length > 1 || aHandles.length == 0)) {
							VBI.Trace("Error: Box edit mode must fill one rectangle only");
						}
						xy = aHandles[0];
						if (VBI.m_bTrace) {
							VBI.Trace("BaseDesignHitTest Box");
						}
						// check for sizer handles.................................//
						var r2 = 9;
						var w = xy[2] - xy[0];
						var h = xy[3] - xy[1];

						var wh = w / 2;
						var hh = h / 2;

						// determine the active box design handles.................//
						var adh = this.DesignGetActiveBoxHandles(nJ);

						// fill corner arcs........................................//
						for (var x = 0; x < 3; ++x) {
							for (var y = 0; y < 3; ++y) {
								// skip inactive handles.............................//
								if (x == 1 && y == 1) {
									continue;
								}
								if (!adh[y * 3 + x]) {
									continue;
								}
								var ax = xy[0] + x * wh - (nsx - dx);
								var ay = xy[1] + y * hh - (nsy);
								if ((ax * ax + ay * ay) < r2) {
									// 0 1 2 -->y * 3 + x
									// 3 4 5
									// 6 7 8
									hi.m_Index = nJ;
									hi.m_Handle = y * 3 + x;
									hi.m_Design = true; // flag indicating design handle hit
									hi.m_Hit = VBI.HTBOXHANDLE; // it is a box scaling handle
									hi.m_NsX = nsx; // store current non scaled x
									hi.m_NsY = nsy; // store current non scaled y
									hi.m_IO = dx;
									return true;
								}
							}
						}

						// check for content hit...................................//
						if (PtInRect([
							nsx - dx, nsy
						], xy)) {
							if (VBI.m_bTrace) {
								VBI.Trace("BaseDesignHitTest Box Hit! Index:" + nJ);
							}
							hi.m_Index = nJ;
							hi.m_Handle = -1;
							hi.m_Design = true; // flag indicating design handle hit
							hi.m_Hit = VBI.HTBOX; // it the box itself
							hi.m_NsX = nsx; // store current non scaled x
							hi.m_NsY = nsy; // store current non scaled y
							hi.m_IO = dx;
							return true;
						}
					}
				}
			}
			return false;
		},

		// base implementation for all visual objects..........................//
		DesignHandleDrag: function(ocb, event) {
			var scene = this.m_Scene;
			if (VBI.m_bTrace) {
				VBI.Trace("DesignHandleDrag");
			}
			// trace invalid input mode state...................................//
			if (VBI.m_bTrace && (scene.m_nInputMode != VBI.InputModeTrackObject)) {
				VBI.Trace("Error: DesignHandleDrag wrong input mode: " + scene.m_nInputMode);
			}

			if (ocb.m_ClientX != ocb.m_ClientStartX || ocb.m_ClientY != ocb.m_ClientStartY) {
				ocb.m_bDragStart = true;
			}

			if (ocb.m_bDragStart) {
				// select the right datasource element and set the data.............//
				this.m_DataSource.Select(ocb.m_Index);

				// determine the new point information..............................//
				var pos = scene.GetPosFromPoint([
					ocb.m_ClientX - ocb.m_IO, ocb.m_ClientY, 0
				]);
				var posold = scene.GetPosFromPoint([
					ocb.m_ClientStartX - ocb.m_IO, ocb.m_ClientStartY, 0
				]);

				if (this.IsPosChangeable(scene.m_Ctx)) {
					// modify the position or the position array.....................//
					// get the complete data from the context........................//

					// do a clone before modification to get the modified flag in....//
					// data provider set correctly...................................//

					var apos = this.m_Pos.GetValueVector(scene.m_Ctx).slice(0);
					var aposold = ocb.m_PosOrig;
					var idx;
					if (ocb.hasOwnProperty('m_Handle')) {
						if (VBI.m_bTrace) {
							VBI.Trace("DesignHandleDrag Handle");
						}
						// scene.SetToolTip( pos[0] + ";" + pos[1] );
						if (ocb.m_Hit == VBI.HTHANDLE) {
							idx = ocb.m_Handle * 3;
							// only one handle is moved................................//
							apos[idx] = pos[0]; // modify x
							apos[idx + 1] = pos[1]; // modify y
							this.m_Pos.SetValueVector(scene.m_Ctx, apos);
						} else if (ocb.m_Hit == VBI.HTBOXHANDLE) {
							// we are tracking the box handle..........................//
							// 0 1 2
							// 3 4 5
							// 6 7 8

							// do box sizing on the object.............................//
							if (this.DesignBoxSize) {
								this.DesignBoxSize(ocb);
							}
							// scaling is required.....................................//
						} else if (ocb.m_Hit == VBI.HTBOX) {
							if (VBI.m_bTrace) {
								VBI.Trace("DesignHandleDrag Box");
							}
							// calculate the modification in position space............//
							var dposx = (pos[0] - posold[0]);
							var dposy = (pos[1] - posold[1]);

							// all handles should be moved.............................//
							for (var nJ = 0, len = apos.length / 3; nJ < len; ++nJ) {
								// scene.SetToolTip( pos[0] + ";" + pos[1] );

								idx = nJ * 3;
								apos[idx] = aposold[idx] + dposx; // modify x
								apos[idx + 1] = aposold[idx + 1] + dposy; // modify y
							}
							this.m_Pos.SetValueVector(scene.m_Ctx, apos);
						}
					}
				}
			}

			// render again.....................................................//
			scene.RenderAsync(true);
		},

		DesignHandleDrop: function(ocb, event) {
			var scene = this.m_Scene;

			// trace invalid input mode state...................................//
			if (VBI.m_bTrace && scene.m_nInputMode != VBI.InputModeTrackObject) {
				VBI.Trace("Error: DesignHandleDrop wrong input mode: " + scene.m_nInputMode);
			}
			// check for design handle context menu subscription.............//
			var action, actions = scene.m_Ctx.m_Actions;
			if (actions && ocb.m_Design && ocb.m_Handle > -1) {
				// the action is raised whenever a design action has stopped..//
				// for the instanced type.....................................//
				// is it a HandleMoved or a HandleClick action ...............//
				var reqAction = (ocb.m_bDragStart) ? "HandleMoved" : "HandleClick";
				// check if action is subscribed..............................//
				if ((action = actions.findAction(reqAction, scene, this))) {
					var ele;
					if ((ele = this.m_DataSource.GetIndexedElement(scene.m_Ctx, ocb.m_Index))) {
						var params = scene.GetEventVPCoordsObj(event);
						params.handle = ocb.m_Handle.toString();
						params.mode = ocb.m_Hit.toString();
						scene.m_Ctx.FireAction(action, scene, this, ele, params);
					}
				}
			}

			// set the input mode back to default mode..........................//
			scene.SetInputMode(VBI.InputModeDefault);
			scene.RenderAsync(true);

			return true; // the base does just nothing yet, maybe fire event
		},

		DesignHandleEnd: function(ocb, event) {
			// tracking has ended...............................................//
			this.m_Track.UnHook();
			this.m_Track = null;
		},

		DesignGetActiveBoxHandles: function(idx) {
			// return the valid box handles in design mode......................//
			return [
				1, 1, 1, 1, 0, 1, 1, 1, 1
			];
		},

		// .....................................................................//
		// event handlers......................................................//

		onsapsecclick: function(event) {
			return this.BaseContextmenu(event);
		},

		onsapclick: function(event) {
			return this.BaseClick(event);
		},

		onsapmove: function(event) {
			return this.BaseMousemove(event);
		},

		onsapup: function(event) {
			if (!this.m_Track) {
				return false;
			}
			// stop tracking and reset tracking object..........................//
			this.m_Track.UnHook();
			this.m_Track = null;
		},

		onsapdrop: function(event) {
			if (VBI.m_bTrace) {
				VBI.Trace("onsapdrop in base " + event.type);
			}
			var hit;
			if ((hit = this.IsDataAccepted(event))) {
				var scene = this.m_Scene;
				var myIndex = this.GetDataIndex(hit.m_Index);
				var ele = this.m_DataSource.GetIndexedElement(scene.m_Ctx, myIndex);

				var action, actions = scene.m_Ctx.m_Actions;

				// check for subscribed action and raise it......................//
				if (actions) {
					// check if action is subscribed..............................//
					if ((action = actions.findAction("Drop", scene, this))) {
						this.m_Scene.m_Ctx.FireAction(action, scene, this, ele, scene.GetEventDropObjWithScene(event));
						event.preventDefault();
						return true;
					}
				}
				return false;
			}
			return false;
		},

		onsapdrag: function(event) {
			if (VBI.m_bTrace) {
				VBI.Trace("onsapdrag in base " + event.type);
			}
			if (this.IsDataAccepted(event)) {
				return true;
			}
			return false;

		},

		onsapdown: function(event) {
			if (VBI.m_bTrace) {
				VBI.Trace("onsapdown in base " + event.type);
			}
			var scene = this.m_Scene;

			// do nothing when tracking is active...............................//
			if (this.m_Track) {
				if (VBI.m_bTrace) {
					VBI.Trace("Error: Track object should be already gone");
				}
				return true;
			}

			if (scene.vbiclass == "3DScene") {
				return false; // check: handle the event
			}

			if (!this.GetHitArray) {
				return false;
			}
			// determine the instances that are hit.............................//
			var hit, hits = this.GetHitArray(event.offsetX, event.offsetY);

			if (hits.length && (hit = hits[0]).m_Design) {
				// and start tracking............................................//
				if (VBI.m_bTrace) {
					VBI.Trace("Start Tracking on " + this.m_ID + " caused by " + event.type);
				}
				this.m_DataSource.Select(hit.m_Index);

				// a design handle is hit........................................//
				// apply additional callbacks and props to the hit object........//
				hit.m_CBDrag = this.DesignHandleDrag.bind(this);
				hit.m_CBDrop = this.DesignHandleDrop.bind(this);
				hit.m_CBEnd = this.DesignHandleEnd.bind(this);
				hit.m_ClientStartX = event.offsetX;
				hit.m_ClientStartY = event.offsetY;
				hit.m_bDragStart = false;

				// store the original position and handles array due only deltas //
				// would cause numerical instabilities...........................//
				hit.m_PosOrig = scene.GetNearestPosArray(this.m_Pos.GetValueVector(scene.m_Ctx).slice(0));

				scene.SetInputMode(VBI.InputModeTrackObject);
				scene.SetCursor(this.DetailCursor(event, hit));

				// notify the control about start of tracking....................//
				// the application can append additional info....................//
				if (this.DesignBeginDrag) {
					this.DesignBeginDrag(hit);
				}
				this.m_Track = new scene.DesignTrack(hit);

				event.stopPropagation();
				event.preventDefault();
				return true;
			}

			if (hits.length) {
				this.m_DataSource.Select(hit.m_Index);
				if (this.m_DragSourceInfo && !this.m_Pos.IsChangeable(scene.m_Ctx)) {
					var ctx = scene.m_Ctx;
					var aDragItems = this.m_DragSourceInfo.getItemArray(ctx);
					if (aDragItems.length) {
						scene.m_DragInfo = {};
						scene.m_DragInfo.aItems = aDragItems;
						scene.m_DragInfo.strInstance = this.m_DataSource.m_Path + "." + this.m_DataSource.GetCurrentElement().GetKeyValue();
						scene.m_DragInfo.strScene = this.m_Scene.m_ID;
						scene.m_DragInfo.strID = this.m_ID;
						scene.m_DragInfo.strExtData = this.m_DragData.GetValueString(scene.m_Ctx);
						scene.m_DragInfo.bDragStart = false;
						return true;
					}
				}

			}
			return false;
		},

		// overridable functions...............................................//
		// that can be overridden in specific situations.......................//

		DetailClick: function(event, ele, hit) {
			return false;
		},

		DetailContextmenu: function(event, ele, hit) {
			return false;
		},

		DetailCursor: function(event, hit) {
			if (hit.m_Design) {
				if (hit.m_Hit == VBI.HTBOXHANDLE) {
					var cursor = [
						'nw-resize', 'n-resize', 'ne-resize', 'w-resize', '', 'e-resize', 'sw-resize', 's-resize', 'se-resize'
					];
					return cursor[hit.m_Handle];
				} else if (hit.m_Hit == VBI.HTBOX) {
					return 'move';
				}
			}
			// check: other cursors..............................................//
			return 'pointer';
		},

		// base helper functions...............................................//
		GetSelectColor: function(ctx, orgColor) {
			var rhls;
			// determine the select color shift.................................//
			if ((rhls = this.m_SelectColor.GetValueString(ctx))) {
				return this.ApplyDeltaColor(ctx, orgColor, rhls);
			} else {
				return orgColor; // return the original color......................//
			}
		},

		GetNonSelectColor: function(ctx, orgColor) {
			var rhls;
			// determine the select color shift.................................//
			if ((rhls = this.m_NonSelectColor.GetValueString(ctx))) {
				return this.ApplyDeltaColor(ctx, orgColor, rhls);
			} else {
				return orgColor; // return the original color......................//
			}
		},

		GetHotColor: function(ctx, orgColor) {
			var rhls;
			// determine the delta color shift..................................//
			if ((rhls = this.m_HotDeltaColor.GetValueString(ctx))) {
				return this.ApplyDeltaColor(ctx, orgColor, rhls);
			} else {
				return this.m_colorHot; // return the default hot color.............//
			}
		},

		GetAltBorderColor: function(ctx, orgColor) {
			var rhls;
			// determine the select color shift.................................//
			if ((rhls = this.m_AltColorBorder.GetValueString(ctx))) {
				return this.ApplyDeltaColor(ctx, orgColor, rhls);
			} else {
				return this.GetHotColor(ctx, orgColor); // no alternative border (delta) color given -> apply default hot (delta) color
			}
		},

		ApplyDeltaColor: function(ctx, orgColor, rhls) {
			var res;

			var key = orgColor + rhls;
			if (ctx.m_deltacolTable[key] == undefined) {
				// try to parse rhls.............................................//
				if ((res = VBI.Types.string2rhls(rhls))) {
					// we need to convert the original color to a number array....//
					var acol;
					if ((acol = VBI.Types.color2array(orgColor))) {
						var hls = VBI.Utilities.RGB2HLS(acol[0], acol[1], acol[2]);
						var rgb = VBI.Utilities.HLS2RGB(hls[0] + res[0], hls[1] * res[1], hls[2] * res[2]);

						// assemble the rgba string and cut range..................//
						ctx.m_deltacolTable[key] = 'rgba(' + Math.min(Math.round(rgb[0]), 255) + "," + Math.min(Math.round(rgb[1]), 255) + "," + Math.min(Math.round(rgb[2]), 255) + "," + Math.min((res[3] * acol[3]).toString(), 1.0) + ')';
					}
				} else {
					// try to parse explicit color...................................//
					ctx.m_deltacolTable[key] = VBI.Types.string2color(rhls);
				}
			}
			return ctx.m_deltacolTable[key];
		},

		GetHotScale: function(ctx) {
			var ret;
			// determine the hot scale multiplicator............................//
			if ((ret = this.m_HotScale.GetValueVector(ctx))) {
				return ret;
			}
			return [
				1.0, 1.0, 1.0
			];
		},

		RectSelect: function(selectionRect, hits, orgHits) {
			var tmp, offSelectionRect, bFound = false;

			for (var nJ = this.m_BB.length - 1; nJ >= 0; --nJ) {
				// loop for data bound instances
				if ((tmp = this.m_BB[nJ])) {
					for (var nK = this.m_IO[nJ].length - 1; nK >= 0; --nK) {
						// loop for round world instances
						var off = this.m_IO[nJ][nK];
						offSelectionRect = [
							selectionRect[0] - off, selectionRect[1], selectionRect[2] - off, selectionRect[3]
						];
						if (tmp[0] >= offSelectionRect[0] && tmp[1] >= offSelectionRect[1] && tmp[2] <= offSelectionRect[2] && tmp[3] <= offSelectionRect[3]) {
							orgHits.push(nJ);
							hits.push(this.GetDataIndex(nJ));
							bFound = true;
						}
					}
				}
			}
			return bFound;
		},

		LassoSelectCircle: function(aPos, hits, orgHits) {
			var circlePt = [];
			var aOff, theta;
			var bFound = false;
			for (var nJ = this.m_BB.length - 1; nJ >= 0; --nJ) {
				var pointList = [];
				var xy = this.m_BB[nJ].m_Pos;
				var r = this.m_BB[nJ].m_Radius;
				var nSlices = 20;
				for (var nK = 0; nK < nSlices; ++nK) {
					theta = nK * 2 * Math.PI / nSlices;
					circlePt = [
						xy[0] + r * Math.sin(theta), xy[1] + r * Math.cos(theta)
					];
					pointList.push(circlePt);
				}
				aOff = this.m_IO[nJ];
				if (VBI.Utilities.polyInPolygon(aPos, pointList, aOff)) {
					hits.push(nJ);
					orgHits.push(nJ);
					bFound = true;
				}
			}
			return bFound;
		},

		LassoSelect: function(aPos, hits, orgHits) {
			var tmp;
			var bHit = false, bFound = false;
			var nK, nM;
			for (var nJ = this.m_BB.length - 1; nJ >= 0; --nJ) {
				// loop for data bound instances
				if ((tmp = this.m_BB[nJ])) {
					bHit = false;
					for (var nI = this.m_IO[nJ].length - 1; nI >= 0 && !bHit; --nI) {
						// loop for round world instances
						var off = this.m_IO[nJ][nI];
						var bbPointList = [
							[
								(tmp[0] + off), tmp[1]
							], [
								(tmp[2] + off), tmp[1]
							], [
								(tmp[2] + off), tmp[3]
							], [
								(tmp[0] + off), tmp[3]
							]
						];
						// check if one point of bounding box lies inside polygon
						if ((VBI.Utilities.pointInPolygon(aPos, bbPointList[0][0], bbPointList[0][1]))) {
							bHit = true;
							// check if bounding box and lasso have no intersection
							for (nK = 0; nK < bbPointList.length && bHit; nK += 2) {
								// outer loop for BB
								var bb1 = bbPointList[nK];
								var bb2 = bbPointList[nK + 1];
								for (nM = 0; nM < aPos.length && bHit; ++nM) {
									var poly1 = aPos[nM];
									var poly2 = (nM + 1 == aPos.length) ? aPos[0] : aPos[nM + 1];
									VBI.Utilities.LineLineIntersection(bb1, bb2, poly1, poly2, true);
									if ((VBI.Utilities.LineLineIntersection(bb1, bb2, poly1, poly2, true))) {
										bHit = false;
									}
								}
							}
						}
					}
					// push if instance found
					if (bHit) {
						orgHits.push(nJ);
						hits.push(this.GetDataIndex(nJ));
						bFound = true;
					}
				}

			}
			return bFound;
		},

		GetLabel: function(ctx) {
			var label = {};
			var text = this.m_Labeltext.GetValueString(ctx);
			var icon = this.m_LabelIcon.GetValueString(ctx);
			if (text || icon) {
				label.text = text;
				label.icon = icon;
				label.icColor = this.m_LabelIcBgrdCol.GetValueColor(ctx);
				label.icTextColor = this.m_LabelIcTextCol.GetValueColor(ctx);
				label.bgColor = this.m_LabelBgCol.GetValueColor(ctx);
				label.brdrCol = this.m_LabelBrdrCol.GetValueColor(ctx);
				label.arrow = this.m_LabelArrow.GetValueBool(ctx);
				label.rounded = this.m_LabelRounded.GetValueBool(ctx);
				label.offset = this.m_LabelOffset.GetValueVector(ctx);
				label.Align = this.m_LabelPos.GetValueLong(ctx);
				return label;
			} else {
				return null;
			}
		},

		RenderShadowDot: function(dcs, node, lodF, xOff, yOff, sz, zzf) {
			if (node.isCl) {
				for (var i = node.bw.length; i--;) {
					this.RenderShadowDot(dcs, node.bw[i], lodF, xOff, yOff, sz, zzf);
				}
			} else {
				dcs.beginPath();
				dcs.moveTo(zzf[0] * (lodF * node[0] - xOff - sz), zzf[1] * (lodF * node[1] - yOff - sz));
				dcs.lineTo(zzf[0] * (lodF * node[0] - xOff + sz), zzf[1] * (lodF * node[1] - yOff - sz));
				dcs.lineTo(zzf[0] * (lodF * node[0] - xOff + sz), zzf[1] * (lodF * node[1] - yOff + sz));
				dcs.lineTo(zzf[0] * (lodF * node[0] - xOff - sz), zzf[1] * (lodF * node[1] - yOff + sz));
				dcs.closePath();
				dcs.stroke();
			}
		},

		GetRefBorders: function(node, refLength, myLod, lodF) {
			var fExactLOD = this.m_Scene.m_Canvas[0].m_nExactLOD;
			var corr = (fExactLOD == Math.floor(fExactLOD) ? 1 : 0.5);
			var xMiddle, yMiddle, length = refLength;
			var lod = myLod;

			if (node.isCl == 1) { // Grid Based Clustering
				var lu = (node.e[0])[0], rl = (node.e[2])[0];

				xMiddle = (lu[0] + rl[0]) / 2;
				yMiddle = (lu[1] + rl[1]) / 2;
				length = 1.2 * lodF * Math.max(rl[0] - lu[0], rl[1] - lu[1]); // we are bigger than the box

			} else {
				xMiddle = (node.bo[0] + node.bo[2]) / 2;
				yMiddle = (node.bo[1] + node.bo[3]) / 2;
			}
			var radius = corr * length / lodF;

			var rv = [
				xMiddle - radius, xMiddle + radius, yMiddle - radius, yMiddle + radius
			];
			var myNode = node;
			while (myNode.c != undefined) {
				length *= (1 << (lod - myNode.c.lod));
				lod = myNode.c.lod;
				myNode = myNode.c;
				xMiddle = (myNode.bo[0] + myNode.bo[2]) / 2;
				yMiddle = (myNode.bo[1] + myNode.bo[3]) / 2;
				radius = length / lodF;
				rv = [
					Math.max(rv[0], xMiddle - radius), Math.min(rv[1], xMiddle + radius), Math.max(rv[2], yMiddle - radius), Math.min(rv[3], yMiddle + radius)
				];
			}

			return rv;
		},

		GetNextPoint: function(p0, p1, borders, xscr, yscr) {
			var perc, yi;
			if (xscr != 0) {
				var xi = xscr < 0 ? 0 : 1;
				perc = (p0[0] - borders[xi]) / (p0[0] - p1[0]);
				var y = p0[1] + perc * (p1[1] - p0[1]);
				if (yscr == 0 || ((y >= borders[2]) && (y <= borders[3]))) {
					return [
						borders[xi], y, true
					];
				}
				yi = yscr < 0 ? 2 : 3;
				perc = (p0[1] - borders[yi]) / (p0[1] - p1[1]);
				return [
					p0[0] + perc * (p1[0] - p0[0]), borders[yi], false
				];

			}

			if (yscr != 0) {
				yi = yscr < 0 ? 2 : 3;
				perc = (p0[1] - borders[yi]) / (p0[1] - p1[1]);
				return [
					p0[0] + perc * (p1[0] - p0[0]), borders[yi], false
				];
			}
		},

		CheckNextLinePoint: function(p0, p1, borders, index) {
			var isX = (index < 2);
			var ti = isX ? 0 : 1;
			var oi = 1 - ti;
			var perc = (p0[ti] - borders[index]) / (p0[ti] - p1[ti]);
			if ((perc <= 0) || (perc > 1)) {
				return undefined;
			}
			var other = p0[oi] + perc * (p1[oi] - p0[oi]);
			if ((other < borders[2 * oi]) || (other > borders[2 * oi + 1])) {
				return undefined;
			}
			return isX ? [
				borders[index], other
			] : [
				other, borders[index]
			];
		},

		paintLineList: function(dcs, pList, lodF, xOff, yOff, zzf) {
			var first;
			for (var j = 0; j < 4; ++j) {
				var pi = pList[j];
				for (var k = 0; k < pi.length; ++k) {
					if (first == undefined) {
						dcs.moveTo(zzf[0] * (lodF * (pi[k])[0] - xOff), zzf[1] * (lodF * (pi[k])[1] - yOff));
						first = true;
					} else {
						dcs.lineTo(zzf[0] * (lodF * (pi[k])[0] - xOff), zzf[1] * (lodF * (pi[k])[1] - yOff));
					}
				}
			}
		},

		GetNextLinePoint: function(p0, p1, borders, scr, isX) {
			var bCornerReached;
			var ti = isX ? 0 : 1;
			var oi = 1 - ti;
			var bi = 2 * ti + (scr < 0 ? 0 : 1);
			var perc = (p0[ti] - borders[bi]) / (p0[ti] - p1[ti]);
			var other = p0[oi] + perc * (p1[oi] - p0[oi]);
			if (isX) {
				bCornerReached = (other < borders[2]) || (other >= borders[3]);
				return [
					borders[bi], Math.max(Math.min(other, borders[3]), borders[2]), !bCornerReached
				];
			}
			bCornerReached = (other < borders[0]) || (other >= borders[1]);
			return [
				Math.max(Math.min(other, borders[1]), borders[0]), borders[bi], bCornerReached
			];
		},

		doCornerConnection: function(dcs, xOff, yOff, lodF, p0, p1, borders, my0, oth0, my1, oth1, isX, zzf) {
			var lastPoint = this.GetNextLinePoint(p0, p1, borders, my0, isX);
			dcs.lineTo(zzf[0] * (lodF * lastPoint[0] - xOff), zzf[1] * (lodF * lastPoint[1] - yOff));
			if (oth1 && (lastPoint[2] == isX)) {
				// axxis has not switched yet
				lastPoint = this.GetNextLinePoint(p0, p1, borders, oth1, !isX);
				dcs.lineTo(zzf[0] * (lodF * lastPoint[0] - xOff), zzf[1] * (lodF * lastPoint[1] - yOff));
			}
			if (my1 && (oth1 == 0 || oth1 == -oth0)) { // we switched completely to the otherside
				lastPoint = this.GetNextLinePoint(p0, p1, borders, my1, isX);
				lastPoint[2] = !lastPoint[2];
				dcs.lineTo(zzf[0] * (lodF * lastPoint[0] - xOff), zzf[1] * (lodF * lastPoint[1] - yOff));
			}
			return lastPoint;
		},

		RenderAreaFromBox: function(dcs, node, edges, borders, lodF, xOff, yOff, zzf) {
			var clustering = this.m_Scene.m_Ctx.m_Clustering;

			var cPt;
			var pList = [
				[
					[
						borders[1], borders[2]
					]
				], [
					[
						borders[1], borders[3]
					]
				], [
					[
						borders[0], borders[3]
					]
				], [
					[
						borders[0], borders[2]
					]
				]
			];
			var deltaX = borders[1] - borders[0], deltaY = borders[3] - borders[2];
			var cMap = [
				3, 1, 0, 2
			];
			var xMap = [
				1, 1, 0, 0
			];
			var yMap = [
				2, 3, 3, 2
			];
			var x, y;
			var atomNode = node; // will be filled with atomic node when required
			for (var i = 0; i < node.e.length; ++i) {
				var elte = clustering.getEdge(node.e[i], edges);
				var xPts = [], ind = [];
				for (var j = 0; j < 4; ++j) {
					if ((cPt = this.CheckNextLinePoint(elte[0], elte[1], borders, j)) != undefined) {
						ind.push(cMap[j]);
						xPts.push(cPt);
					}
				}
				if (xPts.length == 2) {
					while (atomNode.bw != undefined) {
						atomNode = atomNode.bw[0]; // we just need any of the VOs
					}
					var dist = ((4 + ind[1] - ind[0]) % 4);
					if ((dist % 2) == 1) {
						var src = (dist == 1 ? 0 : 1);
						var trg = 1 - src;
						var p1 = pList[ind[src]];
						if (ind[src] % 2) {
							x = (xPts[trg])[0];
							y = (xPts[src])[1];
						} else {
							x = (xPts[src])[0];
							y = (xPts[trg])[1];
						}
						var target = [
							borders[xMap[ind[src]]], borders[yMap[ind[src]]]
						];
						var xDist = Math.abs(target[0] - x);
						var yDist = Math.abs(target[1] - y);

						var axDist = Math.abs(target[0] - atomNode[0]);
						var ayDist = Math.abs(target[1] - atomNode[1]);
						// var tst = (axDist / xDist) + (ayDist / yDist);
						if (!xDist || !yDist || ((axDist / xDist) + (ayDist / yDist) > 1)) {
							p1.splice(p1.length - 1, 1, xPts[src], xPts[trg]);
						} else {
							var pNext = pList[(ind[src] + 1) % 4];
							pNext.splice(pNext.length - 1, 1, xPts[trg]);
							pNext = pList[(ind[src] + 2) % 4];
							pNext.splice(0, 1, xPts[trg]);
							pNext = pList[(ind[src] - 1) % 4];
							pNext.splice(0, 1, xPts[src]);

						}
					}
					if (dist == 2) {
						while (atomNode.bw != undefined) {
							atomNode = atomNode.bw[0]; // we just need any of the VOs
						}
						var perc;
						if (ind[0] % 2) {// uneven, breaking y-axxises
							var rgt = (ind[0] == 1 ? 0 : 1), lft = 1 - rgt;
							perc = (atomNode[0] - borders[0]) / deltaX;
							var yCut = (1 - perc) * (xPts[rgt])[1] + perc * (xPts[lft])[1];
							if (yCut > atomNode[1]) {
								pList[1].splice(pList[1].length - 1, 1, xPts[rgt]);
								pList[2] = [
									xPts[lft]
								];
							} else {
								pList[3].splice(pList[3].length - 1, 1, xPts[lft]);
								pList[0] = [
									xPts[rgt]
								];
							}
						} else { // even, both cutting x-axxises
							var top = (ind[0] == 0 ? 0 : 1), btm = 1 - top;
							perc = (atomNode[1] - borders[2]) / deltaY;
							var xCut = (1 - perc) * (xPts[btm])[0] + perc * (xPts[top])[0];
							if (xCut > atomNode[0]) {
								pList[0].splice(pList[0].length - 1, 1, xPts[top]);
								pList[1] = [
									xPts[btm]
								];
							} else {
								pList[2].splice(pList[2].length - 1, 1, xPts[btm]);
								pList[3] = [
									xPts[top]
								];
							}
						}
					}
				}
			}
			this.paintLineList(dcs, pList, lodF, xOff, yOff, zzf);
		},

		RenderAreaFromEdges: function(dcs, node, p0, pList, borders, lodF, xOff, yOff, zzf) {
			var p1, l0, l1, lastPoint, newPoint, pFirst = p0;
			var xscr0 = 0, yscr0 = 0;

			dcs.moveTo(zzf[0] * (lodF * p0[0] - xOff), zzf[1] * (lodF * p0[1] - yOff));
			var bOutside = false; // first point is always inside
			var yscr1, xscr1;
			var numEdges = node.e.length - 1;
			for (var i = numEdges; i--;) {
				p1 = p0.ot;
				xscr1 = (p1[0] > borders[1]) - (p1[0] < borders[0]);
				yscr1 = (p1[1] > borders[3]) - (p1[1] < borders[2]);
				if (bOutside) {
					if (xscr1 == 0 && yscr1 == 0) {
						if (xscr0 && yscr0) {
							if ((newPoint = this.GetNextLinePoint(p0, pFirst, borders, lastPoint[2] ? xscr0 : yscr0, lastPoint[2]))) {
								dcs.lineTo(zzf[0] * (lodF * newPoint[0] - xOff), zzf[1] * (lodF * newPoint[1] - yOff));
							}
						}
						newPoint = this.GetNextPoint(p1, p0, borders, xscr0, yscr0);
						dcs.lineTo(zzf[0] * (lodF * newPoint[0] - xOff), zzf[1] * (lodF * newPoint[1] - yOff));
						dcs.lineTo(zzf[0] * (lodF * p1[0] - xOff), zzf[1] * (lodF * p1[1] - yOff));
						bOutside = false;
					} else {
						if (lastPoint[2]) {
							if (xscr0 != xscr1) {
								lastPoint = this.doCornerConnection(dcs, xOff, yOff, lodF, p0, p1, borders, xscr0, yscr0, xscr1, yscr1, true, zzf);
							}

						} else if (yscr0 != yscr1) {
							lastPoint = this.doCornerConnection(dcs, xOff, yOff, lodF, p0, p1, borders, yscr0, xscr0, yscr1, xscr1, false, zzf);
						}

						xscr0 = xscr1;
						yscr0 = yscr1;
					}
				} else if (xscr1 == 0 && yscr1 == 0) {
					dcs.lineTo(zzf[0] * (lodF * p1[0] - xOff), zzf[1] * (lodF * p1[1] - yOff));
				} else {
					lastPoint = this.GetNextPoint(p0, p1, borders, xscr1, yscr1);
					dcs.lineTo(zzf[0] * (lodF * lastPoint[0] - xOff), zzf[1] * (lodF * lastPoint[1] - yOff));
					bOutside = true;
				}

				l1 = p1.li;
				l0 = pList[l1.ot];
				p0 = l0.p;
				xscr0 = xscr1;
				yscr0 = yscr1;
			}

			if (bOutside) {
				if (xscr0 && yscr0) {
					if ((newPoint = this.GetNextLinePoint(p0, pFirst, borders, lastPoint[2] ? xscr1 : yscr1, lastPoint[2]))) {
						dcs.lineTo(zzf[0] * (lodF * newPoint[0] - xOff), zzf[1] * (lodF * newPoint[1] - yOff));
					}
				}
				newPoint = this.GetNextPoint(pFirst, p0, borders, xscr0, yscr0);
				dcs.lineTo(zzf[0] * (lodF * newPoint[0] - xOff), zzf[1] * (lodF * newPoint[1] - yOff));
			}
		},

		FindEndPointInBorders: function(node, pList, p0, borders) {
			var cnt = node.e.length;
			var p1, l1, l0;
			while (cnt) {
				if ((p0[0] >= borders[0]) && (p0[0] <= borders[1]) && (p0[1] >= borders[2]) && (p0[1] <= borders[3])) {
					return p0;
				}
				p1 = p0.ot;
				l1 = p1.li;
				l0 = pList[l1.ot];
				p0 = l0.p;
				cnt--;
			}

			return undefined;
		},

// debugPaintEdges: function(dcs,node, lodF, xOff, yOff)
// {
// dcs.strokeStyle = "rgba(0,255,0,1)"
// var pList = node.e;
// for (var i = pList.length; i--;){
// var edge = pList[i];
// var e1 = edge[0], e2 = edge[1];
// dcs.beginPath();
// dcs.moveTo(lodF * e1[0] - xOff, lodF * e1[1] - yOff);
// dcs.lineTo(lodF * e2[0] - xOff, lodF * e2[1] - yOff);
// dcs.stroke();
// }
// };
//      
// debugPaintBox: function(dcs, borders, lodF, xOff, yOff)
// {
// dcs.strokeStyle = "rgba(255,255,0,0.5)";
// dcs.beginPath();
// dcs.moveTo(lodF * borders[0] - xOff, lodF * borders[2] - yOff);
// dcs.lineTo(lodF * borders[0] - xOff, lodF * borders[3] - yOff);
// dcs.lineTo(lodF * borders[1] - xOff, lodF * borders[3] - yOff);
// dcs.lineTo(lodF * borders[1] - xOff, lodF * borders[2] - yOff);
// dcs.lineTo(lodF * borders[0] - xOff, lodF * borders[2] - yOff);
// dcs.stroke();
// };

		RenderShadowArea: function(dcs, node, edges, refLength, myLod, bSize, bCol, fCol, lodF, xOff, yOff, zzf, nonFill) {
			// this.debugPaintEdges(dcs,node,lodF,xOff,yOff);
			var clustering = this.m_Scene.m_Ctx.m_Clustering;
			var pList;
			if (node.ei != undefined && !nonFill) { // Render fist original borders and then inner borders to do correct fill
				this.RenderShadowArea(dcs, node, edges, refLength, myLod, bSize, bCol, fCol, lodF, xOff, yOff, zzf, true);
				pList = clustering.createEdgeIndex(edges, node.ei);
				dcs.strokeStyle = "rgba(0,0,0,0)";
			} else {
				pList = clustering.createEdgeIndex(edges, node.e);
				dcs.strokeStyle = bCol;
			}

			var borders = this.GetRefBorders(node, refLength, myLod, lodF);

			dcs.lineWidth = bSize;
			dcs.beginPath();

			var p0 = this.FindEndPointInBorders(node, pList, pList[0].p, borders);

			if (p0 == undefined) {
				// no point is in rectangle, so use box centric approach
				this.RenderAreaFromBox(dcs, node, edges, borders, lodF, xOff, yOff, zzf);
			} else { // use standard approach beginning with found edge end point
				this.RenderAreaFromEdges(dcs, node, p0, pList, borders, lodF, xOff, yOff, zzf);
			}

			dcs.closePath();
			if (!nonFill && fCol != undefined) {
				dcs.fillStyle = fCol;
				dcs.fill();
			}
			dcs.stroke();

		},

		RenderShadow: function(dcs, node, edges, conf, nLod, lodF, xOff, yOff) {
			var zzf = this.m_Scene.GetZoomFactor4Mode();
			if (conf.sCol) {
				dcs.strokeStyle = conf.sCol;
				dcs.lineWidth = 2;
				dcs.lineCap = 'round';

				var sz = conf.sSize;
				if (sz == -1) {
					if (node.cnt > 100) {
						sz = 1;
					} else if (node.cnt > 30) {
						sz = 2;
					} else {
						sz = 3;
					}
				}
				if (sz) {
					this.RenderShadowDot(dcs, node, lodF, xOff, yOff, sz, zzf);
				}
			}

			if ((conf.permArea && (node.grI > 1)) || (node.e == undefined) || (nLod < node.lod - 4 && node.c == undefined)) {
				// father node and too far outside -> too many artefacts
				return;
			}

			if (conf.bCol) {
				var refLength = conf.baseConf.m_ref;
				var myLod = conf.baseConf.m_lod;
				if (conf.bCol3) {
					if (node.c && node.c.lod == myLod - 1) {
						this.RenderShadowArea(dcs, node.c, edges, refLength * 2, myLod - 1, 1, conf.bCol3, conf.fCol3, lodF, xOff, yOff, zzf);
					} else {
						this.RenderShadowArea(dcs, node, edges, refLength * 2, myLod - 1, 1, conf.bCol3, conf.fCol3, lodF, xOff, yOff, zzf);
					}
				}
				this.RenderShadowArea(dcs, node, edges, refLength, myLod, conf.bSize, conf.bCol, conf.fCol, lodF, xOff, yOff, zzf);
				if (conf.bCol2 && node.bw) {
					if (nLod == node.lod) {
						for (var i = 0; i < node.bw.length; i++) {
							var bwNode = node.bw[i];
							if (bwNode.e.length > 0) {
								this.RenderShadowArea(dcs, bwNode, edges, refLength / 2, myLod + 1, 1, conf.bCol2, conf.fCol2, lodF, xOff, yOff, zzf);
							}
						}
					} else {
						this.RenderShadowArea(dcs, node, edges, refLength / 2, myLod + 1, 1, conf.bCol2, conf.fCol2, lodF, xOff, yOff, zzf);
					}
				}
			}
		}

	};

	// ........................................................................//
	// spot object............................................................//

	VBI.VisualObjects.Spot = function() {
		// instance constants..................................................//
		this.m_fHotScale = 1.2;

		this.load = function(dat, ctx) {
			// call prototype...................................................//
			Object.getPrototypeOf(this).load.call(this, dat, ctx);

			// load bindable properties.........................................//
			this.m_Props.push(this.m_DataSource = new VBI.NodeProperty(dat, 'datasource', null, ctx));
			this.m_Props.push(this.m_Pos = new VBI.AttributeProperty(dat, 'pos', this.m_DataSource, ctx));
			this.m_Props.push(this.m_Image = new VBI.AttributeProperty(dat, 'image', this.m_DataSource, ctx));
			this.m_Props.push(this.m_ImageSelected = new VBI.AttributeProperty(dat, 'imageSelected', this.m_DataSource, ctx, null));
			this.m_Props.push(this.m_Icon = new VBI.AttributeProperty(dat, 'icon', this.m_DataSource, ctx));
			this.m_Props.push(this.m_Text = new VBI.AttributeProperty(dat, 'text', this.m_DataSource, ctx));
			this.m_Props.push(this.m_Tooltip = new VBI.AttributeProperty(dat, 'tooltip', this.m_DataSource, ctx, this.m_defaultTooltip));
			this.m_Props.push(this.m_Scale = new VBI.AttributeProperty(dat, 'scale', this.m_DataSource, ctx, [
				1.0, 1.0, 1.0
			]));
			this.m_Props.push(this.m_Alignment = new VBI.AttributeProperty(dat, 'alignment', this.m_DataSource, ctx, "5"));
			this.m_Props.push(this.m_ContentColor = new VBI.AttributeProperty(dat, 'contentColor', this.m_DataSource, ctx, "rgb(0,0,0)"));
			this.m_Props.push(this.m_ContentOffset = new VBI.AttributeProperty(dat, 'contentOffset', this.m_DataSource, ctx, [
				0, 0, 0
			]));
			this.m_Props.push(this.m_ContentFont = new VBI.AttributeProperty(dat, 'contentFont', this.m_DataSource, ctx, "arial"));
			this.m_Props.push(this.m_ContentSize = new VBI.AttributeProperty(dat, 'contentSize', this.m_DataSource, ctx, null));

			// load shared properties...........................................//
			this.BaseLoad(dat, ctx, this);
		};

		this.DetailHitTest = function(ocb, nIndex, nsx, nsy) {
			var iname, bHot, bSelected;
			var ctx = ocb.m_Ctx;

			var myIndex = nIndex;
			var hotColor = null;
			var selectColor = null;
			bHot = this.IsHot(myIndex, ctx);

			if (this.bUsePreData) {
				var InstancesOfVO = this.m_Scene.m_PreassembledData.base[this.m_nPreDataIndex];
				var oRef = this.m_BBRefs[nIndex];
				if (oRef.cI != undefined) {
					InstancesOfVO = this.m_Scene.m_PreassembledData.clust[oRef.cI];
				}
				var myInst = InstancesOfVO[oRef.i];

				iname = myInst.im;
				if (bHot) {
					hotColor = myInst.hcol;
				}
				bSelected = myInst.s;
			} else {
				this.m_DataSource.Select(myIndex);
				iname = this.m_Image.GetValueString(ctx);
				if (bHot) {
					hotColor = this.m_HotDeltaColor.GetValueString(ctx);
				}
				bSelected = this.IsSelected(ctx);
				if (bSelected) {
					selectColor = this.m_HotDeltaColor.GetValueString(ctx);
				}
			}

			var image, alpha = 0;
			if ((image = ctx.GetResources().GetImageBits(iname, hotColor, selectColor))) {
				var imageData = image[0];
				var rc = this.m_BB[nIndex]; // get bounds rect

				var width = rc[2] - rc[0];
				var height = rc[3] - rc[1];
				var ix = Math.floor((nsx - rc[0]) / width * image[1]);
				var iy = Math.floor((nsy - rc[1]) / height * image[2]);

				alpha = imageData[(iy * image[1] + ix) * 4 + 3];
			}
			return (alpha > 0) ? {
				m_hit: (alpha == 255 ? 1 : 2)
			} : null;
		};

		this.MatchIcon = function(iiconVal) {
			var iicon = {};
			if (iiconVal) {
				sap.ui.core.IconPool.insertFontFaceStyle();
				switch (iiconVal) {
					case "A8":
						iicon.i = "\ue078";
						iicon.f = "SAP-icons";
						break; // factory / location
					case "7T":
						iicon.i = "\ue075";
						iicon.f = "SAP-icons";
						break; // flight / airplane
					case "7R":
						iicon.i = "\ue08a";
						iicon.f = "SAP-icons";
						break; // cargo-train / train
					case "7Q":
						iicon.i = "\ue0b3";
						iicon.f = "SAP-icons";
						break; // shipping-status / truck
					case "13":
						iicon.i = "\ue1cb";
						iicon.f = "SAP-icons";
						break; // search
					case "89":
						iicon.i = "\ue176";
						iicon.f = "SAP-icons";
						break; // dimension
					case "5X":
						iicon.i = "\ue326";
						iicon.f = "VBI-Icons";
						break; // zone
					case "7S":
						iicon.i = "\ue345";
						iicon.f = "VBI-Icons";
						break; // ship
					default:
						iicon.f = "SAP-icons";
						if (iiconVal.charCodeAt(0) > 255) {
							iicon.i = iiconVal;
						} else {
							var icInfo = sap.ui.core.IconPool.getIconInfo(iiconVal);
							if (icInfo) {
								iicon.i = icInfo.content;
								iicon.f = icInfo.fontFamily;
							}
						}
						break;
				}

			}
			return iicon;
		};

		this.GetHitArray = function(x, y) {
			// determine the array of instances that are hit....................//
			// x and y are the canvas relative coordinates......................//
			var zsf = this.m_Scene.GetStretchFactor4Mode();
			var nsx = x / zsf[0];
			var nsy = y / zsf[0];

			var ocb = {
				m_cb: this.DetailHitTest.bind(this),
				m_Ctx: this.m_Scene.m_Ctx
			};

			// call base function for bounds check..............................//
			return this.BaseHitTest(nsx, nsy, ocb);
		};

		this.GetLabelPos = function(xy, width, height, eal) {
			var al = parseInt(eal != undefined ? eal : "5", 10);

			switch (al) {
				case 0:
					return {
						left: xy[0] - width / 2,
						top: xy[1] - height / 2
					}; // center
				case 8:
					return {
						left: xy[0],
						top: xy[1]
					}; // top left
				case 1:
					return {
						left: xy[0] - width / 2,
						top: xy[1]
					}; // top
				case 2:
					return {
						left: xy[0] - width,
						top: xy[1]
					}; // top right
				case 3:
					return {
						left: xy[0] - width,
						top: xy[1] - height / 2
					}; // right
				case 4:
					return {
						left: xy[0] - width,
						top: xy[1] - height
					}; // bottom right
				case 6:
					return {
						left: xy[0],
						top: xy[1] - height
					}; // bottom left
				case 7:
					return {
						left: xy[0],
						top: xy[1] - height / 2
					}; // left
				case 5:
				default:
					return {
						left: xy[0] - width / 2,
						top: xy[1] - height
					}; // bottom
			}
		};

		// render the single instance..........................................//
		this.RenderThisInstance = function(elem, edges, conf, cI, nIndex, nOrgIndex, dc, dcs, nLod, nDist, lodF, xOff, yOff, bRenderWithLabel) {
			if (VBI.m_bTrace) {
				VBI.Trace("Spot: RenderThisInstance");
			}
			var xy;
			var scene = this.m_Scene;
			var zzf = scene.GetZoomFactor4Mode();

			if (elem.c != undefined && conf.anim && (nLod > conf.animLow) && nDist && elem.c != undefined && elem.c.lod == nLod - 1) {
				var fElem = elem.c;
				var nDist3 = nDist * nDist;

				xy = [
					zzf[0] * (lodF * (elem[0] * (1 - nDist3) + fElem[0] * nDist3) - xOff), zzf[1] * (lodF * (elem[1] * (1 - nDist3) + fElem[1] * nDist3) - yOff)
				];
				if (conf.anim == 2) {
					var xyOrg = [
						zzf[0] * (lodF * fElem[0] - xOff), zzf[1] * (lodF * fElem[1] - yOff)
					];
					var tr = 2 * Math.abs(0.5 - nDist);
					var trans = "" + (1 - tr);
					dc.strokeStyle = "rgba(110,110,110," + trans + ")";
					dc.lineWidth = 2;
					dc.lineCap = 'round';
					dc.beginPath();
					dc.moveTo(xy[0], xy[1]);
					dc.lineTo(xyOrg[0], xyOrg[1]);
					dc.stroke();
				}

			} else {
				xy = [
					zzf[0] * (lodF * elem[0] - xOff), zzf[1] * (lodF * elem[1] - yOff)
				];
			}

			var image = scene.m_Ctx.GetResources().GetImage((elem.s && elem.simag) ? elem.simag : elem.im, elem.s ? elem.scol : null, elem.h ? elem.hcol : null, scene.RenderAsync.bind(scene));
			var scale = elem.sc;
			var text = elem.tx;
			var icon = elem.ic;

			var imgContentFont = elem.ctfont;

			if (!image) {
				return false; // when image is not available do nothing......//
			}
			var clustertext = elem.fs && elem.fz && (elem.cnt != undefined ? "" + elem.cnt : undefined);

			// determine the master box.........................................//
			var zsf = scene.GetStretchFactor4Mode();
			var width = image.naturalWidth * scale[0] / zsf[0];
			var height = image.naturalHeight * scale[1] / zsf[1], originalHeight = height;

			if (elem.h) {
				// determine the hot scale.......................................//
				if (elem.hscale != undefined) {
					width = width * elem.hscale[0];
					height = height * elem.hscale[1];
				}
			}

			var pos = this.GetLabelPos(xy, width, height, elem.al);
			// store the bounding box as a rectangle as array...................//
			// with [left, top, right, bottom]..................................//
			// calc and store the instance offsets..............................//

			var aIO = this.m_IO[nIndex] = scene.GetCorrectedInstanceOffsets(this.m_BB[nIndex] = [
				pos.left, pos.top, pos.left + width, pos.top + height
			], zzf);
			if (!aIO.length) {
				return false;
			}
			this.m_BBRefs.push({
				cI: cI,
				i: nOrgIndex
			});
			if (elem.h) {
				scene.VerifyHotItem(this, this.m_BBRefs.length - 1);
			}

			this.m_BB[nIndex].nI = nOrgIndex;
			// collect design handles...........................................//
			if (this.IsPosChangeable(scene.m_Ctx)) {
				var aDH = this.m_DH[nIndex] = [];
				if (this.IsHandleMode()) {
					aDH.m_EditMode = VBI.EMHandle;
					aDH.push(xy);
				} else if (this.IsBoxMode()) {
					// just push the box points to the design handle array........//
					aDH.m_EditMode = VBI.EMBox;
					aDH.push(this.m_BB[nIndex]);
				}
			}

			// render the images................................................//

			var content, imgContentSize;

			if (text) {
				imgContentSize = Math.floor((elem.ctsz ? elem.ctsz : 12) * height / image.naturalHeight);
				VBI.Utilities.SetTextAttributes(dc, imgContentSize.toString() + "px " + imgContentFont, elem.ctcol, elem.ctcol, "center", "middle");
				content = text;
			} else if (icon) {
				var oIcon = this.MatchIcon(icon);
				if (oIcon && oIcon.i && oIcon.f) {
					imgContentSize = Math.floor((elem.ctsz ? elem.ctsz : 16) * height / image.naturalHeight);
					VBI.Utilities.SetTextAttributes(dc, (imgContentSize ? imgContentSize : 16).toString() + "px " + oIcon.f, elem.ctcol, elem.ctcol, "center", "middle");
					content = oIcon.i;
				}
			}

			var offset, nJ;
			for (nJ = 0; nJ < aIO.length; ++nJ) {
				offset = aIO[nJ];
				if (conf && (elem.h || conf.permArea)) {
					this.RenderShadow(dcs, elem, edges, conf, nLod, lodF, xOff - offset, yOff);
				}
				dc.drawImage(image, pos.left + offset, pos.top, width, height);
				if (content) {
					var off = [
						0, 0, 0
					];
					if (elem.ctoffs && elem.ctoffs.length) {
						off = elem.ctoffs;
					}
					var offsX = off[0] * scale[0] / zsf[0];
					var offsY = off[1] * scale[1] / zsf[1];

					if (elem.h && elem.hscale != undefined) {
						offsX *= elem.hscale[0];
						offsY *= elem.hscale[1];
					}
					dc.fillText(content, pos.left + offset + offsX + width / 2, pos.top + offsY + height / 2);
				}
			}

			if (clustertext) {
				var fontSize = elem.fz ? elem.fz * height / image.naturalHeight : Math.floor(originalHeight / elem.fs);
				VBI.Utilities.SetTextAttributes(dc, (fontSize).toString() + "px " + elem.f, elem.fc, elem.fc, "left", "alphabetic");

				for (nJ = 0; nJ < aIO.length; ++nJ) {
					offset = aIO[nJ];
					dc.fillText(clustertext, width + pos.left + offset + elem.fo / zsf[0], pos.top + elem.foy / zsf[1] + (height + fontSize / 1.5) / 2.0);
				}
			}

			if (bRenderWithLabel == true) {
				if (elem.label && aIO.length) {
					var aLabelPos = {
						pa: [
							xy[0], xy[1], xy[2]
						],
						bb: null
					};
					this.m_Label.push(new VBI.Label(elem.label, nIndex, this.CalculateLabelPos, aLabelPos, this.m_BB[nIndex], aIO));
				}
			}

			return true;
		};

		// render the single instance..........................................//
		this.RenderInstance = function(nIndex, dc, realPos, image, text, scale, hot, label, icon) {
			if (VBI.m_bTrace) {
				VBI.Trace("Spot: RenderInstance");
			}
			if (!image) {
				return; // when image is not available do nothing......//
			}

			var scene = this.m_Scene;
			var zzf = scene.GetZoomFactor4Mode();
			var zsf = scene.GetStretchFactor4Mode();

			// determine the location where to render the main instance.........//
			var xy = scene.GetPointFromPos(realPos, true);
			// determine the master box.........................................//
			var width = image.naturalWidth * scale[0] / zsf[0];
			var height = image.naturalHeight * scale[1] / zsf[1];

			// determine the hot scale.......................................//
			var hs = this.GetHotScale(scene.m_Ctx);
			if (hot) {
				width = Math.round(width * hs[0]);
				height = Math.round(height * hs[1]);
			}

			// adjust left and top according to alignment specified
			var pos = this.GetLabelPos(xy, width, height, this.m_Alignment.GetValueString(scene.m_Ctx));

			// store the bounding box as a rectangle as array...................//
			// with [left, top, right, bottom]..................................//
			// calc and store the instance offsets..............................//
			var aIO = this.m_IO[nIndex] = scene.GetCorrectedInstanceOffsets(this.m_BB[nIndex] = [
				pos.left, pos.top, pos.left + width, pos.top + height
			], zzf);

			// collect design handles...........................................//
			if (this.IsPosChangeable(scene.m_Ctx)) {
				var aDH = this.m_DH[nIndex] = [];
				if (this.IsHandleMode()) {
					aDH.m_EditMode = VBI.EMHandle;
					aDH.push(xy);
				} else if (this.IsBoxMode()) {
					// just push the box points to the design handle array........//
					aDH.m_EditMode = VBI.EMBox;
					aDH.push(this.m_BB[nIndex]);
				}
			}

			// render the images................................................//

			var imgContentCol = this.m_ContentColor.GetValueString(scene.m_Ctx);
			var imgContentOffs = this.m_ContentOffset.GetValueVector(scene.m_Ctx);
			var imgContentFont = this.m_ContentFont.GetValueString(scene.m_Ctx);
			var imgContentSize = this.m_ContentSize.GetValueLong(scene.m_Ctx);

			var content;
			if (text) {
				if (!imgContentSize) {
					// no default and no explicit setting: set size for text
					imgContentSize = 12;
				}
				imgContentSize = imgContentSize * height / image.naturalHeight;
				VBI.Utilities.SetTextAttributes(dc, (Math.floor(imgContentSize)).toString() + "px " + imgContentFont, imgContentCol, imgContentCol, "center", "middle");
				content = text;
			} else if (icon) {
				if (!imgContentSize) {
					// no default and no explicit setting: set size for icon
					imgContentSize = 16;
				}
				imgContentSize = imgContentSize * height / image.naturalHeight;
				var oIcon = this.MatchIcon(icon);
				if (oIcon && oIcon.i && oIcon.f) {
					VBI.Utilities.SetTextAttributes(dc, (Math.floor(imgContentSize)).toString() + "px " + oIcon.f, imgContentCol, imgContentCol, "center", "middle");
					content = oIcon.i;
				}
			}
			for (var nJ = 0; nJ < aIO.length; ++nJ) {
				var offset = aIO[nJ];
				dc.drawImage(image, pos.left + offset, pos.top, width, height);

				if (content) {
					var offsX = imgContentOffs[0] * scale[0] / zsf[0];
					var offsY = imgContentOffs[1] * scale[1] / zsf[1];
					if (hot) {
						offsX *= hs[0];
						offsY *= hs[1];
					}

					dc.fillText(content, pos.left + offset + width / 2 + offsX, pos.top + height / 2 + offsY);
				}
			}
			if (label && aIO.length) {
				var aLabelPos = {
					pa: [
						xy[0], xy[1], xy[2]
					],
					bb: null
				};
				this.m_Label.push(new VBI.Label(label, nIndex, this.CalculateLabelPos, aLabelPos, this.m_BB[nIndex], aIO));
			}

		};

		// Calculate label position for spots
		this.CalculateLabelPos = function(scene, pointarray, instancesOffset) {

			var nLen = Math.floor(pointarray.pa.length / 3) * 3,
				aTmp = [],
				viewportCoord = scene.GetViewport();

			for (var nI = 0; nI < nLen; nI += 3) {
				var pt = [
					pointarray.pa[nI] + instancesOffset, pointarray.pa[nI + 1]
				];
				if (pt[0] > viewportCoord[0] && pt[0] < viewportCoord[2] && pt[1] > viewportCoord[1] && pt[1] < viewportCoord[3]) {
					aTmp.push(pt);
				}
			}

			return aTmp.length ? aTmp : null;
		};

		this.Init4Render = function() {
			this.m_BB = [];
			this.m_IO = [];
			this.m_DH = [];
			this.m_BBRefs = [];
		};

		// Spot.Render with respect to data binding.................................//
		this.Render = function(canvas, dc, preAssembledData, shadow, dcs, bSkipLabel) {
			// clear bounding boxes and instance offsets.......................//

			// get scene .......................................................//
			var scene = this.m_Scene;
			this.SwitchPreDataRendering(preAssembledData != undefined);
			var cntInstances;
			if (this.bUsePreData) {
				if ((preAssembledData.m_nNumIgnore != undefined) && (preAssembledData.m_nNumIgnore == preAssembledData.length)) {
					return 0; // everything to ignore
				}

				var bRenderWithLabel = bSkipLabel ? false : true;
				cntInstances = this.m_BB.length; // might be unequal 0 if entity in a predecessor call
				var fExactLod = scene.m_Canvas[0].m_nExactLOD;
				var xOff = scene.m_Canvas[0].m_nCurrentX * scene.m_MapManager.m_tileWidth;
				var yOff = scene.m_Canvas[0].m_nCurrentY * scene.m_MapManager.m_tileHeight;
				var conf = preAssembledData.config;
				var cI = preAssembledData.cI;
				var fNode = preAssembledData.m_TreeFatherNode;
				var nLOD;
				if (fNode) {
					nLOD = Math.ceil(fExactLod);
					var nDist = this.GetAnimClusterDistance(nLOD, fExactLod);
					cntInstances = this.RenderTree(fNode, preAssembledData.m_edges, conf, cI, cntInstances, nLOD, nDist, dc, dcs, preAssembledData.m_lodOffset, xOff, yOff, false);
				} else {
					nLOD = scene.m_Canvas[0].m_nCurrentLOD;
					var nElements = preAssembledData.length;
					var lodF = preAssembledData.m_lodOffset;
					for (var nL = 0; nL < nElements; ++nL) {
						var elem = preAssembledData[nL];
						if (!elem.b2Ignore) {
							if (this.RenderThisInstance(elem, preAssembledData.m_edges, conf, cI, cntInstances, nL, dc, dcs, nLOD, 0, lodF, xOff, yOff, bRenderWithLabel)) {
								this.SetClusteredRichTooltip(elem);
								cntInstances++;
							}
						}
					}
				}
			} else {
				// determine the binding information................................//
				var ctx = scene.m_Ctx;
				var node, tmp;
				if ((node = this.m_DataSource.GetCurrentNode(ctx))) {
					var len = node.m_dataelements.length;
					// the element count determines the number of rendered instances.//
					for (var nJ = 0; nJ < len; ++nJ) {
						this.m_DataSource.Select(nJ);
						var bHot = this.IsHot(nJ);
						var bSelected = this.IsSelected(ctx);

						// render the instance........................................//
						var ilonlat = this.m_Pos.GetValueVector(ctx);
						var iname = this.m_Image.GetValueString(ctx);

						// when selected we replace the image with the selected image.//
						if (bSelected && (tmp = this.m_ImageSelected.GetValueString(ctx))) {
							iname = tmp;
						}
						var itext = this.m_Text.GetValueString(ctx);
						var iicon = this.m_Icon.GetValueString(ctx);
						var iscale = this.m_Scale.GetValueVector(ctx);

						// it is possible that the image is not loaded, therefore we..//
						// bind the on load function to the renderascyn function of...//
						// the current scene..........................................//
						var image = ctx.GetResources().GetImage(iname, bSelected ? this.m_SelectColor.GetValueString(ctx) : null, bHot ? this.m_HotDeltaColor.GetValueString(ctx) : null, scene.RenderAsync.bind(scene));
						this.RenderInstance(nJ, dc, ilonlat, image, itext, iscale, bHot, this.GetLabel(ctx), iicon);

						// Spot: open or close RichTooltip based on VO instance hotness
						this.SetRichTooltip(bHot);
					}
				}
				// check: do single instance rendering in else branch ...........//

			}

			// call base rendering method.......................................//
			this.BaseRender(canvas, dc);

			return cntInstances; // to increase count of Scaling instances
		};

		this.DesignBeginDrag = function(ocb) {
			// append the original scale to the context.........................//
			ocb.m_ScaleOrig = this.m_Scale.GetValueVector(this.m_Scene.m_Ctx).slice(0);
			ocb.m_DhOrig = this.m_DH[ocb.m_Index].slice(0);
			if (ocb.m_IO) {
				(ocb.m_DhOrig[0])[0] += ocb.m_IO;
				(ocb.m_DhOrig[0])[2] += ocb.m_IO;
			}
		};

		// design overridden members...........................................//
		this.DesignGetActiveBoxHandles = function(idx) {
			// return the valid box handles in design mode......................//
			return [
				1, 1, 1, 1, 0, 1, 0, 0, 0
			];
		};

		this.InternalChangeHotItem = function(nIndex, value, hitItem) {
			if (this.bUsePreData) {
				var oRef = this.m_BBRefs[nIndex];
				if (oRef != undefined) {
					var InstancesOfVO = (oRef.cI != undefined) ? this.m_Scene.m_PreassembledData.clust[oRef.cI] : this.m_Scene.m_PreassembledData.base[this.m_nPreDataIndex];
					if (InstancesOfVO[oRef.i] != undefined) {
						InstancesOfVO[oRef.i].h = value;
						this.m_HotClusterVO = ((value && InstancesOfVO[oRef.i].isCl) ? InstancesOfVO[oRef.i] : undefined);
					}
					if (hitItem) {
						hitItem.cI = value ? oRef.cI : undefined;
						hitItem.nI = value ? oRef.i : undefined;
					}
				}
			}
		};

		this.BaseIsHot = this.IsHot;
		this.PreDataIsHot = function(nIndex, ctx) {
			var oRef = this.m_BBRefs[nIndex];
			var InstancesOfVO = (oRef.cI != undefined) ? this.m_Scene.m_PreassembledData.clust[oRef.cI] : this.m_Scene.m_PreassembledData.base[this.m_nPreDataIndex];
			return InstancesOfVO[oRef.i].h;
		};

		this.BaseGetEntity = this.GetEntity;
		this.PreDataGetEntity = function(nIndex, ctx) {
			this.m_DataSource.Select(nIndex);
			return this.m_Entity.GetValueString(ctx);
		};

		this.SwitchHotItemToStandard = function() {
			var scene = this.m_Scene;

			var oRef = this.m_BBRefs[scene.m_HotItem.m_Index];
			var InstancesOfVO = (oRef.cI != undefined) ? this.m_Scene.m_PreassembledData.clust[oRef.cI] : this.m_Scene.m_PreassembledData.base[this.m_nPreDataIndex];
			var elte = InstancesOfVO[oRef.i];

			if (elte) {
				if (elte.isCl == true) {
					scene.InternalSetHotItem(null, null);
					return elte;
				} else {
					scene.m_HotItem.m_Index = elte.nI;
					if (scene.m_HotItem.m_HitObj) {
						scene.m_HotItem.m_HitObj.m_Index = elte.nI;
					}
					return undefined;
				}
			}
		};

		this.IsClusterable = function() {
			return true;
		};

		this.GetDataIndex = function(BBIndex) {
			if (this.bUsePreData) {
				var oPreData = this.m_BBRefs[BBIndex];
				if (oPreData != undefined) {
					var InstancesOfVO = (oPreData.cI == undefined ? this.m_Scene.m_PreassembledData.base[this.m_nPreDataIndex] : this.m_Scene.m_PreassembledData.clust[oPreData.cI]);
					var elte = InstancesOfVO[oPreData.i];
					if (elte != undefined) {
						return elte.nI;
					}
				}
			}
			return BBIndex;
		};

		this.GetPreassembledElement = function(BBIndex) {
			var oPreData = this.m_BBRefs[BBIndex];
			if (oPreData == undefined) {
				return undefined;
			}
			var InstancesOfVO = (oPreData.cI == undefined ? this.m_Scene.m_PreassembledData.base[this.m_nPreDataIndex] : this.m_Scene.m_PreassembledData.clust[oPreData.cI]);

			return InstancesOfVO[oPreData.i];
		};

		this.GetInternalIndex = function(BBIndex) {
			if (this.bUsePreData) {
				return this.m_BBRefs[BBIndex];
			}
			return BBIndex;
		};

		this.getTooltip = function(ctx, hitObj) {
			this.m_DataSource.Select(this.GetDataIndex(hitObj.m_Index));
			// var test = this.m_DataSource.GetIndexedElement(ctx, this.GetDataIndex(hitObj.m_Index));
			return this.m_Tooltip.GetValueString(ctx);
		};

		this.DesignBoxSize = VBI.Utilities.SceneBindDesignSpotBoxSize.bind(this);
	};
	VBI.VisualObjects.Spot.prototype = VBI.VisualObjects.Base;

	// ........................................................................//
	// route object...........................................................//

	VBI.VisualObjects.Route = function() {
		this.m_LP = []; // array of line point arrays...........//

		this.load = function(dat, ctx) {
			// call prototype...................................................//
			Object.getPrototypeOf(this).load.call(this, dat, ctx);

			// load bindable properties.........................................//
			this.m_Props.push(this.m_DataSource = new VBI.NodeProperty(dat, 'datasource', null, ctx));
			this.m_Props.push(this.m_Pos = new VBI.AttributeProperty(dat, 'posarray', this.m_DataSource, ctx));
			this.m_Props.push(this.m_Scale = new VBI.AttributeProperty(dat, 'scale', this.m_DataSource, ctx));
			this.m_Props.push(this.m_Color = new VBI.AttributeProperty(dat, 'color', this.m_DataSource, ctx, this.m_defaultColor));
			this.m_Props.push(this.m_Start = new VBI.AttributeProperty(dat, 'start', this.m_DataSource, ctx, 0));
			this.m_Props.push(this.m_End = new VBI.AttributeProperty(dat, 'end', this.m_DataSource, ctx, 0));
			this.m_Props.push(this.m_Tooltip = new VBI.AttributeProperty(dat, 'tooltip', this.m_DataSource, ctx, this.m_defaultTooltip));
			this.m_Props.push(this.m_LineWidth = new VBI.AttributeProperty(dat, 'linewidth', this.m_DataSource, ctx, 6.0));
			this.m_Props.push(this.m_DotColor = new VBI.AttributeProperty(dat, 'dotcolor', this.m_DataSource, ctx, this.m_defaultColor));
			this.m_Props.push(this.m_DotBorderColor = new VBI.AttributeProperty(dat, 'dotbordercolor', this.m_DataSource, ctx, this.m_defaultColor));
			this.m_Props.push(this.m_ColorBorder = new VBI.AttributeProperty(dat, 'colorBorder', this.m_DataSource, ctx, null));
			this.m_Props.push(this.m_LineDash = new VBI.AttributeProperty(dat, 'lineDash', this.m_DataSource, ctx, null));
			this.m_Props.push(this.m_DotWidth = new VBI.AttributeProperty(dat, 'dotwidth', this.m_DataSource, ctx, 0.0));
			this.m_Props.push(this.m_Tri = new VBI.AttributeProperty(dat, 'directionIndicator', this.m_DataSource, ctx, 0));

			// load shared properties...........................................//
			this.BaseLoad(dat, ctx, this);
		};

		this.DrawArrow = function(ctx, a, color, colorBorder, lft, rgt, h) {
			// First we check whether there is at least one vertex on the canvas
			if ((a.length < 3) || (Math.max(a[0][0], a[1][0], a[2][0]) < lft) || (Math.max(a[0][1], a[1][1], a[2][1]) < 0) || (Math.min(a[0][0], a[1][0], a[2][0]) > rgt) || (Math.min(a[0][1], a[1][1], a[2][1]) > h)) {
				return;
			}
			ctx.beginPath();
			ctx.moveTo(a[0][0], a[0][1]);
			ctx.lineTo(a[1][0], a[1][1]);
			ctx.lineTo(a[2][0], a[2][1]);
			ctx.lineTo(a[0][0], a[0][1]);
			ctx.closePath();
			if (colorBorder) {
				ctx.strokeStyle = colorBorder;
				ctx.lineWidth = 2;
				ctx.stroke();
			}
			ctx.fillStyle = color;
			ctx.fill();

		};

		this.CalcTriangle = function(ptStart, ptEnd, arrowlength, arrowwidth, result, bRev, bInter, nLw) {
			var dx = ptEnd[0] - ptStart[0];
			var dy = ptEnd[1] - ptStart[1];

			while ((Math.abs(dx) > 1000.0) && (Math.abs(dy) > 1000.0)) {
				dx /= 1000.0;
				dy /= 1000.0;
			}

			var l = Math.sqrt(dx * dx + dy * dy); // length

			var ldx = (dx * arrowlength) / l; // normalize and scale
			var ldy = (dy * arrowlength) / l;

			var wdx = (dx * arrowwidth / 2) / l; // normalize and scale
			var wdy = (dy * arrowwidth / 2) / l;

			var wInterx, wIntery;
			if (bInter) {
				// we need two additional points to mark the line where the route meets the base point of the triangle
				wInterx = (dx * nLw / 2) / l; // normalize and scale
				wIntery = (dy * nLw / 2) / l;
			}
			// calc first point for array rendering.............................//
			var ptx = ptStart[0] + ldx;
			var pty = ptStart[1] + ldy;

			// we return the first index to render in the line..................//
			if (!bRev) {
				result.ta = [
					[
						ptStart[0], ptStart[1]
					], // first start pos
					[
						ptx + wdy, pty - wdx
					], // top arrow point
					[
						ptx - wdy, pty + wdx
					]
				]; // bottom arrow point

				result.pt = [
					ptx, pty, 0
				]; // base point
				if (bInter) {
					result.int = [
						[
							ptx + wIntery, pty - wInterx
						], [
							ptx - wIntery, pty + wInterx
						]
					];
				}
			} else {
				result.ta = [
					[
						ptx, pty, 0
					], // first start pos
					[
						ptStart[0] + wdy, ptStart[1] - wdx
					], // top arrow point
					[
						ptStart[0] - wdy, ptStart[1] + wdx
					]
				]; // bottom arrow point

				result.pt = [
					ptStart[0], ptStart[1]
				]; // base point
				if (bInter) {
					result.int = [
						[
							ptStart[0] + wIntery, ptStart[1] - wInterx
						], [
							ptStart[0] - wIntery, ptStart[1] + wInterx
						]
					];
				}

			}

		};

		this.getArrowLength = function(lw) {
			return (Math.min(15, lw * 5));
		};
		this.getArrowWidth = function(lw) {
			return (Math.min(Math.max(8, lw * 3), lw + 8));
		};

		this.CalcArrowIntermediate = function(aLinePoints, ptStart, nOffset, linewidth, start, end, bBorder) {
			var pt1 = ptStart;
			var bRet = false;
			var off = nOffset;
			var arrowwidth = this.getArrowWidth(linewidth);
			var arrowlength = this.getArrowLength(linewidth);
			var arrowlengthQ = arrowlength * arrowlength;
			var count = 0;// counters
			var tdx, tdy, dist;
			var ptXyz = [
				0, 0, 0
			];
			var result;
			var nJ;

			dist = 0;
			if (start) {
				result = {};
				count = 0;
				for (nJ = off; nJ < aLinePoints.length; ++nJ) {
					ptXyz = aLinePoints[nJ];
					tdx = pt1[0] - ptXyz[0];
					tdy = pt1[1] - ptXyz[1];
					dist = tdx * tdx + tdy * tdy;
					if (dist > arrowlengthQ) {
						this.CalcTriangle(pt1, ptXyz, arrowlength, arrowwidth, result, false, bBorder, linewidth);
						aLinePoints.m_aArrows.push(result);
						bRet = true;
						break;
					} else {
						count++; // count the points to be removed from the array
					}
				}
				if (result.pt) {
					// finally remove the points between arrow head and base from the array and add the new points ( arrowhead and base )
					aLinePoints.splice(off, count, pt1, result.pt);
					off = off + 2;
					pt1 = result.pt;
				}
			}
			if (end) {
				// calculate the next offset where to start
				var bS = true;
				var tmp1 = pt1;
				var tmp2 = aLinePoints[off];
				var w = this.getArrowWidth(linewidth);
				var tl = 0;
				var l;
				pt1 = [];
				while (bS && off < aLinePoints.length) {
					tdx = (tmp2[0] - tmp1[0]);
					tdy = (tmp2[1] - tmp1[1]);
					l = Math.sqrt(tdx * tdx + tdy * tdy);
					if (tl + l > w) {
						bS = false;
						// calculate intermediate point
						var tx = tdx / (tl + l) * w;
						var ty = tdy / (tl + l) * w;
						pt1 = [
							tmp1[0] + tx, tmp1[1] + ty, 0
						];
					} else {
						tl += l;
						off++;
						tmp1 = tmp2;
						tmp2 = aLinePoints[off];
					}
				}
				if (pt1.length) {
					result = {};
					count = 0;
					for (nJ = off; nJ < aLinePoints.length; ++nJ) {
						ptXyz = aLinePoints[nJ];
						tdx = pt1[0] - ptXyz[0];
						tdy = pt1[1] - ptXyz[1];
						dist = tdx * tdx + tdy * tdy;
						if (dist > arrowlengthQ) {
							this.CalcTriangle(pt1, ptXyz, arrowlength, arrowwidth, result, true, bBorder, linewidth);
							aLinePoints.m_aArrows.push(result);
							bRet = true;
							break;
						} else {
							count++; // count the points to be removed from the array
						}
					}
					if (result.pt) {
						// finally remove the points between arrow head and base from the array and add the new points ( arrowhead and base )
						aLinePoints.splice(off, count, pt1, [
							result.ta[0][0], result.ta[0][1], 0
						]);
						off = off + 2;
					}
				}
			}

			if (bRet) {
				return off - 1;
			}
			return -1;
		};

// this.CalcArrowIntermediate = function(aLinePoints, ptStart, nOffset, linewidth, start, end, bBorder) {
// var pt1 = ptStart;
// var bRet = false;
// var off = nOffset;
// var arrowwidth = this.getArrowWidth(linewidth);
// var arrowlength = this.getArrowLength(linewidth);
// var arrowlengthQ = arrowlength * arrowlength;
// var count = 0;// counters
// var tdx, tdy, dist;
// var ptXyz = [
// 0, 0, 0
// ];
// var result;
//
// dist = 0;
// if (start) {
// result = {};
// count = 0;
// for (var nJ = off; nJ < aLinePoints.length; ++nJ) {
// ptXyz = aLinePoints[nJ];
// tdx = pt1[0] - ptXyz[0];
// tdy = pt1[1] - ptXyz[1];
// dist = tdx * tdx + tdy * tdy;
// if (dist > arrowlengthQ) {
// this.CalcTriangle(pt1, ptXyz, arrowlength, arrowwidth, result, false);
// aLinePoints.m_aArrows.push(result);
// bRet = true;
// break;
// } else {
// count++; // count the points to be removed from the array
// }
// }
// if (result.pt) {
// // finally remove the points between arrow head and base from the array and add the new points ( arrowhead and base )
// aLinePoints.splice(off, count, pt1, result.pt);
// off = off + 2;
// if (end) {
// if (bBorder) {
// // one pixel ahead to adjust the second triangle due to border!!
// tdx = (result.pt[0] - pt1[0]) / arrowlength * (arrowlength + 1);
// tdy = (result.pt[1] - pt1[1]) / arrowlength * (arrowlength + 1);
// pt1[0] += tdx;
// pt1[1] += tdy;
// } else {
// pt1 = result.pt;
// }
// }
// }
// }
// if (end) {
// result = {};
// count = 0;
// for (var nJ = off; nJ < aLinePoints.length; ++nJ) {
// ptXyz = aLinePoints[nJ];
// tdx = pt1[0] - ptXyz[0];
// tdy = pt1[1] - ptXyz[1];
// dist = tdx * tdx + tdy * tdy;
// if (dist > arrowlengthQ) {
// this.CalcTriangle(pt1, ptXyz, arrowlength, arrowwidth, result, true);
// aLinePoints.m_aArrows.push(result);
// bRet = true;
// break;
// } else {
// count++; // count the points to be removed from the array
// }
// }
// if (result.pt) {
// // finally remove the points between arrow head and base from the array and add the new points ( arrowhead and base )
// aLinePoints.splice(off, count, pt1, [
// result.ta[0][0], result.ta[0][1], 0
// ]);
// off = off + 2;
// }
// }
//
// if (bRet) {
// return off - 1;
// }
// return -1;
// };

		this.CalcArrow = function(pointarray, lt, rb, linewidth, reverse, result) {
			var arrowwidth = this.getArrowWidth(linewidth);
			var arrowlength = this.getArrowLength(linewidth);
			var nItems = pointarray.length / 3;

			var tdx, tdy, dist = arrowlength * arrowlength; // quad distance
			// first check bounding box, whether further checks make sense at all
			if (((tdx = (lt[0] - rb[0])) * tdx + (tdy = (lt[1] - rb[1])) * tdy) < dist) {
				return false;
			}

			var nJ, nOffset; // counters
			var start, xyz = [
				0, 0, 0
			]; // positions
			var bFound = false;

			// determine the start point........................................//
			nOffset = reverse ? 3 * (nItems - 1) : 0;
			start = [
				pointarray[nOffset], pointarray[nOffset + 1], 0.0
			];

			// iterate dependent on reverse flag................................//
			var nEnd = 3 * nItems;
			for (nJ = 3; nJ < nEnd; nJ += 3) {
				nOffset = reverse ? nEnd - 3 - nJ : nJ;
				xyz = [
					pointarray[nOffset], pointarray[nOffset + 1], 0.0
				];

				// when the distance is too small between projected points.......//
				// skip rendering................................................//
				if (((tdx = (start[0] - xyz[0])) * tdx + (tdy = (start[1] - xyz[1])) * tdy) > dist) {
					bFound = true;
					break;
				}
			}

			if (!bFound) {
				return false; // makes no sense to render an arrow..//
			}

			this.CalcTriangle(start, xyz, arrowlength, arrowwidth, result, false, false, 0);
			result.idx = nOffset;

			return true;
		};

		this.CalculateLabelPos = function(scene, pointarray, offset) {
			var pts = VBI.Utilities.GetMidpointsForLine(pointarray.pa, offset, scene.GetViewport());
			return pts.aPos;
		};

		this.LassoSelect = function(aPos, hits, orgHits) {
			var pointList, routePt, aOff;
			var bFound = false;
			for (var nJ = this.m_LP.length - 1; nJ >= 0; --nJ) {
				pointList = this.m_LP[nJ];
				aOff = this.m_IO[nJ];
				var bEnclosed = false;
				for (var nL = 0; nL < aOff.length; ++nL) {
					if (bEnclosed) {
						break;
					}
					for (var nK = 0; nK < pointList.length; ++nK) {
						routePt = pointList[nK];
						if (!(bEnclosed = VBI.Utilities.pointInPolygon(aPos, routePt[0] + aOff[nL], routePt[1]))) {
							break;
						}
					}
				}
				if (bEnclosed) {
					hits.push(nJ);
					orgHits.push(nJ);
					bFound = true;
				}
			}
			return bFound;
		};

		this.RenderInstance = function(nIndex, dc, bHot, ctx) {
			var zzf = this.m_Scene.GetZoomFactor4Mode();

			// create a subarray linepoints...............................//
			this.m_LP[nIndex] = [];

			// create design handlearrays.................................//
			// they are filled in the render step.........................//
			var editMode;
			if (this.IsPosChangeable(ctx)) {
				// tag the array with the current mode.....................//
				this.m_DH[nIndex] = [];
				if (this.IsHandleMode()) {
					editMode = VBI.EMHandle;
				} else if (this.IsBoxMode()) {
					editMode = VBI.EMBox;
				}
			}
			var bSelected = this.IsSelected(ctx);

			// render the instance........................................//
			var pa = this.m_Pos.GetValueVector(ctx);

			var scene = this.m_Scene;
			if (pa.cache == undefined) {
				scene.FillPositionCache(pa);
			}

			var col = this.m_Color.GetValueColor(ctx);
			if (bSelected) {
				col = this.GetSelectColor(ctx, col);
			}
			if (bHot) {
				col = this.GetHotColor(ctx, col);
			}
			var start = this.m_Start.GetValueLong(ctx);
			var end = this.m_End.GetValueLong(ctx);
			var tri = this.m_Tri.GetValueLong(ctx);

			var linewidth = this.m_LineWidth.GetValueFloat(ctx);
			if (bHot) {
				linewidth *= (this.GetHotScale(ctx))[0];
			}
			var dotcolor = this.m_DotColor.GetValueColor(ctx);
			if (bSelected) {
				dotcolor = this.GetSelectColor(ctx, dotcolor);
			}
			if (bHot) {
				dotcolor = this.GetHotColor(ctx, dotcolor);
			}
			var dotbordercolor = this.m_DotBorderColor.GetValueColor(ctx);
			var colorBorder = this.m_ColorBorder.GetValueColor(ctx);
			if (bSelected) {
				dotbordercolor = this.GetSelectColor(ctx, dotbordercolor);
				colorBorder = this.GetSelectColor(ctx, colorBorder);
			}
			if (bHot) {
				dotbordercolor = this.GetHotColor(ctx, dotbordercolor);
				colorBorder = this.GetHotColor(ctx, colorBorder);
			}
			var lineDash = this.m_LineDash.GetValueString(ctx);
			var dotwidth = this.m_DotWidth.GetValueFloat(ctx);

			var label = this.GetLabel(ctx);

			// var lt = scene.GetPointFromUCSPoint(pa.cache.lt);
			// var rb = scene.GetPointFromUCSPoint(pa.cache.rb);

			// determine the nearest position array.............................//
			// and the instance ofsets..........................................//
			var apos = scene.GetNearestPosArray(pa);

			// due y maps are positive in top direction there is a cross over of//
			// of min and max values............................................//
			var lt = scene.GetPointFromPos([
				apos.m_MinX, apos.m_MaxY, 0.0
			], false);
			var rb = scene.GetPointFromPos([
				apos.m_MaxX, apos.m_MinY, 0.0
			], false);

			// determine the instance offsets and store bounds..................//
			var border = Math.max(linewidth, dotwidth / 2);
			var aIO = this.m_IO[nIndex] = scene.GetCorrectedInstanceOffsets(this.m_BB[nIndex] = [
				lt[0] - border, lt[1] - border, rb[0] + border, rb[1] + border
			], zzf);
			if (aIO.length) {
				var pointarray = scene.GetPointArrayFromUCSArray(pa.cache.data);
				if (editMode != undefined) {
					this.m_DH[nIndex] = this.FillDesignHandles(pointarray, editMode, nIndex);
				}
				for (var nJ = 0, len = aIO.length; nJ < len; ++nJ) {
					dc.setTransform(1, 0, 0, 1, aIO[nJ], 0);
					this.RenderRoute(nIndex, dc, pointarray, lt, rb, col, start, end, tri, linewidth, dotcolor, dotbordercolor, colorBorder, lineDash, dotwidth, aIO[nJ]);

					// draw the bounding box.........................................//
					if (VBI.m_bTrace) {
						VBI.Utilities.DrawFrameRect(dc, "red", this.m_BB[nIndex]);
					}
				}
				dc.setTransform(1, 0, 0, 1, 0, 0);
				if (label) {
					var positions = {
						pa: pointarray,
						bb: [
							lt, rb
						]
					};
					this.m_Label.push(new VBI.Label(label, nIndex, this.CalculateLabelPos, positions, null, aIO));
				}
			}
		};

		this.FillDesignHandles = function(pointarray, editMode, nIndex) {
			var aHandlePoints = []; // designhandle array...//

			// in design mode we push all points to the design handle array.....//
			// checking the array ensures that we do not add the handles twice..//
			// in round world situation.........................................//
			if (editMode == VBI.EMHandle) {
				var hLen = pointarray.length;
				for (var nJ = 0; nJ < hLen; nJ += 3) {
					aHandlePoints.push([
						pointarray[nJ], pointarray[nJ + 1]
					]);
				}
			} else if (editMode == VBI.EMBox) {
				aHandlePoints.push(this.m_BB[nIndex]);
			}
			aHandlePoints.m_EditMode = editMode;

			return aHandlePoints;
		};

		this.RenderRoute = function(nIndex, dc, pointarray, lt, rb, color, start, end, triangles, linewidth, dotcolor, dotbordercolor, colorBorder, lineDash, dotwidth, iO) {
			if (pointarray.length < 6) {
				return;
			}
			var xMin = -iO, xMax = dc.canvas.m_pixelWidth - iO, yMax = dc.canvas.m_pixelHeight;
			var bRouteCompletelyOnCanvas = ((lt[0] > xMin) && (lt[1] > 0) && (rb[0] < xMax) && (rb[1] < yMax));

			var aLinePoints = this.m_LP[nIndex]; // linepoint array......//
			var nStart = 3, nEnd = pointarray.length - 3;
			var bCollectLPs = aLinePoints.length ? false : true;

			// calculate the triangles at the end...............................//
			var rs = {}, re = {};

			if (linewidth && start && this.CalcArrow(pointarray, lt, rb, linewidth, false, rs)) {
				this.DrawArrow(dc, rs.ta, color, colorBorder, xMin, xMax, yMax);
				nStart = rs.idx;
				if (bCollectLPs) {
					aLinePoints.m_RS = rs; // append start arrow info to linepoints array
				}
			}
			if (linewidth && end && this.CalcArrow(pointarray, lt, rb, linewidth, true, re)) {
				this.DrawArrow(dc, re.ta, color, colorBorder, xMin, xMax, yMax);
				nEnd = re.idx;
				if (bCollectLPs) {
					aLinePoints.m_RE = re; // append end arrow info to linepoints array
				}
			}

			if (bCollectLPs) {
				this.CollectLinePoints(pointarray, aLinePoints, nStart, nEnd, start, end, triangles, rs, re, linewidth, iO, colorBorder ? true : false);
			}

			var bLineDashed = this.CheckLineDashing(lineDash, dc);

			if (linewidth) {
				this.DrawActualRoute(dc, aLinePoints, color, colorBorder, linewidth, bRouteCompletelyOnCanvas, xMin, xMax, yMax);
			}

			if (dotwidth) { // render the dotpoints when required...............................//
				this.DrawRouteDots(dc, aLinePoints, start, end, dotcolor, dotbordercolor, dotwidth / 2.0, bRouteCompletelyOnCanvas, xMin, xMax, yMax);
			}

			if (bLineDashed) {
				dc.setLineDash([]); // reset the dashing again to non dashed lines to not interfere with other object instances
			}

			if (aLinePoints.m_aArrows && aLinePoints.m_aArrows.length) {
				for (var nJ = 0; nJ < aLinePoints.m_aArrows.length; ++nJ) {
					this.DrawArrow(dc, aLinePoints.m_aArrows[nJ].ta, color, colorBorder, xMin, xMax, yMax);
					if (aLinePoints.m_aArrows[nJ].int) {
						var a = aLinePoints.m_aArrows[nJ].int;
						dc.beginPath();
						dc.moveTo(a[0][0], a[0][1]);
						dc.lineTo(a[1][0], a[1][1]);
						dc.strokeStyle = color;
						dc.lineWidth = 2;
						dc.stroke();
					}
				}
			}
		};

		this.CollectLinePoints = function(pointarray, aLinePoints, nStart, nEnd, start, end, triangles, rs, re, linewidth, iO, hasBorderCol) {
			var sqdistance = Math.min(linewidth * linewidth / 2, 4); // limit distance to avoid rendering artefacts with big lines
			// var rc = this.m_Scene.m_Canvas[this.m_Scene.m_nOverlayIndex].getBoundingClientRect();
			var rc = this.m_Scene.GetViewport();

			aLinePoints.m_aArrows = [];
			var s = rs.pt ? [
				rs.pt[0], rs.pt[1], 0.0
			] : [
				pointarray[0], pointarray[1], 0.0
			];
			var e = re.pt ? [
				re.pt[0], re.pt[1], 0.0
			] : [
				pointarray[nEnd], pointarray[nEnd + 1], 0.0
			];
			var tdx, tdy, xyz, tmp = s;
			aLinePoints.push(tmp);

			for (var nJ = nStart; nJ <= nEnd; nJ += 3) {
				xyz = [
					pointarray[nJ], pointarray[nJ + 1], 0.0
				];

				// render only when distance is big enough between projected points.......//
				if (((tdx = (tmp[0] - xyz[0])) * tdx + (tdy = (tmp[1] - xyz[1])) * tdy) > sqdistance) {
					aLinePoints.push(xyz);
					tmp = xyz;
				}
			}
			if (re.pt) {
				aLinePoints.push(re.pt);
			}
			if ((start || end) && triangles && linewidth && this.CheckTriangleRendering()) {
				if (!(s[0] >= rc[0] && s[0] <= rc[2] && s[1] >= rc[1] && s[1] <= rc[3] && e[0] >= rc[0] && e[0] <= rc[2] && e[1] >= rc[1] && e[1] <= rc[3])) {
					this.CalculateRouteArrows(aLinePoints, start, end, linewidth, iO, hasBorderCol);
				}
			}
		};

		this.CheckTriangleRendering = function() {
			var scene = this.m_Scene;
			var eLod = scene.m_Canvas[0].m_nExactLOD;
			return (scene.m_bNonIntPosStable || eLod == Math.floor(eLod) || eLod <= (scene.m_CacheVars.minLOD + 0.01));
		};

		this.CheckLineDashing = function(lineDash, dc) {
			// set non-dashed line first
			var scene = this.m_Scene;
			var eLod = scene.m_Canvas[0].m_nExactLOD;
			if (lineDash && dc.setLineDash && (scene.m_bNonIntPosStable || eLod == Math.floor(eLod) || eLod <= (scene.m_CacheVars.minLOD + 0.01))) {
				var ld = lineDash.split(";");
				dc.setLineDash(ld);
				// dc.lineDashOffset++;
				return true;
			}
			return false;
		};

		this.DrawActualRoute = function(dc, aLinePoints, color, colorBorder, linewidth, bRouteCompletelyOnCanvas, xMin, xMax, yMax) {
			// check if route border => draw the route border first
			if (colorBorder) {
				dc.strokeStyle = colorBorder;
				dc.lineWidth = linewidth + 2;
				dc.lineJoin = 'round';
				dc.lineCap = 'butt';
			} else {
				dc.strokeStyle = color;
				dc.lineWidth = linewidth;
				dc.lineJoin = dc.lineCap = 'round';
			}

			var bPathNotYetBegan = true;

			if (bRouteCompletelyOnCanvas) { // everything on canvas so let's omit all the checks and simply paint

				dc.beginPath();
				bPathNotYetBegan = false;
				dc.moveTo((aLinePoints[0])[0], (aLinePoints[0])[1]);
				for (var nJJ = 1; nJJ < aLinePoints.length; ++nJJ) {
					dc.lineTo((aLinePoints[nJJ])[0], (aLinePoints[nJJ])[1]);
				}

			} else {

				var q0, q1;
				var tr = this.m_Scene.m_TransitionTable;
				var tr_result;
				var bLastNotYetMoved = true;
				var xyz, tmp = aLinePoints[0];

				// Calculate Quarter of predecessor point
				if (tmp[1] < 0) {
					q0 = 3;
				} else {
					q0 = tmp[1] > yMax ? 6 : 0;
				}
				if (tmp[0] < xMin) {
					q0++;
				} else {
					q0 += (tmp[0] > xMax ? 2 : 0);
				}

				for (var nJ = 1; nJ < aLinePoints.length; ++nJ) {
					xyz = aLinePoints[nJ];
					if (xyz[1] < 0) { // calc quarter of current point
						q1 = 3;
					} else {
						q1 = xyz[1] > yMax ? 6 : 0;
					}
					if (xyz[0] < xMin) {
						q1++;
					} else {
						q1 += (xyz[0] > xMax ? 2 : 0);
					}
					tr_result = tr[q0 + 9 * q1]; // line can/must/does not cross canvas?
					if (tr_result == 1 || (tr_result > 1 && this.Check4Intersect(tmp, xyz, tr_result, xMin, xMax, 0, yMax))) {
						if (bPathNotYetBegan) {
							dc.beginPath();
							bPathNotYetBegan = false;
						}
						if (bLastNotYetMoved) {
							dc.moveTo(tmp[0], tmp[1]);
						}
						dc.lineTo(xyz[0], xyz[1]);
						bLastNotYetMoved = false;
					} else {
						bLastNotYetMoved = true;
						tmp = xyz;
					}
					q0 = q1;
				}
			}

			if (!bPathNotYetBegan) {
				dc.stroke();

				// if there is border color => draw the original route on top of the route border
				if (colorBorder) {
					dc.strokeStyle = color;
					dc.lineWidth = linewidth;
					dc.stroke();
				}
			}
		};

		this.Check4Intersect = function(p1, p2, tr_result, xMin, xMax, yMin, yMax) {
			// function checks for intersections of p1->p2 with canvas under
			// certain preconditions pre-evaluated accordint to tr_result
			// (see scene.BuildQuarterTransactionTable for this)
			var xCut, yCut, comp;
			var deltaX = p2[0] - p1[0]; // both values are definitely <> 0
			var deltaY = p2[1] - p1[1]; // as otherwise this Check won't be called

			if (tr_result & 20) { // top edge or bottom edge (but not both)
				comp = (tr_result & 4) ? yMax : yMin;
				yCut = (p2[1] - comp) / deltaY;
				xCut = p2[0] - deltaX * yCut;
				if ((xCut >= xMin) && (xCut <= xMax)) {
					return true;
				}
			}

			if (tr_result & 10) { // left edge or right edge (but not both)
				comp = (tr_result & 2) ? xMin : xMax;
				xCut = (p2[0] - comp) / deltaX;
				yCut = p2[1] - deltaY * xCut;
				if ((yCut >= yMin) && (yCut <= yMax)) {
					return true;
				}
			}

			return false;
		};

		this.DrawRouteDots = function(dc, aLinePoints, start, end, dotcolor, dotbordercolor, r, bRouteCompletelyOnCanvas, xMin, xMax, yMax) {
			dc.fillStyle = dotcolor;
			dc.strokeStyle = dotbordercolor;
			dc.lineWidth = 1;
			var firstDot = start ? 1 : 0;
			var lastDot = aLinePoints.length - (end ? 2 : 1);
			var zwoPi = 2.0 * Math.PI;
			for (var nJ = firstDot; nJ <= lastDot; ++nJ) {
				var xyz = aLinePoints[nJ];
				if (bRouteCompletelyOnCanvas || ((xyz[0] - r > xMin) && (xyz[0] + r < xMax) && (xyz[1] - r > 0) && (xyz[1] + r < yMax))) {
					// fill arc...................................................//
					dc.beginPath();
					dc.arc(xyz[0], xyz[1], r, 0, zwoPi);
					dc.closePath();
					dc.fill();
					dc.stroke();
				}
			}
		};

		this.CalculateRouteArrows = function(aLinePoints, start, end, linewidth, iO, bBorder) {
			// collect linepoints and calculate midarrows
			var intermediateDistArrow = 250; // the distance between intermediate arrows
			var fSegLength = 0;
			var flength = 0;
			var tdx, tdy, nOffset, delta;
			var width = this.m_Scene.m_Canvas[this.m_Scene.m_nOverlayIndex].width;
			var height = this.m_Scene.m_Canvas[this.m_Scene.m_nOverlayIndex].height;
			var rc = [
				-iO, 0, -iO + width, height
			];
			var bRet = false;
			var bLeaving = false;
			var bLoop = true;
			var pt1 = aLinePoints[0];
			var pt2 = aLinePoints[1];
			nOffset = 1;
			while (bLoop) {
				if (pt1 == undefined || pt2 == undefined) {
					if (VBI.m_bTrace) {
						VBI.Trace("Wrong offset in CalculateRouteArrows");
					}
					break;
				}
				bRet = VBI.Utilities.LineIntersectRect(pt1[0], pt1[1], pt2[0], pt2[1], rc);
				if (bRet.bReturn == false) {
					bLeaving = false;
					fSegLength = 0;
					nOffset++;
					if (nOffset < aLinePoints.length) {
						pt1 = pt2;
						pt2 = aLinePoints[nOffset];
					} else {
						bLoop = false;
					}
				} else {
					if (bRet.x0 != pt1[0] || bRet.y0 != pt1[1]) {
						pt1 = [
							bRet.x0, bRet.y0, 0
						];
						aLinePoints.splice(nOffset, 0, pt1);
						nOffset++;
						bLeaving = false;
					}
					if (bRet.x1 != pt2[0] || bRet.y1 != pt2[1]) {
						if (bRet.x1 == pt1[0] && bRet.y1 == pt1[1] && bLeaving) {
							nOffset += 2;
							if (nOffset < aLinePoints.length) {
								pt1 = aLinePoints[nOffset - 1];
								pt2 = aLinePoints[nOffset];
								bLeaving = false;
							} else {
								bLoop = false;
							}
						} else {
							pt2 = [
								bRet.x1, bRet.y1, 0
							];
							aLinePoints.splice(nOffset, 0, pt2);
							bLeaving = true;
						}

					}
					tdx = (pt2[0] - pt1[0]);
					tdy = (pt2[1] - pt1[1]);

					// collect the indices where to place intermediate arrowheads
					delta = Math.sqrt(tdx * tdx + tdy * tdy);
					flength += delta;
					if (fSegLength + delta > intermediateDistArrow) {
						// calculate intermediate point
						var tx = tdx / delta * (intermediateDistArrow - fSegLength);
						var ty = tdy / delta * (intermediateDistArrow - fSegLength);
						var pt = [
							pt1[0] + tx, pt1[1] + ty, 0
						];
						var newOff = this.CalcArrowIntermediate(aLinePoints, pt, nOffset, linewidth, start, end, bBorder);
						if (newOff >= 0) {
							nOffset = newOff + 1;
							pt1 = aLinePoints[newOff];
							pt2 = aLinePoints[nOffset];
							fSegLength = 0;
						} else {
							bLoop = false;
						}
					} else {
						fSegLength += delta;
						nOffset++;
						if (nOffset < aLinePoints.length) {
							pt1 = pt2;
							pt2 = aLinePoints[nOffset];
						} else {
							bLoop = false;
						}
					}
				}
			}
		};

		this.Init4Render = this.StandardInitWithLPs;

		// Route.Render with respect to data binding.................................//
		this.Render = function(canvas, dc, clusterData) {
			// clear bounding boxes and index offsets and linepoints and design.//
			// handles and labels for all instances ............................//

			// get scene and design mode........................................//
			var scene = this.m_Scene;
			var ctx = scene.m_Ctx;

			// determine the binding information................................//
			var node;
			var hotIndex;
			if ((node = this.m_DataSource.GetCurrentNode(ctx))) {
				// the element count determines the number of rendered instances.//
				for (var nJ = 0, len = node.m_dataelements.length; nJ < len; ++nJ) {
					this.m_DataSource.Select(nJ);
					if (this.IsHot(nJ)) {
						hotIndex = nJ;
					} else {
						this.RenderInstance(nJ, dc, false, ctx);
					}
					// Route: open or close RichTooltip based on VO instance hotness
					this.SetRichTooltip(this.IsHot(nJ));
				}
			}
			// check: do single instance rendering in else branch ................//

			if (hotIndex != undefined) {
				this.m_DataSource.Select(hotIndex);
				this.RenderInstance(hotIndex, dc, true, ctx);
			}

			// call base rendering method.......................................//
			this.BaseRender(canvas, dc);
		};

		this.DetailHitDot = function(nsx, nsy, x0, y0, sqrad) {
			// check if distance is fitting..................................//
			var tdx, tdy;
			return (((tdx = (x0 - nsx)) * tdx + (tdy = (y0 - nsy)) * tdy) < sqrad) ? true : false;
		};

		this.DetailHitTest = function(ocb, nIndex, nsx, nsy) {
			var x0, y0, x1, y1;

			this.m_DataSource.Select(nIndex);
			var linerad = this.m_LineWidth.GetValueLong(this.m_Scene.m_Ctx) / 2; // half of the thickness of the line
			var dotrad = this.m_DotWidth.GetValueLong(this.m_Scene.m_Ctx) / 2; // half of the thickness of the line
			var sqlinerad = linerad * linerad; // square of half of the thickness of the line
			var sqdotrad = dotrad * dotrad; // square of dot radius

			var aLP = this.m_LP[nIndex];

			// get first linepoint..............................................//
			x0 = aLP[0][0];
			y0 = aLP[0][1];

			// check first dot..................................................//
			if (sqdotrad && this.DetailHitDot(nsx, nsy, x0, y0, sqdotrad)) {
				return {
					m_hit: 1,
					m_dot: 0
				};
			}

			var nCount = aLP.length;
			var nK;
			for (nK = 1; nK < nCount; ++nK) {
				x1 = aLP[nK][0];
				y1 = aLP[nK][1];

				// check wether a waypoint is hit................................//

				// check if not outside segment box and continue.................//
				if (linerad && !((nsx < (Math.min(x0, x1) - linerad)) || // outside left
				(nsx > (Math.max(x0, x1) + linerad)) || // outside right
				(nsy < (Math.min(y0, y1) - linerad)) || // outside top
				(nsy > (Math.max(y0, y1) + linerad)) // outside bottom
				) && (sqlinerad > VBI.Utilities.sqDistance(x0, y0, x1, y1, nsx, nsy))) {
					if (VBI.m_bTrace) {
						VBI.Trace("VBI.VisualObjects.Route hit line " + nIndex);
					}
					return {
						m_hit: 1
					}; // true hit, todo: diffuse hits
				}

				// check first dot...............................................//
				if (sqdotrad && this.DetailHitDot(nsx, nsy, x1, y1, sqdotrad)) {
					if (VBI.m_bTrace) {
						VBI.Trace("VBI.VisualObjects.Route hit dot " + nIndex);
					}
					return {
						m_hit: 1,
						m_dot: nK
					}; // true hit, todo: diffuse hits
				}

				// set positions for the next iteration..........................//
				x0 = x1;
				y0 = y1;
			}

			// check the arrows.................................................//
			// intermediate triangles
			if (aLP.m_aArrows) {
				nCount = aLP.m_aArrows.length;
				for (nK = 0; nK < nCount; ++nK) {
					if (VBI.Utilities.pointInTriangle(aLP.m_aArrows[nK].ta, [
						nsx, nsy
					])) {
						return {
							m_hit: 1
						};
					}
				}
			}
			if (aLP.m_RS && VBI.Utilities.pointInTriangle(aLP.m_RS.ta, [
				nsx, nsy
			])) {
				return {
					m_hit: 1,
					m_arrow: 0
				}; // true start arrow hit, todo: diffuse hits
			}
			if (aLP.m_RE && VBI.Utilities.pointInTriangle(aLP.m_RE.ta, [
				nsx, nsy
			])) {
				return {
					m_hit: 1,
					m_arrow: 1
				}; // true end arrow is hit, todo: diffuse hits
			}
			return null; // no hit
		};

		this.GetHitArray = function(x, y) {
			// determine the array of instances that are hit....................//
			// x and y are the canvas relative coordinates......................//

			var ocb = {
				m_cb: this.DetailHitTest.bind(this)
			};
			var zsf = this.m_Scene.GetStretchFactor4Mode();

			// bounding boxes are defined always in non stretched canvas........//
			// coordinates, therefore transform them............................//
			var nsx = x / zsf[0];
			var nsy = y / zsf[1];
			// call base function for bounds check..............................//
			return this.BaseHitTest(nsx, nsy, ocb);
		};

		// design overridden members...........................................//
		this.DesignBoxSize = VBI.Utilities.SceneBindPosArrayDesignBoxSize.bind(this);
	};
	VBI.VisualObjects.Route.prototype = VBI.VisualObjects.Base;

	// ........................................................................//
	// circle object..........................................................//

	VBI.VisualObjects.Circle = function() {
		this.load = function(dat, ctx) {
			// call prototype...................................................//
			Object.getPrototypeOf(this).load.call(this, dat, ctx);

			// load circle data.................................................//
			this.m_Props.push(this.m_DataSource = new VBI.NodeProperty(dat, 'datasource', null, ctx));
			this.m_Props.push(this.m_Pos = new VBI.AttributeProperty(dat, 'pos', this.m_DataSource, ctx));
			this.m_Props.push(this.m_ColorBorder = new VBI.AttributeProperty(dat, 'colorBorder', this.m_DataSource, ctx, this.m_defaultColor));
			this.m_Props.push(this.m_Radius = new VBI.AttributeProperty(dat, 'radius', this.m_DataSource, ctx, 5));
			this.m_Props.push(this.m_Tooltip = new VBI.AttributeProperty(dat, 'tooltip', this.m_DataSource, ctx, this.m_defaultTooltip));
			this.m_Props.push(this.m_Color = new VBI.AttributeProperty(dat, 'color', this.m_DataSource, ctx, this.m_defaultColor));
			this.m_Props.push(this.m_Slices = new VBI.AttributeProperty(dat, 'slices', this.m_DataSource, ctx, 10));
			this.m_Props.push(this.m_AltColorBorder = new VBI.AttributeProperty(dat, 'altBorderDeltaColor', this.m_DataSource, ctx, null));

			// load shared properties...........................................//
			this.BaseLoad(dat, ctx, this);
		};

		this.CalculateLabelPos = function(scene, pointarray, offset) {

			var pt = VBI.Utilities.GetMidpointForPolygon(pointarray.pa, pointarray.bb, offset, scene.GetViewport());
			if (pt && pt.aPos) {
				return pt.aPos;
			}
			return null;
		};

		this.LassoSelect = this.LassoSelectCircle;

		// render the single instance..........................................//
		this.RenderInstance = function(nIndex, dc, pos, color, colorBorder, radius, slices, label) {
			var scene = this.m_Scene;
			var nJ;
			// correct zoom factor..............................................//
			var zsf = scene.GetStretchFactor4Mode();
			var zzf = scene.GetZoomFactor4Mode();
			var r = radius / zsf[0];

			// get the center point and calculate the bounds....................//
			var xy = scene.GetPointFromPos(pos, false);

			// determine the instance offsets...................................//
			var bb;
			var aIO = this.m_IO[nIndex] = scene.GetCorrectedInstanceOffsets(bb = this.m_BB[nIndex] = [
				xy[0] - r, xy[1] - r, xy[0] + r, xy[1] + r
			], zzf);
			bb.m_Radius = r; // remember radius at the boundingbox
			bb.m_Pos = xy; // remember position at the boundingbox

			// fill design handle information...................................//
			if (this.IsPosChangeable(scene.m_Ctx)) {
				var aDH = (this.m_DH[nIndex] = []);
				if (this.IsHandleMode()) {
					aDH.m_EditMode = VBI.EMHandle;
					aDH.push(xy);
				} else if (this.IsBoxMode()) {
					aDH.m_EditMode = VBI.EMBox;
					aDH.push(bb);
				}
			}

			// pixel the instance...............................................//
			dc.lineWidth = 1;
			dc.fillStyle = color;

			for (nJ = 0; nJ < aIO.length; ++nJ) {
				dc.setTransform(1, 0, 0, 1, aIO[nJ], 0);

				// fill arc......................................................//
				dc.beginPath();
				dc.arc(xy[0], xy[1], r, 0, 2 * Math.PI);
				dc.closePath();
				dc.fill();

				// draw border line..............................................//
				dc.strokeStyle = colorBorder;
				dc.stroke();

				// draw the bounding box.........................................//
				if (VBI.m_bTrace) {
					VBI.Utilities.DrawFrameRect(dc, "red", this.m_BB[nIndex]);
				}
			}
			dc.setTransform(1, 0, 0, 1, 0, 0);
			// get the points for rendering the label
			// r for radius; xy for vMiddle
// D3DVECTOR4 vPos;
// for( int nJ = 0; nJ < 20; nJ++ )
// {
// double theta = nJ * 2 * Math.PI / 20;
// vPos.x = vMiddle.x + (float)(fRadius * sin( theta ));
// vPos.y = vMiddle.y + (float)(fRadius * cos( theta ));
// vPos.z = vMiddle.z + 0.0f;
// vPos.w = 1.0f;
// vCirclePosList->push_back( vPos );
// }

			if (label && aIO.length) {

				var pta = [];
				var nSlices = 20;
				for (nJ = 0; nJ < nSlices; ++nJ) {
					var theta = nJ * 2 * Math.PI / nSlices;
					var circleX = xy[0] + r * Math.sin(theta);
					var circleY = xy[1] + r * Math.cos(theta);
					pta.push(circleX, circleY);
				}
// var lt = [bb[0],bb[1]];
// var rb = [bb[2],bb[3]];
				var positions = {
					pa: pta,
					bb: [
						[
							bb[0], bb[1]
						], [
							bb[2], bb[3]
						]
					]
				};
				this.m_Label.push(new VBI.Label(label, nIndex, this.CalculateLabelPos, positions, null, aIO));
			}

		};

		this.Init4Render = this.StandardInit;

		// Circle.Render with respect to data binding.................................//
		this.Render = function(canvas, dc, clusterData) {
			// clear bounding boxes and index offsets and design handle array...//

			// get scene .......................................................//
			var ctx = this.m_Scene.m_Ctx;
			var cntInstances = 0;

			// determine the binding information................................//
			var node;
			if ((node = this.m_DataSource.GetCurrentNode(ctx))) {
				cntInstances = node.m_dataelements.length;
				// the element count determines the number of rendered instances.//
				for (var nJ = 0; nJ < cntInstances; ++nJ) {
					this.m_DataSource.Select(nJ);

					var bHot = this.IsHot(nJ);
					var bSelected = this.IsSelected(ctx);

					var p = this.m_Pos.GetValueVector(ctx);
					var col = this.m_Color.GetValueColor(ctx);
					if (bSelected) {
						col = this.GetSelectColor(ctx, col);
					}
					if (bHot) {
						col = this.GetHotColor(ctx, col);
					}
					var cb = this.m_ColorBorder.GetValueColor(ctx);
					if (bSelected) {
						cb = this.GetSelectColor(ctx, cb);
					}
					if (bHot) {
						cb = this.GetAltBorderColor(ctx, cb);
					}
					var r = this.m_Radius.GetValueFloat(ctx);
					if (bHot) {
						r = (this.GetHotScale(ctx))[0] * r;
					}
					var s = this.m_Slices.GetValueLong(ctx);

					this.RenderInstance(nJ, dc, p, col, cb, r, s, this.GetLabel(ctx));

					// Circle: open or close RichTooltip based on VO instance hotness
					this.SetRichTooltip(bHot);
				}
			}
			// check: do single instance rendering in else branch ................//

			// call base rendering method.......................................//
			this.BaseRender(canvas, dc);

			return cntInstances; // to increase count of Scaling instances
		};

		this.DetailHitTest = function(ocb, nIndex, nsx, nsy) {
			var bb = this.m_BB[nIndex];
			var r = bb.m_Radius;
			var xy = bb.m_Pos;
			var tdx, tdy;

			// when hit distance lies within the radius, this is a hit..........//
			if (((tdx = (xy[0] - nsx)) * tdx + (tdy = (xy[1] - nsy)) * tdy) < r * r) {
				return {
					m_hit: 1
				}; // check: do diffuse hits here as well
			}

			return null; // no hit
		};

		this.GetHitArray = function(x, y) {
			// determine the array of instances that are hit....................//
			// x and y are the canvas relative coordinates......................//
			var zsf = this.m_Scene.GetStretchFactor4Mode();
			var ocb = {
				m_cb: this.DetailHitTest.bind(this),
				m_zf: zsf
			};
			var nsx = x / zsf[0];
			var nsy = y / zsf[1];
			// call base function for bounds check..............................//
			return this.BaseHitTest(nsx, nsy, ocb);
		};

		// design overridden members...........................................//
		this.DesignGetActiveBoxHandles = function(idx) {
			// only when the radius can be changed, handles are active..........//
			var scene = this.m_Scene;
			this.m_DataSource.Select(idx);
			return this.m_Radius.IsChangeable(scene.m_Ctx) ? [
				0, 1, 0, 1, 0, 1, 0, 1, 0
			] : [
				0, 0, 0, 0, 0, 0, 0, 0, 0
			];
		};

		this.DesignBoxSize = VBI.Utilities.SceneBindRadiusDesignBoxSize.bind(this);

		// event handlers......................................................//
	};
	VBI.VisualObjects.Circle.prototype = VBI.VisualObjects.Base;

	// ........................................................................//
	// CircleDist object......................................................//

	VBI.VisualObjects.CircleDist = function() {
		this.load = function(dat, ctx) {
			// call prototype...................................................//
			Object.getPrototypeOf(this).load.call(this, dat, ctx);

			// load circle data.................................................//
			this.m_Props.push(this.m_DataSource = new VBI.NodeProperty(dat, 'datasource', null, ctx));
			this.m_Props.push(this.m_Pos = new VBI.AttributeProperty(dat, 'midpoint', this.m_DataSource, ctx));
			this.m_Props.push(this.m_ColBorder = new VBI.AttributeProperty(dat, 'colorBorder', this.m_DataSource, ctx, this.m_defaultColor));
			this.m_Props.push(this.m_Radius = new VBI.AttributeProperty(dat, 'radius', this.m_DataSource, ctx, 10));
			this.m_Props.push(this.m_Tooltip = new VBI.AttributeProperty(dat, 'tooltip', this.m_DataSource, ctx, this.m_defaultTooltip));
			this.m_Props.push(this.m_ColFill = new VBI.AttributeProperty(dat, 'color', this.m_DataSource, ctx, this.m_defaultColor));
			this.m_Props.push(this.m_Slices = new VBI.AttributeProperty(dat, 'slices', this.m_DataSource, ctx, 10));
			this.m_Props.push(this.m_AltColorBorder = new VBI.AttributeProperty(dat, 'altBorderDeltaColor', this.m_DataSource, ctx, null));

			// load shared properties...........................................//
			this.BaseLoad(dat, ctx, this);
		};

		this.CalculateLabelPos = function(scene, pointarray, offset) {
			var pt = VBI.Utilities.GetMidpointForPolygon(pointarray.pa, pointarray.bb, offset, scene.GetViewport());
			if (pt && pt.aPos) {
				return pt.aPos;
			}
			return null;
		};

		this.LassoSelect = function(aPos, hits, orgHits) {
			var circlePt = [];
			var aOff, theta;
			var bFound = false;
			for (var nJ = this.m_LP.length - 1; nJ >= 0; --nJ) {
				var pointList = [];
				if (this.m_BB[nJ].m_bArcCircle) {
					// consider as circle
					var xy = this.m_BB[nJ].m_Pos;
					var r = this.m_BB[nJ].m_Radius;
					var nSlices = 20;
					for (var nK = 0; nK < nSlices; ++nK) {
						theta = nK * 2 * Math.PI / nSlices;
						circlePt = [
							xy[0] + r * Math.sin(theta), xy[1] + r * Math.cos(theta)
						];
						pointList.push(circlePt);
					}
				} else {
					// consider as area
					pointList = this.m_LP[nJ];
				}
				aOff = this.m_IO[nJ];
				if (VBI.Utilities.polyInPolygon(aPos, pointList, aOff)) {
					orgHits.push(nJ);
					hits.push(nJ);
					bFound = true;
				}
			}
			return bFound;
		};

		this.RenderCircleDist = function(nIndex, dc, data, colFill, colBorder) {
			var scene = this.m_Scene;

			// get linepoints, when already collected set them to null..........//
			var aLinePoints = this.m_LP[nIndex]; // linepoint array......//
			if (aLinePoints.length) {
				aLinePoints = null;
			}

			// because radians are delivered, GetPointFromGeo must be used......//
			// this accepts radians only........................................//
			var tdx, tdy, xy, tmp = scene.GetPointFromGeo(data[0], false);
			var bArcCircle = false;
			var crC, crRad;

			// if the circle center is within 10 degrees latitude from the equator and the geo radius is small, render it with an Arc
			var ctx = this.m_Scene.m_Ctx;
			var pos = this.m_Pos.GetValueVector(ctx);
			var rad = this.m_Radius.GetValueFloat(ctx);

			// check if an arc circle can be rendered
			// limit the radius because of geo imprecision, and circle dissapear issue (the latter has to do with scene.GetCorrectedInstanceOffsets)
			bArcCircle = (Math.abs(pos[1] - 45) <= 10 && rad <= 10000) ? true : false;

			if (bArcCircle) {
				var crRadSum = 0;
				crC = scene.GetPointFromGeo(VBI.MathLib.DegToRad(pos), false); // circle center

				// find the average radius from all geo segment points
				for (var nJ = 0; nJ < data.length; ++nJ) {
					xy = scene.GetPointFromGeo(data[nJ], false);
					crRadSum += Math.sqrt((xy[0] - crC[0]) * (xy[0] - crC[0]) + (xy[1] - crC[1]) * (xy[1] - crC[1]));
				}
				crRad = crRadSum / data.length;

				// adjust the bounding box for the circle
				var bb = this.m_BB[nIndex];
				bb[1] = crC[1] - crRad;
				bb[3] = crC[1] + crRad;
				bb.m_Radius = crRad;
				bb.m_Pos = crC;
				bb.m_bArcCircle = true;
			}

// var exLod = this.m_Scene.m_Canvas[0].m_nExactLOD;
// var sqrtLod = Math.sqrt(exLod);
// var maxLod = this.m_Scene.GetMaxLOD();
// var lodFactor = (exLod + 1) * (exLod + 1) - (maxLod - exLod);

			// set the colors and styles........................................//
			dc.strokeStyle = colBorder;
			dc.fillStyle = colFill;
			dc.lineWidth = 1;

			// start rendering..................................................//
			dc.beginPath();

			if (!bArcCircle) {
				dc.moveTo(tmp[0], tmp[1]);

				if (aLinePoints) {
					aLinePoints.push(tmp); // add first line point
				}
				for (var nJJ = 1; nJJ < data.length; ++nJJ) {
					xy = scene.GetPointFromGeo(data[nJJ], false);

					// when the distance is too small between projected points.......//
					// skip rendering................................................//
					if (((tdx = (tmp[0] - xy[0])) * tdx + (tdy = (tmp[1] - xy[1])) * tdy) < 9.0) {
						continue;
					}

					if (aLinePoints) {
						aLinePoints.push(xy); // add other line points
					}
					dc.lineTo(xy[0], xy[1]);
					tmp = xy;
				}
				dc.closePath();
			} else {
				dc.arc(crC[0], crC[1], crRad, 0, 2 * Math.PI);
			}

			// stroke and fill..................................................//
			dc.stroke();
			dc.fill();
		};

		// render the single instance..........................................//
		this.RenderInstance = function(nIndex, dc, pos, colFill, colBorder, radius, slices, label) {
			var bb, scene = this.m_Scene;
			var zzf = scene.GetZoomFactor4Mode();

			// determine the positions..........................................//
			// all the math functions deliver radians...........................//

			// make the slices count a function of the circle radius and map lod
			var exLod = this.m_Scene.m_Canvas[0].m_nExactLOD;
			var sqrtLod = Math.sqrt(exLod);
			var lnRad = Math.log(radius);
			var cStep = 1 / lnRad;
			var newSlices = 2 * Math.PI / cStep;
			slices = (newSlices > slices) ? newSlices : slices;
			var finSlices = slices * sqrtLod;
			finSlices = (finSlices < 7) ? 7 : finSlices;
			finSlices = (finSlices > 500) ? 500 : finSlices;

			var data = VBI.MathLib.EquidistantLonLat(VBI.MathLib.DegToRad(pos), radius, finSlices);

			// add the center as a design handle................................//
			if (this.m_Pos.IsChangeable(scene.m_Ctx)) {
				(this.m_DH[nIndex] = [
					scene.GetPointFromPos(pos, false)
				]);
			}

			// due y maps are positive in top direction there is a cross over of//
			// of min and max values............................................//
			var lt = scene.GetPointFromGeo([
				data.m_MinX, data.m_MaxY, 0.0
			], false);
			var rb = scene.GetPointFromGeo([
				data.m_MaxX, data.m_MinY, 0.0
			], false);

			// determine the instance offsets...................................//
			var aIO = this.m_IO[nIndex] = scene.GetCorrectedInstanceOffsets(bb = this.m_BB[nIndex] = [
				lt[0], lt[1], rb[0], rb[1]
			], zzf);

			// add the center as a design handle................................//
			if (this.IsPosChangeable(scene.m_Ctx)) {
				// tag the array with the current mode.....................//
				var aDH = (this.m_DH[nIndex] = []);
				if (this.IsHandleMode()) {
					aDH.m_EditMode = VBI.EMHandle;
					aDH.push(scene.GetPointFromPos(pos, false));
				} else if (this.IsBoxMode()) {
					aDH.m_EditMode = VBI.EMBox;
					aDH.push(bb);
				}
			}

			for (var nK = 0; nK < aIO.length; ++nK) {
				dc.setTransform(1, 0, 0, 1, aIO[nK], 0);

				this.RenderCircleDist(nIndex, dc, data, colFill, colBorder);

				// draw the bounding box.........................................//
				if (VBI.m_bTrace) {
					VBI.Utilities.DrawFrameRect(dc, "red", this.m_BB[nIndex]);
				}
			}

			// reset any transforms.............................................//
			dc.setTransform(1, 0, 0, 1, 0, 0);
			if (label && aIO.length) {

				var pta = [];
				for (var nJ = 0; nJ < this.m_LP[nIndex].length; ++nJ) {
					pta.push(this.m_LP[nIndex][nJ][0], this.m_LP[nIndex][nJ][1]);
				}
				var positions = {
					pa: pta,
					bb: [
						lt, rb
					]
				};
				this.m_Label.push(new VBI.Label(label, nIndex, this.CalculateLabelPos, positions, null, aIO));
			}

		};

		this.Init4Render = this.StandardInitWithLPs;

		// CircleDist.Render with respect to data binding.................................//
		this.Render = function(canvas, dc, clusterData) {
			// clear bounding boxes and index offsets and linepoints and design.//
			// handles..........................................................//

			// get scene........................................................//
			var ctx = this.m_Scene.m_Ctx;

			// determine the binding information................................//
			var node;
			if ((node = this.m_DataSource.GetCurrentNode(ctx))) {
				// the element count determines the number of rendered instances.//
				for (var nJ = 0, len = node.m_dataelements.length; nJ < len; ++nJ) {
					this.m_DataSource.Select(nJ);

					var bHot = this.IsHot(nJ);
					var bSelected = this.IsSelected(ctx);

					var p = this.m_Pos.GetValueVector(ctx);
					var cb = this.m_ColBorder.GetValueColor(ctx);
					if (bSelected) {
						cb = this.GetSelectColor(ctx, cb);
					}
					if (bHot) {
						cb = this.GetAltBorderColor(ctx, cb);
					}
					var r = this.m_Radius.GetValueFloat(ctx);
					if (bHot) {
						r = (this.GetHotScale(ctx))[0] * r;
					}
					var s = this.m_Slices.GetValueLong(ctx);
					var cf = this.m_ColFill.GetValueColor(ctx);

					if (bSelected) {
						cf = this.GetSelectColor(ctx, cf);
					}
					if (bHot) {
						cf = this.GetHotColor(ctx, cf);
					}
					// create a subarray on the index.............................//
					this.m_LP[nJ] = [];

					this.RenderInstance(nJ, dc, p, cf, cb, r, s, this.GetLabel(ctx));

					// CircleDist: open or close RichTooltip based on VO instance hotness
					this.SetRichTooltip(bHot);
				}
			}
			// check: do single instance rendering in else branch ................//

			// call base rendering method.......................................//
			this.BaseRender(canvas, dc);
		};

		this.DetailHitTest = function(ocb, nIndex, nsx, nsy) {
			var bb = this.m_BB[nIndex];

			// check if its an Arc Circle => hit test as a normal circle
			if (bb.m_bArcCircle) {
				var r = bb.m_Radius;
				var xy = bb.m_Pos;
				var tdx, tdy;

				// when hit distance lies within the radius, this is a hit..........//
				if (((tdx = (xy[0] - nsx)) * tdx + (tdy = (xy[1] - nsy)) * tdy) < r * r) {
					return {
						m_hit: 1
					}; // check: do diffuse hits here as well
				}

				return null; // no hit
			} else {
				// check the segmented point geo circle
				// check: check for diffuse hits.....................................//
				return VBI.Utilities.pointInPolygon(this.m_LP[nIndex], nsx, nsy) ? {
					m_hit: 1
				} : null;
			}
		};

		this.GetHitArray = function(x, y) {
			// determine the array of instances that are hit....................//
			// x and y are the canvas relative coordinates......................//
			var zsf = this.m_Scene.GetStretchFactor4Mode();

			var nsx = x / zsf[0];
			var nsy = y / zsf[1];

			var ocb = {
				m_cb: this.DetailHitTest.bind(this),
				m_zf: zsf
			};

			// call base function for bounds check..............................//
			return this.BaseHitTest(nsx, nsy, ocb);
		};

		// design handlers.....................................................//
		this.DesignGetActiveBoxHandles = function(idx) {
			// only when the radius can be changed, handles are active..........//
			var scene = this.m_Scene;
			this.m_DataSource.Select(idx);
			return this.m_Radius.IsChangeable(scene.m_Ctx) ? [
				0, 1, 0, 1, 0, 1, 0, 1, 0
			] : [
				0, 0, 0, 0, 0, 0, 0, 0, 0
			];
		};

		this.DesignBoxSize = VBI.Utilities.SceneBindMeterRadiusDesignBoxSize.bind(this);

		// event handlers......................................................//
	};
	VBI.VisualObjects.CircleDist.prototype = VBI.VisualObjects.Base;

	// ........................................................................//
	// pie object.............................................................//

	VBI.VisualObjects.m_AC = // analytic colors........................//
	[
		"rgba(0,143,211,1.0)", "rgba(153,209,1,1.0)", "rgba(243,155,2,1.0)", "rgba(159,207,236,1.0)", "rgba(75,167,7,1.0)", "rgba(246,209,51,1.0)", "rgba(203,77,44,1.0)", "rgba(202,199,186,1.0)", "rgba(13,134,156,1.0)", "rgba(205,215,46,1.0)", "rgba(36,114,48,1.0)", "rgba(108,222,220,1.0)", "rgba(235,115,0,1.0)", "rgba(185,187,209,1.0)", "rgba(0,109,211,1.0)", "rgba(61,185,127,1.0)", "rgba(165,84,148,1.0)", "rgba(1,88,43,1.0)", "rgba(77,182,239,1.0)", "rgba(175,43,23,1.0)", "rgba(212,153,18,1.0)", "rgba(187,204,210,1.0)", "rgba(48,146,13,1.0)", "rgba(29,169,193,1.0)", "rgba(42,71,201,1.0)", "rgba(209,153,194,1.0)", "rgba(204,88,38,1.0)", "rgba(114,191,68,1.0)", "rgba(10,72,157,1.0)", "rgba(151,156,163,1.0)", "rgba(14,145,144,1.0)", "rgba(97,32,154,1.0)"
	];

	VBI.VisualObjects.Pie = function() {
		this.load = function(dat, ctx) {
			// call prototype...................................................//
			Object.getPrototypeOf(this).load.call(this, dat, ctx);

			// load bindable properties.........................................//
			this.m_Props.push(this.m_DataSource = new VBI.NodeProperty(dat, 'datasource', null, ctx));
			this.m_Props.push(this.m_Series = new VBI.NodeProperty(dat, 'series', this.m_DataSource, ctx));
			this.m_Props.push(this.m_Scale = new VBI.AttributeProperty(dat, 'scale', this.m_DataSource, ctx, [
				1.0, 1.0, 1.0
			]));
			this.m_Props.push(this.m_Pos = new VBI.AttributeProperty(dat, 'pos', this.m_DataSource, ctx));
			this.m_Props.push(this.m_Values = new VBI.AttributeProperty(dat, 'value', this.m_Series, ctx));
			this.m_Props.push(this.m_Texts = new VBI.AttributeProperty(dat, 'text', this.m_Series, ctx));
			this.m_Props.push(this.m_SliceColor = new VBI.AttributeProperty(dat, 'slicecolor', this.m_Series, ctx));
			this.m_Props.push(this.m_Tooltips = new VBI.AttributeProperty(dat, 'extooltip', this.m_Series, ctx, this.m_defaultTooltip));
			this.m_Props.push(this.m_Tooltip = new VBI.AttributeProperty(dat, 'tooltip', this.m_DataSource, ctx, this.m_defaultTooltip));
			this.m_Props.push(this.m_StartColor = new VBI.AttributeProperty(dat, 'startcolor', this.m_DataSource, ctx, 0));

			// load shared properties...........................................//
			this.BaseLoad(dat, ctx, this);
		};

		this.LassoSelect = this.LassoSelectCircle;

		// render the single pie instance......................................//
		this.RenderInstance = function(nIndex, dc, pos, radius, values, texts, colors, nHotSlice, bSelected) {
			var scene = this.m_Scene;
			var zzf = scene.GetZoomFactor4Mode();
			var ctx = scene.m_Ctx;

			// calc sum of values...............................................//
			var nSum = 0;
			var nJ;
			for (nJ = 0; nJ < values.length; ++nJ) {
				nSum += values[nJ];
			}
			this.m_SUM[nIndex] = nSum;

			// determine the location where to render the main instance.........//
			// get the current zoom factors.....................................//
			var xy = scene.GetPointFromPos(pos, false);

			// determine the box and the instance offsets.......................//
			var bb;
			var aIO = this.m_IO[nIndex] = scene.GetCorrectedInstanceOffsets(bb = this.m_BB[nIndex] = [
				xy[0] - radius, xy[1] - radius, xy[0] + radius, xy[1] + radius
			], zzf);
			bb.m_Radius = radius; // remember used radius
			bb.m_Pos = xy; // remember used position

			// collect design handle information................................//
			if (this.IsPosChangeable(ctx)) {
				// tag the array with the current mode...........................//
				var aDH = (this.m_DH[nIndex] = []);
				if (this.IsHandleMode()) {
					aDH.m_EditMode = VBI.EMHandle;
					aDH.push(xy); // center is the design handle
				} else if (this.IsBoxMode()) {
					aDH.m_EditMode = VBI.EMBox;
					aDH.push(bb);
				}
			}
			this.m_ARC[nIndex] = [
				3 * Math.PI / 2
			];

			// get the start color..............................................//
			var startcolor = this.m_StartColor.GetValueLong(ctx);
			var colarraylen = VBI.VisualObjects.m_AC.length;

			for (var nK = 0; nK < aIO.length; ++nK) {
				dc.setTransform(1, 0, 0, 1, aIO[nK], 0);

				var lastPosition = 3 * Math.PI / 2;
				for (nJ = 0; nJ < values.length; ++nJ) {
					var gradient = dc.createRadialGradient(xy[0], xy[1], 0, xy[0], xy[1], radius);
					var col = colors[nJ];
					if (!col) {
						col = VBI.VisualObjects.m_AC[(nJ + startcolor) % colarraylen];
					}
					// determine the hot color....................................//
					if (bSelected) {
						col = this.GetSelectColor(ctx, col);
					}
					if (nJ == nHotSlice) {
						col = this.GetHotColor(ctx, col);
					}
					gradient.addColorStop(0, col);
					gradient.addColorStop(0.95, col);
					gradient.addColorStop(1.0, 'rgba(255,255,255,0.0 )');

					dc.fillStyle = gradient;
					dc.beginPath();
					dc.moveTo(xy[0], xy[1]); // move to center

					var deltaPhi = Math.PI * 2 * (values[nJ] / nSum);

					dc.arc(xy[0], xy[1], radius, lastPosition, lastPosition + deltaPhi, false);
					dc.lineTo(xy[0], xy[1]); // move to center
					dc.closePath();
					dc.fill(); // fill the pie
					lastPosition += deltaPhi;
					if (!nK) {
						// store the angle for the first instance
						this.m_ARC[nIndex].push(lastPosition);
					}

					// check: store segments positions.............................//
				}
			}

			// reset the transformation.........................................//
			dc.setTransform(1, 0, 0, 1, 0, 0);

		};

		this.Init4Render = function() {
			// clear bounding boxes, index offsets and design handles...........//
			this.m_BB = [];
			this.m_IO = [];
			this.m_DH = [];
			this.m_ARC = []; // Angles of the pies for hittest
			this.m_SUM = []; // total sum of values in pie for percentage calculation
		};

		// Pie.Render pie with respect to data binding.............................//
		this.Render = function(canvas, dc, clusterData) {

			// get scene and desin mode.........................................//
			var scene = this.m_Scene;
			var ctx = scene.m_Ctx;
			var cntInstances = 0;

			var node, nSeries;
			if ((node = this.m_DataSource.GetCurrentNode(ctx))) {
				cntInstances = node.m_dataelements.length;
				for (var nJ = 0; nJ < cntInstances; ++nJ) {
					this.m_DataSource.Select(nJ);
					var aPos = this.m_Pos.GetValueVector(ctx);
					var aScale = this.m_Scale.GetValueVector(ctx);

					var radius = 16 * aScale[0];
					var bHot = this.IsHot(nJ);
					var bSelected = this.IsSelected(ctx);

					// determine the hot scale for the pie........................//
					if (bHot) {
						radius = (this.GetHotScale(ctx))[0] * radius;
					}
					// select the series item.....................................//
					var aValue = [], aText = [], aSliceColor = [];
					if ((nSeries = this.m_Series.GetCurrentNode(ctx))) {
						for (var nS = 0; nS < nSeries.m_dataelements.length; ++nS) {
							this.m_Series.Select(nS);
							aValue.push(this.m_Values.GetValueFloat(ctx));
							aText.push(this.m_Texts.GetValueString(ctx));
							aSliceColor.push(this.m_SliceColor.GetValueColor(ctx));
						}
					}
					var tmp, nHotSlice = (bHot && (tmp = scene.m_HotItem.m_HitObj) && (tmp = tmp.m_Detail)) ? tmp.m_slice : -1;
					this.RenderInstance(nJ, dc, aPos, radius, aValue, aText, aSliceColor, nHotSlice, bSelected);

					// Pie: open or close RichTooltip based on VO instance hotness
					this.SetRichTooltip(bHot);
				}
			}
			// check: do single instance rendering in else branch

			// call base rendering method.......................................//
			this.BaseRender(canvas, dc);

			return cntInstances; // to increase count of Scaling instances
		};

		this.DetailHitTest = function(ocb, nIndex, nsx, nsy) {
			// we can use the box arrays attributes to get the current radius...//
			// and position.....................................................//
			var bb = this.m_BB[nIndex];
			var radius = bb.m_Radius;
			var pos = bb.m_Pos;
			var tdx, tdy;

			// when hit distance lies within the radius, this is a hit..........//
			if (((tdx = (pos[0] - nsx)) * tdx + (tdy = (pos[1] - nsy)) * tdy) < (radius * radius)) {
				// VBI.Trace("pos=["+pos[0]+","+pos[1]+"] nsx="+nsx+", nsy="+nsy+" tdx="+tdx+",tdy="+tdy);
				var angle = Math.acos(tdy / Math.sqrt(tdx * tdx + tdy * tdy));
				var realangle = (tdx <= 0 ? 3 * Math.PI / 2 + angle : 7 * Math.PI / 2 - angle);
				var myArc = this.m_ARC[nIndex];
				var lowVal = 0, highVal = myArc.length - 1, median;
				while (highVal > lowVal + 1) { // binary search
					median = Math.round((lowVal + highVal) / 2);
					if (myArc[median] > realangle) {
						highVal = median;
					} else {
						lowVal = median;
					}
				}

				return {
					m_hit: 1,
					m_slice: lowVal
				}; // check: do diffuse hits here as well
			}

			return null; // no hit
		};

		this.GetHitArray = function(x, y) {
			var zsf = this.m_Scene.GetStretchFactor4Mode();

			// bounding boxes are defined always in non stretched canvas........//
			// coordinates, therefore transform them............................//
			var nsx = x / zsf[0];
			var nsy = y / zsf[1];

			var ocb = {
				m_cb: this.DetailHitTest.bind(this)
			};

			// call base function for bounds check..............................//
			return this.BaseHitTest(nsx, nsy, ocb);
		};

		this.doFormatedReplaces = function(mytext, startStr, endStr, value) {
			var len = startStr.length;
			var nIndex;
			while ((nIndex = mytext.indexOf(startStr)) >= 0) {
				var nIndex2 = nIndex + mytext.substring(nIndex + len).indexOf(endStr) + len + 1;
				var sFormatStr = mytext.substring(nIndex + len, nIndex2 - 1);
				var bUseKomma = false, nSep;
				if ((nSep = sFormatStr.indexOf(",")) >= 0) {
					bUseKomma = true;
				} else {
					nSep = sFormatStr.indexOf(".");
				}
				var nDigits = Math.min(10, (nSep >= 0 ? parseInt(sFormatStr.substring(nSep + 1), 10) : 0));

				var nCompleteStr = mytext.substring(nIndex, nIndex2);
				var valStr = "" + value.toFixed(nDigits);
				if (bUseKomma) {
					valStr = valStr.replace(".", ",");
				}
				mytext = mytext.replace(nCompleteStr, valStr);
			}

			return mytext;

		};

		this.getTooltip = function(ctx, hitObj) {
			var pIndex = hitObj.m_Index; // which pie?
			var sIndex = hitObj.m_Detail.m_slice; // which slice?

			this.m_DataSource.Select(pIndex);
			this.m_Series.Select(sIndex);
			var tooltip = this.m_Tooltips.GetValueString(ctx);
			if (tooltip == "") {
				tooltip = this.m_Tooltip.GetValueString(ctx);
			}
			if ((tooltip === null) || (tooltip === "")) {
				return "";
			}
			tooltip = tooltip.replace(/%MAIN%/, this.m_Tooltip.GetValueString(ctx));
			tooltip = tooltip.replace(/%NUM%/g, sIndex + 1);
			tooltip = tooltip.replace(/%ONUM%/g, sIndex + 1);
			tooltip = tooltip.replace(/%NAME%/g, this.m_Texts.GetValueString(ctx));

			var val = parseFloat(this.m_Values.GetValueString(ctx));

			tooltip = this.doFormatedReplaces(tooltip, "%VALUE", "%", val);
			tooltip = this.doFormatedReplaces(tooltip, "%PERCENTAGE", "%", 100 * val / this.m_SUM[pIndex]);

			return tooltip;
		};

		// design overridden members...........................................//
		this.DesignBeginDrag = function(ocb) {
			// append the original scale to the context.........................//
			ocb.m_ScaleOrig = this.m_Scale.GetValueVector(this.m_Scene.m_Ctx).slice(0);
			ocb.m_DhOrig = this.m_DH[ocb.m_Index].slice(0);
			if (ocb.m_IO) {
				(ocb.m_DhOrig[0])[0] += ocb.m_IO;
				(ocb.m_DhOrig[0])[2] += ocb.m_IO;
			}
		};

		this.DesignBoxSize = VBI.Utilities.SceneBindDesignBoxBoxSize.bind(this, true);

		// event handlers......................................................//
	};
	VBI.VisualObjects.Pie.prototype = VBI.VisualObjects.Base;

	// ........................................................................//
	// box object.............................................................//

	VBI.VisualObjects.Box = function() {
		this.load = function(dat, ctx) {
			// call prototype...................................................//
			Object.getPrototypeOf(this).load.call(this, dat, ctx);

			// load bindable properties.........................................//
			this.m_Props.push(this.m_DataSource = new VBI.NodeProperty(dat, 'datasource', null, ctx));
			this.m_Props.push(this.m_Pos = new VBI.AttributeProperty(dat, 'pos', this.m_DataSource, ctx, [
				0.0, 0.0, 0.0
			]));
			this.m_Props.push(this.m_Scale = new VBI.AttributeProperty(dat, 'scale', this.m_DataSource, ctx, [
				1.0, 1.0, 1.0
			]));
			this.m_Props.push(this.m_Tooltip = new VBI.AttributeProperty(dat, 'tooltip', this.m_DataSource, ctx, this.m_defaultTooltip));
			this.m_Props.push(this.m_Color = new VBI.AttributeProperty(dat, 'color', this.m_DataSource, ctx, this.m_defaultColor));
			this.m_Props.push(this.m_ColorBorder = new VBI.AttributeProperty(dat, 'colorBorder', this.m_DataSource, ctx, this.m_defaultColor));
			this.m_Props.push(this.m_AltColorBorder = new VBI.AttributeProperty(dat, 'altBorderDeltaColor', this.m_DataSource, ctx, null));

			// load shared properties...........................................//
			this.BaseLoad(dat, ctx, this);
		};

		// render the single instance..........................................//
		this.RenderInstance = function(nIndex, dc, pos, scale, color, colorBorder, fs) {
			var bb, scene = this.m_Scene;
			var zzf = scene.GetZoomFactor4Mode();
			var zsf = scene.GetStretchFactor4Mode();

			if (!scale) {
				scale = [
					1.0, 1.0, 1.0
				];
			}
			if (!color) {
				color = "#6f6f7a";
			}

			// determine the location where to render the main instance.........//
			// get the current zoom factors.....................................//
			var xy = scene.GetPointFromPos(pos, false);

			var sx = 1.0;
			var sy = 1.0;
			if (this.IsHot(nIndex)) {
				// determine the hot scale.......................................//
				var hs = this.GetHotScale(scene.m_Ctx);
				sx = hs[0];
				sy = hs[1];
			}

			// remark: precise box rendering analog to 3D is not possible.......//
			// due 2D uses parallel projection instead of a perspective.........//
			// projection.......................................................//

			var baseSize = 370;
			var bx = baseSize * scale[0] * sx / zsf[0];
			var by = baseSize * scale[1] * sy / zsf[1];

			if (!fs) {
				// when size is not fixed it scales proportional to the zoom.....//
				// level.........................................................//
				var f = Math.pow(2, scene.GetCurrentZoomlevel()) / 14.6;
				bx *= f;
				by *= f;
			}

			// determine the box dimensions.....................................//
			var l = xy[0] - bx / 2;
			var t = xy[1] - by / 2;
			var r = xy[0] + bx / 2;
			var b = xy[1] + by / 2;

			// determine the instance offsets...................................//
			var aIO = this.m_IO[nIndex] = scene.GetCorrectedInstanceOffsets(bb = this.m_BB[nIndex] = [
				l, t, r, b
			], zzf);

			// push all points to design mode handles array.....................//
			if (this.IsPosChangeable(scene.m_Ctx)) {
				var aDH = (this.m_DH[nIndex] = []);
				if (this.IsHandleMode()) {
					// just push the line points to the design handle array.......//
					aDH.m_EditMode = VBI.EMHandle;
					aDH.push(xy);
				} else if (this.IsBoxMode()) {
					// just push the box points to the design handle array........//
					aDH.m_EditMode = VBI.EMBox;
					aDH.push(bb);
				}
			}

			// pixel the box....................................................//
			for (var nJ = 0; nJ < aIO.length; ++nJ) {
				dc.setTransform(1, 0, 0, 1, aIO[nJ], 0);

				// draw the filled rectangle.....................................//
				dc.fillStyle = color;
				dc.fillRect(l, t, bx, by);

				// daw a border around...........................................//
				dc.lineWidth = 1;
				dc.strokeStyle = colorBorder;
				dc.strokeRect(l, t, bx, by);

				// draw the bounding box.........................................//
				if (VBI.m_bTrace) {
					VBI.Utilities.DrawFrameRect(dc, "red", this.m_BB[nIndex]);
				}
			}

			dc.setTransform(1, 0, 0, 1, 0, 0);
		};

		this.Init4Render = this.StandardInit;

		// Box.Render with respect to data binding.................................//
		this.Render = function(canvas, dc, clusterData) {
			// clear bounding boxes and index offsets and design handles........//

			// get the scene and design mode....................................//
			var scene = this.m_Scene, ctx = scene.m_Ctx;
			var cntInstances = 0;

			var node;
			if ((node = this.m_DataSource.GetCurrentNode(ctx))) {
				cntInstances = node.m_dataelements.length;
				for (var nJ = 0; nJ < cntInstances; ++nJ) {
					this.m_DataSource.Select(nJ);
					var bHot = this.IsHot(nJ);
					var bSelected = this.IsSelected(ctx);

					var aPos = this.m_Pos.GetValueVector(ctx);
					var aScale = this.m_Scale.GetValueVector(ctx);

					var aCol = this.m_Color.GetValueColor(ctx);
					if (bSelected) {
						aCol = this.GetSelectColor(ctx, aCol);
					}
					if (bHot) {
						aCol = this.GetHotColor(ctx, aCol);
					}
					var aColBorder = this.m_ColorBorder.GetValueColor(ctx);
					if (bSelected) {
						aColBorder = this.GetSelectColor(ctx, aColBorder);
					}
					if (bHot) {
						aColBorder = this.GetAltBorderColor(ctx, aColBorder);
					}
					var aFxSize = this.m_FxSize.GetValueBool(ctx);

					this.RenderInstance(nJ, dc, aPos, aScale, aCol, aColBorder, aFxSize);

					// Box: open or close RichTooltip based on VO instance hotness
					this.SetRichTooltip(bHot);
				}
			}
			// check: do single instance rendering in else branch

			// call base rendering method.......................................//
			this.BaseRender(canvas, dc);

			return cntInstances; // to increase count of Scaling instances
		};

		this.DetailHitTest = function(ocb, nIndex, nsx, nsy) {
			return {
				m_hit: 1
			}; // always a hit due bounds is equal to box, todo: diffuse hit
		};

		this.GetHitArray = function(x, y) {
			// determine the array of instances that are hit....................//
			// x and y are the canvas relative coordinates......................//
			var zsf = this.m_Scene.GetStretchFactor4Mode();

			var nsx = x / zsf[0];
			var nsy = y / zsf[1];

			var ocb = {
				m_cb: this.DetailHitTest.bind(this)
			};

			// call base function for bounds check..............................//
			return this.BaseHitTest(nsx, nsy, ocb);
		};

		// design overridden members...........................................//
		this.DesignBeginDrag = function(ocb) {
			// append the original scale to the context.........................//
			ocb.m_ScaleOrig = this.m_Scale.GetValueVector(this.m_Scene.m_Ctx).slice(0);
			ocb.m_DhOrig = this.m_DH[ocb.m_Index].slice(0);
			if (ocb.m_IO) {
				(ocb.m_DhOrig[0])[0] += ocb.m_IO;
				(ocb.m_DhOrig[0])[2] += ocb.m_IO;
			}
		};

		// design overridden members...........................................//
		/*
		 * this.DesignGetActiveBoxHandles = function( idx ) { // return the valid box handles in design mode......................// return [ 1, 1, 1,
		 * 1, 0, 1, 0, 0, 0 ]; };
		 */
		this.DesignBoxSize = VBI.Utilities.SceneBindDesignBoxBoxSize.bind(this, false);

		// event handlers......................................................//
	};
	VBI.VisualObjects.Box.prototype = VBI.VisualObjects.Base;

	// ........................................................................//
	// area object............................................................//

	VBI.VisualObjects.Area = function() {
		this.m_LineWidth = 1;

		this.load = function(dat, ctx) {
			// call prototype...................................................//
			Object.getPrototypeOf(this).load.call(this, dat, ctx);

			// load bindable properties.........................................//
			this.m_Props.push(this.m_DataSource = new VBI.NodeProperty(dat, 'datasource', null, ctx));
			if (typeof (dat["posarraymulti.bind"]) === "string" || typeof (dat["posarraymulti"]) === "string") {
				this.m_Props.push(this.m_PosM = new VBI.AttributeProperty(dat, 'posarraymulti', this.m_DataSource, ctx));
				this.m_Pos = null;
			} else {
				this.m_Props.push(this.m_Pos = new VBI.AttributeProperty(dat, 'posarray', this.m_DataSource, ctx));
				this.m_PosM = null;
			}
			this.m_Props.push(this.m_Scale = new VBI.AttributeProperty(dat, 'scale', this.m_DataSource, ctx));
			this.m_Props.push(this.m_Color = new VBI.AttributeProperty(dat, 'color', this.m_DataSource, ctx, this.m_defaultColor));
			this.m_Props.push(this.m_ColorBorder = new VBI.AttributeProperty(dat, 'colorBorder', this.m_DataSource, ctx, null));
			this.m_Props.push(this.m_BorderDash = new VBI.AttributeProperty(dat, 'borderDash', this.m_DataSource, ctx, null));
			this.m_Props.push(this.m_Tooltip = new VBI.AttributeProperty(dat, 'tooltip', this.m_DataSource, ctx, this.m_defaultTooltip));
			this.m_Props.push(this.m_AltColorBorder = new VBI.AttributeProperty(dat, 'altBorderDeltaColor', this.m_DataSource, ctx, null));

			// load shared properties...........................................//
			this.BaseLoad(dat, ctx, this);
		};

		this.LassoSelect = function(aPos, hits, orgHits) {
			var bEnclosed = false;
			var shapeList, polygonPts;
			var bFound = false;
			for (var nJ = this.m_LP.length - 1; nJ >= 0; --nJ) {
				shapeList = this.m_LP[nJ];
				bEnclosed = false;
				for (var nK = 0; nK < shapeList.length; ++nK) {
					polygonPts = shapeList[nK];
					if (jQuery.type(polygonPts[0]) == 'array' && jQuery.type(polygonPts[0][0]) == 'array') {
						polygonPts = polygonPts[0];
					}
					if (!(bEnclosed = VBI.Utilities.polyInPolygon(aPos, polygonPts, this.m_IO[nJ]))) {
						break;
					}
				}
				if (bEnclosed) {
					hits.push(nJ);
					orgHits.push(nJ);
					bFound = true;
				}
			}
			return bFound;
		};

		this.RenderArea = function(nIndex, dc, pointarray, color, colorBorder, borderDash, linewidth, hotedge) {

			var sqdistance = linewidth * linewidth / 2;
			var idx, xyz, tdx, tdy;

			var scene = this.m_Scene;
			var n = scene.m_CacheVars;

			// draw lines between the points....................................//
			if (pointarray[0].length < 6) {
				return; // at least 2 points are required..//
			}

			var aLinePoints = this.m_LP[nIndex]; // linepoint array......//

			// linepoints and handle points are only collected for the first.....//
			// world instance...................................................//
			if (aLinePoints.length) {
				aLinePoints = null;
			}

			// set non-dashed line first
			var bLineDashSupported = dc.setLineDash ? true : false;
			var bLineDashSet = false;
			var eLod = this.m_Scene.m_Canvas[0].m_nExactLOD;
			if (bLineDashSupported && borderDash && (VBI.m_bIsIDevice || VBI.m_bIsAndroid || eLod == Math.floor(eLod) || eLod <= (this.m_Scene.m_CacheVars.minLOD + 0.01))) {
				var bd = borderDash.split(";");
				dc.setLineDash(bd);
				// dc.lineDashOffset++;
				bLineDashSet = true;
			}

			dc.strokeStyle = (colorBorder) ? colorBorder : color;
			dc.fillStyle = color;
			dc.lineWidth = hotedge > -1 ? 2 : linewidth;
			dc.lineCap = 'round';

			// Use Premultiplied values for better performance
			var factX = n.factX;
			var factY = n.factY;
			var addX = n.addX;
			var addY = n.addY;

			dc.beginPath();
			// loop on given shapes: base shape + exclusions

			for (var nI = 0, paLen = pointarray.length; nI < paLen; ++nI) {
				var tmp = [
					pointarray[nI][0] * factX + addX, pointarray[nI][1] * factY + addY
				];
				if (aLinePoints) {
					aLinePoints.push([]);
					aLinePoints[nI].push(tmp);
				}

				dc.moveTo(tmp[0], tmp[1]); // move to start............//
				var len = pointarray[nI].length;
				for (idx = 3; idx < len; idx += 3) {
					xyz = [
						pointarray[nI][idx] * factX + addX, pointarray[nI][idx + 1] * factY + addY, 0.0
					];

					// when the distance is too small between projected points.......//
					// skip rendering................................................//
					if (((tdx = (tmp[0] - xyz[0])) * tdx + (tdy = (tmp[1] - xyz[1])) * tdy) < sqdistance) {
						continue;
					}

					dc.lineTo(xyz[0], xyz[1]);
					if (aLinePoints) {
						aLinePoints[nI].push(xyz);
					}
					tmp = xyz;
				}
			}
			dc.closePath();

			// fill and stroke..................................................//
			dc.fill();
			dc.stroke();
			if (bLineDashSet) {
				dc.setLineDash([]); // reset the line dashing
			}
		};

		this.CalculateLabelPos = function(scene, pointarray, offset) {
			var zsf = scene.GetStretchFactor4Mode();
			var rctest = scene.GetInternalDivClientRect();
			var rcWidth = rctest.width / zsf[0];
			var rcHeight = rctest.height / zsf[1];
			var PosXTest = scene.m_Canvas[0].getPixelLeft() / zsf[0];
			var PosYTest = scene.m_Canvas[0].getPixelTop() / zsf[1];

			var rcviewport = [
				-PosXTest, -PosYTest, -PosXTest + rcWidth, -PosYTest + rcHeight
			];

			var pt = VBI.Utilities.GetMidpointsForPolygon(pointarray.pa, pointarray.bb, offset, rcviewport);
			if (pt && pt.aPos) {
				return pt.aPos;
			}
			return null;
		};

		this.ExtendBB = function(tBB, aBB) {
			if (tBB[0] > aBB[0]) {
				tBB[0] = aBB[0];
			}
			if (tBB[1] > aBB[1]) {
				tBB[1] = aBB[1];
			}
			if (tBB[2] < aBB[2]) {
				tBB[2] = aBB[2];
			}
			if (tBB[3] < aBB[3]) {
				tBB[3] = aBB[3];
			}
		};

		this.IsPosChangeable = function(ctx) {
			// no design mode when mouse is not supported
			if (!VBI.m_bMouseSupported) {
				return false;
			}
			// determine if position is changeable..............................//
			if (this.m_PosM) {
				return this.m_PosM.IsChangeable(ctx);
			} else {
				// call prototype...................................................//
				return Object.getPrototypeOf(this).IsPosChangeable.call(this, ctx);
			}
		};

		this.CalcExcludeAreaMinLod = function(scene, myArray, lod, accuracy) {
			var aposexcl = scene.GetNearestPosArray(myArray);
			var lte = scene.GetPointFromPos([
				aposexcl.m_MinX, aposexcl.m_MaxY, 0.0
			], false);
			var rbe = scene.GetPointFromPos([
				aposexcl.m_MaxX, aposexcl.m_MinY, 0.0
			], false);
			return this.CalcAreaMinLod(lte, rbe, lod, accuracy);
		};

		this.RenderShape = function(nIndex, dc, posarrays, color, colorBorder, borderDash, linewidth, hotedge, label, lod) {
			var scene = this.m_Scene;

			var bExcludes = false, baseShape;
			if (typeof (posarrays[0]) === "number") {
				baseShape = posarrays;
			} else {
				baseShape = posarrays[0];
				bExcludes = true;
			}
			var zzf = scene.GetZoomFactor4Mode();
			var n = scene.m_CacheVars;
			if (baseShape.cache == undefined) {
				scene.FillPositionCache(baseShape);
			}
			var accuracy = 2.1; // accuracy finetunes how small painted areas can be
			if (baseShape.cache.minLod > lod - accuracy) {
				return;
			}

			var lt = [
				(baseShape.cache.lt[0] * n.completeX - n.ox) * n.fx, (baseShape.cache.lt[1] * n.completeY - n.oy) * n.fy
			];
			var rb = [
				(baseShape.cache.rb[0] * n.completeX - n.ox) * n.fx, (baseShape.cache.rb[1] * n.completeY - n.oy) * n.fy
			];

			// determine the instance offsets and store the bounds..............//

			var aBB, aIO = scene.GetCorrectedInstanceOffsets(aBB = [
				lt[0] - linewidth, lt[1] - linewidth, rb[0] + linewidth, rb[1] + linewidth
			], zzf);

			if (this.m_BB[nIndex]) {
				// multi part area -> sum up bounding boxes
				this.ExtendBB(this.m_BB[nIndex], aBB);
				this.m_IO[nIndex] = scene.GetCorrectedInstanceOffsets(this.m_BB[nIndex], zzf);
			} else {
				this.m_IO[nIndex] = aIO;
				this.m_BB[nIndex] = aBB;
			}

			// one burst convert to points......................................//
			// for all round world instances....................................//
			var nJ;
			var pointarray = null;
			if (aIO.length) {
				pointarray = [];
				pointarray.push(baseShape.cache.data);
				if (bExcludes) {
					for (var nI = 1, paLen = posarrays.length; nI < paLen; ++nI) {
						var myArray = posarrays[nI];
						if (myArray.cache == undefined) { // calc extension and minLod of hole
							scene.FillPositionCache(myArray);
						}
						if (myArray.cache.minLod <= lod + accuracy) { // only paint if big enough
							pointarray.push(myArray.cache.data);
						}
					}
				}
				// move all points to design mode handles array.....................//
				if (this.IsPosChangeable(scene.m_Ctx)) {
					var aDH = (this.m_DH[nIndex] = []);
					if (this.IsHandleMode()) {
						// just push the line points to the design handle array.......//
						// Note: We use only the base shape so far
						aDH.m_EditMode = VBI.EMHandle;
						var length = pointarray[0].length / 3;
						for (nJ = 0; nJ < length; ++nJ) {
							aDH.push([
								(pointarray[0][nJ * 3] * n.completeX - n.ox) * n.fx, (pointarray[0][nJ * 3 + 1] * n.completeY - n.oy) * n.fy
							]);
						}
					} else if (this.IsBoxMode()) {
						// just push the box points to the design handle array........//
						aDH.m_EditMode = VBI.EMBox;
						aDH.push(this.m_BB[nIndex]);
					}
				}

				// do actual canvas rendering
				for (nJ = 0; nJ < aIO.length; ++nJ) {
					dc.setTransform(1, 0, 0, 1, aIO[nJ], 0);
					this.RenderArea(nIndex, dc, pointarray, color, colorBorder, borderDash, linewidth, hotedge);

					// draw the bounding box.........................................//
					if (VBI.m_bTrace) {
						VBI.Utilities.DrawFrameRect(dc, "red", this.m_BB[nIndex]);
					}
				}
				dc.setTransform(1, 0, 0, 1, 0, 0);

				// draw labels
				if (label) {

					var pta = scene.GetShortPointArrayFromUCSArray(baseShape.cache.data);
					var positions = {
						pa: pta,
						bb: [
							lt, rb
						]
					};
					this.m_Label.push(new VBI.Label(label, nIndex, this.CalculateLabelPos, positions, null, aIO));
				}
			}
		};

		this.RenderInstance = function(nIndex, dc, bHot, ctx, bSelected, lod) {
			// create a subarray on the index.............................//
			this.m_LP[nIndex] = [];

			var scene = this.m_Scene;

			// get the instance attributes................................//
			var hotedge = -1;
			var col = this.m_Color.GetValueColor(ctx);
			var colBorder = this.m_ColorBorder.GetValueColor(ctx);
			var borderDash = this.m_BorderDash.GetValueString(ctx);

			if (bSelected) {
				col = this.GetSelectColor(ctx, col);
				colBorder = this.GetAltBorderColor(ctx, colBorder);
			} else if (this.GetNumActiveSelections(ctx)) {
				col = this.GetNonSelectColor(ctx, col);
				// colBorder = this.GetNonSelectColor( ctx, colBorder );
			}

			// get details of the hot state...............................//
			if (bHot) {
				var detail = scene.m_HotItem.m_HitObj.m_Detail;
				// only when edge events are subscribed the border gets hot//
				if (detail && detail.m_edge >= 0 && (this.BaseFindAction("EdgeClick") || this.BaseFindAction("EdgeContextMenu"))) {
					hotedge = detail.m_edge;
				} else {
					col = this.GetHotColor(ctx, col);
				}
				colBorder = this.GetAltBorderColor(ctx, colBorder);
			}

			// get position array(s)
			var pa;
			if (this.m_Pos) {
				pa = this.m_Pos.GetValueVector(ctx);
				this.RenderShape(nIndex, dc, pa, col, colBorder, borderDash, this.m_LineWidth, hotedge, this.GetLabel(ctx), lod);
			} else if (this.m_PosM) {
				var a = this.m_PosM.GetValueVector(ctx);
				var aMultiLP = [];
				for (var nK = 0, l = a.length; nK < l; ++nK) {
					this.RenderShape(nIndex, dc, a[nK], col, colBorder, borderDash, this.m_LineWidth, hotedge, this.GetLabel(ctx), lod);
					// collect line points for all parts + clear last result, otherwise RenderArea will only fill it once!
					if (this.m_LP[nIndex].length) {
						(aMultiLP.push(this.m_LP[nIndex]));
						this.m_LP[nIndex] = [];
					}
				}
				this.m_LP[nIndex] = aMultiLP;
			}
		};

		this.Init4Render = this.StandardInitWithLPs;

		// Area.Render with respect to data binding.................................//
		this.Render = function(canvas, dc, clusterData) {
			// clear bounding boxes and index offsets and linepoints and design.//
			// handles and labels for all instances ............................//

			var ctx = this.m_Scene.m_Ctx;
			var selected = [];

			// determine the binding information................................//
			var node, len;
			var hotIndex;

			var fExactLod = this.m_Scene.m_Canvas[0].m_nExactLOD;

			if ((node = this.m_DataSource.GetCurrentNode(ctx))) {
				len = node.m_dataelements.length;
				// the element count determines the number of rendered instances.//
				for (var nJ = 0; nJ < len; ++nJ) {
					this.m_DataSource.Select(nJ);
					var bHot = this.IsHot(nJ);
					if (bHot) {
						hotIndex = nJ;
					} else if (this.IsSelected(ctx)) {
						selected.push(nJ);
					} else {
						this.RenderInstance(nJ, dc, false, ctx, false, fExactLod);
					}

					// close RichTooltip if it is open
					this.SetRichTooltip(bHot);
				}
			}

			// check: do single instance rendering in else branch ............//
			len = selected.length;
			for (var i = 0; i < len; i++) {
				this.m_DataSource.Select(selected[i]);
				this.RenderInstance(selected[i], dc, false, ctx, true, fExactLod); // Render all selected non hotties
			}

			if (hotIndex != undefined) {
				this.m_DataSource.Select(hotIndex);
				this.RenderInstance(hotIndex, dc, true, ctx, this.IsSelected(ctx), fExactLod); // Render Hottie
			}

			// call base rendering method.......................................//
			this.BaseRender(canvas, dc);
		};

		this.DetailHitTest = function(ocb, nIndex, nsx, nsy) {
			var bHit = false;
			var len;
			var aLP = this.m_LP[nIndex]; // aLP points to part which is hit
			if (jQuery.type(aLP[0]) == 'array' && jQuery.type(aLP[0][0]) == 'array' && jQuery.type(aLP[0][0][0]) == 'array') { // multipart area
				len = aLP.length;
				for (var nI = 0; !bHit && nI < len; ++nI) {
					// check for a hit on any part
					aLP = this.m_LP[nIndex][nI];
					bHit = VBI.Utilities.pointInPolygon(aLP, nsx, nsy);
				}
			} else { // single part area
				bHit = VBI.Utilities.pointInPolygon(aLP, nsx, nsy);
			}
			if (bHit) {
				var oHit = {
					m_hit: 1
				};

				// line points defined always in non stretched canvas............//
				// So far we test only the border of the base shape!
				var o;
				if ((o = VBI.Utilities.pointOnLine(aLP[0], nsx, nsy, 5, true)) && o.m_edge >= 0) {
					oHit.m_edge = o.m_edge;
					oHit.m_node = o.m_node;
				}

				return oHit;
			}
			return null;
		};

		this.GetHitArray = function(x, y) {
			// determine the array of instances that are hit....................//
			// x and y are the canvas relative coordinates......................//

			var zsf = this.m_Scene.GetStretchFactor4Mode();

			var nsx = x / zsf[0];
			var nsy = y / zsf[1];

			var ocb = {
				m_cb: this.DetailHitTest.bind(this)
			};

			// call base function for bounds check..............................//
			return this.BaseHitTest(nsx, nsy, ocb);
		};

		this.ProcessDetailNodeEdgeEvent = function(event, ele, hit, name) {
			// the detail click is called before a potential click event is.....//
			// fired by the base implementation.................................//

			// check if the edge click is subscribed............................//
			var scene = this.m_Scene, actions = scene.m_Ctx.m_Actions;
			if (actions) {
				var action;
				if ((action = actions.findAction(name, scene, this))) {
					// get basic params........................................//
					var params = scene.GetEventVPCoordsObj(event);

					// append the edge parameter...............................//
					params.edge = hit.m_Detail.m_edge.toString();
					params.node = hit.m_Detail.m_node.toString();
					this.m_Scene.m_Ctx.FireAction(action, scene, this, ele, params);
					return true;
				}
			}
			return false;
		};

		this.DetailClick = function(event, ele, hit) {
			if (hit.m_Detail && (hit.m_Detail.m_edge >= 0)) {
				return this.ProcessDetailNodeEdgeEvent(event, ele, hit, 'EdgeClick');
			}
			return false;
		};

		this.DetailContextmenu = function(event, ele, hit) {
			if (hit.m_Detail && (hit.m_Detail.m_edge >= 0)) {
				return this.ProcessDetailNodeEdgeEvent(event, ele, hit, 'EdgeContextMenu');
			}
			return false;
		};

		// design overridden members...........................................//
		this.DesignBoxSize = VBI.Utilities.SceneBindPosArrayDesignBoxSize.bind(this);
	};
	VBI.VisualObjects.Area.prototype = VBI.VisualObjects.Base;

// ........................................................................//
// heatmap object.........................................................//

	VBI.VisualObjects.HeatMap = function() {
		this.load = function(dat, ctx) {
			jQuery.sap.require("sap.ui.vbm.lib.sapheatmap");

			// call prototype...................................................//
			Object.getPrototypeOf(this).load.call(this, dat, ctx);

			// load bindable properties.........................................//
			this.m_Props.push(this.m_DataSource = new VBI.NodeProperty(dat, 'datasource', null, ctx));
			this.m_Props.push(this.m_Pos = new VBI.AttributeProperty(dat, 'pos', this.m_DataSource, ctx));
			this.m_Props.push(this.m_Value = new VBI.AttributeProperty(dat, 'value', this.m_DataSource, ctx, 1));
			this.m_Props.push(this.m_Opacity = new VBI.AttributeProperty(dat, 'opacity', this.m_DataSource, ctx, 0.5));
			this.m_Props.push(this.m_Gradient = new VBI.AttributeProperty(dat, 'gradient', this.m_DataSource, ctx, ""));
			this.m_Props.push(this.m_Radius = new VBI.AttributeProperty(dat, 'radius', this.m_DataSource, ctx, 5));
			this.m_Props.push(this.m_Behavior = new VBI.AttributeProperty(dat, 'behavior', this.m_DataSource, ctx, 2));
			this.m_Props.push(this.m_RScale = new VBI.AttributeProperty(dat, 'radiusScale', this.m_DataSource, ctx, 1.0));
			this.m_Props.push(this.m_VScale = new VBI.AttributeProperty(dat, 'valueScale', this.m_DataSource, ctx, 1.0));
			this.m_Props.push(this.m_AExp = new VBI.AttributeProperty(dat, 'alphaExponent', this.m_DataSource, ctx, 1.0));
			this.m_Props.push(this.m_CExp = new VBI.AttributeProperty(dat, 'colorExponent', this.m_DataSource, ctx, 1.0));

			var genGradient = (jQuery.type(this.m_Gradient.m_Value) == 'array');
			this.GradientImage = new Image();
			this.GradientImage.onload = function() {
				this.GradientImage.IsLoaded = true;
			}.bind(this);
			if (genGradient) {
				this.m_GeneratedGradient = this.GenerateGradient(this.m_Gradient.m_Value);
				this.GradientImage.src = this.m_GeneratedGradient;
			} else {
				this.GradientImage.src = ctx.GetResources().GetData(this.m_Gradient.GetValueString(ctx));
			}
			this.cache = undefined;

			// load shared properties...........................................//
			this.BaseLoad(dat, ctx, this);
		};

		this.SetColor = function(c, pos, mult1, col1, mult2, col2) {
			var j = 4 * pos;
			c[j] = col1[0] * mult1 + col2[0] * mult2;
			c[j + 1] = col1[1] * mult1 + col2[1] * mult2;
			c[j + 2] = col1[2] * mult1 + col2[2] * mult2;
			c[j + 3] = col1[3] * mult1 + col2[3] * mult2;
			// VBI.Trace("Set " + pos + " to [" + c[j] + "," + c[j + 1] + "," + c[j + 2] + "]");
		};

		this.SetColor1 = function(c, pos, col) {
			var j = 4 * pos;
			c[j] = col[0];
			c[j + 1] = col[1];
			c[j + 2] = col[2];
			c[j + 3] = 255;
			// VBI.Trace("Set " + pos + " to [" + c[j] + "," + c[j + 1] + "," + c[j + 2] + "]");
		};

		this.GenerateGradient = function(colGradient) {
			var colStops = colGradient.length / 2;
			var cWidth = colGradient[2 * (colStops - 1)];
			var idPrefix = this.m_Scene.m_TargetName + "-" + this.m_Scene.m_ID + "-";
			var tempCanvas = VBI.Utilities.CreateGeoSceneCanvas(idPrefix + "temporary", cWidth, 1, 0, false);
			var ctx = tempCanvas.getContext("2d");
			var cols = [];
			ctx.lineWidth = 1;
			var i;
			for (i = 0; i < colStops; ++i) {
				ctx.fillStyle = colGradient[2 * i + 1];
				ctx.fillRect(colGradient[2 * i], 0, 1, 1);
				var iData = ctx.getImageData(colGradient[2 * i], 0, 1, 1);
				cols.push(iData.data);
			}
			var wholeLine = ctx.getImageData(0, 0, cWidth, 1);
			for (i = 1; i < colStops; ++i) {
				var col1 = cols[i - 1];
				var col1hls = VBI.Utilities.RGB2HLS(col1[0], col1[1], col1[2]);
				var hue1 = col1hls[0];
				var lum1 = col1hls[1];
				var sat1 = col1hls[2];
				var start = colGradient[2 * (i - 1)], end = colGradient[2 * i], divider = end - start;
				var col2 = cols[i];
				var col2hls = VBI.Utilities.RGB2HLS(col2[0], col2[1], col2[2]);
				var hue2 = col2hls[0];
				var delta = (hue2 - hue1) / divider;
				for (var j = start; j <= end; ++j) {
					var cCol = VBI.Utilities.HLS2RGB(hue1 + (j - start) * delta, lum1, sat1);
					this.SetColor1(wholeLine.data, j, cCol);
				}
			}

			ctx.putImageData(wholeLine, 0, 0);
			return tempCanvas.toDataURL("png");
		};

		this.CollectData = function(ctx) {
			var scene = this.m_Scene;
			var node, aVal = [], aRad = [], aPos = [];
			var myList = [];
			var maxRad = 0;
			if ((node = this.m_DataSource.GetCurrentNode(ctx))) {
				for (var nJ = 0, len = node.m_dataelements.length; nJ < len; ++nJ) {
					this.m_DataSource.Select(nJ);
					var pos = this.m_Pos.GetValueVector(ctx);
					myList.push({
						x: pos[0],
						y: pos[1],
						r: this.m_Radius.GetValueFloat(ctx),
						v: this.m_Value.GetValueFloat(ctx)
					});
				}
				myList.sort(function(a, b) {
					return a.x - b.x;
				});

				for (var nK = 0; nK < myList.length; ++nK) {
					var elte = myList[nK];
					aVal.push(elte.v);
					aRad.push(elte.r);
					aPos.push(elte.x, elte.y, 0);
					if (elte.r > maxRad) {
						maxRad = elte.r;
					}
				}
			}

			scene.FillPositionCache(aPos, true);
			this.cache = aPos.cache;
			this.cache.val = aVal;
			this.cache.rad = aRad;
			this.cache.maxRad = maxRad;
		};

		this.Init4Render = function() {
			this.m_IO = [];
		};

		this.AddPoints2Heatmap = function(heatmap, oVal, eLod, correction, vFactor) {
			// VBI.Trace("Counter: " + (this.mCnt = this.mCnt ? this.mCnt + 1 : 1));
			var heatmpaVals = heatmap.m_V;
			var scene = this.m_Scene;
			heatmap.Clear();
			var val, hsize;
			var hmWidth = heatmap.m_W;
			var hmHeight = heatmap.m_H;
			var maxHSize = (eLod * oVal.maxRad / correction) / 2.0;

			var pos = scene.GetPointArrayFromUCSArray(oVal.data);
			for (var nK = 0; nK < this.m_IO.length; ++nK) {
				// loop for round world instances
				var len = oVal.data.length;
				var offset = this.m_IO[nK];
				var x0 = pos[0] + offset, xl = pos[len - 3] + offset;
				var tp0 = 0, tp1 = len / 3, bt0 = 0, bt1 = 0, mdl;
				if (x0 <= -maxHSize && xl > -maxHSize) {
					tp0 = len / 3;
					while (tp0 > bt0 + 1) {
						mdl = Math.floor((bt0 + tp0) / 2);
						if (pos[3 * mdl] + offset <= -maxHSize) {
							bt0 = mdl;
						} else {
							tp0 = mdl;
						}
					}
				}

				if (x0 > hmHeight + maxHSize && xl <= hmHeight + maxHSize) {
					while (tp1 > bt1 + 1) {
						mdl = Math.floor((bt1 + tp1) / 2);
						if (pos[3 * mdl] + offset <= hmHeight + maxHSize) {
							bt1 = mdl;
						} else {
							tp1 = mdl;
						}
					}
				}
				// VBI.Trace("Rendering with IO = " + this.m_IO[nK] + " from " + tp0 + " to " + (tp1 - 1));
				for (var nJ = 3 * tp0, cnt = tp0; cnt < tp1; nJ += 3, cnt++) {
					var px = pos[nJ] + offset;
					var py = pos[nJ + 1];
					hsize = (eLod * oVal.rad[cnt] / correction) / 2.0;
					if ((py > -hsize) && (px < hmWidth + hsize)) {
						val = vFactor * (oVal.val[cnt]) / 50;
						heatmpaVals.AddPoint(px, py, val, hsize);
					}
				}
			}
			heatmpaVals.m_PointsSet = true;
		};

		// Heatmap.Render with respect to data binding.........................//
		this.Render = function(canvas, dc) {
			// var ts = Date.now();
			// get scene and desin mode.........................................//
			var scene = this.m_Scene;
			var ctx = scene.m_Ctx;
			var actWidth = canvas.clientWidth;
			var actHeight = canvas.clientHeight;
			var width = scene.m_nWidthCanvas;
			var height = scene.m_nHeightCanvas;

			var gradPic = this.m_GeneratedGradient ? this.m_GeneratedGradient : ctx.GetResources().GetData(this.m_Gradient.GetValueString(ctx));
			if (this.HeatmapWidth != width || this.HeatmapHeight != height) {
				var canv = document.createElement("canvas");
				canv.width = 2 * width;
				canv.height = 2 * height;
				this.Heatmap = VBI.CreateHM({
					canvas: canv,
					colorTexture: gradPic,
					colorTex: this.GradientImage,
					alpha: true,
					width: 2 * width, // we use double sizes as the actual canvas might use upto double size
					height: 2 * height,
					scene: this.m_Scene,
					aFunc: this.m_AExp.GetValueFloat(ctx),
					cFunc: this.m_CExp.GetValueFloat(ctx)
				});
				this.HeatmapWidth = width;
				this.HeatmapHeight = height;
			}

			var heatmap = this.Heatmap;
			if (!this.cache) {
				this.CollectData(ctx);
			}
			var lt = scene.GetPointFromUCSPoint([
				this.cache.lt[0], this.cache.lt[1]
			]);
			var rb = scene.GetPointFromUCSPoint([
				this.cache.rb[0], this.cache.rb[1]
			]);
			var zzf = scene.GetZoomFactor4Mode();

			this.m_IO = scene.GetCorrectedInstanceOffsets([
				lt[0], lt[1], rb[0], rb[1]
			], zzf);

			var rFactor = this.m_RScale.GetValueFloat(ctx);
			var vFactor = this.m_VScale.GetValueFloat(ctx);
			var behav = this.m_Behavior.GetValueFloat(ctx);
			var exactLod = scene.m_Canvas[0].m_nExactLOD;
			var integerLod = Math.floor(exactLod);
			var correction = (scene.m_bObjCanvasMode == 0 ? Math.pow(2, exactLod - integerLod) : 1.0) / rFactor;
			var eLod = 1.0;
			if (behav > 0) {
				eLod = 1 + scene.m_Canvas[0].m_nExactLOD;
				if (behav == 2) {
					eLod = Math.pow(2, eLod);
				}
			}
			this.AddPoints2Heatmap(heatmap, this.cache, eLod, correction, vFactor);
			heatmap.Render(); // render

			var a = dc.globalAlpha;
			dc.globalAlpha = this.m_Opacity.GetValueFloat(ctx);
			dc.drawImage(heatmap.m_Canv, 0, 0, actWidth, actHeight, 0, 0, actWidth, actHeight);
			dc.globalAlpha = a;
			// VBI.Trace("Rendering of Heatmap took " + (Date.now() - ts) + " ms");
		};

		this.DetailHitTest = function(ocb, nIndex, nsx, nsy) {
			return null; // no hit
		};

		this.GetHitArray = function(x, y) {
			// determine the array of instances that are hit....................//
			// x and y are the canvas relative coordinates......................//
			var zsf = this.m_Scene.GetStretchFactor4Mode();

			// bounding boxes are defined always in non stretched canvas........//
			// coordinates, therefore transform them............................//
			var nsx = x / zsf[0];
			var nsy = y / zsf[1];
			var ocb = {
				m_cb: this.DetailHitTest.bind(this)
			};

			// call base function for bounds check..............................//
			return this.BaseHitTest(nsx, nsy, ocb);
		};

		// design overridden members...........................................//
		this.DesignBeginDrag = function(ocb) {
			// append the original scale to the context.........................//
			ocb.m_ScaleOrig = this.m_Scale.GetValueVector(this.m_Scene.m_Ctx).slice(0);
			ocb.m_DhOrig = this.m_DH[ocb.m_Index].slice(0);
			if (ocb.m_IO) {
				(ocb.m_DhOrig[0])[0] += ocb.m_IO;
				(ocb.m_DhOrig[0])[2] += ocb.m_IO;
			}
		};

		this.DesignBoxSize = VBI.Utilities.SceneBindDesignBoxBoxSize.bind(this, true);

		// event handlers.........................................................//
	};
	VBI.VisualObjects.HeatMap.prototype = VBI.VisualObjects.Base;

// ...........................................................................//
// container.................................................................//

	VBI.VisualObjects.Container = function() {
		this.m_Sub = []; // subscriptions...............................//
		this.m_bContainer = true;
		this.m_openWin = [];
		this.m_Marker = 1;

		this.load = function(dat, ctx) {
			// call prototype......................................................//
			Object.getPrototypeOf(this).load.call(this, dat, ctx);

			this.m_Props.push(this.m_DataSource = new VBI.NodeProperty(dat, 'datasource', null, ctx));
			this.m_Props.push(this.m_Pos = new VBI.AttributeProperty(dat, 'pos', this.m_DataSource, ctx));
			this.m_Props.push(this.m_Key = new VBI.AttributeProperty(dat, 'key', this.m_DataSource, ctx, ""));
			this.m_Props.push(this.m_Tooltip = new VBI.AttributeProperty(dat, 'tooltip', this.m_DataSource, ctx, ""));
			this.m_Props.push(this.m_Alignment = new VBI.AttributeProperty(dat, 'alignment', this.m_DataSource, ctx, "0"));

			// push the subscriptions..............................................//
			this.m_Sub.push(this.m_Scene.m_EvtCont.subscribe("onMove", this.onLayout.bind(this)));
			// this.m_Sub.push(this.m_Scene.m_EvtCont.subscribe("onZoom", this.onLayout.bind(this)));
			// force update
			this.m_bChanged = true;
		};

		this.clear = function() {
			// unsubscribe events..................................................//
			for (var nJ = 0, len = this.m_Sub.length; nJ < len; ++nJ) {
				this.m_Sub[nJ].unsubscribe();
			}
			this.m_Sub = [];

			// ... and delete container entries
			this.m_Marker++;
			this.sweepContainers(this.m_Scene.m_Ctx);

			// call common prototype impl part.....................................//
			Object.getPrototypeOf(this).clear.call(this);
		};

		// helper functions.......................................................//
		this.getParentDiv = function() {
			return this.m_Scene.m_MapsLayerDiv;
		};

		// mark and sweep.........................................................//

		this.sweepContainers = function(ctx) {
			for ( var key in this.m_openWin) {
				if (this.m_openWin[key].Marker != this.m_Marker) {
					var cont = this.m_openWin[key];
					ctx.onCloseContainer(cont.id, cont);

					var par = this.getParentDiv();
					par.removeChild(cont);
					delete this.m_openWin[key];
				}
			}
		};

		this.updateContainers = function(canvas, scene, ctx) {
			// mark containers for potential deletion..........................//

			var div = this.getParentDiv();
			var oX = canvas.getPixelLeft();
			var oY = canvas.getPixelTop();
			var len, nJ;
			// determine the array of instances that are hit....................//
			// x and y are the canvas relative coordinates......................//
			var node;
			if ((node = this.m_DataSource.GetCurrentNode(ctx))) {
				len = node.m_dataelements.length;
				for (nJ = 0; nJ < len; ++nJ) {
					this.m_DataSource.Select(nJ);

					var pos = this.m_Pos.GetValueVector(ctx);
					var key = this.m_Key.GetValueString(ctx);
					var tt = this.m_Tooltip.GetValueString(ctx);
					var lt = scene.GetPointFromPos(pos, false);

					// when container with a key is found, then use it
					var cont = this.m_openWin[key];
					if (cont) {
						// when we find a container but it has no content (anymore)//
						// ask for content by calling open window..................//
						if (!cont.children.length) {
							ctx.onOpenContainer(key, cont);
						}
					} else {
						// create a new one and add it............................//
						cont = VBI.Utilities.CreateContainer("vbi_" + key, key, oX + (lt[0] | 0), oY + (lt[1] | 0), "50px", "30px", tt);
						cont.addEventListener("mouseover", this.onMouseOverDiv.bind(cont));
						cont.addEventListener("mouseout", this.onMouseOutDiv.bind(cont));
						cont.m_ID = this.m_ID;
						this.m_openWin[key] = cont;
						this.m_openWin[key].index = nJ;
						div.appendChild(cont);

						// call hook...............................................//
						ctx.onOpenContainer(key, cont);
					}
					this.m_openWin[key].Marker = this.m_Marker;
				}
			}
			this.sweepContainers(ctx);
		};

		this.onMouseOverDiv = function() {
			this.bIsHot = true;
		};

		this.onMouseOutDiv = function() {
			this.bIsHot = false;
		};

		this.onLayout = function(o) {
			// there was a move or zoom.........................................//

			// determine the array of instances that are hit....................//
			// x and y are the canvas relative coordinates......................//
			var scene = this.m_Scene;
			var canvas = scene.m_Canvas[scene.m_nOverlayIndex];
			this.clusterParams = this.GetClusterPosParameters();
			var fExactLod = scene.m_Canvas[0].m_nExactLOD;

			if (!this.m_LastCanvasPos || this.m_LastCanvasPos[2] != fExactLod) {
				return;
			}

			var delta = [
				canvas.getPixelLeft() - this.m_LastCanvasPos[0], canvas.getPixelTop() - this.m_LastCanvasPos[1]
			];

			for ( var key in this.m_openWin) {
				var cont = this.m_openWin[key];
				if (delta[0]) {
					var newX = parseFloat(cont.style.left) + delta[0];
					newX += this.findRoundWorldOffset(newX);
					cont.style.left = (newX) + "px";
				}
				if (delta[1]) {
					cont.style.top = (parseInt(cont.style.top, 10) + delta[1]) + "px";
				}
			}

			this.m_LastCanvasPos = [
				canvas.getPixelLeft(), canvas.getPixelTop(), scene.m_Canvas[0].m_nExactLOD
			];
		};

		this.ContainerAlign = function(cont, ctx) {
			var algnmt = this.m_Alignment.GetValueString(ctx);
			var oStyle = cont.style;
			switch (algnmt) {
				case "0":
					oStyle.msTransform = oStyle.transform = oStyle.webkitTransform = "translate( -50%, -50%)";
					break; // center
				case "1":
					oStyle.msTransform = oStyle.transform = oStyle.webkitTransform = "translate( -50%,   0%)";
					break; // top center
				case "2":
					oStyle.msTransform = oStyle.transform = oStyle.webkitTransform = "translate(-100%,   0%)";
					break; // top right
				case "3":
					oStyle.msTransform = oStyle.transform = oStyle.webkitTransform = "translate(-100%, -50%)";
					break; // center right
				case "4":
					oStyle.msTransform = oStyle.transform = oStyle.webkitTransform = "translate(-100%,-100%)";
					break; // bottom right
				case "5":
					oStyle.msTransform = oStyle.transform = oStyle.webkitTransform = "translate( -50%,-100%)";
					break; // bottom center
				case "6":
					oStyle.msTransform = oStyle.transform = oStyle.webkitTransform = "translate(   0%,-100%)";
					break; // bottom left
				case "7":
					oStyle.msTransform = oStyle.transform = oStyle.webkitTransform = "translate(   0%, -50%)";
					break; // center left
				default:
				case "8":
					oStyle.msTransform = oStyle.transform = oStyle.webkitTransform = "translate(0%, 0%)";
					break; // top left
			}
		};

		// render with respect to data binding....................................//
		this.RenderInstances = function(canvas, zsf) {
			var scene = this.m_Scene;
			var ctx = scene.m_Ctx;

			// mark all containers.................................................//
			if (this.m_bChanged) {
				this.updateContainers(canvas, scene, ctx);
				this.m_bChanged = false;
			}

			var oX = canvas.getPixelLeft();
			var oY = canvas.getPixelTop();
			if (this.m_DataSource.GetCurrentNode(ctx)) {
				for ( var key in this.m_openWin) {
					// for (var nJ = 0; nJ < len; ++nJ) {
					var cont = this.m_openWin[key];
					if (cont.index == undefined) {
						continue;
					}
					this.m_DataSource.Select(cont.index);
					var pos = this.m_Pos.GetValueVector(ctx);

					var lt = scene.GetPointFromPos(pos, true);
					var left = Math.round(oX + (lt[0] | 0) * zsf[0]);
					left = left + this.findRoundWorldOffset(left);

					cont.style.left = left + "px";
					cont.style.top = Math.round(oY + (lt[1] | 0) * zsf[1]) + "px";
					this.ContainerAlign(cont, ctx);
				}
			}
		};

		this.GetClusterPosParameters = function() {
			var retVal = {};
			var scene = this.m_Scene;
			var fExactLod = scene.m_Canvas[0].m_nExactLOD;
			retVal.worldPxOnLOD = Math.pow(2, fExactLod) * scene.m_nWidthCanvas / scene.m_nTilesX * scene.m_Proj.m_nXYRatio;
			retVal.nLeftBorder = scene.m_nDivWidth - retVal.worldPxOnLOD;
			retVal.nRightBorder = scene.m_nDivWidth - retVal.nLeftBorder;
			return retVal;
		};

		this.findRoundWorldOffset = function(xVal) {
			var offset = 0;
			var custParams = this.clusterParams;
			while (xVal + offset < custParams.nLeftBorder) {
				offset += custParams.worldPxOnLOD;
			}

			while (xVal + offset > custParams.nRightBorder) {
				offset -= custParams.worldPxOnLOD;
			}

			return offset;
		};

		this.GetClusterPosition = function(dc, elem, conf, nLod, nDist, lodF, xOff, yOff) {
			var lt;
			var scene = this.m_Scene;
			var oX = dc.canvas.getPixelLeft();
			var oY = dc.canvas.getPixelTop();
			var zf = scene.GetCurrentZoomFactors();
			lt = [
				oX + zf[0] * (lodF * elem[0] - xOff), oY + zf[1] * (lodF * elem[1] - yOff)
			];

			var offset = this.findRoundWorldOffset(lt[0]);
			var zzf = this.m_Scene.GetZoomFactor4Mode();
			lt[0] += offset;
			lt[2] = offset / zzf[0];

			if (elem.c != undefined && conf.anim && (nLod > conf.animLow) && nDist && elem.c != undefined && elem.c.lod == nLod - 1) {
				var zsf = this.m_Scene.GetStretchFactor4Mode();
				var fElem = elem.c;
				var nDist3 = nDist * nDist;

				lt = [
					oX + offset + zf[0] * (lodF * (elem[0] * (1 - nDist3) + fElem[0] * nDist3) - xOff), oY + zf[1] * (lodF * (elem[1] * (1 - nDist3) + fElem[1] * nDist3) - yOff), offset / zzf[0]
				];
				if (conf.anim == 2) {
					var xyOrg = [
						offset + zzf[0] * (lodF * fElem[0] - xOff), zzf[1] * (lodF * fElem[1] - yOff)
					];
					var tr = 2 * Math.abs(0.5 - nDist);
					var trans = "" + (1 - tr);
					dc.strokeStyle = "rgba(110,110,110," + trans + ")";
					dc.lineWidth = 2;
					dc.lineCap = 'round';
					dc.beginPath();
					dc.moveTo((lt[0] - oX) / zsf[0], (lt[1] - oY) / zsf[0]);
					dc.lineTo(xyOrg[0], xyOrg[1]);
					dc.stroke();
				}
			}
			return lt;
		};

		this.RenderThisInstance = function(elem, edges, conf, cI, nIndex, nOrgIndex, dc, dcs, nLod, nDist, lodF, xOff, yOff, bRenderWithLabel) {
			var scene = this.m_Scene;
			var ctx = this.m_Scene.m_Ctx;
			var div = this.getParentDiv();

			var lt = this.GetClusterPosition(dc, elem, conf, nLod, nDist, lodF, xOff, yOff);

			var instanceIdent = scene.m_Ctx.m_Clustering.getClusterIdent(scene.m_PreassembledData, cI, nOrgIndex);
			var cont = this.m_openWin[instanceIdent];

			if (cont == undefined) {
				// create a new one and add it............................//
				cont = VBI.Utilities.CreateContainer("vbi_" + instanceIdent, instanceIdent, lt[0], lt[1], "50px", "30px", "", true);
				cont.addEventListener("mouseover", this.onMouseOverDiv.bind(cont));
				cont.addEventListener("mouseout", this.onMouseOutDiv.bind(cont));
				cont.m_ID = this.m_ID;
				cont.index = elem.nJ;

				div.appendChild(cont);
				this.m_openWin[instanceIdent] = cont;

				// call hook...............................................//
				ctx.onOpenContainer(instanceIdent, cont);
				this.ContainerAlign(cont, ctx);

			} else {
				if (cont.bIsHot) {
					this.RenderShadow(dcs, elem, edges, conf, nLod, lodF, xOff - lt[2], yOff);
				}
				cont.style.left = Math.round(lt[0]) + "px";
				cont.style.top = Math.round(lt[1]) + "px";
			}

			this.m_openWin[instanceIdent].Marker = this.m_Marker;
		};

		// Container.Render with respect to data binding....................................//
		this.Render = function(canvas, dc, preAssembledData, shadow, dcs, bCluster) {
			var scene = this.m_Scene;
			var ctx = this.m_Scene.m_Ctx;
			var fExactLod = scene.m_Canvas[0].m_nExactLOD;
			this.m_Marker++;
			this.clusterParams = this.GetClusterPosParameters();

			if (bCluster) {
				var cntInstances = 0;
				var xOff = scene.m_Canvas[0].m_nCurrentX * scene.m_MapManager.m_tileWidth;
				var yOff = scene.m_Canvas[0].m_nCurrentY * scene.m_MapManager.m_tileHeight;
				var conf = preAssembledData.config;
				var cI = preAssembledData.cI;
				var fNode = preAssembledData.m_TreeFatherNode;
				var nLOD = Math.ceil(fExactLod);
				if (fNode) {
					var nDist = this.GetAnimClusterDistance(nLOD, fExactLod);
					cntInstances = this.RenderTree(fNode, preAssembledData.m_edges, conf, cI, cntInstances, nLOD, nDist, dc, dcs, preAssembledData.m_lodOffset, xOff, yOff, false);
				} else {
					var lodF = preAssembledData.m_lodOffset;
					var nElements = preAssembledData.length;
					for (var nL = 0; nL < nElements; ++nL) {
						var elem = preAssembledData[nL];
						if (!elem.b2Ignore) {
							if (this.RenderThisInstance(elem, preAssembledData.m_edges, conf, cI, cntInstances, nL, dc, dcs, nLOD, 0, lodF, xOff, yOff, false)) {
								cntInstances++;
							}
						}
					}
				}
				this.sweepContainers(ctx);

			} else if (this.m_DataSource.GetCurrentNode(ctx)) { // Virtual Node only
				var zsf = this.m_Scene.GetStretchFactor4Mode();
				this.RenderInstances(canvas, [
					zsf[0], zsf[1]
				]);
			}
			var canvas2 = scene.m_Canvas[scene.m_nOverlayIndex];
			this.m_LastCanvasPos = [
				canvas2.getPixelLeft(), canvas2.getPixelTop(), fExactLod
			];
		};

		this.GetHitArray = function(x, y) {
			var hits = [];
			for ( var key in this.m_openWin) {
				// when container with a key is found, then use it
				var cont = this.m_openWin[key];
				if (cont && cont.bIsHot) {
					hits.push({
						m_Index: cont.index,
						m_Entity: null, // this.GetEntity(nJ, this.m_Scene.m_Ctx),
						m_Detail: {
							m_hit: 2
						},
						m_IO: 0
					});
				}
			}
			return hits;
		};

		// event handler..........................................................//
		this.onclick = function(event) {
			// call base implementation for click events...........................//
			return this.BaseClick(event);
		};
	};
	VBI.VisualObjects.Container.prototype = VBI.VisualObjects.Base;

// ........................................................................//
// 2D controls............................................................//
// prototype object of 2D controls........................................//

	VBI.VisualObjects.Base2D = function() {
		this.m_DOMElement = null;

		// we do calculated paddings for our 2D ui elements to get rid of an...//
		// additional container................................................//

		this.m_paddingLeft = 5;
		this.m_paddingTop = 5;
		this.m_paddingRight = 5;
		this.m_paddingBottom = 5;

		// check if the ui element is still valid..............................//
		this.IsValid = function() {
			if (this.m_DOMElement && this.m_Scene.m_Div) {
				// check if everything is still ok...............................//
				if (this.m_DOMElement.parentNode == this.m_Scene.m_Div) {
					return true;
				}
			}
			return false;
		};

		this.load = function(inst, dat, ctx) {
			// call prototype of base class.....................................//
			Object.getPrototypeOf(this).load.call(inst, dat, ctx);

			// load bindable properties.........................................//
			inst.m_Props.push(inst.m_Left = new VBI.AttributeProperty(dat, 'left', null, ctx));
			inst.m_Props.push(inst.m_Top = new VBI.AttributeProperty(dat, 'top', null, ctx));
			inst.m_Props.push(inst.m_Right = new VBI.AttributeProperty(dat, 'right', null, ctx));
			inst.m_Props.push(inst.m_Bottom = new VBI.AttributeProperty(dat, 'bottom', null, ctx));

			// align values left:1, right:2, center:4 ,,,,,,,,,,,,,,,,,,,,,,,,,,//
			inst.m_Props.push(inst.m_Align = new VBI.AttributeProperty(dat, 'align', null, ctx, 1));
		};

		this.clear = function() {
			// call prototype of base class.....................................//
			// Note: This prototype method runs in the scope of the actual object.
			// Thus getPrototypeOf() returns VisualObjects.Base2D and we need to call again to get the VisualObjects.Base impl!
			Object.getPrototypeOf(Object.getPrototypeOf(this)).clear.call(this);

			this.m_DOMElement = null;
		};

		// .....................................................................//
		// overwritten functions...............................................//

		this.BaseClick = function(event) {
			var scene = this.m_Scene;

			// check for subscribed action and fire event.......................//
			var actions;
			if ((actions = scene.m_Ctx.m_Actions)) {
				var action;
				if ((action = actions.findAction("Click", scene, this))) {
					scene.m_Ctx.FireAction(action, scene, this, null, scene.GetEventVPCoordsObj(event));
					event.preventDefault();
					return true; // handled
				}
			}

			return false;
		};
	};
	VBI.VisualObjects.Base2D.prototype = VBI.VisualObjects.Base;

// ........................................................................//
// caption object.........................................................//

	VBI.VisualObjects.Caption = function() {
		this.m_LineWidth = 1;
		this.load = function(dat, ctx) {
			// call prototype...................................................//
			Object.getPrototypeOf(this).load(this, dat, ctx);

			// load bindable properties.........................................//
			this.m_Props.push(this.m_Text = new VBI.AttributeProperty(dat, 'text', null, ctx, ""));
			this.m_Props.push(this.m_Design = new VBI.AttributeProperty(dat, 'design', null, ctx, "0"));
			this.m_Props.push(this.m_Level = new VBI.AttributeProperty(dat, 'level', null, ctx, 0));
			this.m_Props.push(this.m_Tooltip = new VBI.AttributeProperty(dat, 'tooltip', null, ctx, ""));
		};

		// Caption.Render with respect to data binding.................................//
		this.Render = function(canvas, dc, clusterData) {
			if (this.IsValid()) {
				return; // no update needed.........................//
			}
			// get properties and apply them to the dom element.................//
			var ctx = this.m_Scene.m_Ctx;
			var l = this.m_Left.GetValueLong(ctx);
			var t = this.m_Top.GetValueLong(ctx);
			var r = this.m_Right.GetValueLong(ctx);
			var b = this.m_Bottom.GetValueLong(ctx);
			var align = this.m_Align.GetValueLong(ctx);
			var txt = this.m_Text.GetValueString(ctx);
			var dsn = this.m_Design.GetValueLong(ctx);
			var lev = this.m_Level.GetValueLong(ctx);
			var tt = this.m_Tooltip.GetValueString(ctx);

			this.m_DOMElement = VBI.Utilities.CreateCaption(this.m_ID, txt, l + this.m_paddingLeft, t + this.m_paddingTop, r + this.m_paddingLeft, b + this.m_paddingTop, tt, dsn, lev, align);

			// append the child to the div......................................//
			this.m_Scene.m_Div.appendChild(this.m_DOMElement);
		};
	};

	VBI.VisualObjects.Caption.prototype = new VBI.VisualObjects.Base2D();

// ........................................................................//
// caption object.........................................................//

	VBI.VisualObjects.Label = function() {
		this.m_LineWidth = 1;

		this.load = function(dat, ctx) {
			// call prototype...................................................//
			Object.getPrototypeOf(this).load(this, dat, ctx);

			// load bindable properties.........................................//
			this.m_Props.push(this.m_Text = new VBI.AttributeProperty(dat, 'text', null, ctx, ""));
			this.m_Props.push(this.m_Design = new VBI.AttributeProperty(dat, 'design', null, ctx, "0"));
		};

		// Label.Render with respect to data binding.................................//
		this.Render = function(canvas, dc, clusterData) {
			if (this.IsValid()) {
				return; // no update needed.........................//
			}
			// get properties and apply them to the dom element.................//
			var ctx = this.m_Scene.m_Ctx;
			var l = this.m_Left.GetValueLong(ctx);
			var t = this.m_Top.GetValueLong(ctx);
			var r = this.m_Right.GetValueLong(ctx);
			var align = this.m_Align.GetValueLong(ctx);
			var b = this.m_Bottom.GetValueLong(ctx);
			var txt = this.m_Text.GetValueString(ctx);
			this.m_DOMElement = VBI.Utilities.CreateLabel(this.m_ID, txt, l + this.m_paddingLeft, t + this.m_paddingTop, r + this.m_paddingLeft, b + this.m_paddingTop, 0, align);

			// append the child to the div......................................//
			this.m_Scene.m_Div.appendChild(this.m_DOMElement);
		};
	};
	VBI.VisualObjects.Label.prototype = new VBI.VisualObjects.Base2D();

// ........................................................................//
// link object............................................................//

	VBI.VisualObjects.Link = function() {
		this.m_LineWidth = 1;

		this.load = function(dat, ctx) {
			// call prototype...................................................//
			Object.getPrototypeOf(this).load(this, dat, ctx);

			// load bindable properties.........................................//
			this.m_Props.push(this.m_Reference = new VBI.AttributeProperty(dat, 'reference', null, ""));
			this.m_Props.push(this.m_Autoexecute = new VBI.AttributeProperty(dat, 'autoexecute', null, ctx, false));
			this.m_Props.push(this.m_Tooltip = new VBI.AttributeProperty(dat, 'tooltip', null, ctx, ""));
			this.m_Props.push(this.m_Text = new VBI.AttributeProperty(dat, 'text', null, ctx, ""));
		};

		this.clear = function() {
			// unsubscribe events...............................................//
			if (this.m_DOMElement) {
				this.m_DOMElement.onclick = null;
			}
			// call prototype of base class.....................................//
			Object.getPrototypeOf(this).clear.call(this);
		};

		// Link.Render with respect to data binding.................................//
		this.Render = function(canvas, dc, clusterData) {
			if (this.IsValid()) {
				return; // no update needed.........................//
			}
			// get properties and apply them to the dom element.................//
			var ctx = this.m_Scene.m_Ctx;
			var l = this.m_Left.GetValueLong(ctx);
			var t = this.m_Top.GetValueLong(ctx);
			var r = this.m_Right.GetValueLong(ctx);
			var b = this.m_Bottom.GetValueLong(ctx);
			var align = this.m_Align.GetValueLong(ctx);
			var txt = this.m_Text.GetValueString(ctx);
			var ref = this.m_Reference.GetValueString(ctx);
			var ae = this.m_Autoexecute.GetValueBool(ctx);
			var tt = this.m_Tooltip.GetValueString(ctx);

			this.m_DOMElement = VBI.Utilities.CreateLink(this.m_ID, txt, l + this.m_paddingLeft, t + this.m_paddingTop, r + this.m_paddingLeft, b + this.m_paddingTop, ae ? ref : null, tt, align);

			// append the child to the div......................................//
			this.m_Scene.m_Div.appendChild(this.m_DOMElement);

			// subscribe to events..............................................//
			this.m_DOMElement.onclick = this.onclick.bind(this);
		};

		// event handler.......................................................//
		this.onclick = function(event) {
			// call base implementation for click events........................//
			return this.BaseClick(event);
		};
	};
	VBI.VisualObjects.Link.prototype = new VBI.VisualObjects.Base2D();

// ........................................................................//
// image object...........................................................//

	VBI.VisualObjects.Image = function() {
		this.load = function(dat, ctx) {
			// call prototype...................................................//
			Object.getPrototypeOf(this).load(this, dat, ctx);

			// load bindable properties.........................................//
			this.m_Props.push(this.m_Image = new VBI.AttributeProperty(dat, 'image', null, ctx));
			this.m_Props.push(this.m_Tooltip = new VBI.AttributeProperty(dat, 'tooltip', null, ctx, ""));
		};

		// Image.Render with respect to data binding.................................//
		this.Render = function(canvas, dc, clusterData) {
			if (this.IsValid()) {
				return; // no update needed.........................//
			}
			// get properties and apply them to the dom element.................//
			var ctx = this.m_Scene.m_Ctx;
			var l = this.m_Left.GetValueLong(ctx);
			var t = this.m_Top.GetValueLong(ctx);
			var r = this.m_Right.GetValueLong(ctx);
			var b = this.m_Bottom.GetValueLong(ctx);
			var align = this.m_Align.GetValueLong(ctx);
			var img = this.m_Image.GetValueString(ctx);
			var tt = this.m_Tooltip.GetValueString(ctx);

			var image;
			if ((image = ctx.GetResources().GetImage(img))) {
				this.m_DOMElement = VBI.Utilities.CreateImage(this.m_ID, image, l + this.m_paddingLeft, t + this.m_paddingTop, r + this.m_paddingLeft, b + this.m_paddingTop, tt, align);

				// append the child to the div......................................//
				this.m_Scene.m_Div.appendChild(this.m_DOMElement);
			}
		};
	};
	VBI.VisualObjects.Image.prototype = new VBI.VisualObjects.Base2D();

// ........................................................................//
// button object..........................................................//

	VBI.VisualObjects.Button = function() {
		this.load = function(dat, ctx) {
			// call prototype...................................................//
			Object.getPrototypeOf(this).load(this, dat, ctx);

			// load bindable properties.........................................//
			this.m_Props.push(this.m_Tooltip = new VBI.AttributeProperty(dat, 'tooltip', null, ctx, ""));
			this.m_Props.push(this.m_Text = new VBI.AttributeProperty(dat, 'text', null, ctx, ""));
		};

		this.clear = function() {
			// unsubscribe events...............................................//
			if (this.m_DOMElement) {
				this.m_DOMElement.onclick = null;
			}
			// call prototype of base class.....................................//
			Object.getPrototypeOf(this).clear.call(this);
		};

		// Button.Render with respect to data binding.................................//
		this.Render = function(canvas, dc, clusterData) {
			if (this.IsValid()) {
				return; // no update needed.........................//
			}

			// get properties and apply them to the dom element.................//
			var ctx = this.m_Scene.m_Ctx;
			var l = this.m_Left.GetValueLong(ctx);
			var t = this.m_Top.GetValueLong(ctx);
			var r = this.m_Right.GetValueLong(ctx);
			var b = this.m_Bottom.GetValueLong(ctx);
			var txt = this.m_Text.GetValueString(ctx);
			var tt = this.m_Tooltip.GetValueString(ctx);

			this.m_DOMElement = VBI.Utilities.CreateButton(this.m_ID, txt, l + this.m_paddingLeft, t + this.m_paddingTop, r + this.m_paddingLeft, b + this.m_paddingTop, tt);

			// append the child to the div......................................//
			this.m_Scene.m_Div.appendChild(this.m_DOMElement);

			// subscribe to events..............................................//
			this.m_DOMElement.onclick = this.onclick.bind(this);
		};

		// event handler.......................................................//
		this.onclick = function(event) {
			// call base implementation for click events........................//
			return this.BaseClick(event);
		};
	};
	VBI.VisualObjects.Button.prototype = new VBI.VisualObjects.Base2D();

// ........................................................................//
// dummy object...........................................................//

	VBI.VisualObjects.Dummy = function() {
		this.load = function(dat, ctx) {
			// call prototype...................................................//
			Object.getPrototypeOf(this).load.call(this, dat, ctx);
		};

		// render the single instance..........................................//
		this.RenderInstance = function(nIndex, dc, xyz, scale, color) {
		};

		// Dummy.Render with respect to data binding.................................//
		this.Render = function(canvas, dc, clusterData) {
			// call base rendering method.......................................//
			this.BaseRender(canvas, dc);
		};

		this.RenderShadow = function(dcs, node, conf, lodF, xOff, yOff) {
		};

		// return this; automatically returned
	};
	VBI.VisualObjects.Dummy.prototype = VBI.VisualObjects.Base;

// ........................................................................//
// box3D object...........................................................//

	VBI.VisualObjects.Box3D = function() {
		// var m_BoxSceneId = null;

		this.load = function(dat, ctx) {
			// call prototype...................................................//
			Object.getPrototypeOf(this).load.call(this, dat, ctx);

			// load bindable properties.........................................//
			this.m_Props.push(this.m_DataSource = new VBI.NodeProperty(dat, 'datasource', null, ctx));
			this.m_Props.push(this.m_Pos = new VBI.AttributeProperty(dat, 'pos', this.m_DataSource, ctx, [
				0.0, 0.0, 0.0
			]));
			this.m_Props.push(this.m_Scale = new VBI.AttributeProperty(dat, 'scale', this.m_DataSource, ctx, [
				1.0, 1.0, 1.0
			]));
			this.m_Props.push(this.m_Tooltip = new VBI.AttributeProperty(dat, 'tooltip', this.m_DataSource, ctx, this.m_defaultTooltip));
			this.m_Props.push(this.m_Color = new VBI.AttributeProperty(dat, 'color', this.m_DataSource, ctx, this.m_defaultColor));
			this.m_Props.push(this.m_ColorBorder = new VBI.AttributeProperty(dat, 'colorBorder', this.m_DataSource, ctx, this.m_defaultColor));

			// load shared properties...........................................//
			this.BaseLoad(dat, ctx, this);
		};

		// render the single instance..........................................//
		this.RenderInstance = function(nIndex, pos, scale, color, colorBorder, fs) {
			// var scene = this.m_Scene;

			if (!scale) {
				scale = [
					1.0, 1.0, 1.0
				];
			}
			if (!color) {
				color = "#6f6f7a";
			}
			// determine the instance offsets...................................//
			// var aIO = this.m_IO[ nIndex ] = scene.GetInstanceOffsets( bb = this.m_BB[ nIndex ] = [ l, t, r, b ] );

		};

		// Box3D.Render with respect to data binding.................................//
		this.Render = function(canvas) {
			// get the scene and design mode....................................//
			var scene = this.m_Scene;

			if (!scene.m_bMainSceneInitialized) {
				return 0;
			}
			var ctx = scene.m_Ctx;
			var cntInstances = 0;

			var node;
			if ((node = this.m_DataSource.GetCurrentNode(ctx))) {
				cntInstances = node.m_dataelements.length;
				for (var nJ = 0; nJ < cntInstances; ++nJ) {
					this.m_DataSource.Select(nJ);
					var bHot = this.IsHot(nJ);
					var bSelected = this.IsSelected(ctx);

					var aPos = this.m_Pos.GetValueVector(ctx);
					var aScale = this.m_Scale.GetValueVector(ctx);

					var aCol = this.m_Color.GetValueColor(ctx);
					if (bSelected) {
						aCol = this.GetSelectColor(ctx, aCol);
					}
					if (bHot) {
						aCol = this.GetHotColor(ctx, aCol);
					}
					var aColBorder = this.m_ColorBorder.GetValueColor(ctx);
					if (bSelected) {
						aColBorder = this.GetSelectColor(ctx, aColBorder);
					}
					if (bHot) {
						aColBorder = this.GetHotColor(ctx, aColBorder);
					}

					var aFxSize = this.m_FxSize.GetValueBool(ctx);

					this.RenderInstance(nJ, aPos, aScale, aCol, aColBorder, aFxSize);
				}
			} // check: do single instance rendering in else branch

			// call base rendering method.......................................//
			// this.BaseRender( canvas, dc );

			return cntInstances; // to increase count of Scaling instances
		};

		this.DetailHitTest = function(ocb, nIndex, nsx, nsy) {
		};

		this.GetHitArray = function(x, y) {
		};

		// this.DesignBoxSize = VBI.Utilities.SceneBindDesignBoxBoxSize.bind( this, false );

		// event handlers......................................................//
	};
	VBI.VisualObjects.Box3D.prototype = VBI.VisualObjects.Base;

// return the visual object...............................................//
	return visualobjects;

};

}; // end of sap/ui/vbm/lib/sapvobase.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.library') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/**
 * Initialization Code and shared classes of library sap.ui.vbm.
 */
jQuery.sap.declare('sap.ui.vbm.library'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.core.Core'); // unlisted dependency retained
jQuery.sap.require('sap.ui.core.library'); // unlisted dependency retained
sap.ui.define("sap/ui/vbm/library",[
	'sap/ui/core/Core', 'sap/ui/core/library'
], function(Core, library1) {
	"use strict";

	/**
	 * SAP UI library: sap.ui.vbm
	 *
	 * @namespace
	 * @name sap.ui.vbm
	 * @author SAP SE
	 * @version 1.50.5
	 * @public
	 */

	// library dependencies
	// delegate further initialization of this library to the Core
	sap.ui.getCore().initLibrary({
		name: "sap.ui.vbm",
		dependencies: [
			"sap.ui.core"
		    // Also use of sap.ui.commons.RichTooltip ans sap.ui.unified.Menu,
			// but usage depends on application.
			// Thus we load those dependencies olny on demand with jQuery.sap.require!
		],
		types: [
			"sap.ui.vbm.ClusterInfoType", "sap.ui.vbm.SemanticType"
		],
		interfaces: [],
		controls: [
			"sap.ui.vbm.AnalyticMap", "sap.ui.vbm.GeoMap", "sap.ui.vbm.VBI", "sap.ui.vbm.Cluster"
		],
		elements: [
			"sap.ui.vbm.Area", "sap.ui.vbm.Areas", "sap.ui.vbm.Box", "sap.ui.vbm.Boxes", "sap.ui.vbm.Circle", "sap.ui.vbm.Circles",
			"sap.ui.vbm.Container", "sap.ui.vbm.Containers", "sap.ui.vbm.DragSource", "sap.ui.vbm.DropTarget", "sap.ui.vbm.Feature",
			"sap.ui.vbm.FeatureCollection", "sap.ui.vbm.GeoJsonLayer", "sap.ui.vbm.GeoCircle", "sap.ui.vbm.GeoCircles", "sap.ui.vbm.Legend",
			"sap.ui.vbm.LegendItem", "sap.ui.vbm.Pie", "sap.ui.vbm.PieItem", "sap.ui.vbm.Pies", "sap.ui.vbm.Region", "sap.ui.vbm.Resource",
			"sap.ui.vbm.Route", "sap.ui.vbm.Routes", "sap.ui.vbm.Spot", "sap.ui.vbm.Spots", "sap.ui.vbm.VoAggregation", "sap.ui.vbm.VoBase",
			"sap.ui.vbm.ClusterBase", "sap.ui.vbm.ClusterTree", "sap.ui.vbm.ClusterGrid", "sap.ui.vbm.ClusterDistance", "sap.ui.vbm.Heatmap",
			"sap.ui.vbm.HeatPoint", "sap.ui.vbm.ClusterContainer", "sap.ui.vbm.Adapter", "sap.ui.vbm.Adapter3D"
		],
		noLibraryCSS: false,
		version: "1.50.5"
	});

	/**
	 * Semantic type with pre-defined display properties, like colors, icon, pin image, and so on. Semantic types enforce to fiori guidelines.
	 *
	 * @enum {string}
	 * @public
	 * @ui5-metamodel This enumeration also will be described in the UI5 (legacy) designtime metamodel
	 */
	sap.ui.vbm.SemanticType = {

		/**
		 * Type indicating no state
		 *
		 * @public
		 */
		None: "None",

		/**
		 * Type indicating an Error state
		 *
		 * @public
		 */
		Error: "Error",

		/**
		 * Type indicating a Warning state
		 *
		 * @public
		 */
		Warning: "Warning",

		/**
		 * Type indicating a Success/Positive state
		 *
		 * @public
		 */
		Success: "Success",

		/**
		 * Type indicating the Default state
		 *
		 * @public
		 */
		Default: "Default",

		/**
		 * Type indicating an Inactive state
		 *
		 * @public
		 */
		Inactive: "Inactive",

		/**
		 * Type indicating a Hidden state
		 *
		 * @public
		 */
		Hidden: "Hidden"

	};

	/**
	 * Cluster Info Type
	 *
	 * @enum {int}
	 * @public
	 * @ui5-metamodel This enumeration also will be described in the UI5 (legacy) designtime metamodel
	 */
	sap.ui.vbm.ClusterInfoType = {

		/**
		 * Type indicating that Cluster Info should return only VOs covered by the Cluster object
		 *
		 * @public
		 */
		ContainedVOs: 0,

		/**
		 * Type indicating that Cluster Info should return info on child cluster nodes (next LOD). This is only supported for tree clustering.
		 *
		 * @public
		 */
		ChildCluster: 1,

		/**
		 * Type indicating that Cluster Info should return info on parent cluster node (previous LOD). This is only supported for tree clustering.
		 *
		 * @public
		 */
		ParentNode: 2,

		/**
		 * Type indicating that Cluster Info should return info on cluster node itself.
		 *
		 * @public
		 */
		NodeInfo: 10,

		/**
		 * Type indicating that Cluster Info should return info on Edges of the Voronoi Area for the cluster. This is only supported for tree
		 * clustering. Edges not merged with rectangles.
		 *
		 * @public
		 */
		Edges: 11

	};

	/**
	 * Route type, determining how line between start and endpoint should be drawn.
	 *
	 * @enum {string}
	 * @public
	 * @ui5-metamodel This enumeration also will be described in the UI5 (legacy) designtime metamodel
	 */
	sap.ui.vbm.RouteType = {

		/**
		 * Type indicating a straight connection
		 *
		 * @public
		 */
		Straight: "Straight",

		/**
		 * Type indicating a geodesic connection
		 *
		 * @public
		 */
		Geodesic: "Geodesic"

	};

	sap.ui.vbm.getResourceBundle = function() {
		return sap.ui.getCore().getLibraryResourceBundle("sap.ui.vbm.i18n");
	};

	/**
	 * Find the value of the first element in an Array satisfying the predicate.
	 *
	 * @param {object[]} source    The source array.
	 * @param {function} predicate The predicate.
	 * @returns {object|undefined} The first element of the array that matches the predicate.
	 * @private
	 */
	sap.ui.vbm.findInArray = function(source, predicate) {
		if (!Array.isArray(source) || typeof predicate !== "function") {
			return undefined;
		}

		for (var i = 0, count = source.length; i < count; i++) {
			var value = source[i];
			if (predicate(value)) {
				return value;
			}
		}

		return undefined;
	};

	/**
	 * Find the index of the first element in an Array satisfying the predicate.
	 *
	 * @param {object[]} source    The source array.
	 * @param {function} predicate The predicate.
	 * @returns {int} The index of the first element of the array for which the predicate returns true, -1 if none.
	 * @private
	 */
	sap.ui.vbm.findIndexInArray = function(source, predicate) {
		if (!Array.isArray(source) || typeof predicate !== "function") {
			return -1;
		}

		for (var i = 0, count = source.length; i < count; i++) {
			var value = source[i];
			if (predicate(value)) {
				return i;
			}
		}

		return -1;
	};

	return sap.ui.vbm;

}, /* bExport= */false);

}; // end of sap/ui/vbm/library.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Adapter') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides class sap.ui.vbm.Adapter
jQuery.sap.declare('sap.ui.vbm.Adapter'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained
sap.ui.define("sap/ui/vbm/Adapter",[
	'sap/ui/core/Element', './library'
], function(Element, library) {
	"use strict";

	var log = jQuery.sap.log;

	/**
	 * Constructor for a new GeoMap Adapter.
	 *
	 * @class
	 * Provides the ability to load VBI JSON into {@link sap.ui.vbm.GeoMap sap.ui.vbm.GeoMap} control.
	 *
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new object
	 * @author SAP SE
	 * @version 1.50.5
	 * @extends sap.ui.core.Element
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.Adapter
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 * @experimental Since 1.48.0 This class is experimental and might be modified or removed in future versions.
	 */
	var Adapter = Element.extend("sap.ui.vbm.Adapter", /** @lends sap.ui.vbm.Adapter.prototype */ {
		metadata: {

			library: "sap.ui.vbm",

			publicMethods: [
				"load"
			],

			associations: {
				/**
				 * The GeoMap control associated with the Adapter. The adapter would invoke methods and subscribe to events
				 * on this GeoMap instance
				 *
				 **/
				map: {
					type: "sap.ui.vbm.GeoMap"
				}
			},

			events: {
				/**
				 * The event is raised when a when the Adapter receives an event from GeoMap control. It is intended to unify the various
				 * GeoMap events as provided by VBI.
				 */
				submit: {
					parameters: {
						data: {
							type: "string"
						}
					}
				}
			}
		}
	});

	Adapter.prototype.init = function() {
		this._eventHandlers = [];

		//initialize section
		this._mapConfiguration = {};
		this._clusterVOs = [];

		//Dictionary for Data Attributes
		this._dataTypes = {};
		this._data = {};

		this._groupedActions = {};

		this._clickHandler = this._genericClickHandler;
		this._handler = this._genericGeomapHandler;

		this._idKeyMap = {};

		//Properties in VBI JSON that need special handling
		this._propsAnomalies = new Map();
		this._propsAnomalies.set("pos", "position");
		this._propsAnomalies.set("posarray", "position");
		this._propsAnomalies.set("dragdata", "dragData");

		// Allowed Route properties
		this._routeProperties = [
			"color",
			"colorBorder",
			"directionIndicator",
			"dotcolor",
			"dotwidth",
			"dragdata",
			"end",
			"hotDeltaColor",
			"labelBgColor",
			"labelPos",
			"labelText",
			"lineDash",
			"linewidth",
			"posarray",
			"selectColor",
			"start",
			"tooltip"];

			// Allowed Spot properties
		this._spotProperties = [
			"alignment",
			"contentOffset",
			"dragdata",
			"fxdir",
			"fxsize",
			"hotDeltaColor",
			"icon",
			"image",
			"labelBgColor",
			"labelPos",
			"labelText",
			"pos",
			"selectColor",
			"tooltip",
			"semanticType"];
	};

	Adapter.prototype.exit = function() {
		this._detachHandlers();
	};

	Adapter.prototype.setMap = function(map) {
		var oldMap = this._map() || null;
		var newMap = sap.ui.getCore().byId(map instanceof sap.ui.vbm.GeoMap ? map.getId() : map);

		if ((oldMap != newMap) && (oldMap != null)) {
			this._detachHandlers();
			this.init();
		}
		this.setAssociation("map", map, true);


		if (newMap != null) {
			var oModel = new sap.ui.model.json.JSONModel();
			newMap.setModel(oModel);
		}
	};

	/**
	 * Intrernal helper function to get map object out of map association

	 * @returns {sap.ui.vbm.GeoMap} The instance of Geomap
	 * @private
	 */
	Adapter.prototype._map = function() {
		return sap.ui.getCore().byId(this.getMap());
	};

	/**
	 * Attaches the specified event handler to the specified event with the provided listener.
	 * Mainly used for custom events - FCODE_SELECT & DETAILS_FCODE_SELECT
	 *
	 *
	 * @param {string} eventName The name of the event on 'this' to which the handler needs to be attached. <br/>
	 * @param {function} handler The handler needs to be attached. <br/>
	 * @param {object} listener The listener - would turn out to be value of 'this' inside the event handler. <br/>
	 * @returns {sap.ui.vbm.Adapter} <code>this</code> to allow method chaining.
	 * @private
	 */
	Adapter.prototype._attachHandler = function(eventName, handler, listener) {
		if ((eventName in this.mEventRegistry) && (this.mEventRegistry[eventName].length > 0)) {
			return this;
		} else {
			if (!listener._eventHandlers.some(function(eh) { return eh === handler; })) {
				listener._eventHandlers.push(handler);
			}
			this.attachEvent(eventName, handler, listener);
			return this;
		}
	};

	/**
	 * Detaches the adapter's event handlers from the instance of GeoMap instance associated with GeoMap
	 *
	 * @returns {sap.ui.vbm.Adapter} <code>this</code> to allow method chaining.
	 * @private
	 */
	Adapter.prototype._detachHandlers = function() {
		var that = this;
		var detachHandlers = function(sEventId) {
			if (this.hasListeners(sEventId)) {
				var aEventListeners = this.mEventRegistry[sEventId];

				for (var i = 0, iL = aEventListeners.length; i < iL; i++) {
					var index = that._eventHandlers.indexOf(aEventListeners[i].fFunction);
					if (index !== -1 ) {
						this.detachEvent(sEventId, aEventListeners[i].fFunction, aEventListeners[i].oListener);
					}
				}
			}
		};

		var geoMap = this._map();
		if (geoMap != null) {
			var oMapEvents = geoMap.mEventRegistry;

			for (var aEvent in oMapEvents) {
				if (oMapEvents.hasOwnProperty(aEvent)) {
					detachHandlers.call(geoMap, aEvent);
				}
			}

			var detachVoHandlers = function(oVo) {
				var oVoEvents = oVo.mEventRegistry;

				for (var aVoEvent in oVoEvents) {
					if (oVoEvents.hasOwnProperty(aVoEvent)) {
						detachHandlers.call(oVo, aVoEvent);
					}
				}
			};

			geoMap.getVos().forEach(detachVoHandlers);
		}

		return this;
	};

	/**
	 * Parses and process sections of the VBI JSON and loads them into JSON Model bound to the GeoMap
	 *
	 * @param {string | object} data VBI JSON to be loaded into the GeoMap control. <br/>
	 * @returns {Promise} A Promise object that is resolved when the VBI JSON is processed.
	 * @public
	 */
	Adapter.prototype.load = function(data) {
		var obj = null;

		if (typeof data === 'string') {
			try {
				obj = JSON.parse(data);
			} catch (ex) {
				log.debug("sap.ui.vbm.Adapter: attempt to load invalid JSON string.");
				return this;
			}
		} else if (typeof data === 'object') {
			obj = data;
		}

		if (!obj) {
			log.debug("sap.ui.vbm.Adapter: nothing to load.");
			return this;
		}
		if (!obj.SAPVB) {
			log.debug("sap.ui.vbm.Adapter:invalid object supplied for load.");
			return this;
		}
		if (obj.SAPVB.Config) {
			this._processConfiguration(obj.SAPVB.Config);
		}
		if (obj.SAPVB.Resources) {
			this._processResources(obj.SAPVB.Resources);
		}
		if (obj.SAPVB.DataTypes) {
			this._processDataTypes(obj.SAPVB.DataTypes);
		}
		//this has to be processed before scene to mark cluster VOs which must not be created
		if (obj.SAPVB.Clustering) {
			this._processClusters(obj.SAPVB.Clustering);
		}

		return (obj.SAPVB.MapProviders ? this._processMapProviders(obj.SAPVB.MapProviders)
			: Promise.resolve()).then(function() {
				if (obj.SAPVB.MapLayerStacks) {
					this._processMapLayerStacks(obj.SAPVB.MapLayerStacks);
				}

				if (obj.SAPVB.Scenes) {
					this._processScenes(obj.SAPVB.Scenes);
				}

				if (obj.SAPVB.Data) {
					this._processData(obj.SAPVB.Data);
				}

				if (obj.SAPVB.Actions) {
					this._processActions(obj.SAPVB.Actions);
				}

				if (obj.SAPVB.Automation && obj.SAPVB.Automation.Call) {
					this._processAutomation(obj.SAPVB.Automation, obj.SAPVB.Menus);
				}

				if (obj.SAPVB.Windows) {
					this._processDetailWindows(obj);
				}
			}.bind(this));
	};

	/**
	 * Processes the Configuration section of the VBI JSON
	 *
	 * @param {object} configuration Configuration section of VBI JSON. <br/>
	 * @returns {sap.ui.vbm.Adapter} <code>this</code> to allow method chaining.
	 * @private
	 */
	Adapter.prototype._processConfiguration = function(configuration) {
		return this;
	};

	/**
	 * Processes the Resources section of the VBI JSON. Delta load is not supported for resources.
	 *
	 * @param {object} resources Resources section of VBI JSON. <br/>
	 * @returns {sap.ui.vbm.Adapter} <code>this</code> to allow method chaining.
	 * @private
	 */
	Adapter.prototype._processResources = function(resources) {
		if (resources.Set) {
			var geoMap = this._map();
			geoMap.destroyResources();

			[].concat(resources.Set.Resource).forEach(function(res) {
				geoMap.addResource(new sap.ui.vbm.Resource({"name": res.name, "value": res.value}));
			}, this);
		}

		//Delta load of resources isn't supported from back-end - Need not check resources.Remove

		return this;
	};

	/**
	 * Processes the DataTypes section of the VBI JSON. Delta load is supported for this section but VBI back-end does not
	 * provide an option for it.
	 *
	 * @param {object} dataTypes DataTypes section of VBI JSON. <br/>
	 * @returns {sap.ui.vbm.Adapter} <code>this</code> to allow method chaining.
	 * @private
	 */
	Adapter.prototype._processDataTypes = function(dataTypes) {
		if (dataTypes.Set) {
			// Delta - The below check is an assumption - There is now way this can be true since none of the
			// simple transformations on the backend support delta on Data types yet.
			if (dataTypes.Set.name && dataTypes.Set.type && (dataTypes.Set.type === "N")) {
				[].concat(dataTypes.Set.N).foreach(function(dt) {
					this._dataTypes.forEach(function(_dt) {
						if (_dt.name == dt.name) {
							_dt = dt;
						}
					});
				});
			} else {
				// This is Replace all Data types
				this._dataTypes = [].concat(dataTypes.Set.N);
			}
		}
		return this;
	};

	/**
	 * Processes the Data section of the VBI JSON. Delta load is supported for this section.
	 *
	 * @param {object} data Data section of VBI JSON. <br/>
	 * @returns {sap.ui.vbm.Adapter} <code>this</code> to allow method chaining.
	 * @private
	 */
	Adapter.prototype._processData = function(data) {
		/*
		 * Helper function to perform a lookup of the DataTypes and fetch the name of the attribute from its alias and data type name
		 *
		 * */
		var findAttribute = function(a, name) {
			var oEntry = sap.ui.vbm.findInArray(this._dataTypes, function(_dt) { return _dt.name == name; });

			if ((oEntry == null) || !(oEntry.A)) {
				return undefined;
			} else {
				var oAttr = sap.ui.vbm.findInArray(oEntry.A, function(_a) { return _a.alias == a; });
				if (oAttr != null) {
					return oAttr.name;
				} else {
					return undefined;
				}
			}
		};

		var set = function(n) {
			if (n.name && n.E) {
				this._data[n.name] = [].concat(n.E).map(function(e) {
					var d = {};
					for (var a in e) {
						if ((a !== "xmlns:VB") &&
							(a !== "n.name") &&
							e.hasOwnProperty(a)) {
							if (a === "VB:c") {
								d["changeable"] = e[a];
							} else if (a === "VB:s") {
								d["select"] = e[a];
							} else {
								var sAttr = findAttribute.call(this, a, n.name);
								if ((sAttr != null) && (sAttr !== "")) {
									d[sAttr] = e[a];
								} else {
									d[a] = e[a];
								}
							}
						}
					}

					return d;
				}, this);
			}
		};

		var update = function(e) {
			var d = {};
			for (var a in e) {
				if ((a !== "xmlns:VB") &&
					(a !== "n.name") &&
					e.hasOwnProperty(a)) {
					if (a === "VB:c") {
						d["changeable"] = e[a];
					} else if (a === "VB:s") {
						d["select"] = e[a];
					} else {
						var sAttr = findAttribute.call(this, a, e["n.name"]);
						if ((sAttr != null) && (sAttr !== "")) {
							d[sAttr] = e[a];
						} else {
							d[a] = e[a];
						}
					}
				}
			}

			//If the aggregation doesn't exist, initialize it to an empty array.
			if (!this._data[e["n.name"]]) {
				this._data[e["n.name"]] = [];
			}

			if (this._data[e["n.name"]].some(function(_d) {return _d.Key == e.K;})) {
				// The instance (Spot) already exists - modify it
				var index = sap.ui.vbm.findIndexInArray(this._data[e["n.name"]], function(_d) { return _d.Key === e.K; });
				if (index !== -1) {
					this._data[e["n.name"]][index] = d;
				}
			} else {
				// The instance (Spot) doesn't exist - push it
				this._data[e["n.name"]].push(d);
			}
		};

		if (data.Remove) {
			[].concat(data.Remove).filter(function(r) {
				return (r.N && r.N.E);
			}).forEach(function(r) {
				[].concat(r.N.E).forEach(function(e){
					var index = sap.ui.vbm.findIndexInArray(this._data[r.name], function(_d) { return _d.Key === e.K; });

					if (index !== -1) {
						this._data[r.name].splice(index, 1);
					}
				}, this);
			}, this);
		}

		/*
		 * The key to differentiating delta load from full update is the structure of
		 * data.Set. See simple transformation VBI_DYN_DATA_TRANSFER
		 *
		 * --> Delta Load
		 * "Data" : {
		 * 	"Set": [
		 * 		{ "name": "Spots", "type": "N", ....},
		 *      { "name": "Links", "type": "N", ....},
		 * 	]
		 * }
		 *
		 * --> Full Update
		 *	"Data": {
	  	 *		"Set": {
		 *			"N": [
		 *				{ "name": "Spots", ... },
		 *				{ "name": "Links", ... },
		 *			]
		 *		}
		 *	}
		 *
		 *  Conditions to differentiate full update from full load
		 *  	Data.Set, is an object, does not have has attributes other than N (namely name & type)
		 *  	Other wise delta load
		 * */

		if (data.Set && (typeof data.Set === 'object') && !(jQuery.isEmptyObject(data.Set))) {
			if (!Array.isArray(data.Set) && !(data.Set.name) && !(data.Set.type)) {
				//Full Update - Replace complete Data Section
				this._data = {};
				if (data.Set.N !== null) {
					[].concat(data.Set.N).forEach(set, this);
				}

			} else {
				//Delta Update
				[].concat(data.Set)
					.filter(function(s) { return (s.name) && (s.type); })
					.map(function(s) { return [].concat(s.N); })
					.reduce(function(oAn, oBn) { return oAn.concat(oBn); })
					.map(function(n) {
						var e = [].concat(n.E);
						return e.map(function(_e){
							_e["n.name"] = n.name;
							return _e;
						});
					})
					.reduce(function(oAe, oBe) { return oAe.concat(oBe); })
					.forEach(update, this);
			}
		}

		this._map().getModel().setData(this._data, false);
		return this;
	};

	/**
	 * Processes the MapProviders section of the VBI JSON. Delta load is supported for this section.
	 *
	 * @param {object} providers MapProviders section of VBI JSON transformed into map provider structure for GeoMap. <br/>
	 * @returns {Promise} A Promise object that is resolved when the MapProviders in VBI JSON is processed.
	 * @private
	 */
	Adapter.prototype._processMapProviders = function(providers) {
		if (providers.Set && providers.Set.MapProvider) { //support only for "set" verb
			var mapProviders = [].concat(providers.Set.MapProvider).map(function(provider) {
				return {
					name 		: provider.name,
					tileX		: provider.tileX,
					tileY		: provider.tileY,
					minLOD		: provider.minLOD,
					maxLOD		: provider.maxLOD,
					copyright	: provider.copyright,
					Source 		: provider.Source ? [].concat(provider.Source).map(function(source) {
						return {
							id	: source.id,
							url	: source.url
						};
					}) : provider.Source
				};
			});

			var googleSniffer = function(source) {
				// var sRegex = /:\/\/(.[^/]+)/;
				// var sHostname = sUrl.match(sRegex)[1];
				// return jQuery.sap.endsWith(sHostname, "googleapis.com");
				return source && source.url && source.url.indexOf("google") !== -1;
			};

			var aGoogleTileApiSources = mapProviders
				.map(function(oProvider) { return [].concat(oProvider.Source); })
				.reduce(function(a, b) { return a.concat(b); })
				.filter(googleSniffer);

			if (aGoogleTileApiSources.length > 0) {
				var apiKeys = [];
				var oGoogleTileApiSourcesByApiKey = aGoogleTileApiSources.reduce(function(g, a) {
					var apiKey = a.url.split("key=")[1];
					g[apiKey] = g[apiKey] || [];
					if (sap.ui.vbm.findIndexInArray(apiKeys, function(k) { return k === apiKey; } ) === -1) {
						apiKeys.push(apiKey);
					}
					g[apiKey].push(a);
					return g;
				}, {});

				var getSessionResponse = function(apiKey) {
					return new Promise(function(resolve, reject) {
						var xmlHttp = new XMLHttpRequest();
						xmlHttp.open("POST", 'https://www.googleapis.com/tile/v1/createSession?key=' + apiKey, true); // true for asynchronous
						xmlHttp.setRequestHeader("Content-Type", "application/json");

						xmlHttp.onreadystatechange = function() {
							if (xmlHttp.readyState == 4) {
								if (xmlHttp.status == 200) {
									resolve(JSON.parse(xmlHttp.responseText));
								} else {
									reject(new Error(xmlHttp.statusText));
								}
							}
						};

						var parameters = {
							"mapType": "terrain",
							"language": "en-NZ",
							"region": "nz",
							"layerTypes": [ "layerRoadmap" ],
							"overlay":  false,
							"scale": "scaleFactor1x"
						};
						xmlHttp.send(JSON.stringify(parameters));

					}).then(function(response) {
						// Expected URL from backend
						// https://www.googleapis.com/tile/v1/tiles/{Z}/{X}/{Y}?key=YOUR_API_KEY
						if (response && response.session) {
							oGoogleTileApiSourcesByApiKey[apiKey].forEach(function(source) {
								source.url = source.url + "&session=" + response.session;
							});
						}
					}, function(statusText) {
						log.debug(statusText);
					});
				};

				return Promise.all(apiKeys.map(getSessionResponse)).then(function() {
					this._mapConfiguration.MapProvider = mapProviders;
					this._updateMapconfiguration();
				}.bind(this));
			} else {
				this._mapConfiguration.MapProvider = mapProviders;
				this._updateMapconfiguration();
				return Promise.resolve();
			}
		}
		return this;
	};

	/**
	 * Processes the MapLayerStacks section of the VBI JSON. Delta load is supported for this section.
	 *
	 * @param {object} stacks MapLayerStacks section of VBI JSON transformed into map layer stacks structure for GeoMap. <br/>
	 * @returns {sap.ui.vbm.Adapter} <code>this</code> to allow method chaining.
	 * @private
	 */
	Adapter.prototype._processMapLayerStacks = function(stacks) {
		if (stacks.Set && stacks.Set.MapLayerStack) { //support only for "set" verb
			this._mapConfiguration.MapLayerStacks = [].concat(stacks.Set.MapLayerStack).map(function(stack) {
				return {
					name		: stack.name,
					MapLayer 	: stack.MapLayer ? [].concat(stack.MapLayer).map(function(layer) {
						return {
							name			: layer.name,
							refMapProvider	: layer.refMapProvider,
							opacity			: layer.opacity,
							colBkgnd		: layer.colBkgnd
						};
					}) : stack.MapLayer
				};
			});
			this._updateMapconfiguration();
		}
		return this;
	};

	/**
	 * Sets the GeoMap's Map configuration to the transformed MapLayerStacks and MapProviders from VBI JSON.
	 *
	 * @param {object} mapLayerStacks MapLayerStacks section of VBI JSON transformed into map layer stacks structure for GeoMap. <br/>
	 * @returns {sap.ui.vbm.Adapter} <code>this</code> to allow method chaining.
	 * @private
	 */
	Adapter.prototype._updateMapconfiguration = function() {
		if (this._mapConfiguration.MapProvider && this._mapConfiguration.MapLayerStacks) {
			this._map().setMapConfiguration(this._mapConfiguration);
		}
		return this;
	};

	/**
	 * Processes the VOs array from VBI JSON VBI JSON.
	 *
	 * @param {object[]} oScenes Scenes section of VBI JSON. <br/>
	 * @returns {sap.ui.vbm.Adapter} <code>this</code> to allow method chaining.
	 * @private
	 */
	Adapter.prototype._processScenes = function(oScenes) {
		//Process VOs only if scene is SceneGeo
		if (oScenes.Set && oScenes.Set.SceneGeo) {
			var oMap = this._map();

			if (oScenes.Set.SceneGeo.refMapLayerStack) {
				oMap.setRefMapLayerStack(oScenes.Set.SceneGeo.refMapLayerStack);
			}

			var vos = oScenes.Set.SceneGeo.VO;
			oMap.destroyVos();

			if (!vos) {
				return this;
			}

			vos.forEach(function(definition) {
				// skip cluster VOs as we're converting from Spots (VO) based clustering to container based clustering on a fly and do not need cluster VOs at all
				// see _processCluster() for details
				if (this._clusterVOs.indexOf(definition.id) !== -1) {
					return;
				}
				var voTemplate, voAggregation, boundProperties = [], settings = {};

				function processProperties(allowedAttributes, propsAnomalies) {
					for (var attribute in definition) {
						var pos = attribute.indexOf('.bind');
						var property = pos !== -1 ? attribute.substring(0, pos) : attribute;

						if (allowedAttributes.indexOf(property) !== -1) {
							property = propsAnomalies.get(property) || property;
							var value = definition[attribute];

							if (pos !== -1) {
								value = definition[attribute].substring(definition[attribute].indexOf('.') + 1);
								boundProperties.push(value);
							}
							settings[property] = pos !== -1 ? "{" + value + "}" : value;
						}
					}
				}
				// This function doesn't support data binding for Drag'N'Drop related subnodes
				// as it will require to change loading for data types and data sections from list like approach to full tree approach
				function processDragAndDrop() {
					if (definition.DragSource && voAggregation.getMetadata().hasAggregation("dragSource")) {
						[].concat(definition.DragSource.DragItem).forEach(function(item) {
							voAggregation.addDragSource(new sap.ui.vbm.DragSource({
								type: item.type
							}));
						});
					}
					if (definition.DropTarget && voAggregation.getMetadata().hasAggregation("dropTarget")) {
						[].concat(definition.DropTarget.DropItem).forEach(function(item) {
							voAggregation.addDropTarget(new sap.ui.vbm.DropTarget({
								type: item.type
							}));
						});
					}
				}

				switch (definition.type) {
					case "{00100000-2012-0004-B001-64592B8DB964}": // Spot
						processProperties(this._spotProperties, this._propsAnomalies);
						voTemplate = new sap.ui.vbm.Spot(settings);
						voAggregation = new sap.ui.vbm.Spots(definition.id);
						processDragAndDrop();
						break;
					case "{00100000-2012-0004-B001-C46BD7336A1A}": // Route
						processProperties(this._routeProperties, this._propsAnomalies);
						voTemplate = new sap.ui.vbm.Route(settings);
						voAggregation = new sap.ui.vbm.Routes(definition.id);
						processDragAndDrop();
						break;
					case "{00100000-2012-0004-B001-F311DE491C77}": // Area
					case "{00100000-2013-0004-B001-7EB3CCC039C4}": // Circle
					case "{00100000-2013-0004-B001-686F01B57873}": // Geo Circle
					case "{00100000-2012-0004-B001-BFED458C3076}": // Box
					case "{00100000-2012-0004-B001-383477EA1DEB}": // Pie Chart
					case "ExtLink": // GUID???
					case "ExtArea": // GUID???
					default:
						log.debug("unsupported VO type: " + definition.type);
						return;
				}

				var index = sap.ui.vbm.findIndexInArray(this._dataTypes, function(_d) { return _d.name === definition.datasource; });

				if (index !== -1) {
					var dataType = this._dataTypes[index];
					/*
					* REF-1
					* The back-end eventing is based on the Key attribute for each VO from the Data section.
					* However, GeoMap does not consider these values. This becomes a problem when converting a GeoMap event into
					* Adapter's submit event - the key corresponding to the VO (ex. Spot) which is the object of the event (clicked) needs to embedded into
					* the event payload to enable backend to continue with it's event pipeline.
					*
					* Hence, the below binds this key to an addition attribute stored on the model bound to the VOAggregation so that the same can be retrieved.
					* */
					voTemplate.bindProperty("key", { path: dataType.key });
					boundProperties.push(dataType.key);

					// custom properties handling
					var customProperties = [];

					dataType.A.forEach(function(attribute) {
						if (boundProperties.indexOf(attribute.name) === -1) {
							customProperties.push(attribute.name);
							var data = new sap.ui.core.CustomData({
								key: attribute.name,
								value: "{" + attribute.name + "}"
							});
							voTemplate.addCustomData(data);
						}
					});

					if (customProperties.length) {
						voAggregation.setCustomProperties(customProperties);
					}
					voAggregation.bindAggregation("items", {
						path: "/" + definition.datasource + "",
						template: voTemplate
					});
				} else {
					voAggregation.addItem(voTemplate);
				}
				oMap.addVo(voAggregation);
			}.bind(this));
		}
		return this;
	};

	/**
	 * Processes the VOs array from VBI JSON.
	 *
	 * @param {object} actions Actions section of VBI JSON. <br/>
	 * @returns {sap.ui.vbm.Adapter} <code>this</code> to allow method chaining.
	 * @private
	 */
	Adapter.prototype._processActions = function(actions) {
		var attach = function(obj) {
			return function(ga) {
				switch (ga.refEvent) {
					case "Click":
						if (!this._eventHandlers.some(function(eh) { return eh === this._handler; }, this)) {
							this._eventHandlers.push(this._handler);
						}
						obj.attachClick(this._handler, this);
						break;
					case "ContextMenu":
						if (!this._eventHandlers.some(function(eh) { return eh === this._handler; }, this)) {
							this._eventHandlers.push(this._handler);
						}
						obj.attachContextMenu(this._handler, this);
						break;
					case "DoubleClick":
						if (!this._eventHandlers.some(function(eh) { return eh === this._clickHandler; }, this)) {
							this._eventHandlers.push(this._clickHandler);
						}
						obj.attachClick(this._clickHandler, this);
						break;
					case "Drop":
						if (!this._eventHandlers.some(function(eh) { return eh === this._handler; }, this)) {
							this._eventHandlers.push(this._handler);
						}
						obj.attachDrop(this._handler, this);
						break;
					default:
						break;
				}
			};
		};
		//var matchingVo = function(t) { return function(v) { return v.getId() == t; }; };
		if ((actions.Set != null) &&
			(actions.Set.Action != null)) {

			var vos = this._map().getVos();
			var voTypes = vos.map(function(v) { return v.getTemplateObject().type; });

			this._groupedActions = [].concat(actions.Set.Action)
									.reduce(function(g, a) {
										var group = a.refVO;
										if (!a.refVO) {
											group = "General";
										}
										g[group] = g[group] || [];
										g[group].push(a);
										return g;
									}, {});

			var keyPressFinder = function(t) { return t.refEvent === "KeyPress"; };
			var clickFinder = function(a) { return a.refEvent === "Click"; };
			var doubleClickFinder = function(a) { return a.refEvent === "DoubleClick"; };
			var clickSkipper = function(a) { return a.refEvent !== "Click"; };
			var type;

			for (var group in this._groupedActions) {
				switch (group) {
					case "Spot":
						type = "{00100000-2012-0004-B001-64592B8DB964}";
						break;
					case "Link":
						type = "{00100000-2012-0004-B001-C46BD7336A1A}";
						break;
					case "Map":
						type = group;
						break;
					default:
						type = "";
						break;
				}
				var obj = type === "Map" ? this._map() : vos[voTypes.indexOf(type)];

				if (obj) {
					var groupedActions = this._groupedActions[group];

					if (groupedActions.some(doubleClickFinder)) {
						if (groupedActions.some(clickFinder)) {
							groupedActions.filter(clickSkipper).forEach(attach(obj), this);
						} else {
							groupedActions.forEach(attach(obj), this);
						}
					} else {
						groupedActions.forEach(attach(obj), this);
					}
				}

				if (group === "General") {
					var keyPressAction = sap.ui.vbm.findInArray(this._groupedActions[group], keyPressFinder);
					if (keyPressAction != null) {
						this._setupKeyboardEvents(keyPressAction);
					}
				}
			}
		}
		return this;
	};

	/**
	 * Processes the KeyPress Action from VBI JSON.
	 *
	 * @param {object} action KeyPress Action from Action section of VBI JSON. <br/>
	 * @returns {sap.ui.vbm.Adapter} <code>this</code> to allow method chaining.
	 * @private
	 */
	Adapter.prototype._setupKeyboardEvents = function(action) {
		var that = this;
		var geoMap = this._map();
		geoMap.setAllowKeyEventRepeat(false);
		geoMap.setKeyEventDelay(250);

		var handler = function(event){
			var param = event.mParameters;
			if (param.key == "Shift" || param.code == 16 ||
				param.key == "Control" || param.code == 17 ||
				param.key == "Alt" || param.code == 18 ||
				param.key == "Meta" || param.code == 91) {
				return that;
			}
			var data = {
				"version": "2.0",
				"xmlns:VB": "VB",
				"Action": {
					"name": action.name,
					"Params": {
						"Param": [
							{
								"name": "code",
								"#": param.code
							},
							{
								"name": "shift",
								"#": param.shift
							},
							{
								"name": "ctrl",
								"#": param.ctrl
							},
							{
								"name": "alt",
								"#": param.alt
							},
							{
								"name": "meta",
								"#": param.meta
							}
						]
					}
				}
			};
			that.fireSubmit({data: JSON.stringify(data)});
		};

		if (!this._eventHandlers.some(function(eh) { return eh === handler; }, this)) {
			this._eventHandlers.push(handler);
		}
		this._map().attachKeyDown(handler);
		return this;
	};

	/**
	 * Processes the Automation section from VBI JSON.
	 *
	 * @param {object} automation Automation section of VBI JSON. <br/>
	 * @param {object} menus Menus section of VBI JSON. <br/>
	 * @returns {sap.ui.vbm.Adapter} <code>this</code> to allow method chaining.
	 * @private
	 */
	Adapter.prototype._processAutomation = function(automation, menus) {

		var call = {};

		//If ContextMenu Automation, then the instance ID needs to be patched from VBI (Ex: Spot.NEC1sJ/qHta0xL4LqkzyXg==) to Geo JSON Unique Id
		//Else while returning the FCODE selected event, in OnGeomapSubmit, it wouldn't be able to find an instance for the event.

		// This won't work since the action of the event from VBI would be what's specified in the Menus section of VBI JSON and there is no way
		// that event can be subscribed to.

		if (automation.Call.handler === "CONTEXTMENUHANDLER") {
			var that = this;

			//Fetch the VO with matching Key
			var oVos = this._map().getVos()
				.map(function(oVoAggregation) { return oVoAggregation.getItems(); })
				.reduce(function(oVoA, oVoB) { return oVoA.concat(oVoB); });

			var index = sap.ui.vbm.findIndexInArray(oVos, function(v) { return v.getKey() === automation.Call.instance.split('.')[1]; });
			if (index !== -1) {
				var oVo = oVos[index];

				if (oVo) {
					automation.Call.instance = oVo.getUniqueId();

					if (menus.Set.Menu) {
						[].concat(menus.Set.Menu).forEach(function(oMenu) {
							that._attachHandler.call(
									oVo,
									oMenu.action,
									function(oEvent) {
										var oEventData = oEvent.mParameters.data;
										oEventData.Action.instance = oEventData.Action.object + '.' + oEvent.oSource.getKey();

										this.fireSubmit({
											data: JSON.stringify(oEventData)
										});
									},
									that);
						});
					}
				}
			}
		}

		call["Automation"] = automation;
		call["Menus"] = menus;

		var oLoad = {};
		oLoad["SAPVB"] = call;

		this._map().load(oLoad);
		return this;
	};

	/**
	 * Processes the Clustering section of the VBI JSON
	 *
	 * @param {object} clusters Clustering section of VBI JSON. <br/>
	 * @returns {sap.ui.vbm.Adapter} <code>this</code> to allow method chaining.
	 * @private
	 */
	Adapter.prototype._processClusters = function(clusters) {
		this._clusterVOs = []; //always clear list of cluser VOs

		if (clusters.Set) {
			var map = this._map();
			map.destroyClusters();

			[].concat(clusters.Set.Cluster).forEach(function(item) {
				//mark cluster VOs, to avoid creating them later in scene processing
				this._clusterVOs.push(item.VO);
				var cluster = null;
				//convert cluster definition
				switch (item.type) {
					case "distance":
						cluster = new sap.ui.vbm.ClusterDistance(item.id);
						if (item.distance) {
							cluster.setDistance(parseFloat(item.distance));
						}
						break;
					case "grid":
						cluster = new sap.ui.vbm.ClusterGrid(item.id);
						if (item.limit) {
							cluster.setLimit(parseInt(item.limit, 10));
						}
						if (item.limitOnSum) {
							cluster.setLimitTotal(parseInt(item.limitOnSum, 10));
						}
						if (item.order) {
							cluster.setOrderIndex(parseInt(item.order, 10));
						}
						if (item.areabordersize) {
							cluster.setCellSpacing(-parseInt(item.areabordersize, 10));
						}
						if (item.distanceX && item.distanceY) {
							cluster.setGridSize(item.distanceX + ";" + item.distanceY);
						}
						if (item.offsetX && item.offsetY) {
							cluster.setOffset(item.offsetX + ";" + item.offsetY);
						}
						break;
					case "tree":
						cluster = new sap.ui.vbm.ClusterTree(item.id, {});
						break;
					default:
						log.debug("sap.ui.vbm.Adapter: unsupported clustering type \"" + item.type + "\"" );
						break;
				}
				if (cluster) {
					//process common properties
					if (item.rule) {
						cluster.setRule(item.rule);
					}
					cluster.setTextSettings({
						textcolor: item.textcolor,
						textfont: item.textfont,
						textfontsize: item.textfontsize,
						textoffset: item.textoffset,
						textoffsetY: item.textoffsetY
					});
					cluster.setVizTemplate(new sap.ui.vbm.Cluster()); //must be container based cluster
					map.addCluster(cluster);
				}
			}, this);
		}
		return this;
	};

	/**
	 * Processes the Windows section of the VBI JSON
	 *
	 * @param {object} obj oSAPVB VBI JSON in entirety since processing detail window needs multiple sections <br/>
	 * @returns {sap.ui.vbm.Adapter} <code>this</code> to allow method chaining.
	 * @private
	 */
	Adapter.prototype._processDetailWindows = function(obj) {
		//No transformation needed for removal - pass it along to VBI as is.

		var oGeoMap = this._map();
		var that = this;

		/*Only delta supported for Windows - Set*/
		if (obj.SAPVB.Windows.Set.name) {

			var findPredicate =  function(prop, name) {
				return function(d) {
					return d[prop] === name;
				};
			};

			var aWindows = [].concat(obj.SAPVB.Windows.Set).map(function(wnd) {

				var oModelData = oGeoMap.getModel().getData();

				var oWindow = wnd;

				for (var sAttribute in wnd.Window) {
					if (wnd.Window.hasOwnProperty(sAttribute)) {
						if (jQuery.sap.endsWith(sAttribute, ".bind")) {
							//Only known bound attribute is pos - known to have a value like Spots.+hY+jTn2HueNpLoqrc5IAg==.GeoPosition
							if (jQuery.sap.startsWith(sAttribute, "pos")) {
								var aParameters = wnd.Window[sAttribute].split(".");
								if (aParameters[0] in oModelData) {
									var index = sap.ui.vbm.findIndexInArray(oModelData[aParameters[0]], findPredicate("Key", aParameters[1]));

									if (index !== -1) {
										var oData = oModelData[aParameters[0]][index];

										if (aParameters[2] in oData) {
											delete oWindow.Window[sAttribute];
											oWindow.Window[sAttribute.split(".")[0]] = oData[aParameters[2]];
										}
									}
								}
							}
						}
					}
				}
				return oWindow;
			}, this);

			obj.SAPVB.Windows.Set = aWindows;

			//Dereference VOs
			if (obj.SAPVB.Scenes && obj.SAPVB.Scenes.Set && obj.SAPVB.Scenes.Set.name && obj.SAPVB.Scenes.Set.Scene && obj.SAPVB.Scenes.Set.Scene.VO) {

				var aVOs = [].concat(obj.SAPVB.Scenes.Set.Scene.VO).map(function(v) {
					var oVO = v;

					var dereferenceBoundAttributes = function(oVO, sAttribute, aParameters) {
						return function(s) {
							if (s.name && s.type) {
								var oDataList = s[s.type];
								if (oDataList.name === s.name) {
									var oDataType = sap.ui.vbm.findInArray([].concat(this._dataTypes), findPredicate("name", oDataList.name));
									var sAlias = sap.ui.vbm.findInArray([].concat(sap.ui.vbm.findInArray([].concat(oDataType.N), findPredicate("name", aParameters[2])).A),
											findPredicate("name", aParameters[4])).alias;

									var oData = [].concat(oDataList.E)[aParameters[1]];
									var oSubData = [].concat(sap.ui.vbm.findInArray([].concat(oData.N), findPredicate("name", aParameters[2])).E)[aParameters[3]];

									oVO[sAttribute.split(".")[0]] = oSubData[sAlias];
									delete oVO[sAttribute];
								}
							}
						};
					};


					for (var sAttribute in v) {
						if (v.hasOwnProperty(sAttribute)) {
							if (jQuery.sap.endsWith(sAttribute, ".bind")) {
								//Only known bound attribute is text - has values like DetailData.0.Column.1.Text
								var aParameters = v[sAttribute].split(".");

								if (obj.SAPVB.Data && obj.SAPVB.Data.Set) {
									//Only Delta supported for Detail Window
									[].concat(obj.SAPVB.Data.Set).forEach(dereferenceBoundAttributes(oVO, sAttribute, aParameters), this);
								}
							}
						}
					}

					//Process relevant actions
					if (obj.SAPVB.Actions && obj.SAPVB.Actions.Set) {
						[].concat(obj.SAPVB.Actions.Set).filter(function(a) { return a.Action.refVO === oVO.id; }).forEach(function(fa) {
							that._attachHandler.call(oGeoMap, fa.Action.name, that._handler, that);
						});
					}

					return oVO;
				}, this);

				//delete obj.SAPVB["Actions"];
				obj.SAPVB.Scenes.Set.Scene.VO = aVOs;
			}
			oGeoMap.load(obj);
		}
		return this;
	};

	/**
	 * Generic Geomap event handler that relays the event to the consuming application
	 * This addresses all events.
	 * @param {object} event VBI JSON payload containing the event details. <br/>
	 * @private
	 */
	Adapter.prototype._genericGeomapHandler = function(event) {
		var oParameters = event.getParameters();
		var oEventData = oParameters.data ? oParameters.data : oParameters;
		if (oEventData.Action && oEventData.Action.object) {
			// Whatever back-end refers to as Links, they are referred to as Routes by Geomap
			if (oEventData.Action.object === "Route") {
				oEventData.Action.object = "Link";
			}
			var oAction = sap.ui.vbm.findInArray(this._groupedActions[oEventData.Action.object], function(a) { return a.refEvent.toLowerCase() === oEventData.Action.name.toLowerCase(); });
			if (oAction) {
				if (oEventData.Action && oEventData.Action.instance) {
					oEventData.Action.instance = oEventData.Action.instance.split('.')[0] + '.' + oParameters.instance.getKey();
					oEventData.Action.name = oAction.name;
				}

				if ((oEventData.Data) && (oEventData.Data.Merge) && (oEventData.Data.Merge.N)) {
					var idKeyMapGenerator = function() {
						 this._map().getVos()
							.map(function(a) { return a.getItems(); })
							.reduce(function(a, b) { return a.concat(b); })
							.forEach(function(i) {
								this._idKeyMap[i.getUniqueId()] = i.getKey();
							}, this);
					}.bind(this);

					var uniqueIds = oEventData.Data.Merge.N.map(function(n) { return n.E; })
										.reduce(function(a, b) { return a.concat(b); })
										.map(function(e) { return e.K; });

					if (jQuery.isEmptyObject(this._idKeyMap)) {
						//The map was never aggregated - do it the first time.
						idKeyMapGenerator();
					}

					if (uniqueIds.some(function(u) { return !this._idKeyMap.hasOwnProperty(u); }, this)) {
						//The map could be outdated - needs to be regenerated.
						idKeyMapGenerator();
					}

					//At this point, every Unique Id must have a corresponding Key in the map. Replace it in the event payload.
					var idKeyReplacer = function(e) { e.K = this._idKeyMap[e.K]; };
					[].concat(oEventData.Data.Merge.N).map(function(n) { return n.E; })
						.reduce(function(a, b) { return a.concat(b); })
						.forEach(idKeyReplacer, this);
				}

				this.fireSubmit({
					data: JSON.stringify(oEventData)
				});
			}
		}

		this.timeout = undefined;
	};

	/**
	 * Generic click event handler that relays the click/double click event to the consuming application
	 * When click is received, it waits for 500 ms for another click to assert whether this is double click
	 *
	 * @param {object} event VBI JSON payload containing the event details. <br/>
	 * @private
	 */
	Adapter.prototype._genericClickHandler = function(event) {
		if (this.timeout) {
			event.getParameters().data.Action.name = "doubleclick";
			clearTimeout(this.timeout);
			this._genericGeomapHandler.call(this, event);
		} else {
			// This needs to be done since by the time callback (event handler) is executed, the object is reclaimed.
			this.oEvent = jQuery.extend(true, {}, event);
			this.timeout = setTimeout(this._genericGeomapHandler.bind(this, this.oEvent), 500);
		}
	};

	return Adapter;
});
}; // end of sap/ui/vbm/Adapter.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Adapter3D') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* global THREE */

// Provides class sap.ui.vbm.Adapter3D
jQuery.sap.declare('sap.ui.vbm.Adapter3D'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('jquery.sap.global'); // unlisted dependency retained
jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained
jQuery.sap.require('sap.ui.vk.ContentConnector'); // unlisted dependency retained
jQuery.sap.require('sap.ui.vk.threejs.Viewport'); // unlisted dependency retained
jQuery.sap.require('sap.ui.vk.threejs.ViewStateManager'); // unlisted dependency retained
jQuery.sap.require('sap.ui.vk.ContentResource'); // unlisted dependency retained
jQuery.sap.require('sap.ui.vk.TransformationMatrix'); // unlisted dependency retained
sap.ui.define("sap/ui/vbm/Adapter3D",[
	"jquery.sap.global", "sap/ui/core/Element", "sap/ui/vk/ContentConnector", "sap/ui/vk/threejs/Viewport", "sap/ui/vk/threejs/ViewStateManager",
	"sap/ui/vk/ContentResource", "sap/ui/vk/TransformationMatrix", "./library"
], function(jQuery, Element, ContentConnector, Viewport, ViewStateManager,
	 ContentResource, TransformationMatrix, library
) {
	"use strict";

	var log        = jQuery.sap.log,
		Box3       = THREE.Box3,
		Vector2    = THREE.Vector2,
		Vector3    = THREE.Vector3,
		Face3      = THREE.Face3,
		Matrix4    = THREE.Matrix4,
		Quaternion = THREE.Quaternion,
		degToRad   = THREE.Math.degToRad;

	var createBox; // Forward declaration.

	/**
	 * Constructor for a new Visual Business Adapter 3D.
	 *
	 * @class
	 * Provides the ability to load VBI JSON into {@link sap.ui.vk.threejs.Viewport sap.ui.vk.threejs.Viewport} control.
	 *
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new object
	 * @author SAP SE
	 * @version 1.50.5
	 * @extends sap.ui.core.Element
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.Adapter3D
	 * @experimental Since 1.50.0 This class is experimental and might be modified or removed in future versions.
	 */
	var Adapter3D = Element.extend("sap.ui.vbm.Adapter3D", /** @lends sap.ui.vbm.Adapter3D.prototype */ {
		metadata: {
			library: "sap.ui.vbm",

			publicMethods: [
				"load"
			],

			associations: {
				/**
				 * The {@link sap.ui.vk.threejs.Viewport Viewport} control associated with the Adapter3D. The Adapter3D would invoke methods and subscribe to events
				 * on this {@link sap.ui.vk.threejs.Viewport Viewport} instance.
				 */
				viewport: {
					type: "sap.ui.vk.threejs.Viewport"
				}
			},

			events: {
				/**
				 * This event is fired when interactions in the viewport happen.
				 */
				submit: {
					parameters: {
						/**
						 * A string in the VBI JSON format.
						 */
						data: {
							type: "string"
						}
					}
				}
			}
		}
	});

	var basePrototype = Adapter3D.getMetadata().getParent().getClass().prototype;

	Adapter3D.prototype.init = function() {
		if (basePrototype.init) {
			basePrototype.init.call(this);
		}

		this._contentConnector = new ContentConnector();
		// Bind the lifespan of the content connector to this adapter instance.
		this.addDependent(this._contentConnector);
		this._contentConnector.attachContentReplaced(function(event) {
			var content = event.getParameter("newContent"),
				scene = content && content.getSceneRef();
			if (scene) {
				scene.rotation.x = degToRad(90);
			}
		}, this);

		this._viewStateManager = new ViewStateManager({
			contentConnector: this._contentConnector
		});
		// Bind the lifespan of the view state manager to this adapter instance.
		this.addDependent(this._viewStateManager);

		this._viewport = null;

		this._resourceFiles = {};
		this._dataTypes = {};
		this._contentResourceTemplates = {};
		this._data = [];
	};

	Adapter3D.prototype.exit = function() {
		// The content connector and view state manager will be destroyed automatically by the base class of this adapter.
		this._contentConnector = null;
		this._viewStateManager = null;
		this._disconnectViewport();

		this._resourceFiles = null;
		this._dataTypes = null;
		this._contentResourceTemplates = null;
		this._data = null;

		if (basePrototype.exit) {
			basePrototype.exit.call(this);
		}
	};

	// Override the auto-generated setter to suppress invalidation and to connect to the associated viewport.
	Adapter3D.prototype.setViewport = function(viewport) {
		this.setAssociation("viewport", viewport, true);
		this._configureViewport();
		return this;
	};

	/**
	 * Updates the connection to the associated viewport.
	 *
	 * @returns {sap.ui.vbm.Adapter3D} <code>this</code> to allow method chaining.
	 * @private
	 */
	Adapter3D.prototype._configureViewport = function() {
		// sap.ui.getCore().byId() does not define what it returns when it cannot find an element by ID,
		// the current implementation returns undefined, so coalesce the return value with null for predictable results.
		var associatedViewport = sap.ui.getCore().byId(this.getViewport()) || null;
		if (associatedViewport !== this._viewport) {
			this._disconnectViewport();
			this._viewport = associatedViewport;
			this._connectViewport();
		}
		return this;
	};

	/**
	 * Connects the associated viewport to the adapter's content connector and view state manager.
	 * Subscribes to events from the associated viewport.
	 *
	 * @returns {sap.ui.vbm.Adapter3D} <code>this</code> to allow method chaining.
	 * @private
	 */
	Adapter3D.prototype._connectViewport = function() {
		if (this._viewport) {
			this._viewport.setContentConnector(this._contentConnector);
			this._viewport.setViewStateManager(this._viewStateManager);
			this._viewport.attachNodesPicked(this._handleNodesPicked, this);
		}
		return this;
	};

	/**
	 * Unsubscribes from events from the associated viewport.
	 * Disconnects the associated viewport from the adapter's content connector and view state manager.
	 *
	 * @returns {sap.ui.vbm.Adapter3D} <code>this</code> to allow method chaining.
	 * @private
	 */
	Adapter3D.prototype._disconnectViewport = function() {
		if (this._viewport) {
			if (!this._viewport.bIsDestroyed) {
				this._viewport.detachNodesPicked(this._handleNodesPicked, this);
				this._viewport.setViewStateManager(null);
				this._viewport.setContentConnector(null);
			}
			this._viewport = null;
		}
		return this;
	};

	/**
	 * Handles the nodesPicked event from the associated viewport and converts it into the adapter's submit event.
	 *
	 * @param {sap.ui.base.Event} event The nodesPicked event.
	 * @private
	 */
	Adapter3D.prototype._handleNodesPicked = function(event) {
		var currentlySelected = [];
		this._viewStateManager.enumerateSelection(Array.prototype.push.bind(currentlySelected));

		if (currentlySelected.length > 0) {
			this._viewStateManager.setSelectionState(currentlySelected, false);
		}

		var parameters = event.getParameters();
		if (parameters.picked.length > 0) {
			this._viewStateManager.setSelectionState(parameters.picked, true);

			var dataElement = sap.ui.vbm.findInArray(this._data, function(d) { return d.meshUUID === parameters.picked[0].uuid; });

			var aActions, sVoName;
			for (var sVoType in this._groupedActions) {
				if (this._groupedActions.hasOwnProperty(sVoType)) {
					if (jQuery.sap.startsWith(dataElement.resourceType, sVoType)) {
						sVoName = sVoType;
						aActions = this._groupedActions[sVoType];
						break;
					}
				}
			}

			if (aActions) {
				var eventName = parameters.isDoubleClick ? "DoubleClick" : "Click",
				    action = sap.ui.vbm.findInArray(aActions, function(a) { return a.refEvent === eventName; });

				if (action) {
					var payload = {
						"version": "2.0",
						"xmlns:VB": "VB",
						"Action": {
							"name": action.name,
							"object": sVoName,
							"instance": dataElement.K,
							"Params": {
								"Param": [
									{
										"name": "x",
										"#": parameters.x
									},
									{
										"name": "y",
										"#": parameters.y
									}
								]
							}
						}
					};

					this.fireSubmit({
						data: JSON.stringify(payload)
					});
				}
			}
		}
	};

	/**
	 * Processes the DataTypes section from the VBI JSON.
	 *
	 * @param {object[]} aDataTypes The array of DataType objects to be processed from VBI JSON.
	 * @returns {sap.ui.vbm.Adapter3D} <code>this</code> to allow method chaining.
	 * @private
	 */
	Adapter3D.prototype._processDataTypes = function(aDataTypes) {
		var processAttributes = function(aA) {
			var oAttributes = {};

			aA.forEach(function(a) {
				oAttributes[a.name] = a.alias;
			});

			return oAttributes;
		};

		var processItem = function(oDt) {
			if ("A" in oDt) {
				this._dataTypes[oDt.name] = processAttributes([].concat(oDt.A));
			} else if ("N" in oDt) {
				var oEntity = {};
				[].concat(oDt.N).forEach(function(n) {
					if ("A" in n) {
						oEntity[n.name] = processAttributes([].concat(n.A));
					}
				});
				this._dataTypes[oDt.name] = oEntity;
			}
		};

		aDataTypes.forEach(processItem, this);
		return this;
	};

	/**
	 * Processes the Data section from the VBI JSON.
	 *
	 * This usually contains the scale, position and rotation details for each item that would be
	 * loaded into viewer.
	 *
	 * @param {object|object[]} oDataSet The array of Data objects to be processed from VBI JSON.
	 * @returns {sap.ui.vbm.Adapter3D} <code>this</code> to allow method chaining.
	 * @private
	 */
	Adapter3D.prototype._processData = function(oDataSet) {
		var processItem = function(r) {
			var contentResource,
				color = r.C.slice(r.C.indexOf("(") + 1, r.C.indexOf(")")).split(",").map(function(i) { return parseInt(i, 10); }),
				scale = r.S.split(";").map(parseFloat),
				rotation = r.Y.split(";").map(parseFloat),
				position = r.A.split(";").map(parseFloat),
				localMatrix = sap.ui.vk.TransformationMatrix.convertTo4x3(
					new Matrix4().compose(
						new Vector3(-position[0], position[1], position[2]),
						new Quaternion().setFromEuler(new THREE.Euler(degToRad(rotation[0]), degToRad(-rotation[1]), degToRad(-rotation[2]), 'XYZ')),
						new Vector3(scale[0], scale[1], scale[2])
					).elements
				);


			if (this._contentResourceTemplates.hasOwnProperty(r.resourceType)
				&& this._contentResourceTemplates[r.resourceType].contentResource
			) {
				var oProperties = this._contentResourceTemplates[r.resourceType].contentResource;
				contentResource = new ContentResource({
					source: {
						content: this._resourceFiles[oProperties.source],
						color: new THREE.Color(color[1] / 255, color[2] / 255, color[3] / 255),
						opacity: color[0] / 255
					},
					localMatrix: localMatrix
				});
			} else {
				var material = new THREE.MeshPhongMaterial(),
					boxGeometry = createBox();

				material.color = new THREE.Color(color[1] / 255, color[2] / 255, color[3] / 255);
				material.opacity = color[0] / 255;

				if (r.I) {
					material.map = new THREE.TextureLoader().load(this._resourceFiles[r.I]);
					material.map.flipY = false; // Use the Direct3D texture coordinate space where the origin is in the top left corner.
				}

				var box = new THREE.Mesh(
					boxGeometry,
					material
				);
				box.applyMatrix(new Matrix4().makeScale(1, -1, -1));

				contentResource = new ContentResource({
					source: box,
					localMatrix: localMatrix
				});
			}

			return contentResource;
		};

		// Flatten into an array as sequence is crucial to apply pos, rot, scale.

		if (!Array.isArray(oDataSet) &&
			!("name" in oDataSet) &&
			!("type" in oDataSet)
		) {
			this._data = [];
		} else {
			this._data = this._data.concat([].concat(oDataSet).map(function(d) {
				return [].concat(d.N.E).map(function(e) {
					e["resourceType"] = d.N.name;
					return e;
				});
			}).reduce(function(a, b) { return a.concat(b); }));
		}

		this._data.map(processItem, this).forEach(ContentConnector.prototype.addContentResource, this._contentConnector);

		return this;
	};

	/**
	 * Processes the Resources section from the VBI JSON.
	 *
	 * The resources section of the VBI JSON contains the pre-caliberated primitives that
	 * are to be loaded into the viewer and manipulated according the details from the Data section
	 *
	 * @param {object[]} aResources The array of DataType objects to be processed from VBI JSON.
	 * @returns {sap.ui.vbm.Adapter3D} <code>this</code> to allow method chaining.
	 * @private
	 */
	Adapter3D.prototype._processResources = function(aResources) {
		var resourceToFile = function(data, name) {
			return atob(data.split(",")[0]);
		};

		var processResource = function(r) {
			if (jQuery.sap.endsWith(r.name, ".dae")) {
				this._resourceFiles[r.name] = resourceToFile(r.value, r.name);
			} else {
				this._resourceFiles[r.name] = "data:" + r.name.split(".")[1] + ";base64," + r.value;
			}
		};

		aResources.forEach(processResource, this);

		return this;
	};

	/**
	 * Processes the Actions array from VBI JSON.
	 *
	 * @param {object} actions Actions section of VBI JSON. <br/>
	 * @returns {sap.ui.vbm.Adapter3D} <code>this</code> to allow method chaining.
	 * @private
	 */
	Adapter3D.prototype._processActions = function(actions) {
		this._groupedActions = actions.reduce(function(g, a) {
			var group = a.refVO;
			if (!a.refVO) {
				group = "General";
			}
			g[group] = g[group] || [];
			g[group].push(a);
			return g;
		}, {});

		return this;
	};

	/**
	 * Processes the VOs from the Scenes section from the VBI JSON.
	 *
	 * The VO definition forms the template for each instance of the primitive and acts as a bridge in
	 * collating the Data and DataTypes section for each primitive
	 *
	 * @param {object[]} aVOs The array of VOs to be processed from VBI JSON.
	 * @returns {sap.ui.vbm.Adapter3D} <code>this</code> to allow method chaining.
	 * @private
	 */
	Adapter3D.prototype._processVOs = function(aVOs) {
		var _processVO = function(oVO) {
			if (oVO.hasOwnProperty("model")) {
				oVO["contentResource"] = { source: oVO.model, sourceType: "dae", id: oVO.model };
			}
			this._contentResourceTemplates[oVO.datasource] = oVO;
		};

		aVOs.forEach(_processVO, this);
		return this;
	};

	/**
	 * Processes the various sections from the VBI JSON.
	 *
	 * The Resources, DataTypes, Scenes and Data sections from the VBI JSON are sequentially processed.
	 * Processing of the Data section would eventually lead to change in the content resources.
	 *
	 * @param {object|string} data The VBI JSON.
	 * @returns {sap.ui.vbm.Adapter3D} <code>this</code> to allow method chaining.
	 * @public
	 */
	Adapter3D.prototype.load = function(data) {
		// If the adapter was created before the associated viewport then the adapter might not be connected to the viewport.
		// In case if the associated viewport is destroyed this call will disconnect from the viewport.
		this._configureViewport();

		var oPayload = null;

		if (typeof data === "string") {
			try {
				oPayload = JSON.parse(data);
			} catch (ex) {
				log.error("sap.ui.vbm.Adapter: attempt to load invalid JSON string.");
				return this;
			}
		} else if (typeof data === "object") {
			oPayload = data;
		}

		if (!(oPayload && oPayload.SAPVB)) {
			log.error("sap.ui.vbm.Adapter3D: attempt to load null.");
			return this;
		}

		// Resources
		if (oPayload.SAPVB.Resources &&
			oPayload.SAPVB.Resources.Set &&
			oPayload.SAPVB.Resources.Set.Resource
		) {
			this._processResources([].concat(oPayload.SAPVB.Resources.Set.Resource));
		}

		// DataTypes
		if (oPayload.SAPVB.DataTypes &&
			oPayload.SAPVB.DataTypes.Set &&
			oPayload.SAPVB.DataTypes.Set.N
		) {
			this._processDataTypes([].concat(oPayload.SAPVB.DataTypes.Set.N));
		}

		// VOs
		if (oPayload.SAPVB.Scenes &&
			oPayload.SAPVB.Scenes.Set &&
			oPayload.SAPVB.Scenes.Set.Scene &&
			oPayload.SAPVB.Scenes.Set.Scene.VO
		) {
			this._processVOs([].concat(oPayload.SAPVB.Scenes.Set.Scene.VO));
		}

		// Actions
		if (oPayload.SAPVB.Actions &&
			oPayload.SAPVB.Actions.Set &&
			oPayload.SAPVB.Actions.Set.Action
		) {
			this._processActions([].concat(oPayload.SAPVB.Actions.Set.Action));
		}

		// Data
		if (oPayload.SAPVB.Data &&
			oPayload.SAPVB.Data.Set &&
			!jQuery.isEmptyObject(oPayload.SAPVB.Data.Set)
		) {
			this._processData(oPayload.SAPVB.Data.Set, true);
		}

		return this;
	};

	/**
	 * Creates a box.
	 *
	 * We cannot use the three.js BoxGeometry class as its faces, UVs etc are quite different from what is expected in legacy VB.
	 *
	 * The geometry is generated according to the algorithm in the legacy VB ActiveX control.
	 *
	 * @returns {THREE.Geometry} The box geometry.
	 * @private
	 */
	createBox = function() {
		var geometry = new THREE.Geometry(),
			halfSideLength = 0.1;

		geometry.vertices.push(
			// Top
			new Vector3( halfSideLength,  halfSideLength, -halfSideLength),
			new Vector3( halfSideLength, -halfSideLength, -halfSideLength),
			new Vector3(-halfSideLength, -halfSideLength, -halfSideLength),
			new Vector3(-halfSideLength,  halfSideLength, -halfSideLength),

			// Bottom
			new Vector3( halfSideLength,  halfSideLength,  halfSideLength),
			new Vector3(-halfSideLength,  halfSideLength,  halfSideLength),
			new Vector3(-halfSideLength, -halfSideLength,  halfSideLength),
			new Vector3( halfSideLength, -halfSideLength,  halfSideLength),

			// Right
			new Vector3( halfSideLength,  halfSideLength, -halfSideLength),
			new Vector3( halfSideLength,  halfSideLength,  halfSideLength),
			new Vector3( halfSideLength, -halfSideLength,  halfSideLength),
			new Vector3( halfSideLength, -halfSideLength, -halfSideLength),

			// Front
			new Vector3( halfSideLength, -halfSideLength, -halfSideLength),
			new Vector3( halfSideLength, -halfSideLength,  halfSideLength),
			new Vector3(-halfSideLength, -halfSideLength,  halfSideLength),
			new Vector3(-halfSideLength, -halfSideLength, -halfSideLength),

			// Left
			new Vector3(-halfSideLength, -halfSideLength, -halfSideLength),
			new Vector3(-halfSideLength, -halfSideLength,  halfSideLength),
			new Vector3(-halfSideLength,  halfSideLength,  halfSideLength),
			new Vector3(-halfSideLength,  halfSideLength, -halfSideLength),

			// Back
			new Vector3( halfSideLength,  halfSideLength,  halfSideLength),
			new Vector3( halfSideLength,  halfSideLength, -halfSideLength),
			new Vector3(-halfSideLength,  halfSideLength, -halfSideLength),
			new Vector3(-halfSideLength,  halfSideLength,  halfSideLength)
		);

		var normalTop    = new Vector3( 0,  0, -1),
			normalBottom = new Vector3( 0,  0,  1),
			normalRight  = new Vector3( 1,  0,  0),
			normalFront  = new Vector3( 0, -1,  0),
			normalLeft   = new Vector3(-1,  0,  0),
			normalBack   = new Vector3( 0,  1,  0),
			defaultColor = new THREE.Color(0.5, 0.5, 0.5);

		geometry.faces.push(
			// Top
			new Face3(0, 2, 3, normalTop, defaultColor),
			new Face3(0, 1, 2, normalTop, defaultColor),

			// Bottom
			new Face3(4, 5, 6, normalBottom, defaultColor),
			new Face3(4, 6, 7, normalBottom, defaultColor),

			// Right
			new Face3(8, 10, 11, normalRight, defaultColor),
			new Face3(8,  9, 10, normalRight, defaultColor),

			// Front
			new Face3(12, 14, 15, normalFront, defaultColor),
			new Face3(12, 13, 14, normalFront, defaultColor),

			// Left
			new Face3(16, 18, 19, normalLeft, defaultColor),
			new Face3(16, 17, 18, normalLeft, defaultColor),

			// Back
			new Face3(20, 22, 23, normalBack, defaultColor),
			new Face3(20, 21, 22, normalBack, defaultColor)
		);

		// Use the Direct3D texture coordinate space where the origin is in the top left corner.
		// If there is a texture with the following quadrants
		// (0,0)                       (1,0)
		//      +----------+----------+
		//      |   BACK   |  FRONT   |
		//      +----------+----------+
		//      |RIGHT/LEFT|TOP/BOTTOM|
		//      +----------+----------+
		// (0,1)                       (1,1)
		// then those quadrants should map to faces as in the comments below.
		var uvs = [
			// Top
			new Vector2(0.5, 0.5),
			new Vector2(1.0, 0.5),
			new Vector2(1.0, 1.0),
			new Vector2(0.5, 1.0),

			// Bottom
			// VB ActiveX incorrectly defines bottom the same as right/left, though the comments say it is the same as top.
			new Vector2(0.5, 0.5),
			new Vector2(1.0, 0.5),
			new Vector2(1.0, 1.0),
			new Vector2(0.5, 1.0),

			// Right
			new Vector2(0.5, 0.5),
			new Vector2(0.5, 1.0),
			new Vector2(0.0, 1.0),
			new Vector2(0.0, 0.5),

			// Front
			new Vector2(0.5, 0.5),
			new Vector2(0.5, 0.0),
			new Vector2(1.0, 0.0),
			new Vector2(1.0, 0.5),

			// Left
			new Vector2(0.5, 0.5),
			new Vector2(0.5, 1.0),
			new Vector2(0.0, 1.0),
			new Vector2(0.0, 0.5),

			// Back
			new Vector2(0.0, 0.5),
			new Vector2(0.0, 0.0),
			new Vector2(0.5, 0.0),
			new Vector2(0.5, 0.5)
		];

		geometry.faceVertexUvs[0].push(
			// Top
			[ uvs[0], uvs[2], uvs[3] ],
			[ uvs[0], uvs[1], uvs[2] ],

			// Bottom
			[ uvs[4], uvs[5], uvs[6] ],
			[ uvs[4], uvs[6], uvs[7] ],

			// Right
			[ uvs[8], uvs[10], uvs[11] ],
			[ uvs[8],  uvs[9], uvs[10] ],

			// Front
			[ uvs[12], uvs[14], uvs[15] ],
			[ uvs[12], uvs[13], uvs[14] ],

			// Left
			[ uvs[16], uvs[18], uvs[19] ],
			[ uvs[16], uvs[17], uvs[18] ],

			// Back
			[ uvs[20], uvs[22], uvs[23] ],
			[ uvs[20], uvs[21], uvs[22] ]
		);

		return geometry;
	};

	/**
	 * Removes descendant nodes that are lights or cameras.
	 *
	 * @param {THREE.Object3D} node The node to process.
	 * @returns {THREE.Object3D} The input <code>node</code> parameter to allow method chaining.
	 * @private
	 */
	var removeLightsAndCameras = function(node) {
		var objectsToRemove = [];
		node.traverse(function(object) {
			if (object.isLight || object.isCamera) {
				objectsToRemove.push(object);
			}
		});
		objectsToRemove.forEach(function(object) {
			while (object && object !== node) { // Do not remove the top level node.
				var parent = object.parent;
				if (object.children.length === 0) {
					parent.remove(object);
				}
				object = parent;
			}
		});
		return node;
	};

	/**
	 * Converts from the left-handed coordinate system to the right-handed one.
	 *
	 * @param {THREE.Object3D} node The node to process.
	 * @returns {THREE.Object3D} The input <code>node</code> parameter to allow method chaining.
	 * @private
	 */
	var convertCoordinateSystem = function(node) {
		if (node.isMesh && node.geometry && node.geometry.isGeometry) {
			node.geometry.vertices.forEach(function(vertex) {
				vertex.x = -vertex.x;
			});
			node.geometry.faces.forEach(function(face) {
				var tmp = face.b;
				face.b = face.c;
				face.c = tmp;
				if (face.normal) {
					face.normal.x = -face.normal.x;
				}
				if (face.vertexNormals && face.vertexNormals.length === 3) {
					tmp = face.vertexNormals[1];
					face.vertexNormals[1] = face.vertexNormals[2];
					face.vertexNormals[2] = tmp;
					face.vertexNormals[0].x = -face.vertexNormals[0].x;
					face.vertexNormals[1].x = -face.vertexNormals[1].x;
					face.vertexNormals[2].x = -face.vertexNormals[2].x;
				}
				if (face.vertexColors && face.vertexColors.length === 3) {
					tmp = face.vertexColors[1];
					face.vertexColors[1] = face.vertexColors[2];
					face.vertexColors[2] = tmp;
				}
			});
			node.geometry.faceVertexUvs.forEach(function(uvs) {
				uvs.forEach(function(face) {
					var tmp = face[1];
					face[1] = face[2];
					face[2] = tmp;
				});
			});
		}
		return node;
	};

	/**
	 * Normalize the object.
	 *
	 * The node is centered and then scaled uniformly so that vertex coordinates fit into the 3D box defined as range [(-1, -1, -1), (+1, +1, +1)].
	 *
	 * @param {THREE.Object3D} node The node to normalize.
	 * @returns {THREE.Object3D} The input <code>node</code> parameter to allow method chaining.
	 * @private
	 */
	var normalizeObject3D = function(node) {
		// Re-centre according to the VB ActiveX implementation.

		var center = new Box3().setFromObject(node).getCenter();
		node.applyMatrix(new Matrix4().makeTranslation(-center.x, -center.y, +center.z)); // NB: sic! the Z move is positive.

		// Normalize coordinates (not the size!) according to the VB ActiveX implementation.

		var box = new Box3().setFromObject(node);
		var scaleFactor = Math.max(
			Math.abs(box.min.x),
			Math.abs(box.min.y),
			Math.abs(box.min.z),
			Math.abs(box.max.x),
			Math.abs(box.max.y),
			Math.abs(box.max.z)
		);
		if (scaleFactor) {
			scaleFactor = 1 / scaleFactor;
		}
		node.applyMatrix(new Matrix4().makeScale(scaleFactor, scaleFactor, scaleFactor));

		box = new Box3().setFromObject(node);
		center = box.getCenter();
		node.translateZ(center.z - (box.max.z < 0 ? box.max.z : box.min.z));

		return node;
	};

	/**
	 * Loads a Collada model from an XML string.
	 *
	 * @param {THREE.Object3D}            parentNode      The parent node where to add the loaded content.
	 * @param {sap.ui.vk.ContentResource} contentResource The content resource to load.
	 * @returns {Promise} The Promise object that resolves when the Collada model has been loaded.
	 * @private
	 */
	var loadCollada = function(parentNode, contentResource) {
		return new Promise(function(resolve, reject) {
			var loader = new THREE.ColladaLoader();
			loader.parse(contentResource.getSource().content,
				function(collada) {
					removeLightsAndCameras(collada.scene);
					collada.scene.traverse(convertCoordinateSystem);
					collada.scene.applyMatrix(new Matrix4().makeScale(1, -1, -1));
					var source = contentResource.getSource();
					collada.scene.traverse(function(node) {
						if (node.isMesh) {
							node.material.color = source.color;
							node.material.opacity = source.opacity;
						}
					});
					parentNode.add(normalizeObject3D(collada.scene));
					resolve({
						node: parentNode,
						contentResource: contentResource
					});
				}
			);
		});
	};

	/**
	 * Loads a THREE.Object3D object.
	 *
	 * @param {THREE.Object3D}            parentNode      The parent node where to add the loaded content.
	 * @param {sap.ui.vk.ContentResource} contentResource The content resource to load.
	 * @returns {Promise} The Promise object that resolves when the object has been loaded.
	 * @private
	 */
	var loadThreeJSObject = function(parentNode, contentResource) {
		var node  = contentResource.getSource();

		parentNode.add(normalizeObject3D(convertCoordinateSystem(node)).rotateX(degToRad(180)));
		return Promise.resolve({
			node: parentNode,
			contentResource: contentResource
		});
	};

	var colladaResolver = {
		dimension: 3,
		contentManagerClassName: "sap.ui.vk.threejs.ContentManager",
		settings: { loader: loadCollada }
	};

	var threeJSObjectResolver = {
		dimension: 3,
		contentManagerClassName: "sap.ui.vk.threejs.ContentManager",
		settings: { loader: loadThreeJSObject }
	};

	ContentConnector.addContentManagerResolver(function(contentResource) {
		return Promise.resolve(contentResource.getSource() instanceof THREE.Object3D ? threeJSObjectResolver : colladaResolver);
	});

	return Adapter3D;
});
}; // end of sap/ui/vbm/Adapter3D.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Cluster') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.Cluster.
jQuery.sap.declare('sap.ui.vbm.Cluster'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('jquery.sap.global'); // unlisted dependency retained
jQuery.sap.require('sap.ui.core.Control'); // unlisted dependency retained
sap.ui.define("sap/ui/vbm/Cluster",[
	'jquery.sap.global', './library', 'sap/ui/core/Control'
], function(jQuery, library, Control) {
	"use strict";

	/**
	 * Constructor for a new Cluster.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Cluster control to visualize clustered objects on a map. The Cluster control does not cluster anything itself, instead it only shows a
	 *        predefined image. The image can be configured with the properties <i>type</i>, <i>color</i>, <i>icon</i> and <i>text</i>. If a
	 *        <i>text</i> is given it is shown in the upper right corner of the control with a rounded border around. With the <i>color</i> property
	 *        any color can be chosen. The <i>type</i> property overwrites a property <i>color</i> with semantic color of the type and provides a
	 *        particular semantic icon in the middle of the control. With the <i>icon</i> property an icon can be defined and may overrule the
	 *        semantic icon; if no icon is defined ( and no type) then the semantic icon for type inactive is chosen.
	 * @extends sap.ui.core.Control
	 * @author SAP SE
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.Cluster
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var Cluster = Control.extend("sap.ui.vbm.Cluster", /** @lends sap.ui.vbm.Cluster.prototype */ {
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * Set the color of the control. If a type is set then the semantic color of the type is taken instead.
				 */
				color: {
					type: "sap.ui.core.CSSColor",
					group: "Misc",
					defaultValue: null
				},
				/**
				 * Set the icon of the control. If a type is set then the semantic icon of the type can be overwritten with this property. If no icon
				 * and no type is set then the icon for the semantic type 'inactive' is taken.
				 */
				icon: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},
				/**
				 * Set the text of the control.
				 */
				text: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},
				/**
				 * semantic type for cluster. The type specifies the icon and the color of the cluster control.
				 */
				type: {
					type: "sap.ui.vbm.SemanticType",
					group: "Behavior",
					defaultValue: sap.ui.vbm.SemanticType.None
				}

			}
		}
	});

	// ...........................................................................//
	// This file defines behavior for the control,...............................//
	// ...........................................................................//

	Cluster.prototype.exit = function() {};

	Cluster.prototype.init = function() {};

	// ...........................................................................//

	Cluster.prototype.onAfterRendering = function() {
		// when there is preserved content restore it.............................//
		if (this.$oldContent.length > 0) {
			this.$().append(this.$oldContent);
		}
		if (this.getColor() && (this.getType() === sap.ui.vbm.SemanticType.None)) {
			// color manipulation needed

			//getting the background circle and inner circle DOM id
			var backgroundCircleId = this.getId() + "-" + "backgroundcircle",
				innerCircleId = backgroundCircleId + "-" + "innercircle";

			//getting the background circle and inner circle by element id
			var backgroundCircle = document.getElementById(backgroundCircleId),
				innerCircle = document.getElementById(innerCircleId);

			//getting the bottom border color
			var bottomBorderColor = jQuery(backgroundCircle).css("border-bottom-color");
			//converting the RGB to RGBA
			var rgba = this.string2rgba(bottomBorderColor);
			//setting the 0.5 transparency
			rgba = "rgba(" + rgba[0] + "," + rgba[1] + "," + rgba[2] + "," + 0.5 + ")";

			//updating the HTML elements
			backgroundCircle.style.borderColor = rgba;
			innerCircle.style.borderColor = rgba;
		}
	};

	Cluster.prototype.onBeforeRendering = function() {
		// this is called before the renderer is called...........................//
		this.$oldContent = sap.ui.core.RenderManager.findPreservedContent(this.getId());
	};

	Cluster.prototype.string2rgba = function(a) {
		var cache;

		if ((cache = /^rgb\(([\d]+)[,;]\s*([\d]+)[,;]\s*([\d]+)\)/.exec(a))) {
			return [
				+cache[1], +cache[2], +cache[3], 1.0, 0
			];
		} else {
			return [
				94, 105, 110
			];
		}
	};

	return Cluster;

});

}; // end of sap/ui/vbm/Cluster.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.ClusterBase') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.ClusterBase.
jQuery.sap.declare('sap.ui.vbm.ClusterBase'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained
jQuery.sap.require('sap.ui.core.theming.Parameters'); // unlisted dependency retained
sap.ui.define("sap/ui/vbm/ClusterBase",[
	'sap/ui/core/Element', './library', 'sap/ui/core/theming/Parameters'
], function(Element, library, Parameters) {
	"use strict";

	/**
	 * Constructor for a new ClusterBase.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Abtract base class for Clustering types. This element implements the common part for all specific Cluster elements. It must not be used
	 *        directly, but is the base for further extension.<br>
	 *        There are two optional aggregations: <code>vizTemplate</code> and <code>vizVo</code> determining how cluster objects should be
	 *        visualized. Only the one or the other should be provided.<br>
	 *        With aggregation <code>vizTemplate</code> you can provide an arbitrary SAPUI5 control for the actual visualization. If you want this control 
	 *        to display the number of clustered object you need to provide the name of the receiving property of the template via property <code>textProperty</code>. 
	 *        For interaction with the cluster you can either use the events provided by the visualization template or, if it does not provide appropriate events, 
	 *        the cluster element events <code>click</code> and <code>contextMenu</code>. The event handler will receive an instance of <code>sap.ui.vbm.ClusterContainer</code>.<br>
	 *        With aggregation <code>vizVo</code> you provide an instance of <code>sap.ui.vbm.Spot</code> as visualization object. Spots are based on an image. The text 
	 *        for the number of clustered objects needs to be placed over the image. The actual color, font, size, and positioning of the text can be influence via property
	 *        <code>textSettings</code>. For interaction with the cluster you can use the events provided by the spot.   
	 * @extends sap.ui.core.Element
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.ClusterBase
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var ClusterBase = Element.extend("sap.ui.vbm.ClusterBase", /** @lends sap.ui.vbm.ClusterBase.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * Flag controlling the visibility of the area convered by a cluster object.
				 */
				areaAlwaysVisible: {
					type: "boolean",
					group: "Appearance",
					defaultValue: false
				},

				/**
				 * Fill color for the area covered by a cluster object
				 */
				areaColor: {
					type: "sap.ui.core.CSSColor",
					group: "Appearance",
					defaultValue: "rgba(200,0,0,0.2)"
				},

				/**
				 * Border color for the area covered by a cluster object
				 */
				areaColorBorder: {
					type: "sap.ui.core.CSSColor",
					group: "Appearance",
					defaultValue: "rgba(220,220,220,0.5)"
				},

				/**
				 * Name of property of the visualization control receiving the number of clustered objects. This setting applys only if aggregation
				 * vizTemplate is used.
				 */
				textProperty: {
					type: "string",
					group: "Misc",
					defaultValue: "text"
				},

				/**
				 * Settings for the text placed on the given Spot telling the number of clustered objects. This setting applys only if aggregation
				 * vizVo is used. If omitted the number of clustered object will <b>not</b> be shown!
				 */
				textSettings: {
					type: "object",
					group: "Appearance"
				},

				/**
				 * Clustering rule, describing which visual objects should be considered for clustering
				 */
				rule: {
					type: "string",
					group: "Misc",
					defaultValue: null
				}
			},
			defaultAggregation: "vizTemplate",
			aggregations: {

				/**
				 * Optional: Instance of a control, which is used as template for visualizing cluster objects. This is the prefered choise.
				 */
				vizTemplate: {
					type: "sap.ui.core.Control",
					multiple: false
				},

				/**
				 * Optional: Instance of a spot, which is used as template for visualizing cluster objects
				 */
				vizVo: {
					type: "sap.ui.vbm.Spot",
					multiple: false
				},
				/**
				 * Hidden aggregation for cluster visualization controls
				 */
				clusterVos: {
					type: "sap.ui.core.Control",
					multiple: true,
					visiblity: "hidden",
					singularName: "clusterVo"
				},
				/**
				 * Hidden aggregation for host container VOs
				 */
				clusterContainers: {
					type: "sap.ui.vbm.ClusterContainer",
					multiple: true,
					visiblity: "hidden",
					singularName: "clusterContainer"
				}

			},
			events: {
				/**
				 * The event is raised when there is a click action on a Cluster Object.
				 */
				click: {
					parameters: {
						/**
						 * ID of the clicked cluster object. Can serve as input for GeoMap function getInfoForCluster
						 */
						clusterID: {
							type: "string"
						}
					}
				},
				/**
				 * The event is raised when there is a right click or a tap and hold action on a Cluster.
				 */
				contextMenu: {
					parameters: {
						/**
						 * ID of the clicked cluster object. Can serve as input for GeoMap function getInfoForCluster
						 */
						clusterID: {
							type: "string"
						},
						/**
						 * Menu to open
						 */
						menu: {
							type: "sap.ui.unified.Menu"
						}
					}
				}
			}
		}
	});

	/**
	 * Open a Detail Window. This function can only be used with a Spot as Cluster visualization object!
	 * 
	 * @param {sap.ui.vbm.Spot} oSpotInst Spot instance for which the Detail Window should be opened
	 * @param {object} oParams Parameter object
	 * @param {string} oParams.caption Text for Detail Window caption
	 * @param {string} oParams.offsetX position offset in x-direction from the anchor point
	 * @param {string} oParams.offsetY position offset in y-direction from the anchor point
	 * @returns {void}
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	ClusterBase.prototype.openDetailWindow = function(oSpotInst, oParams) {
		var oParent = this.getParent();
		oParent.mDTWindowCxt.bUseClickPos = true;
		oParent.mDTWindowCxt.open = true;
		oParent.mDTWindowCxt.src = oSpotInst;
		oParent.mDTWindowCxt.key = oSpotInst.getKey();
		oParent.mDTWindowCxt.params = oParams;
		oParent.m_bWindowsDirty = true;
		oParent.invalidate();
	};

	/**
	 * Open a context menu
	 * 
	 * @param {string} sType Type of VO
	 * @param {sap.ui.vbm.ClusterContainer} oContainer VO instance for which the Context Menu should be opened
	 * @param {sap.ui.unified.Menu} oMenu the context menu to be opened
	 * @returns {void}
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	ClusterBase.prototype.openContextMenu = function(sType, oContainer, oMenu) {
		this.oParent.openContextMenu(sType, oContainer, oMenu);
	};

	/**
	 * This file defines behavior for the control,
	 */
	ClusterBase.prototype.init = function() {
		// do something for initialization...
		this.mVizObjMap = {};
		this.mContObjMap = {};
		var sDefaultFontFamily = Parameters.get("sapUiFontFamily");  
		this.setProperty("textSettings", {
			textcolor: "#000000",
			textfont: (sDefaultFontFamily) ? sDefaultFontFamily : "Arial, Helvetica, sans-serif",
			textfontsize: "10"				
		}, true);
	};

	ClusterBase.prototype.exit = function() {
		// clean up
		this.mVizObjMap = null;
		this.mContObjMap = null;
		if (this.oSpotAggr) {
			this.oSpotAggr.destroy();
			this.oSpotAggr = null;
		}
	};

	/**
	 * Set the settings for the text placed on the Spot for number of clustered objects
	 * 
	 * @param {object} oSettings Settings object
	 * @param {CSSColor} ?oSettings.textcolor Text color. Default is black
	 * @param {string} ?oSettings.textfont Text font family. Default take from theming parameter <i>sapUiFontFamily</i>
	 * @param {string} ?oSettings.textfontsize Text font size. Default is 10.
	 * @param {string} ?oSettings.textoffset Text horizontal offset in pixels. Default is 0.
	 * @param {string} ?oSettings.textoffsetY Text vertical offset in pixels. Default is 0.
	 * @returns this To allow method chaining
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	ClusterBase.prototype.setTextSettings = function(oSettings) {
		// apply new settings to existing ones
		var oNewSettings = this.getTextSettings();
		jQuery.extend(oNewSettings, oSettings);
		return this.setProperty("textSettings", oNewSettings);
	};

	// ...........................................................................//
	// model creators............................................................//

	// A cluster needs a reference VO for rendering. Thus we return a container object as ref VO.
	ClusterBase.prototype.getTemplateObject = function() {
		var oTemplate = {};

		// Ref VO id is given in handleOpenWindow event and must match cluster id for event dispatching
		var sId = this.getId();

		if (this.getVizTemplate()) {
			// vizTemplate given -> use a container VO as reference
			oTemplate = {
				id: sId,
				type: "{00100000-2012-0004-B001-2297943F0CE6}",
				datasource: sId
			};
		} else if (this.getVizVo()) {
			// Spot given
			this.oSpotAggr = new sap.ui.vbm.Spots({
				items: {
					path: "/",
					template: this.getVizVo()
				}
			});
			oTemplate = this.oSpotAggr.getTemplateObject();
			// change id to id of cluster for right relation to actions and event routing
			oTemplate.id = sId;
		} else {
			// nothing given
			jQuery.sap.log.error("No visualization object given for cluster");
		}
		return oTemplate;
	};

	ClusterBase.prototype.getActionArray = function() {
		// Note: If we use a Spot for cluster visualization we need to register actions, otherwise we directly use DOM events from the container div
		if (this.oSpotAggr) {
			var aActions = this.oSpotAggr.getActionArray(/* bForce= */true);
			for (var i = 0; i < aActions.length; ++i) {
				// change refVO for right event routing in GeoMap
				aActions[i].refVO = this.getId();
			}
			return aActions;
		} else {
			return [];
		}
	};

	ClusterBase.prototype.getClusterDefinition = function() {

		return jQuery.extend(this.getTextSettings(), {
			id: this.getId(),
			VO: this.getId(),
			rule: this.getRule(),
			areapermanent: this.getAreaAlwaysVisible().toString(),
			areabordersize: "2",
			areafillcol: this.getAreaColor(),
			areabordercol: this.getAreaColorBorder()
		});
	};

	// ...........................................................................//
	// Internal API functions.....................................................//

	ClusterBase.prototype.handleContainerCreated = function(event) {
		// get the control
		var sClusterId = event.mParameters.id;
		var oItem = this._getVizObjInst(sClusterId);
		if (oItem) {
			// read cluster info data for given Id
			var oNodeInfo = this.getParent().getInfoForCluster(sClusterId, sap.ui.vbm.ClusterInfoType.NodeInfo);
			if (!oItem.getBindingInfo("text")) {
				oItem.setProperty(this.getTextProperty(), oNodeInfo.cnt.toString(), /* suppress invaidate */true);
			} 

			if (!this.oDOMHandler) {
				this.oDOMHander = new ClusterBase._DOMHandler(this);
			}

			// attach to container div events
			var oDomRef = event.getParameter("contentarea");
			oDomRef.addEventListener("click", this.oDOMHander, false);
			oDomRef.addEventListener("contextmenu", this.oDOMHander, false);

			var oParent;
			if ((oParent = this.getParent())) {
				// determine the id of the div to place the item in
				var id = oDomRef.id;
				oParent.addRenderItem(oItem, id);
			}
		}
	};

	ClusterBase.prototype.handleContainerDestroyed = function(event) {
		// detach container div events
		var oDomRef = event.getParameter("contentarea");
		oDomRef.removeEventListener("click", this.oDOMHander, false);
		oDomRef.removeEventListener("contextmenu", this.oDOMHander, false);
		// remove associate control instance
		this._removeVizObjInst(event.mParameters.id);
	};

	ClusterBase.prototype.handleEvent = function(event) {
		var sName = event.Action.name;

		var funcname = "fire" + sName[0].toUpperCase() + sName.slice(1);

		// first we try to get the event on a vo instance......................//
		var oVo;
		if ((oVo = this.getVizVo())) {
			var eventContext = {
				data: event
			};
			var nodeInfo = this.getParent().getInfoForCluster(event.Action.instance, sap.ui.vbm.ClusterInfoType.NodeInfo);
			oVo.setProperty("key", event.Action.instance, /* bSuppressInvalidate= */true);
			oVo.setProperty("position", nodeInfo.pos[0] + ";" + nodeInfo.pos[1] + ";0", /* bSuppressInvalidate= */true);
			switch (sName) {
				case "click":
					oVo.mClickGeoPos = event.Action.AddActionProperties.AddActionProperty[0]['#'];
					break;
				case "contextMenu":
					// store screen coordinates where the menu should open
					oVo.mClickPos = [
						event.Action.Params.Param[0]['#'], event.Action.Params.Param[1]['#']
					];
					// lazy load sap.ui.unified library for using the Menu
					sap.ui.getCore().loadLibrary("sap.ui.unified");

					if (this.oParent.mVBIContext.m_Menus) {
						this.oParent.mVBIContext.m_Menus.deleteMenu("DynContextMenu");
					}
					// create an empty menu
					var oMenuObject = new sap.ui.unified.Menu();
					oMenuObject.vbi_data = {};
					oMenuObject.vbi_data.menuRef = "CTM";
					oMenuObject.vbi_data.VBIName = "DynContextMenu";

					eventContext.menu = oMenuObject;
					break;
				case "drop":
					var src = event.Action.Params.Param[0]['#'].split("|");
					var aggr = src[1];
					var inst = src[2].split(".")[1];
					var oDragSource = this.getParent().getAggregatorContainer(aggr).findInstanceByKey(inst);
					eventContext.oDragSource = oDragSource;
					break;
				default:
					break;

			}
			oVo[funcname](eventContext);

			eventContext.instance = oVo;
			this[funcname](eventContext);
		} else {
			jQuery.sap.log.error("Instance for event not found");
		}
	};

	ClusterBase.prototype.findInstance = function(sKey) {
		if (this.oSpotAggr) {
			return this.getVizVo();
		} else {
			return this._getContainer(sKey);
		}
	};

	// ...........................................................................//
	// private helper functions...................................................//

	ClusterBase.prototype._getVizObjInst = function(key) {
		var oResult = this.mVizObjMap[key];
		if (!oResult) {
			// no instance found for given key -> create it
			var oVizObj = this.getVizTemplate();
			if (oVizObj) {
				oResult = this.mVizObjMap[key] = oVizObj.clone();
				oResult.mClusterId = key;
				this.addAggregation("clusterVos", oResult, /* suppress invaidate */true);
			}
		}

		return oResult;
	};

	ClusterBase.prototype._removeVizObjInst = function(key) {
		var oResult = this.mVizObjMap[key];
		if (oResult) {
			this.removeAggregation("clusterVos", oResult, /* suppress invaidate */true);
			this.mVizObjMap[key] = null;
		}
	};


	/**
	 * It retrieves a {sap.ui.vbm.ClusterContainer} by key from the list of current containers.
	 * @param {string} key The key of the container that we want to retrieve.
	 * @returns {sap.ui.vbm.ClusterContainer} oResult
	 * @private
	 */
	ClusterBase.prototype._getContainer = function(key) {
		var oResult = this.mContObjMap[key];
		if (!oResult) {
			// no instance found for given key -> create it
			oResult = this.mContObjMap[key] = new sap.ui.vbm.ClusterContainer({
				key: key
			});
			// add item if we do not use spots for visualization
			if (!this.oSpotAggr) {
				oResult.setItem(this._getVizObjInst(key));
			}
			this.addAggregation("clusterContainers", oResult, /* suppress invaidate */true);
		}

		return oResult;
	};

	ClusterBase.prototype._removeContainer = function(key) {
		var oResult = this.mContObjMap[key];
		if (oResult) {
			this.removeAggregation("clusterContainers", oResult, /* suppress invaidate */true);
			this.mContObjMap[key] = null;
		}
	};

	/**
	 * Generic event handler for DOM events from container divs Note: Naming conventions apply here. Thus the hadler cannot be used directly, but via
	 * sub object _DOMHandler!
	 * 
	 * @param {object} oEvent DOM event
	 * @private
	 */
	ClusterBase.prototype._handleDOMEvent = function(oEvent) {
		var sClusterId = oEvent.currentTarget.m_Key;
		//oCluster is an instance of sap.ui.vbm.ClusterContainer
		var oCluster = this.parent._getContainer(sClusterId);
		switch (oEvent.type) {
			case "click":
				this.parent.fireClick({
					instance: oCluster
				});
				break;
			case "contextmenu":
				var eventContext = {};
				var oMapDiv = this.parent.oParent.getDomRef();
				oCluster.mClickPos = [
					oEvent.clientX - oMapDiv.offsetLeft, oEvent.clientY - oMapDiv.offsetTop
				];
				// lazy load sap.ui.unified library for using the Menu
				sap.ui.getCore().loadLibrary("sap.ui.unified");

				try {
					if (this.parent.oParent.mVBIContext.m_Menus) {
						this.parent.oParent.mVBIContext.m_Menus.deleteMenu("DynContextMenu");
					}
					// create an empty menu
					var oMenuObject = new sap.ui.unified.Menu();
					oMenuObject.vbi_data = {};
					oMenuObject.vbi_data.menuRef = "CTM";
					oMenuObject.vbi_data.VBIName = "DynContextMenu";

					eventContext.menu = oMenuObject;
					oEvent.preventDefault();

					eventContext.instance = oCluster;
					this.parent.fireContextMenu(eventContext);
				} catch (e) {
				}
				break;
			default:
				break;
		}
	};

	ClusterBase._DOMHandler = function(oParent) {
		this.parent = oParent;
		this.handleEvent = oParent._handleDOMEvent;
		return this;
	};

	return ClusterBase;

});

}; // end of sap/ui/vbm/ClusterBase.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.ClusterDistance') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.ClusterDistance.
jQuery.sap.declare('sap.ui.vbm.ClusterDistance'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/ClusterDistance",[
	'./ClusterBase', './library'
], function(ClusterBase, library) {
	"use strict";

	/**
	 * Constructor for a new ClusterDistance.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Cluster definition element for distance based clusters. Visual objects are clustered based on the visible distance between them. Objects
	 *        get aggregated to a cluster object as long as they are inside the given distance range to the start object. The start object for a
	 *        cluster is not specifically defined, just the next object not belonging to a cluster is taken. The visualization objects are placed in
	 *        the center of gravity of the covered objects. Thus the actual distance between them may vary.<br>
	 *        This clustering is fast, but the results may not be very convincing.
	 * @extends sap.ui.vbm.ClusterBase
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.ClusterDistance
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var ClusterDistance = ClusterBase.extend("sap.ui.vbm.ClusterDistance", /** @lends sap.ui.vbm.ClusterDistance.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * Distance in pixels between cluster objects. This distance is used as parameter during the clustering. The visualization objects are
				 * placed in center of gravity of the covered objects. Thus the actual distance between them may vary.
				 */
				distance: {
					type: "int",
					group: "Behaviour",
					defaultValue: "128"
				}

			},
			aggregations: {},
			events: {}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.ClusterDistance.prototype.init = function(){
	// // do something for initialization...
	// };

	// ...........................................................................//
	// model creators............................................................//
	ClusterDistance.prototype.getClusterDefinition = function() {
		var oDefinition = ClusterBase.prototype.getClusterDefinition.apply(this, arguments);

		oDefinition.type = "distance";

		oDefinition.distance = this.getDistance().toString();
		return oDefinition;
	};

	return ClusterDistance;

});

}; // end of sap/ui/vbm/ClusterDistance.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.ClusterGrid') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.ClusterGrid.
jQuery.sap.declare('sap.ui.vbm.ClusterGrid'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/ClusterGrid",[
	'./ClusterBase', './library'
], function(ClusterBase, library) {
	"use strict";

	/**
	 * Constructor for a new ClusterGrid.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Cluster definition element for grid based clusters. Visual objects are clustered based on a grid. It is possible to have multiple grid
	 *        based clusters. The visualization object is placed in the center of the grid cell plus a given offset.
	 * @extends sap.ui.vbm.ClusterBase
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.ClusterGrid
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var ClusterGrid = ClusterBase.extend("sap.ui.vbm.ClusterGrid", /** @lends sap.ui.vbm.ClusterGrid.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * Size of grid cells in pixels. Format is "distanceX;distanceY"
				 */
				gridSize: {
					type: "string",
					group: "Behaviour",
					defaultValue: "256;256"
				},

				/**
				 * Minimal number of objects covered by grid cell fullfilling the cluster rule until clustering is applied.
				 */
				limit: {
					type: "int",
					group: "Behaviour",
					defaultValue: 2
				},

				/**
				 * Minimal total number of objects covered by grid cell until clustering is applied.
				 */
				limitTotal: {
					type: "int",
					group: "Behaviour",
					defaultValue: 2
				},

				/**
				 * Ordering index of given cluster in the sequence of all grid based clusters
				 */
				orderIndex: {
					type: "int",
					group: "Behaviour",
					defaultValue: null
				},

				/**
				 * Offset for the visualization object from the center of the grid cell. This can be used to show multiple visualization objects in on
				 * grid cell without overlapping. Format is "offsetX;offsetY"
				 */
				offset: {
					type: "string",
					group: "Appearance",
					defaultValue: "0;0"
				},

				/**
				 * Space between grid cells if cell area is shown
				 */
				cellSpacing: {
					type: "int",
					group: "Appearance",
					defaultValue: "4"
				}

			},
			aggregations: {},
			events: {}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.ClusterGrid.prototype.init = function(){
	// // do something for initialization...
	// };

	// ...........................................................................//
	// model creators............................................................//
	ClusterGrid.prototype.getClusterDefinition = function() {
		var oDefinition = ClusterBase.prototype.getClusterDefinition.apply(this, arguments);

		oDefinition.type = "grid";

		oDefinition.limit = this.getLimit().toString();
		oDefinition.limitOnSum = this.getLimitTotal().toString();
		oDefinition.order = this.getOrderIndex().toString();
		oDefinition.areabordersize = -this.getCellSpacing().toString();
		var aGridSize = this.getGridSize().split(";");
		oDefinition.distanceX = aGridSize[0];
		oDefinition.distanceY = aGridSize[1];
		var aOffset = this.getOffset().split(";");
		oDefinition.offsetX = aOffset[0];
		oDefinition.offsetY = aOffset[1];
		return oDefinition;
	};

	return ClusterGrid;

});

}; // end of sap/ui/vbm/ClusterGrid.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.ClusterTree') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.ClusterTree.
jQuery.sap.declare('sap.ui.vbm.ClusterTree'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/ClusterTree",[
	'./ClusterBase', './library'
], function(ClusterBase, library) {
	"use strict";

	/**
	 * Constructor for a new ClusterTree.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Cluster definition element for tree clusters. Complex clustering based on Voronoi diagrams. The actual clustering is based on the areas
	 *        in the Voronoi diagram and cluster objects get aggregated to a hierarchy over several levels of detail.
	 * @extends sap.ui.vbm.ClusterBase
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.ClusterTree
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var ClusterTree = ClusterBase.extend("sap.ui.vbm.ClusterTree", /** @lends sap.ui.vbm.ClusterTree.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {
				/**
				 * Indicates whether the split of a cluster object into sub clusterers or visual objects should be animated
				 */
				animateClusterSplit: {
					type: "boolean",
					group: "Behaviour",
					defaultValue: true
				}
			},
			aggregations: {},
			events: {}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.ClusterTree.prototype.init = function(){
	// // do something for initialization...
	// };

	// ...........................................................................//
	// model creators............................................................//
	ClusterTree.prototype.getClusterDefinition = function() {
		var oDefinition = ClusterBase.prototype.getClusterDefinition.apply(this, arguments);

		oDefinition.type = "tree";

		oDefinition.animation = this.getAnimateClusterSplit().toString();
		return oDefinition;
	};

	return ClusterTree;

});

}; // end of sap/ui/vbm/ClusterTree.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.DragSource') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.DragSource.
jQuery.sap.declare('sap.ui.vbm.DragSource'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained
sap.ui.define("sap/ui/vbm/DragSource",[
	'sap/ui/core/Element', './library'
], function(Element, library) {
	"use strict";

	/**
	 * Constructor for a new DragSource.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class DragSource Aggregation element
	 * @extends sap.ui.core.Element
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.DragSource
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var DragSource = Element.extend("sap.ui.vbm.DragSource", /** @lends sap.ui.vbm.DragSource.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * Drag type
				 */
				type: {
					type: "string",
					group: "Misc",
					defaultValue: null
				}
			}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.DragSource.prototype.init = function(){
	// // do something for initialization...
	// };

	return DragSource;

});

}; // end of sap/ui/vbm/DragSource.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.DropTarget') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.DropTarget.
jQuery.sap.declare('sap.ui.vbm.DropTarget'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained
sap.ui.define("sap/ui/vbm/DropTarget",[
	'sap/ui/core/Element', './library'
], function(Element, library) {
	"use strict";

	/**
	 * Constructor for a new DropTarget.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class DropTarget Aggregation element
	 * @extends sap.ui.core.Element
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.DropTarget
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var DropTarget = Element.extend("sap.ui.vbm.DropTarget", /** @lends sap.ui.vbm.DropTarget.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * Drop type
				 */
				type: {
					type: "string",
					group: "Misc",
					defaultValue: null
				}
			}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.DropTarget.prototype.init = function(){
	// // do something for initialization...
	// };

	return DropTarget;

});

}; // end of sap/ui/vbm/DropTarget.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Feature') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.Feature.
jQuery.sap.declare('sap.ui.vbm.Feature'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained
sap.ui.define("sap/ui/vbm/Feature",[
	'sap/ui/core/Element', './library'
], function(Element, library) {
	"use strict";

	/**
	 * Constructor for a new Feature.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class The Feature element can be added to the <i>items</i> aggregation of a <i>FeatureCollection</i>. By matching the id it allows to
	 *        redefine the color of a GeoJSON feature and adds interactivity.
	 * @extends sap.ui.core.Element
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.Feature
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var Feature = Element.extend("sap.ui.vbm.Feature", /** @lends sap.ui.vbm.Feature.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * The color, this should be provided in the rgba(r,g,b,a) format.
				 */
				color: {
					type: "sap.ui.core.CSSColor",
					group: "Appearance",
					defaultValue: null
				},

				/**
				 * The Feature ID. Used to match with the feature in the GeoJSON given to the parent (FeatureCollection).
				 */
				featureId: {
					type: "string",
					group: "Misc",
					defaultValue: null
				}

			},
			events: {

				/**
				 * The event is raised when there is a click action on a Feature.
				 */
				click: {},

				/**
				 * The event is raised when there is a right click or a tap and hold action on a Feature.
				 */
				contextMenu: {
					parameters: {

						/**
						 * Menu object to be used with openContextMenu().
						 */
						menu: {
							type: "sap.ui.unified.Menu"
						}
					}
				}
			}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.Feature.prototype.init = function(){
	// // do something for initialization...
	// };

	/**
	 * Open a Detail Window for the Feature at click position
	 * 
	 * @param {string} sCaption caption of detail window
	 * @param {string} sOffsetX position offset in x-direction from the anchor point
	 * @param {string} sOffsetY position offset in y-direction from the anchor point
	 * @returns {void}
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	Feature.prototype.openDetailWindow = function(sCaption, sOffsetX, sOffsetY) {
		this.oParent.openDetailWindow(this, {
			caption: sCaption,
			offsetX: sOffsetX,
			offsetY: sOffsetY
		});
	};

	/**
	 * Open the context menu
	 * 
	 * @param {object} oMenu the context menu to be opened
	 * @returns {void}
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	Feature.prototype.openContextMenu = function(oMenu) {
		this.oParent.openContextMenu(this, oMenu);
	};

	Feature.prototype.handleChangedData = function(oElement) {
		// default impl is empty, no changes supported so far
		// However, the Interface for GeoMap aggregated Elements must be fulfilled
	};

	return Feature;

});

}; // end of sap/ui/vbm/Feature.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.GeoJsonLayer') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.GeoJsonLayer.
jQuery.sap.declare('sap.ui.vbm.GeoJsonLayer'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.core.theming.Parameters'); // unlisted dependency retained
jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained
sap.ui.define("sap/ui/vbm/GeoJsonLayer",[
	'sap/ui/core/theming/Parameters', 'sap/ui/core/Element', './library'
], function(Parameters, Element, library) {
	"use strict";

	/**
	 * Constructor for a new GeoJsonLayer.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class GeoJsonLayer aggregation container. A GeoJsonLayer can render the content of an assigned GeoJSON. The naming is associated to the
	 *        GeoJSON standard. All features found in the GeoJSON are rendered as separated objects. From the possible feature types only
	 *        <ul>
	 *        <li>Polygon and Multipolygon,
	 *        <li>LineString, and
	 *        <li>Point
	 *        </ul>
	 *        are supported so far. The feature type support will be extended in the upcoming releases.<br>
	 *        All features from the GeoJSON will be rendered with the given default colors and are inactive. They do not react on mouse over, except
	 *        with tooltip, or raise any events on click or right click.<br>
	 *        By adding <i>Feature elements</i> to the items aggregation you can make the match (by id) feature from the GeoJSON interactive and give
	 *        it alternative colors. <br>
	 *        The GeoJSON can be given as a URL using property <i>srcURL</i>, directly as object using property <i>data</i>, or as a combination of
	 *        both.
	 * @extends sap.ui.core.Element
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.GeoJsonLayer
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var GeoJsonLayer = Element.extend("sap.ui.vbm.GeoJsonLayer", /** @lends sap.ui.vbm.GeoJsonLayer.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * Source URL for GeoJSON
				 */
				srcURL: {
					type: "string",
					defaultValue: null
				},

				/**
				 * GeoJSON object according to the {@link http://geojson.org/geojson-spec.html#geojson-objects|specification} or array of such objects
				 */
				data: {
					type: "object",
					defaultValue: null
				},

				/**
				 * Default line width for LineStrings
				 */
				defaultLineWidth: {
					type: "int",
					group: "Appearance",
					defaultValue: 5
				},

				/**
				 * Default Fill color for GeoJSON features (Polygons and LineStrings)
				 */
				defaultFillColor: {
					type: "sap.ui.core.CSSColor",
					group: "Appearance",
					defaultValue: "rgba(186, 193, 196, 0.5)"
				},

				/**
				 * Default border color for GeoJSON features, if applicable (Polygons and LineStrings)
				 */
				defaultBorderColor: {
					type: "sap.ui.core.CSSColor",
					group: "Appearance",
					defaultValue: "rgba(255, 255, 255, 1.0)"
				}
			},
			defaultAggregation: "items",
			aggregations: {

				/**
				 * Feature object aggregation
				 */
				items: {
					type: "sap.ui.vbm.Feature",
					multiple: true,
					singularName: "item"
				}
			},
			events: {

				/**
				 * The event is raised when there is a click action on an aggregated Feature. Clicks on other Features from the GeoJSON are ignored.
				 */
				click: {
					parameters: {
						/**
						 * Id of clicked Feature
						 */
						featureId: {
							type: "string"
						}
					}
				},

				/**
				 * The event is raised when there is a right click or a tap and hold action on an aggregated Feature. Clicks on other Features from
				 * the GeoJSON are ignored.
				 */
				contextMenu: {
					parameters: {
						/**
						 * Id of clicked Feature
						 */
						featureId: {
							type: "string"
						}
					}
				}
			}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	GeoJsonLayer.prototype.init = function() {
		this.mbGeoJSONDirty = true;
		this.mbSrcLoadPending = false;
		this._aGeoJsonObjects = [];
	};

	GeoJsonLayer.prototype.setSrcURL = function(sSrcURL) {
		this.mbGeoJSONDirty = true;
		return this.setProperty("srcURL", sSrcURL);
	};

	GeoJsonLayer.prototype.setData = function(aData) {
		this.mbGeoJSONDirty = true;
		this._aGeoJsonObjects = aData;
		return this.setProperty("data", aData);
	};

	/**
	 * Add GeoJSON object to the layer
	 * 
	 * @param {object} aData GeoJSON object or an array of those
	 * @returns {void}
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	GeoJsonLayer.prototype.addData = function(aData) {
		this.mbGeoJSONDirty = true;
		// append data to internal feature collection
		if (jQuery.type(aData) === "array") {
			this._aGeoJsonObjects = this._aGeoJsonObjects.concat(aData);
		} else {
			this._aGeoJsonObjects.push(aData);
		}
		this.setProperty("data", this._aGeoJsonObjects);
		this.getParent().invalidate(this); // trigger re-rendering
	};

	/*
	 * @private
	 */
	GeoJsonLayer.prototype._createFeatures = function(oData) {
		// set some default colors
		var defaultColorFill = this.getDefaultFillColor();
		var defaultColorBorder = this.getDefaultBorderColor();

		var aGeoJsonObjects = this._aGeoJsonObjects;
		if (oData) {
			aGeoJsonObjects.push(oData);
		}

		// load the data with the default settings................................//
		this.mFeatureColl = [];
		this.mFeatureBBox = {}; // map of feature boundingbox
		this.mNames = {}; // map of names
		this.mFeatureProps = {}; // map of properties

		// process given GeoJSON objects
		for (var nI = 0; nI < aGeoJsonObjects.length; ++nI) {
			// a GeoJSON object must have a property type with one of the values below
			var oEntry = aGeoJsonObjects[nI];
			switch (oEntry.type) {
				case "FeatureCollection":
					for (var nJ = 0, oFeature; nJ < oEntry.features.length; ++nJ) {
						oFeature = oEntry.features[nJ];
						this._processType(oFeature.id, oFeature.geometry.type, oFeature.geometry.coordinates, oFeature.properties, defaultColorFill, defaultColorBorder);
					}
					break;
				case "Feature":
					this._processType(oEntry.id, oEntry.geometry.type, oEntry.geometry.coordinates, oEntry.properties, defaultColorFill, defaultColorBorder);
					break;
				case "GeometryCollection":
					for (var nK = 0, oGeometry; nK < oEntry.geometries.length; ++nK) {
						oGeometry = oEntry.geometries[nK];
						this._processType(null, oGeometry.type, oGeometry.coordinates, null, defaultColorFill, defaultColorBorder);
					}
					break;
				case "Polygon":
				case "MultiPolygon":
				case "LineString":
				case "MultiLineString":
				case "Point":
				case "MultiPoint":
					this._processType(null, oEntry.type, oEntry.coordinates, null, defaultColorFill, defaultColorBorder);
					break;
				default:
					jQuery.sap.log.error("GeoJsonLayer: Unsupported GeoJSON object type " + aGeoJsonObjects[nI].type);
					continue;
			}
		}
		this.mbGeoJSONDirty = false;
	};

	GeoJsonLayer.prototype._processType = function(sId, sType, coordinates, aProperties, fillColor, borderColor) {
		var x, y, minX = Number.MAX_VALUE, maxX = -Number.MAX_VALUE, minY = Number.MAX_VALUE, maxY = -Number.MAX_VALUE;

		var tooltip = '', tmp;
		var aCoordsVB; // array of point coordinates in VB format "lon,lat,0"
		var aCoordsGJ; // array of coordinates in GeoJSON format [lon,lat]
		var nI, nK;
		var aPolygons = [];
		var aPolygoneParts = []; // multi polygon array
		var aBoundingBoxes = []; // array of bounding boxes for multi parts

		// get the name of the fragment........................................//
		tooltip = (aProperties && aProperties.name) ? aProperties.name : "";
		this.mFeatureProps[sId] = aProperties;

		switch (sType) {
			case "Polygon":
				for (nI = 0; nI < coordinates.length; ++nI) {
					aCoordsGJ = coordinates[nI];

					// create the vbi float array for regions
					aCoordsVB = [];
					for (nK = 0; nK < aCoordsGJ.length; ++nK) {
						tmp = aCoordsGJ[nK];
						if (!nI) {
							// do min max detection -> only on null'th, since holes will not contribute //
							if ((x = tmp[0]) < minX) {
								minX = x;
							}
							if (x > maxX) {
								maxX = x;
							}
							if ((y = tmp[1]) < minY) {
								minY = y;
							}
							if (y > maxY) {
								maxY = y;
							}
						}
						aCoordsVB.push(tmp[0], tmp[1], "0");
					}
					aPolygoneParts.push(aCoordsVB);
				}
				aPolygons.push(aPolygoneParts);
				aBoundingBoxes.push([
					minX, maxX, minY, maxY
				]);
				break;
			case "MultiPolygon":
				for (var nL = 0, coordlen, acmlen = coordinates.length; nL < acmlen; ++nL) {
					aPolygoneParts = [];
					coordlen = coordinates[nL].length;
					for (nI = 0; nI < coordlen; ++nI) {
						aCoordsGJ = coordinates[nL][nI];

						// create the vbi float array for regions.....................//
						aCoordsVB = [];
						for (nK = 0; nK < aCoordsGJ.length; ++nK) {
							tmp = aCoordsGJ[nK];
							if (!nI) {
								// do min max detection -> only on null'th, since holes will not contribute //
								if ((x = tmp[0]) < minX) {
									minX = x;
								}
								if (x > maxX) {
									maxX = x;
								}
								if ((y = tmp[1]) < minY) {
									minY = y;
								}
								if (y > maxY) {
									maxY = y;
								}
							}
							aCoordsVB.push(tmp[0], tmp[1], "0");
						}
						aPolygoneParts.push(aCoordsVB);
					}
					aPolygons.push(aPolygoneParts);
					aBoundingBoxes.push([
						minX, maxX, minY, maxY
					]);
				}
				break;
			case "LineString":
				aCoordsVB = [];
				for (nI = 0; nI < coordinates.length; ++nI) {
					tmp = coordinates[nI];

					// create the vbi float array for routes
					// do min max detection -> only on null'th, since holes will not contribute //
					if ((x = tmp[0]) < minX) {
						minX = x;
					}
					if (x > maxX) {
						maxX = x;
					}
					if ((y = tmp[1]) < minY) {
						minY = y;
					}
					if (y > maxY) {
						maxY = y;
					}
					aCoordsVB.push(tmp[0], tmp[1], 0);
				}
				aPolygoneParts.push(aCoordsVB);
				aPolygons.push(aPolygoneParts);
				aBoundingBoxes.push([
					minX, maxX, minY, maxY
				]);
				break;
			case "Point":
				minY = maxY = coordinates[1];
				minX = maxX = coordinates[0];

				aCoordsVB = [
					coordinates[0], coordinates[1], 0
				];
				aPolygoneParts.push(aCoordsVB);
				aPolygons.push(aPolygoneParts);
				aBoundingBoxes.push([
					minX, maxX, minY, maxY
				]);
				break;
			default:
				jQuery.sap.log.error("GeoJsonLayer: Unsupported geometry type " + sType);
				return;
		}
		this.mFeatureColl.push(this._createDataElement(sId, aPolygons, sType, fillColor, borderColor, tooltip, sId));

		// get surrounding box for all parts -> this needs to consider round world for optimized bounding box size!
		this.mFeatureBBox[sId] = window.VBI.MathLib.GetSurroundingBox(aBoundingBoxes);
	};

	/*
	 * @private
	 */
	GeoJsonLayer.prototype._createDataElement = function(id, array, type, color, colorBorder, tooltip, entity) {
		var element = {
			K: id,
			P: [],
			TT: tooltip,
			C: color,
			CB: colorBorder,
			type: type
		};
		element["VB:s"] = false;
		var nK, nJ, nI;
		var str, coords, clen, blen, alen;

		switch (type) {
			case "Polygon":
			case "MultiPolygon":

				var area, areaParts;
				alen = array.length;
				for (nI = 0; nI < alen; ++nI) {
					area = array[nI];
					areaParts = [];
					blen = area.length;
					for (nJ = 0; nJ < blen; ++nJ) {
						str = "";
						clen = area[nJ].length;
						for (nK = 0; nK < clen; ++nK) {
							if (nK) {
								(str += ";");
							}
							str += area[nJ][nK];
						}
						areaParts.push(str);
					}
					element.P.push(areaParts);
				}
				break;
			case "LineString":

				str = "";
				coords = array[0][0];
				clen = coords.length;
				for (nK = 0; nK < clen; ++nK) {
					if (nK) {
						(str += ";");
					}
					str += coords[nK];
				}
				element.P = str;
				break;
			case "Point":

				str = "";
				coords = array[0][0];
				clen = coords.length;
				for (nK = 0; nK < clen; ++nK) {
					if (nK) {
						(str += ";");
					}
					str += coords[nK];
				}
				element.P = str;
				break;
		}
		return element;
	};

	GeoJsonLayer.prototype._triggerFeatureCreation = function() {
		var sPathGeoJSON = null;
		// check whether we have to load from URL or not
		if ((sPathGeoJSON = this.getSrcURL())) {
			if (!this.mbSrcLoadPending) {
				this.mbSrcLoadPending = true;
				jQuery.getJSON(sPathGeoJSON, function(oData) {
					this._createFeatures(oData);
					this.mbSrcLoadPending = false;
					var oParent;
					if ((oParent = this.getParent())) {
						oParent.invalidate(); // trigger re-rendering
					}
				}.bind(this)).fail(function() {
					jQuery.sap.log.error("GeoJsonLayer: The path or the GeoJSON file at location " + sPathGeoJSON + " is invalid.");
				});
			}
		} else {
			// no src URL given -> proceed without loading something
			this._createFeatures(null);
		}
	};

	// ...........................................................................//
	// model creators............................................................//

	GeoJsonLayer.prototype.getTemplateObjects = function() {
		var oTemp, aResult = [];

		// Polygones
		oTemp = {
			id: this.getId() + "_Polys",
			type: "{00100000-2012-0004-B001-F311DE491C77}", // Area
			hotDeltaColor: "RHLSA(0;1;1;1.5)", // increase opacity by 50%
			altBorderDeltaColor: (Parameters) ? Parameters.get("sapUiChartDataPointBorderHoverSelectedColor") : "#666"
		};
		// the data source name is equivalent to the controls id..................//
		oTemp.datasource = oTemp.id;

		oTemp['posarraymulti.bind'] = oTemp.id + ".P"; // P is the position array
		oTemp['color.bind'] = oTemp.id + ".C"; // C the color
		oTemp['colorBorder.bind'] = oTemp.id + ".CB"; // CB the border color
		oTemp['tooltip.bind'] = oTemp.id + ".TT"; // TT the tooltip
		aResult.push(oTemp);

		// Lines
		oTemp = {
			id: this.getId() + "_Lines",
			type: "{00100000-2012-0004-B001-C46BD7336A1A}", // Route
			hotDeltaColor: "RHLSA(0;1;1;1.5)", // increase opacity by 50%
			altBorderDeltaColor: (Parameters) ? Parameters.get("sapUiChartDataPointBorderHoverSelectedColor") : "#666"
		};
		// the data source name is equivalent to the controls id..................//
		oTemp.datasource = oTemp.id;

		oTemp['posarray.bind'] = oTemp.id + ".P"; // P is the position array multi
		oTemp['color.bind'] = oTemp.id + ".C"; // C the color
		oTemp['colorBorder.bind'] = oTemp.id + ".CB"; // CB the border color
		oTemp['tooltip.bind'] = oTemp.id + ".TT"; // TT the tooltip
		aResult.push(oTemp);

		// Points
		oTemp = {
			id: this.getId() + "_Points",
			type: "{00100000-2012-0004-B001-64592B8DB964}", // Spot
			hotDeltaColor: "RHLSA(0;1;2;1)" // increase lightness by 100%
		};
		// the data source name is equivalent to the controls id..................//
		oTemp.datasource = oTemp.id;

		oTemp['pos.bind'] = oTemp.id + ".P"; // P is the position
		oTemp['tooltip.bind'] = oTemp.id + ".TT"; // TT the tooltip
		aResult.push(oTemp);

		return aResult;
	};

	GeoJsonLayer.prototype.getTypeObjects = function() {
		var oType = {}, aResult = [];
		var oTypeTemplate = {
			key: "K",
			minSel: "0",
			maxSel: "0", // suppress selection
			A: [
				{
					"name": "K", // key
					"alias": "K",
					"type": "string"
				}, {
					"name": "C", // color
					"alias": "C",
					"type": "color"
				}, {
					"name": "CB", // border color
					"alias": "CB",
					"type": "string"
				}, {
					"name": "TT", // tooltip
					"alias": "TT",
					"type": "string"
				}
			]
		};

		jQuery.extend(/* deep= */true, oType, oTypeTemplate); // copy template
		// set the id.............................................................//
		oType.name = this.getId() + "_Polys";
		oType.A.push({
			"name": "P", // position array multi
			"alias": "P",
			"type": "vectorarraymulti"
		});
		aResult.push(oType);

		oType = {};
		jQuery.extend(/* deep= */true, oType, oTypeTemplate); // copy template
		// set the id.............................................................//
		oType.name = this.getId() + "_Lines";

		oType.A.push({
			"name": "P", // position array
			"alias": "P",
			"type": "vectorarray"
		});
		aResult.push(oType);

		oType = {};
		jQuery.extend(/* deep= */true, oType, oTypeTemplate); // copy template
		// set the id.............................................................//
		oType.name = this.getId() + "_Points";
		oType.A.push({
			"name": "P", // position
			"alias": "P",
			"type": "vector"
		});
		aResult.push(oType);

		return aResult;
	};

	GeoJsonLayer.prototype.getDataObjects = function() {
		if (this.mbGeoJSONDirty) {
			this._triggerFeatureCreation();
		}

		// apply the feature properties to the vbi datacontext.....................//
		// do a real clone of the original data, to be able to handle complete....//
		// model changes..........................................................//

		var aElements = [], aPolys = [], aLines = [], aPoints = [];
		jQuery.extend(true, aElements, this.mFeatureColl);

		var oOverlayMap = {};
		if (aElements.length) {
			// create lookup for overlayed features..................................//
			var aOverlayFeatures = this.getItems();
			for (var nJ = 0, len = aOverlayFeatures ? aOverlayFeatures.length : 0, item; nJ < len; ++nJ) {
				item = aOverlayFeatures[nJ];
				oOverlayMap[item.getFeatureId()] = item;
			}
		}

		// iterate over feature table.............................................//
		for (var nK = 0, oElement, oOverlay, tmp; nK < aElements.length; ++nK) {
			oElement = aElements[nK];

			if ((oOverlay = oOverlayMap[oElement.K])) {
				// Overlay found, apply properties.....................................//
				oElement.C = oOverlay.getColor();
				if ((tmp = oOverlay.getTooltip())) {
					oElement.TT = tmp;
				}
			}
			switch (oElement.type) {
				case "Polygon":
				case "MultiPolygon":
					aPolys.push(oElement);
					break;
				case "LineString":
				case "MultiLineString":
					aLines.push(oElement);
					break;
				case "Point":
				case "MultiPoint":
					aPoints.push(oElement);
					break;
				default:
					jQuery.sap.log.error("GeoJsonLayer: Unknown object type: " + oElement.type);
			}
		}

		return [
			{
				"name": this.getId() + "_Polys",
				"type": "N",
				"E": aPolys
			}, {
				"name": this.getId() + "_Lines",
				"type": "N",
				"E": aLines
			}, {
				"name": this.getId() + "_Points",
				"type": "N",
				"E": aPoints
			}
		];
	};

	GeoJsonLayer.prototype.getDataRemoveObjects = function() {
		return [
			{
				"name": this.getId() + "_Polys",
				"type": "N"
			}, {
				"name": this.getId() + "_Lines",
				"type": "N"
			}, {
				"name": this.getId() + "_Points",
				"type": "N"
			}
		];
	};

	GeoJsonLayer.prototype.getActionArray = function() {
		var aActions = [];
		var id = this.getId();

		// check if the different vo events are registered..............................//
		if (this.mEventRegistry["click"] || this.isEventRegistered("click")) {
			aActions.push({
				"id": id + "Polys1",
				"name": "click",
				"refScene": "MainScene",
				"refVO": id + "_Polys",
				"refEvent": "Click",
				"AddActionProperty": [
					{
						"name": "pos"
					}
				]
			});
			aActions.push({
				"id": id + "Lines1",
				"name": "click",
				"refScene": "MainScene",
				"refVO": id + "_Lines",
				"refEvent": "Click",
				"AddActionProperty": [
					{
						"name": "pos"
					}
				]
			});
			aActions.push({
				"id": id + "Points1",
				"name": "click",
				"refScene": "MainScene",
				"refVO": id + "_Points",
				"refEvent": "Click",
				"AddActionProperty": [
					{
						"name": "pos"
					}
				]
			});
		}
		if (this.mEventRegistry["contextMenu"] || this.isEventRegistered("contextMenu")) {
			aActions.push({
				"id": id + "_Polys2",
				"name": "contextMenu",
				"refScene": "MainScene",
				"refVO": id + "_Polys",
				"refEvent": "ContextMenu"
			});
			aActions.push({
				"id": id + "_Lines2",
				"name": "contextMenu",
				"refScene": "MainScene",
				"refVO": id + "_Lines",
				"refEvent": "ContextMenu"
			});
			aActions.push({
				"id": id + "_Points2",
				"name": "contextMenu",
				"refScene": "MainScene",
				"refVO": id + "_Points",
				"refEvent": "ContextMenu"
			});
		}
// if( this.mEventRegistry[ "drop" ] || this.isEventRegistered( "drop" ) )
// aActions.push( { "id": id + "3", "name": "drop", "refScene": "MainScene", "refVO": id, "refEvent": "Drop" } );
//	    
// if( this.mEventRegistry[ "edgeClick" ] || this.isEventRegistered( "edgeClick" ) )
// aActions.push( { "id": id + "7", "name": "edgeClick", "refScene": "MainScene", "refVO": id, "refEvent": "EdgeClick" });
// if( this.mEventRegistry[ "edgeContextMenu" ] || this.isEventRegistered( "edgeContextMenu" ) )
// aActions.push( { "id": id + "8", "name": "edgeContextMenu", "refScene": "MainScene", "refVO": id, "refEvent": "EdgeContextMenu" });

		return aActions;
	};

	/**
	 * Returns Properties for Features like name, bounding box, and midpoint
	 * 
	 * @param {string[]} aFeatureIds Array of Feature Ids. The Feature Id must match the GeoJSON tag.
	 * @returns {array} Array of Feature Information Objects. Each object in the array has the properties BBox: Bounding Box for the Feature in format
	 *          "lonMin;latMin;lonMax;latMax", Midpoint: Centerpoint for Feature in format "lon;lat", Name: Name of the Feature, and Properties: Array
	 *          of name-value-pairs associated with the Feature
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	GeoJsonLayer.prototype.getFeaturesInfo = function(aFeatureIds) {
		var result = [];
		for (var nJ = 0, len = aFeatureIds.length, featureId; nJ < len; ++nJ) {
			featureId = aFeatureIds[nJ];
			result[featureId] = {};
			result[featureId].BBox = this.mFeatureBBox[featureId];
			result[featureId].Midpoint = [
				(this.mFeatureBBox[featureId][0] + this.mFeatureBBox[featureId][1]) / 2, (this.mFeatureBBox[featureId][2] + this.mFeatureBBox[featureId][3]) / 2
			];
			result[featureId].Name = this.mNames[featureId];
			result[featureId].Properties = this.mFeatureProps[featureId];
		}
		return result;
	};

	GeoJsonLayer.prototype.handleEvent = function(event) {
		var s = event.Action.name;

		var funcname = "fire" + s[0].toUpperCase() + s.slice(1);

		// first we try to get the event on a GeoJsonLayer instance......................//
		var oOverlay, sInstance = event.Action.instance;
		if ((oOverlay = this.findInstance(sInstance))) {

			if (oOverlay.mEventRegistry[s]) {
				if (s === "click") {
					oOverlay.mClickGeoPos = event.Action.AddActionProperties.AddActionProperty[0]['#'];
				}
				if (s === "contextMenu") {
					oOverlay.mClickPos = [
						event.Action.Params.Param[0]['#'], event.Action.Params.Param[1]['#']
					];
					// lazy load sap.ui.unified library for using the Menu
					sap.ui.getCore().loadLibrary("sap.ui.unified");

					if (this.oParent.mVBIContext.m_Menus) {
						this.oParent.mVBIContext.m_Menus.deleteMenu("DynContextMenu");
					}
					// create an empty menu
					var oMenuObject = new sap.ui.unified.Menu();
					oMenuObject.vbi_data = {};
					oMenuObject.vbi_data.menuRef = "CTM";
					oMenuObject.vbi_data.VBIName = "DynContextMenu";

					// fire the contextMenu..................................................//
					oOverlay.fireContextMenu({
						menu: oMenuObject
					});
				} else if (s === "handleMoved") {
					oOverlay[funcname]({
						data: event
					});
				} else {
					oOverlay[funcname]({});
				}
			}
		}
		// check wether event is registered on Feature Collection and fire in case of
		if (this.mEventRegistry[s]) {
			this[funcname]({
				featureId: sInstance.split(".")[1]
			});
		}
	};

	/**
	 * open a Detail Window
	 * 
	 * @param {sap.ui.vbm.Feature} oFeature VO instance for which the Detail Window should be opened
	 * @param {object} oParams Parameter object
	 * @param {string} oParams.caption Text for Detail Window caption
	 * @param {string} oParams.offsetX position offset in x-direction from the anchor point
	 * @param {string} oParams.offsetY position offset in y-direction from the anchor point
	 * @returns {void}
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	GeoJsonLayer.prototype.openDetailWindow = function(oFeature, oParams) {
		var oParent = this.getParent();
		oParent.mDTWindowCxt.bUseClickPos = true;
		oParent.mDTWindowCxt.open = true;
		oParent.mDTWindowCxt.src = oFeature;
		oParent.mDTWindowCxt.key = oFeature.getFeatureId();
		oParent.mDTWindowCxt.params = oParams;
		oParent.m_bWindowsDirty = true;
		oParent.invalidate(this);
	};

	/**
	 * open the context menu
	 * 
	 * @param {sap.ui.vbm.Feature} oFeature VO instance for which the Detail Window should be opened
	 * @param {object} oMenu the context menu to be opened
	 * @returns {void}
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	GeoJsonLayer.prototype.openContextMenu = function(oFeature, oMenu) {
		this.oParent.openContextMenu("Area", oFeature, oMenu);
	};

	GeoJsonLayer.prototype.handleChangedData = function(aElements) {
		if (aElements && aElements.length) {
			for (var nI = 0, oElement, oInst; nI < aElements.length; ++nI) {
				oElement = aElements[nI];
				// key oElement.K may be undefined for objects without id or feature overlay
				oInst = (oElement.K) ? this.findInstance(oElement.K) : null;
				if (oInst) {
					oInst.handleChangedData(oElement);
				}
			}
		}
	};

	// ..........................................................................//
	// helper functions.........................................................//

	GeoJsonLayer.prototype.isEventRegistered = function(name) {
		var aOverlayFeatures = this.getItems();
		if (!aOverlayFeatures) {
			return false;
		}

		for (var nJ = 0, len = aOverlayFeatures.length; nJ < len; ++nJ) {
			// if one registers for an event we can return........................//
			if (aOverlayFeatures[nJ].mEventRegistry[name]) {
				return true;
			}
		}

		return false;
	};

	GeoJsonLayer.prototype.findInstance = function(name) {
		var aOverlayFeatures = this.getItems();
		if (!aOverlayFeatures) {
			return null;
		}

		switch (jQuery.type(name)) {
			case "string":
				var key = (name.indexOf(".") !== -1) ? name.split(".")[1] : name;
				for (var nJ = 0, len = aOverlayFeatures.length; nJ < len; ++nJ) {
					// get the control.....................................................//
					if (aOverlayFeatures[nJ].getFeatureId() === key) {
						return aOverlayFeatures[nJ];
					}
				}
				break;
			case "number":
				// Check: Are there overlays for non-id GeoJSON objects?
				break;
			default:
				jQuery.sap.log.error("GeoJsonLayer: Unextected instance name type " + jQuery.type(name));
				break;
		}

		return null;
	};

	return GeoJsonLayer;

});

}; // end of sap/ui/vbm/GeoJsonLayer.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.GeoMapRenderer') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

jQuery.sap.declare('sap.ui.vbm.GeoMapRenderer'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/GeoMapRenderer",[
	'./VBIRenderer'
], function(VBIRenderer) {
	"use strict";

	/*
	 * @class GeoMap renderer. @static
	 */
	var GeoMapRenderer = {};

	/**
	 * Renders the HTML for the given control, using the provided {@link sap.ui.core.RenderManager}.
	 * 
	 * @param {sap.ui.core.RenderManager} oRm the RenderManager that can be used for writing to the render output buffer
	 * @param {sap.ui.core.Control} oControl an object representation of the control that should be rendered
	 */
	GeoMapRenderer.render = function(oRm, oControl) {
		oControl.addStyleClass("sapUiVbmGeoMap");
		VBIRenderer.render(oRm, oControl);

		// update bound data......................................................//
		var oApp;
		if ((oApp = oControl.update())) {
			oControl.load(oApp);
		}
	};

	return GeoMapRenderer;

}, /* bExport= */true);

}; // end of sap/ui/vbm/GeoMapRenderer.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Legend') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.Legend.
jQuery.sap.declare('sap.ui.vbm.Legend'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained
sap.ui.define("sap/ui/vbm/Legend",[
	'sap/ui/core/Element', './library'
], function(Element, library) {
	"use strict";

	/**
	 * Constructor for a new Legend.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class The Legend is a window in the GeoMap or AnalyticMap control wich can be used to display color/icon-text pairs on a map.
	 * @extends sap.ui.core.Element
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.Legend
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var Legend = Element.extend("sap.ui.vbm.Legend", /** @lends sap.ui.vbm.Legend.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * The caption of the legend.
				 */
				caption: {
					type: "string",
					group: "Misc",
					defaultValue: sap.ui.getCore().getLibraryResourceBundle("sap.ui.vbm.i18n").getText("CAPTION_LEGEND")
				}
			},
			defaultAggregation: "items",
			aggregations: {

				/**
				 * LegendItem object aggregation
				 */
				items: {
					type: "sap.ui.vbm.LegendItem",
					multiple: true,
					singularName: "item"
				}
			},
			events: {

				/**
				 * The event is raised when there is a click action on a legend.
				 */
				click: {
					parameters: {

						/**
						 * Event data object
						 */
						data: {
							type: "object"
						},

						/**
						 * The row number where the click occurred
						 */
						row: {
							type: "int"
						},

						/**
						 * key modifier Ctrl pressed
						 */
						ctrlKey: {
							type: "boolean"
						},

						/**
						 * key modifier Shift pressed
						 */
						shiftKey: {
							type: "boolean"
						},

						/**
						 * key modifier Meta pressed
						 */
						metaKey: {
							type: "boolean"
						},

						/**
						 * key modifier Alt pressed
						 */
						altKey: {
							type: "boolean"
						}
					}
				}
			}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */

	Legend.prototype.init = function() {
		// set legend flags.......................................................//
		// this.m_bLegendRendered = false;
	};

	// ...........................................................................//
	// model creators............................................................//

	Legend.prototype.getTemplateObject = function() {
		var id = this.getId();
		var oWindowsTemplate = {};

		if (this.getParent().getLegendVisible()) {
			oWindowsTemplate = {
				"Set": [
					{
						"name": id,
						"Window": {
							"id": id,
							"type": "legend",
							"caption": this.getCaption(),
							"refParent": "Main",
							"refScene": "",
							"modal": "true",
							"datasource": id,
							"colors.bind": id + ".C",
							"images.bind": id + ".I",
							"texts.bind": id + ".T",
							"tooltips.bind": id + ".TT"
						}
					}
				]
			};
			if (this.getParent().m_curLegendPos) {
				oWindowsTemplate.Set[0].Window.right = this.getParent().m_curLegendPos.right.toString();
				oWindowsTemplate.Set[0].Window.top = this.getParent().m_curLegendPos.top.toString();
			}
		} else {
			// Legend not visible -> remove legend window
			oWindowsTemplate = {
				"Remove": [
					{
						"name": id
					}
				]
			};
		}
		return oWindowsTemplate;
	};

	Legend.prototype.getTypeObject = function() {
		return {
			"name": this.getId(),
			"A": [
				{
					"name": "C", // color
					"alias": "C",
					"type": "color"
				}, {
					"name": "I", // image
					"alias": "I",
					"type": "string"
				}, {
					"name": "T", // text
					"alias": "T",
					"type": "string"
				}, {
					"name": "TT", // tooltip
					"alias": "TT",
					"type": "string"
				}
			]
		};
	};

	Legend.prototype.getDataObject = function() {
		var oData = {};

		// set the id of the table................................................//
		oData['name'] = this.getId();
		oData.E = [];

		var aVO = this.getItems();
		for (var nJ = 0, len = aVO.length; nJ < len; ++nJ) {
			oData.E.push(aVO[nJ].getDataElement());
		}

		return oData;
	};

	// ..........................................................................//
	// helper functions.........................................................//

	Legend.prototype.handleEvent = function(event) {
		var s = event.Action.name;

		var funcname = "fire" + s[0].toUpperCase() + s.slice(1);

		var params = {
			data: event,
			ctrlKey: event.Action.Params.Param[1]['#'],
			shiftKey: event.Action.Params.Param[2]['#'],
			metaKey: event.Action.Params.Param[3]['#'],
			altKey: event.Action.Params.Param[4]['#']
		};

		// first we try to get the event on a legend item ......................//
		var LegendItem;
		if ((LegendItem = this.findInstance(event.Action.Params.Param[0]['#']))) {
			if (LegendItem.mEventRegistry[s]) {
				if (s == "click") {
					LegendItem[funcname](params);
				}
			}
		}
		params.row = parseInt(event.Action.Params.Param[0]['#'], 10);

		this[funcname](params);
	};

	Legend.prototype.getActionArray = function() {
		var id = this.getId();
		var aActions = [];

		// check if the different vo events are registered..............................//
		if (this.mEventRegistry["click"] || this.isEventRegistered("click")) {
			aActions.push({
				"id": id + "1",
				"name": "click",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "Click"
			});
		}

		return aActions;
	};

	Legend.prototype.isEventRegistered = function(name) {
		var aVO = this.getItems();
		if (!aVO) {
			return false;
		}

		for (var nJ = 0, len = aVO.length; nJ < len; ++nJ) {
			// get the control.....................................................//
			var oInstance = aVO[nJ];

			// if one registers for an event we can return........................//
			if (oInstance.mEventRegistry[name]) {
				return true;
			}
		}

		return false;
	};

	Legend.prototype.findInstance = function(key) {

		var aVO = this.getItems();

		(aVO[0].sId).lastIndexOf('-');

		aVO = this.getItems();
		if (!aVO) {
			return false;
		}

		for (var nJ = 0, len = aVO.length; nJ < len; ++nJ) {
			var id = aVO[nJ].sId;
			var idx = id.lastIndexOf('-');
			var result = id.substring(idx + 1);
			if (result === key) {
				return aVO[nJ];
			}
		}

		return null;
	};

	return Legend;

});

}; // end of sap/ui/vbm/Legend.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.LegendItem') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.LegendItem.
jQuery.sap.declare('sap.ui.vbm.LegendItem'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained
sap.ui.define("sap/ui/vbm/LegendItem",[
	'sap/ui/core/Element', './library'
], function(Element, library) {
	"use strict";

	/**
	 * Constructor for a new LegendItem.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Aggregation element for the Legend. A LegendItem consists of marker and an associated text. The marker is either a rectangle in the
	 *        given color or the given image or a semantic spot type. If no marker but only a text is provided then it is shown in italic letters and
	 *        can be regarded as a header.
	 * @extends sap.ui.core.Element
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.LegendItem
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var LegendItem = Element.extend("sap.ui.vbm.LegendItem", /** @lends sap.ui.vbm.LegendItem.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * The color of the legend marker.
				 */
				color: {
					type: "string",
					group: "Misc",
					defaultValue: ''
				},

				/**
				 * The image for the legend marker.
				 */
				image: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * The semantic spot type for the legend marker.
				 */
				semanticSpotType: {
					type: "sap.ui.vbm.SemanticType",
					group: "Behavior",
					defaultValue: null
				},

				/**
				 * The text of the legend item.
				 */
				text: {
					type: "string",
					group: "Misc",
					defaultValue: null
				}
			},
			events: {

				/**
				 * The event is raised when there is a click action on a legend item.
				 */
				click: {
					parameters: {

						/**
						 * Event data object
						 */
						data: {
							type: "object"
						},

						/**
						 * key modifier Ctrl pressed
						 */
						ctrlKey: {
							type: "boolean"
						},

						/**
						 * key modifier Shift pressed
						 */
						shiftKey: {
							type: "boolean"
						},

						/**
						 * key modifier Meta pressed
						 */
						metaKey: {
							type: "boolean"
						},

						/**
						 * key modifier Alt pressed
						 */
						altKey: {
							type: "boolean"
						}
					}
				}
			}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.LegendItem.prototype.init = function(){
	// // do something for initialization...
	// };

	LegendItem.prototype.getDataElement = function() {
		var oElement = {};
		var col, img, type, txt, tt;
		if ((col = this.getColor())) {
			oElement.C = col;
		}
		if ((img = this.getImage())) {
			oElement.I = img;
		}
		if ((type = this.getSemanticSpotType())) {
			switch (type) {
				case sap.ui.vbm.SemanticType.Hidden:
					oElement.I = "Pin_Hidden.png";
					break;
				case sap.ui.vbm.SemanticType.Error:
					oElement.I = "Pin_Red.png";
					break;
				case sap.ui.vbm.SemanticType.Warning:
					oElement.I = "Pin_Orange.png";
					break;
				case sap.ui.vbm.SemanticType.Success:
					oElement.I = "Pin_Green.png";
					break;
				case sap.ui.vbm.SemanticType.Inactive:
					oElement.I = "Pin_Grey.png";
					break;
				case sap.ui.vbm.SemanticType.Default:
					oElement.I = "Pin_Blue.png";
					break;
				default:
					break;
			}

			if (oElement.I) {
				this.getParent().getParent().addResourceIfNeeded(oElement.I);
			}
		}

		if ((txt = this.getText())) {
			oElement.T = txt;
		}
		if ((tt = this.getTooltip())) {
			oElement.TT = tt;
		}
		return oElement;

	};

	return LegendItem;

});

}; // end of sap/ui/vbm/LegendItem.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.PieItem') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.PieItem.
jQuery.sap.declare('sap.ui.vbm.PieItem'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained
sap.ui.define("sap/ui/vbm/PieItem",[
	'sap/ui/core/Element', './library'
], function(Element, library) {
	"use strict";

	/**
	 * Constructor for a new PieItem.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Slice element for a Pie Chart.
	 * @extends sap.ui.core.Element
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.PieItem
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var PieItem = Element.extend("sap.ui.vbm.PieItem", /** @lends sap.ui.vbm.PieItem.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * The name of the Pie item.
				 */
				name: {
					type: "string",
					group: "Misc",
					defaultValue: ''
				},

				/**
				 * The value of the Pie item.
				 */
				value: {
					type: "string",
					group: "Misc",
					defaultValue: null
				}
			},
			events: {

				/**
				 * The event is raised when there is a click action on a pie item.
				 */
				click: {}
			}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.PieItem.prototype.init = function(){
	// // do something for initialization...
	// };

	return PieItem;

});

}; // end of sap/ui/vbm/PieItem.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Region') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.Region.
jQuery.sap.declare('sap.ui.vbm.Region'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained
sap.ui.define("sap/ui/vbm/Region",[
	'sap/ui/core/Element', './library'
], function(Element, library) {
	"use strict";

	/**
	 * Constructor for a new Region.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Region properties.
	 * @extends sap.ui.core.Element
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.Region
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var Region = Element.extend("sap.ui.vbm.Region", /** @lends sap.ui.vbm.Region.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * The color, this must be provided in the rgba(r,g,b,a) format.
				 */
				color: {
					type: "sap.ui.core.CSSColor",
					group: "Appearance",
					defaultValue: null
				},

				/**
				 * The region code.
				 */
				code: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * set to true if the element is selected
				 */
				select: {
					type: "boolean",
					group: "Misc",
					defaultValue: false
				},

				labelText: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * Type for semantic labels. A given semantic type will overrule color settings and add an icon.
				 */
				labelType: {
					type: "sap.ui.vbm.SemanticType",
					group: "Behavior",
					defaultValue: sap.ui.vbm.SemanticType.None
				},

				labelBgColor: {
					type: "string",
					group: "Misc",
					defaultValue: 'RGB(255;255;255)'
				},

				labelBorderColor: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * The visual objects label arrow. For left/right/top/bottom aligned labels an additional arrow points to the label's object.
				 */
				labelArrow: {
					type: "boolean",
					group: "Misc",
					defaultValue: false
				}

			},
			events: {

				/**
				 * The event is raised when there is a click action on a region.
				 */
				click: {
					parameters: {

						/**
						 * The region code.
						 */
						code: {
							type: "string"
						}
					}
				},

				/**
				 * The event is raised when there is a right click or a tap and hold action on a region.
				 */
				contextMenu: {
					parameters: {

						/**
						 * The region code.
						 */
						code: {
							type: "string"
						}
					}
				}
			}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.Region.prototype.init = function(){
	// // do something for initialization...
	// };

	/**
	 * Returns Infos for the Region like name, bounding box and midpoint
	 * 
	 * @returns {object} Region Information Object. Object has the properties BBox: Bounding Box for Region in format "lonMin;latMin;lonMax;latMax",
	 *          Midpoint: Centerpoint for Region in format "lon;lat", Name: Name of the region, and Properties: Array of name-value-pair associated
	 *          with the region
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	Region.prototype.getInfo = function() {
		return this.getParent().getRegionsInfo([
			this.getCode()
		])[0];
	};

	return Region;

});

}; // end of sap/ui/vbm/Region.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Resource') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.Resource.
jQuery.sap.declare('sap.ui.vbm.Resource'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained
sap.ui.define("sap/ui/vbm/Resource",[
	'sap/ui/core/Element', './library'
], function(Element, library) {
	"use strict";

	/**
	 * Constructor for a new Resource.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class A resource is a Base64 encoded representation of an image binary that can be referenced by name in e.g. a <i>Spot</i> element. When
	 *        images are specified as a string resource it is guaranteed that the control can access the bits in the image. If just a URL to the
	 *        resource is given it is loaded and converted to a Base64 encoded binary. This happens asynchronously and it may require several
	 *        re-renderings of the control until all resource show up correctly.
	 * @extends sap.ui.core.Element
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.Resource
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var Resource = Element.extend("sap.ui.vbm.Resource", /** @lends sap.ui.vbm.Resource.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * Value of the resource. Base64 endode binary.
				 */
				value: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * URL to an image. It is important that the image data is readable fom the visual business control. Therefore e.g. images coming from
				 * a local drive or cross domains are not allowed. The preferred way is to use the Base64 encoded data provided using the value
				 * property.
				 */
				src: {
					type: "string",
					group: "Misc",
					defaultValue: ""
				},

				/**
				 * Name of the resource. The name should be always used when a resource is referenced.
				 */
				name: {
					type: "string",
					group: "Misc",
					defaultValue: null
				}
			}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.Resource.prototype.init = function(){
	// // do something for initialization...
	// };

	return Resource;

});

}; // end of sap/ui/vbm/Resource.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.VoAbstract') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.VoAbstract.
jQuery.sap.declare('sap.ui.vbm.VoAbstract'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained
sap.ui.define("sap/ui/vbm/VoAbstract",[
	'sap/ui/core/Element', './library'
], function(Element, library) {
	"use strict";

	/**
	 * Constructor for a new VoAbstract.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Abstract VO aggregation container. This element implements the common part for VOs. It must not be used
	 *        directly, but is the base for further extension.
	 * @extends sap.ui.core.Element
	 * @abstract
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.VoAbstract
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var VoAbstract = Element.extend("sap.ui.vbm.VoAbstract", /** @lends sap.ui.vbm.VoAbstract.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

			},
			events: {}
		}
	});

// // /**
// // * This file defines behavior for the control,
// // */
// VoAbstract.prototype.init = function() {
// // do something for initialization...
// this.BindingDiff = [];
// };

	VoAbstract.prototype.isEventRegistered = function(name) {
		var aVO = this.getItems();
		if (!aVO) {
			return false;
		}

		for (var nJ = 0, len = aVO.length; nJ < len; ++nJ) {
			// get the control.....................................................//
			var oInstance = aVO[nJ];

			// if one registers for an event we can return........................//
			if (oInstance.mEventRegistry[name]) {
				return true;
			}
		}

		return false;
	};

	VoAbstract.prototype.findInstance = function(name) {
		var aVO = this.getItems();
		if (!aVO) {
			return false;
		}

		// name maybe <aggr>.<elem> or just <elem>
		var key = (name.indexOf(".") !== -1) ? name.split(".")[1] : name;
		for (var nJ = 0, len = aVO.length; nJ < len; ++nJ) {
			// get the control.....................................................//
			if (aVO[nJ].sId === key) {
				return aVO[nJ];
			}
		}

		return null;
	};

	VoAbstract.prototype.findInstanceByKey = function(name) {
		var aVO = this.getItems();
		if (!aVO) {
			return false;
		}

		// name maybe <aggr>.<elem> or just <elem>
		var key = (name.indexOf(".") !== -1) ? name.split(".")[1] : name;
		for (var nJ = 0, len = aVO.length; nJ < len; ++nJ) {
			// get the control.....................................................//
			if (aVO[nJ].sId === key || aVO[nJ].getKey() === key) {
				return aVO[nJ];
			}
		}

		return null;
	};

	VoAbstract.prototype.getActionArray = function() {
		// var id = this.getId();
		var aActions = [];

		return aActions;
	};

	VoAbstract.prototype.getTemplateBindingInfo = function() {
		// read binding info to check what is bound and what is static
		var oBindingInfo = this.getBindingInfo("items");
		if (oBindingInfo && oBindingInfo.template) {
			return oBindingInfo.template.mBindingInfos;
		}
	};

	VoAbstract.prototype.getBindInfo = function() {
		var oBindInfo = {};
		var oTemplateBindingInfo = this.getTemplateBindingInfo();

		oBindInfo.hasTemplate = (oTemplateBindingInfo) ? true : false;

		return oBindInfo;
	};

	// base implementation for object handling corresponding to VoBase
	VoAbstract.prototype.getTemplateObject = function() {
		var oTemp = {};
		oTemp['id'] = this.getId();

		// the data source name is equivalent to the controls id..................//
		oTemp['datasource'] = oTemp.id;

		return oTemp;
	};

	VoAbstract.prototype.getTypeObject = function() {
		var oType = {};

		// set the id.............................................................//
		oType['name'] = this.getId();

		oType['key'] = 'K';

		// extend the object type.................................................//
		oType.A = [
			{
				"name": "K", // key
				"alias": "K",
				"type": "string"
			}, {
				"name": "VB:s", // selection flag
				"alias": "VB:s",
				"type": "boolean"
			}
		];

		return oType;
	};

	VoAbstract.prototype.getDataDeltaObject = function(oDiff) {
		var oData = {};
		var aRemoveData = [];

		var aItems = this.getItems();
		oData['name'] = this.getId();
		oData.E = [];

		for (var nK = 0; nK < oDiff.length; ++nK) {
			if (oDiff[nK].type == "delete") {
				aRemoveData.push(oDiff[nK].object);
			} else if (oDiff[nK].type == "insert") {
				var i = oDiff[nK].idx;
				oData.E.push(aItems[i].getDataElement());
			}
		}
		return {
			oData: oData,
			aRemoveData: aRemoveData
		};
	};

	VoAbstract.prototype.getDataRemoveObject = function() {
		var oData = {
			name: this.getId(),
			type: "N"
		};
		return oData;
	};

	VoAbstract.prototype.getDataObject = function() {
		var oData = {};

		// set the id of the table................................................//
		oData['name'] = this.getId();
		oData.E = [];

		var aVO = this.getItems();
		for (var nJ = 0, len = aVO.length; nJ < len; ++nJ) {
			oData.E.push(aVO[nJ].getDataElement());
		}

		return oData;
	};

	/**
	 * Open a context menu
	 * 
	 * @param {string} sType Type of VO
	 * @param {sap.ui.vbm.VoBase} oVoInst VO instance for which the Context Menu should be opened
	 * @param {sap.ui.unified.Menu} oMenu the context menu to be opened
	 * @returns {void}
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	VoAbstract.prototype.openContextMenu = function(sType, oVoInst, oMenu) {
		this.oParent.openContextMenu(sType, oVoInst, oMenu);
	};

	return VoAbstract;

});

}; // end of sap/ui/vbm/VoAbstract.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.VoAggregation') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.VoAggregation.
jQuery.sap.declare('sap.ui.vbm.VoAggregation'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/VoAggregation",[
	'./VoAbstract', './library'
], function(VoAbstract, library) {
	"use strict";

	/**
	 * Constructor for a new VoAggregation.
	 *
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Abstract VO aggregation container. This element implements the common part for all specific VO aggregations with selection
	 *        cardinatities. It must not be used directly, but is the base for further extension.
	 * @extends sap.ui.vbm.VoAbstract
	 * @abstract
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.VoAggregation
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var VoAggregation = VoAbstract.extend("sap.ui.vbm.VoAggregation", /** @lends sap.ui.vbm.VoAggregation.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * Selection cardinality: minimum selected elements ("0" or "1" )
				 */
				minSel: {
					type: "string",
					group: "Misc",
					defaultValue: "0"
				},

				/**
				 * Selection cardinality: maximum selectable elements ( valid values are "0", "1", and "n" )
				 */
				maxSel: {
					type: "string",
					group: "Misc",
					defaultValue: "n"
				},

				/**
				 * If you want to add custom data to VO instances and make the GeoMap control aware of it, e.g. for basing clustering rules on it, you
				 * can provide an array of property names specifying the keys to consider.
				 */
				customProperties: {
					type: "string[]",
					group: "Misc"
				}
			},
			events: {

				/**
				 * This event is raised when a Design handle is moved.
				 */
				handleMoved: {
					parameters: {

						/**
						 * Clicked instance
						 */
						instance: {
							type: "sap.ui.vbm.VoBase"
						},
						/**
						 * The number of the handle where the click occured. Handles are numbered zero based.
						 */
						handle: {
							type: "int"
						}
					}
				},

				/**
				 * This event is raised when a Design handle is right clicked.
				 */
				handleContextMenu: {
					parameters: {

						/**
						 * Clicked instance
						 */
						instance: {
							type: "sap.ui.vbm.VoBase"
						},
						/**
						 * Menu to open
						 */
						menu: {
							type: "sap.ui.unified.Menu"
						},
						/**
						 * The number of the handle where the click occured. Handles are numbered zero based.
						 */
						handle: {
							type: "int"
						}
					}
				},

				/**
				 * This event is raised when a Design handle is clicked.
				 */
				handleClick: {
					parameters: {

						/**
						 * Clicked instance
						 */
						instance: {
							type: "sap.ui.vbm.VoBase"
						},
						/**
						 * The number of the handle where the click occured. Handles are numbered zero based.
						 */
						handle: {
							type: "int"
						}
					}
				},

				/**
				 * This event is raised when aggregated elements get selected
				 */
				select: {
					parameters: {

						/**
						 * Array of selected VOs
						 */
						selected: {
							type: "array"
						}
					}
				},

				/**
				 * This event is raised when aggregated elements get deselected
				 */
				deselect: {
					parameters: {

						/**
						 * Array of deselected VOs
						 */
						deselected: {
							type: "array"
						}
					}
				},
				/**
				 * The event is raised when there is a click action on a VO.
				 */
				click: {
					parameters: {

						/**
						 * Clicked instance
						 */
						instance: {
							type: "sap.ui.vbm.VoBase"
						}
					}
				},

				/**
				 * The event is raised when there is a right click or a tap and hold action on a VO.
				 */
				contextMenu: {
					parameters: {

						/**
						 * Clicked instance
						 */
						instance: {
							type: "sap.ui.vbm.VoBase"
						},
						/**
						 * Menu to open
						 */
						menu: {
							type: "sap.ui.unified.Menu"
						}
					}
				},

				/**
				 * The event is raised when something is dropped on a VO.
				 */
				drop: {
					parameters: {

						/**
						 * Drop target instance
						 */
						instance: {
							type: "sap.ui.vbm.Spot"
						},
						/**
						 * Dragged instance
						 */
						dragSource: {
							type: "sap.ui.vbm.VoBase"
						}
					}
				}

			}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	VoAggregation.prototype.init = function() {
		// do something for initialization...
		this.aDiff = [];
		this.aUniqueIdx = [];
		this.currentIdx = 1000;
		this.setProperty("customProperties", [], /* bSuppressInvalidate= */true);
		this.bUseExtendedChangeDetection = true;
	};

	VoAggregation.prototype.handleSelectEvent = function(aEl) {

		var aSelect = [];
		var aDeselect = [];
		for (var nK = 0; nK < aEl.length; ++nK) {
			var oEl = aEl[nK];
			var aVO = this.getItems();
			if (aVO) {
				for (var nL = 0, len = aVO.length; nL < len; ++nL) {
					if (aVO[nL].UniqueId == oEl.K) {
						var bEleSel = (oEl["VB:s"] == "true" ? true : false);
						var bModelSel = aVO[nL].getSelect();
						if (bEleSel != bModelSel) {
							if (bEleSel) {
								// to be selected
								aVO[nL].setSelect(true); // set model selection property
								if (this.mEventRegistry["select"]) {
									aSelect.push(aVO[nL]); // add element to array to fire the select on aggregation
								}
							} else {
								// to be deselected
								aVO[nL].setSelect(false); // set model selection property
								if (this.mEventRegistry["deselect"]) {
									aDeselect.push(aVO[nL]); // add element to array to fire the deselect on aggregation
								}
							}
						}
					}
				}
			}
		}
		if (aDeselect.length) {
			this.fireDeselect({
				deselected: aDeselect
			});
		}
		if (aSelect.length) {
			this.fireSelect({
				selected: aSelect
			});
		}
	};

	VoAggregation.prototype.isEventRegistered = function(name) {
		var aVO = this.getItems();
		if (!aVO) {
			return false;
		}

		for (var nJ = 0, len = aVO.length; nJ < len; ++nJ) {
			// get the control.....................................................//
			var oInstance = aVO[nJ];

			// if one registers for an event we can return........................//
			if (oInstance.mEventRegistry[name]) {
				return true;
			}
		}

		return false;
	};

	VoAggregation.prototype.findSelected = function(select, data) {
		var aVO = this.getItems();
		if (!aVO) {
			return null;
		}
		var aSel = [];
		if (jQuery.type(data) == 'object') {
			if (data["VB:s"] == (select ? "true" : "false")) {
				for (var nI = 0; nI < aVO.length; ++nI) {
					// if (aVO[nI].sId == data["K"]) {
					if (aVO[nI].UniqueId == data["K"]) {
						aSel.push(aVO[nI]);
					}
				}

			}
		} else if (jQuery.type(data) == 'array') {
			for (var nJ = 0; nJ < data.length; ++nJ) {
				if (data[nJ]["VB:s"] == (select ? "true" : "false")) {
					for (var nK = 0; nK < aVO.length; ++nK) {
						// if (aVO[nK].sId == data[nJ]["K"]) {
						if (aVO[nK].UniqueId == data[nJ]["K"]) {
							aSel.push(aVO[nK]);
						}
					}
				}
			}
		}
		return aSel;
	};

	VoAggregation.prototype.findInstance = function(name) {
		var aVO = this.getItems();
		if (!aVO) {
			return false;
		}

		// name maybe <aggr>.<elem> or just <elem>
		var key = (name.indexOf(".") !== -1) ? name.split(".")[1] : name;
		for (var nJ = 0, len = this.aUniqueIdx.length; nJ < len; ++nJ) {
			// get the control.....................................................//
			if (this.aUniqueIdx[nJ] === key) {
				return aVO[nJ];
			}
		}

		return null;
	};

	VoAggregation.prototype.findInstanceByKey = function(name) {
		var aVO = this.getItems();
		if (!aVO) {
			return false;
		}

		// name maybe <aggr>.<elem> or just <elem>
		var key = (name.indexOf(".") !== -1) ? name.split(".")[1] : name;
		for (var nJ = 0, len = aVO.length; nJ < len; ++nJ) {
			// get the control.....................................................//
			if (aVO[nJ].sId === key || aVO[nJ].getKey() === key) {
				return aVO[nJ];
			}
		}

		return null;
	};

	VoAggregation.prototype.getActionArray = function() {
		var id = this.getId();
		var aActions = [];

		if (this.mEventRegistry["handleMoved"] || this.isEventRegistered("handleMoved")) {
			aActions.push({
				"id": id + "4",
				"name": "handleMoved",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "HandleMoved"
			});
		}
		if (this.mEventRegistry["handleContextMenu"] || this.isEventRegistered("handleContextMenu")) {
			aActions.push({
				"id": id + "5",
				"name": "handleContextMenu",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "HandleContextMenu"
			});
		}
		if (this.mEventRegistry["handleClick"] || this.isEventRegistered("handleClick")) {
			aActions.push({
				"id": id + "6",
				"name": "handleClick",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "HandleClick"
			});
		}
		// check whether the select/deselect events are subscribed or the select property is part of the template
		// Note: Without template binding all aggregated instances would need to be checked use of select property -> this is not yet done and thus
		// event subscription is needed!
		var oTemplateBindingInfo;
		var bSelectPropertyIsBound = ((oTemplateBindingInfo = this.getTemplateBindingInfo())) ? oTemplateBindingInfo.hasOwnProperty("select") : false;
		if ((this.mEventRegistry["select"] || this.mEventRegistry["deselect"] || bSelectPropertyIsBound) && !this.isEventRegistered("click")) {
			aActions.push({
				"id": id + "9",
				"name": "click",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "Click"
			});
		}

		return aActions;
	};

	VoAggregation.prototype.getBindInfo = function() {
		var oBindInfo = VoAbstract.prototype.getBindInfo.apply(this, arguments);
		var oTemplateBindingInfo = this.getTemplateBindingInfo();

		// Note: Without Template no static properties -> all bound in the sense of VB JSON!
		oBindInfo.HS = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("hotScale") : true;
		oBindInfo.HDC = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("hotDeltaColor") : true;
		oBindInfo.SC = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("selectColor") : true;
		oBindInfo.FS = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("fxsize") : true;
		oBindInfo.FD = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("fxdir") : true;
		oBindInfo.ET = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("entity") : true;
		oBindInfo.LT = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("labelText") : true;
		oBindInfo.LBC = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("labelBgColor") : true;
		oBindInfo.LBBC = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("labelBorderColor") : true;
		oBindInfo.AR = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("labelArrow") : true;
		oBindInfo.LP = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("labelPos") : true;
		oBindInfo.TT = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("tooltip") : true;
		oBindInfo.DD = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("dragData") : true;
		oBindInfo.M = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("changeable") : true;

		oBindInfo.DS = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("dragSource") : true;
		oBindInfo.DT = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("dropTarget") : true;

		oBindInfo.LabelType = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("labelType") : true;

		return oBindInfo;
	};

	// base implementation for object handling corresponding to VoBase
	VoAggregation.prototype.getTemplateObject = function() {
		// get common template from parent class (VoAggregation)
		var oTemp = VoAbstract.prototype.getTemplateObject.apply(this, arguments);

		var oBindInfo = this.mBindInfo = this.getBindInfo();
		var oVoTemplate = (oBindInfo.hasTemplate) ? this.getBindingInfo("items").template : null;

		this.bHasType = oBindInfo.LabelType || (oVoTemplate.mProperties["labelType"] !== sap.ui.vbm.SemanticType.None);

		// add base properties....................................................//
		if (oBindInfo.HS) {
			oTemp['hotScale.bind'] = oTemp.id + ".HS";
		} else {
			oTemp.hotScale = oVoTemplate.getHotScale();
		}
		if (oBindInfo.HDC) {
			oTemp['hotDeltaColor.bind'] = oTemp.id + ".HDC";
		} else {
			oTemp.hotDeltaColor = oVoTemplate.getHotDeltaColor();
		}
		if (oBindInfo.SC) {
			oTemp['selectColor.bind'] = oTemp.id + ".SC";
		} else {
			oTemp.selectColor = oVoTemplate.getSelectColor();
		}
		if (oBindInfo.FS) {
			oTemp['fxsize.bind'] = oTemp.id + ".FS";
		} else {
			oTemp.fxsize = oVoTemplate.getFxsize();
		}
		if (oBindInfo.FD) {
			oTemp['fxdir.bind'] = oTemp.id + ".FD";
		} else {
			oTemp.fxdir = oVoTemplate.getFxdir();
		}
		if (oBindInfo.ET) {
			oTemp['entity.bind'] = oTemp.id + ".ET";
		} else {
			oTemp.entity = oVoTemplate.getEntity();
		}
		if (oBindInfo.LT) {
			oTemp['labelText.bind'] = oTemp.id + ".LT";
		} else {
			oTemp.labelText = oVoTemplate.getLabelText();
		}
		if (this.bHasType) {
			oTemp['labelIcon.bind'] = oTemp.id + ".LIC";
			oTemp['labelIconBgrdCol.bind'] = oTemp.id + ".LICC";
			oTemp['labelIconTextCol.bind'] = oTemp.id + ".LICTC";
			oTemp['labelBgColor.bind'] = oTemp.id + ".LBC";
			oTemp['labelBorderColor.bind'] = oTemp.id + ".LBBC";
		} else {
			if (oBindInfo.LBC) {
				oTemp['labelBgColor.bind'] = oTemp.id + ".LBC";
			} else {
				oTemp.labelBgColor = oVoTemplate.getLabelBgColor();
			}
			if (oBindInfo.LBBC) {
				oTemp['labelBorderColor.bind'] = oTemp.id + ".LBBC";
			} else {
				oTemp.labelBorderColor = oVoTemplate.getLabelBorderColor();
			}
		}
		if (oBindInfo.AR) {
			oTemp['labelArrow.bind'] = oTemp.id + ".AR";
		} else {
			oTemp.labelArrow = oVoTemplate.getLabelArrow();
		}
		if (oBindInfo.LP) {
			oTemp['labelPos.bind'] = oTemp.id + ".LP";
		} else {
			oTemp.labelPos = oVoTemplate.getLabelPos();
		}
		if (oBindInfo.TT) {
			oTemp['tooltip.bind'] = oTemp.id + ".TT";
		} else {
			oTemp.tooltip = oVoTemplate.getTooltip();
		}
		if (oBindInfo.DD) {
			oTemp['dragdata.bind'] = oTemp.id + ".DD";
		} else {
			oTemp.dragdata = oVoTemplate.getDragData();
		}
		// oTemp['select.bind'] = oTemp.id + ".VB:s"; //selection is build in and always bound
		if (!oBindInfo.M) {
			oTemp['VB:c'] = oVoTemplate.getChangeable();
		}

		// set default alternative border color
		oTemp.altBorderDeltaColor = '#676767';

		return oTemp;
	};

	VoAggregation.prototype.getTypeObject = function() {
		var oType = VoAbstract.prototype.getTypeObject.apply(this, arguments);

		var sMinSel = this.getMinSel();
		if (sMinSel != "0" && sMinSel != "1") {
			sMinSel = "0";
		}
		var sMaxSel = this.getMaxSel();
		if (sMaxSel != "0" && sMaxSel != "1" && sMaxSel != "n" || sMaxSel == "n") {
			sMaxSel = "-1";
		}

		oType['minSel'] = sMinSel;
		oType['maxSel'] = sMaxSel;

		var oBindInfo = this.mBindInfo;

		if (oBindInfo.HS) {
			oType.A.push({
				"name": "HS", // hot scale
				"alias": "HS",
				"type": "vector"
			});
		}
		if (oBindInfo.HDC) {
			oType.A.push({
				"name": "HDC", // hot delta color
				"alias": "HDC",
				"type": "string"
			});
		}
		if (oBindInfo.SC) {
			oType.A.push({
				"name": "SC", // select color
				"alias": "SC",
				"type": "string"
			});
		}
		if (oBindInfo.FS) {
			oType.A.push({
				"name": "FS", // fix size
				"alias": "FS",
				"type": "boolean"
			});
		}
		if (oBindInfo.ET) {
			oType.A.push({
				"name": "ET", // entity
				"alias": "ET",
				"type": "string"
			});
		}
		if (oBindInfo.LT) {
			oType.A.push({
				"name": "LT", // label text
				"alias": "LT",
				"type": "string"
			});
		}
		if (this.bHasType) {
			oType.A.push({
				"name": "LBC", // label background color
				"alias": "LBC",
				"type": "color"
			});
			oType.A.push({
				"name": "LBBC", // label background border color
				"alias": "LBBC",
				"type": "color"
			});
			oType.A.push({
				"name": "LIC", // typed label's icon
				"alias": "LIC",
				"type": "string"
			});
			oType.A.push({
				"name": "LICC", // typed label's icon color
				"alias": "LICC",
				"type": "color"
			});
			oType.A.push({
				"name": "LICTC", // typed label's icon text color
				"alias": "LICTC",
				"type": "color"
			});
		} else {
			if (oBindInfo.LBC) {
				oType.A.push({
					"name": "LBC", // label background color
					"alias": "LBC",
					"type": "color"
				});
			}
			if (oBindInfo.LBBC) {
				oType.A.push({
					"name": "LBBC", // label background border color
					"alias": "LBBC",
					"type": "color"
				});
			}
		}
		if (oBindInfo.AR) {
			oType.A.push({
				"name": "AR", // label arrow
				"alias": "AR",
				"type": "boolean"
			});
		}
		if (oBindInfo.LIC) {
			oType.A.push({
				"name": "LIC", // label icon name
				"alias": "LIC",
				"type": "string"
			});
		}
		if (oBindInfo.LP) {
			oType.A.push({
				"name": "LP", // label position
				"alias": "LP",
				"type": "long"
			});
		}
		if (oBindInfo.TT) {
			oType.A.push({
				"name": "TT", // tooltip
				"alias": "TT",
				"type": "string"
			});
		}
		if (oBindInfo.DD) {
			oType.A.push({
				"name": "DD", // dragdata
				"alias": "DD",
				"type": "string"
			});
		}
		if (oBindInfo.DS || oBindInfo.DT) {
			oType.N = [];
			if (oBindInfo.DS) {
				oType.N.push({
					"name": "DS", // DragSource
					"A": {
						"name": "DGT", // DragType
						"alias": "A",
						"type": "string"
					}
				});
			}
			if (oBindInfo.DT) {
				oType.N.push({
					"name": "DT", // DropTarget
					"A": {
						"name": "DPT", // DropType
						"alias": "A",
						"type": "string"
					}
				});
			}
		}

		// custom properties
		var aProperties = this.getCustomProperties();
		for (var i = 0; i < aProperties.length; ++i) {
			oType.A.push({
				"name": aProperties[i],
				"alias": aProperties[i],
				"type": "string"
			});
		}

		return oType;
	};

	VoAggregation.prototype.getDragItemTemplate = function(id) {
		// DragSource of aggregation
		var oBindInfo = this.mBindInfo;
		var aDragSource = this.getDragSource();
		var aDragItem = [];
		for (var nJ = 0, len = aDragSource.length; nJ < len; ++nJ) {
			aDragItem.push({
				"type": aDragSource[nJ].getType()
			});
		}
		if (oBindInfo.DS) {
			aDragItem.push({
				"datasource": id + ".DS",
				"type.bind": id + ".DS.DGT"
			});
		}
		return aDragItem;
	};

	VoAggregation.prototype.getDropItemTemplate = function(id) {
		// DropTarget of aggregation
		var oBindInfo = this.mBindInfo;
		var aDropTarget = this.getDropTarget();
		var aDropItem = [];
		for (var nJ = 0, len = aDropTarget.length; nJ < len; ++nJ) {
			aDropItem.push({
				"type": aDropTarget[nJ].getType()
			});
		}
		if (oBindInfo.DT) {
			aDropItem.push({
				"datasource": id + ".DT",
				"type.bind": id + ".DT.DPT"
			});
		}
		return aDropItem;
	};

	/**
	 * Open a Detail Window
	 *
	 * @param {sap.ui.vbm.VoBase} oVoInst VO instance for which the Detail Window should be opened
	 * @param {object} oParams Parameter object
	 * @param {string} oParams.caption Text for Detail Window caption
	 * @param {string} oParams.offsetX position offset in x-direction from the anchor point
	 * @param {string} oParams.offsetY position offset in y-direction from the anchor point
	 * @param {boolean} bUseClickPos Indicates whether the Detail Window should be located at the click position or object position
	 * @returns {void}
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	VoAggregation.prototype.openDetailWindow = function(oVoInst, oParams, bUseClickPos) {
		var oParent = this.getParent();
		oParent.mDTWindowCxt.bUseClickPos = bUseClickPos;
		oParent.mDTWindowCxt.open = true;
		oParent.mDTWindowCxt.src = oVoInst;
		oParent.mDTWindowCxt.key = oVoInst.getKey();
		oParent.mDTWindowCxt.params = oParams;
		oParent.m_bWindowsDirty = true;
		oParent.invalidate(this);
	};

	VoAggregation.prototype.handleChangedData = function(aElements) {
		if (aElements && aElements.length) {
			for (var nI = 0, oElement, oInst; nI < aElements.length; ++nI) {
				oElement = aElements[nI];
				oInst = this.findInstance(oElement.K);
				if (oInst) {
					oInst.handleChangedData(oElement);
				}
			}
		}
	};

	VoAggregation.prototype.handleEvent = function(event) {
		var sName = event.Action.name;

		var funcname = "fire" + sName[0].toUpperCase() + sName.slice(1);

		// first we try to get the event on a vo instance......................//
		var oVo;
		if ((oVo = this.findInstance(event.Action.instance))) {
			var eventContext = {
				data: event
			};
			if (sName.indexOf("handle") === 0) { // Event name starts with "handle"
				eventContext.handle = event.Action.Params.Param[2]['#'];
			}
			switch (sName) {
				case "click":
					if (event.Action.AddActionProperties && event.Action.AddActionProperties.AddActionProperty.length && event.Action.AddActionProperties.AddActionProperty[0].name == 'pos') {
						oVo.mClickGeoPos = event.Action.AddActionProperties.AddActionProperty[0]['#'];
					}
					break;
				case "contextMenu":
				case "handleContextMenu":
					// store screen coordinates where the menu should open
					oVo.mClickPos = [
						event.Action.Params.Param[0]['#'], event.Action.Params.Param[1]['#']
					];

					// lazy load sap.ui.unified library for using the Menu
					sap.ui.getCore().loadLibrary("sap.ui.unified");

					if (this.oParent.mVBIContext.m_Menus) {
						this.oParent.mVBIContext.m_Menus.deleteMenu("DynContextMenu");
					}
					// create an empty menu
					var oMenuObject = new sap.ui.unified.Menu();
					oMenuObject.vbi_data = {};
					oMenuObject.vbi_data.menuRef = "CTM";
					oMenuObject.vbi_data.VBIName = "DynContextMenu";

					eventContext.menu = oMenuObject;
					break;
				case "drop":
					var src = event.Action.Params.Param[0]['#'].split("|");
					var aggr = src[1];
					var inst = src[2].split(".")[1];
					var oDragSource = this.getParent().getAggregatorContainer(aggr).findInstanceByKey(inst);
					eventContext.oDragSource = oDragSource;
					break;
				default:
					break;

			}
			if (oVo.mEventRegistry[sName]) {
				if (funcname in oVo) {
					oVo[funcname](eventContext);
				} else {
					oVo.fireEvent(sName, eventContext);
				}
			}
			if (this.mEventRegistry[sName]) {
				eventContext.instance = oVo;
				this[funcname](eventContext);
			}
		} else {
			jQuery.sap.log.error("Instance for event not found");
		}

	};

	VoAggregation.prototype.getChangeType = function(diff) {
		var del = 0;
		var ins = 0;
		var chg = 0;
		var length = this.getItems().length;
		var a = [];
		var nK, nJ;
		for (nK = 0; nK < length; ++nK) {
			a.push(2);
		}
		var cA, cV, bFound;
		for (nJ = 0; nJ < diff.length; ++nJ) {
			if (diff[nJ].type == "delete") {
				bFound = false;
				cV = 0;
				cA = 0;
				while (!bFound) {
					if (cV == diff[nJ].index && a[cA] != 0) {
						a[cA] = 0;
						del++;
						break;
					} else if (a[cA] != 0) {
						cV++;
					}
					cA++;
				}
			} else if (diff[nJ].type == "insert") {
				if (diff[nJ].index >= length) {
					ins++;
				} else {
					bFound = false;
					cV = 0;
					cA = 0;
					while (!bFound) {
						if (cV == diff[nJ].index && a[cA] == 0) {
							a[cA] = 2;
							chg++;
							break;
						} else if (a[cA] != 0) {
							cV++;
						}
						cA++;
					}
				}
			}
		}
		if (diff.length && chg == del && del == diff.length / 2) {
			return 1; // update
		}
		if (del == diff.length) {
			return 2; // delete
		}
		if (ins == diff.length) {
			return 3; // add to the end
		}

		return 0;
	};

	VoAggregation.prototype.unbindAggregation = function(name) {
		if (name === "items") {
			this.m_bAggRenew = true;
		}
		VoAbstract.prototype.unbindAggregation.apply(this, arguments);
	};

	VoAggregation.prototype.updateAggregation = function(sName) {
		var oBindingInfo = this.mBindingInfos['items'],
		    oBinding = oBindingInfo && oBindingInfo.binding || null;

		VoAbstract.prototype.updateAggregation.apply(this, arguments);

		if (sName === "items" && oBinding) {
			var aVO = this.getItems();
			var sId = this.sId;
			var K = "0";
			var aContexts = oBinding.getCurrentContexts();
			// var aContexts = oBinding.getContexts();
			if (aContexts.diff && !this.m_bAggChange && !this.m_bAggRenew) {
				var changeType = this.getChangeType(aContexts.diff);
				if (changeType == 2) {
					// elements to remove
					for (var nK = 0; nK < aContexts.diff.length; ++nK) {
						var idx = aContexts.diff[nK].index;
						K = this.aUniqueIdx[idx];
						var E = {
							K: K
						};
						var N = {
							name: sId,
							E: E
						};
						var o = {
							name: sId,
							type: "E",
							N: N
						};
						this.aDiff.push({
							type: "delete",
							object: o
						});
						this.aUniqueIdx.splice(idx, 1);
						for (var nJ = 0; nJ < aVO.length - 1; ++nJ) {
							aVO[nJ].UniqueId = this.aUniqueIdx[nJ];
						}
					}
					this.m_bAggChange = true;
				} else if (changeType == 3 || changeType == 1) {
					// elements to be added to the end or updated
					for (var nL = 0; nL < aContexts.diff.length; ++nL) {
						if (aContexts.diff[nL].type == "insert") {
							this.aDiff.push({
								type: "insert",
								idx: aContexts.diff[nL].index
							});
						}
					}
					this.m_bAggChange = true;
				} else {
					this.m_bAggRenew = true;
				}
			}
		}

	};

	VoAggregation.prototype.invalidate = function(oSource) {
		var idx;
		if (!this.m_bAggRenew) {
			this.m_bAggRenew = true;
			if (oSource && this.getParent()) {
				idx = this.aUniqueIdx.indexOf(oSource.UniqueId);
				if (idx > -1) {
					var bFound = false;
					for (var nJ = 0; nJ < this.aDiff.length && !bFound; ++nJ) {
						if (this.aDiff[nJ].type == "insert" && this.aDiff[nJ].idx == idx) {
							bFound = true;
						}
					}
					if (!bFound) {
						this.aDiff.push({
							type: "insert",
							idx: idx
						});
					}
					this.m_bAggChange = true;
					this.m_bAggRenew = false;
				}
			}
		}
		sap.ui.core.Control.prototype.invalidate.apply(this, arguments);
	};

	VoAggregation.prototype.resetIndices = function() {
		var aVO = this.getItems();
		for (var nK = 0; nK < aVO.length; ++nK) {
			aVO[nK].UniqueId = undefined;
		}
	};

	VoAggregation.prototype.getUniqueIdx = function() {
		return (this.currentIdx++);
	};

	VoAggregation.prototype.updateIdxArray = function() {
		this.aUniqueIdx = [];
		var aVO = this.getItems();
		for (var nK = 0; nK < aVO.length; ++nK) {
			this.aUniqueIdx.push(aVO[nK].UniqueId);
		}
	};

	VoAggregation.prototype.addUnique = function(UniqueId) {
		this.aUniqueIdx.push(UniqueId);
	};

	VoAggregation.prototype.setCustomProperties = function(aProperties) {
		this._oCPMap = null;
		return this.setProperty("customProperties", aProperties);
	};

	VoAggregation.prototype.getCustomPropertiesMap = function() {
		if (!this._oCPMap) {
			this._oCPMap = {};
			var aProperties = this.getCustomProperties();
			for (var i = 0; i < aProperties.length; ++i) {
				this._oCPMap[aProperties[i]] = true;
			}
		}
		return this._oCPMap;
	};

	return VoAggregation;

});

}; // end of sap/ui/vbm/VoAggregation.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.VoBase') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.VoBase.
jQuery.sap.declare('sap.ui.vbm.VoBase'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.core.theming.Parameters'); // unlisted dependency retained
jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained
sap.ui.define("sap/ui/vbm/VoBase",[
	'sap/ui/core/theming/Parameters', 'sap/ui/core/Element', './library'
], function(Parameters, Element, library) {
	"use strict";

	/**
	 * Constructor for a new VoBase.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Abstract aggregation element for VO aggregations. This element implements the common part for all specific VO elements. It must not be
	 *        used directly, but is the base for further extension.<br>
	 *        As a common feature it provides the Label, which may be attached to any visual object. There are two modes for using labels:
	 *        <ul>
	 *        <li>A controlled mode by providing a label type. In this mode most parameters for the label are automatically set by programmed
	 *        defaults according to the Fiori guidelines.</li>
	 *        <li>A freestyle mode, providing the full control on colors and layout.</li>
	 *        </ul>
	 *        Further all visual objects have common edit capabilities and it is possible to drop content on visual objects.
	 * @extends sap.ui.core.Element
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.VoBase
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var VoBase = Element.extend("sap.ui.vbm.VoBase", /** @lends sap.ui.vbm.VoBase.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {
				/**
				 * Unique identifier for the object. This is optional. If not provided the default identifier sId is used. However, sId is generated
				 * if template binding is used and thus it is not stable. Provide the key if the object really needs to have a unique and stable
				 * identifier.
				 */
				key: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * Scaling factor applied when visual object is hovered. This is only supported on selected VOs, which do not present a defined geo
				 * area.
				 */
				hotScale: {
					type: "string",
					group: "Misc",
					defaultValue: '1.0;1.0;1.0'
				},

				/**
				 * Color change applied when visual object is hovered. The format is
				 * RHLSA(&lt;hue&gt;;&lt;lightness&gt;;&lt;saturation&gt;;&lt;opacity&gt;). The hue shift is given in degree (0 to 360). The other
				 * parameters are given as multipliers, where 1 means the component remains unchanged.<br>
				 * Beside the delta color approach it is also possible to specify an absolute color in the usual CSS color formats (except named
				 * colors).
				 */
				hotDeltaColor: {
					type: "string",
					group: "Misc",
					defaultValue: 'RHLSA(0;1.3;1.0;1.0)'
				},

				/**
				 * Color change applied when visual object is selected. This can be explicit or a relative one. See above.
				 */
				selectColor: {
					type: "string",
					group: "Misc",
					defaultValue: 'RHLSA(0.0;1.0;1.0;1.0)'
				},

				/**
				 * The visual object should keep its size when the map is zoomed. Default value is 'true'. Only meaningful for some VOs.
				 */
				fxsize: {
					type: "string",
					group: "Misc",
					defaultValue: 'true'
				},

				/**
				 * The visual object is not rotated when the map is rotated. The property is only required when the PlugIn is used and only meaningful
				 * for some VOs.
				 */
				fxdir: {
					type: "string",
					group: "Misc",
					defaultValue: 'true'
				},

				/**
				 * The visual object builds an entity/group with other VO elements when it is hovered. The property is not supported when the PlugIn
				 * is used.
				 */
				entity: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * The visual objects label text. Providing a label text required, but also sufficient the get a label displayed.
				 */
				labelText: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * Type for semantic labels. A given semantic type will overrule color settings and add an icon.
				 */
				labelType: {
					type: "sap.ui.vbm.SemanticType",
					group: "Behavior",
					defaultValue: sap.ui.vbm.SemanticType.None
				},

				/**
				 * The visual objects label background color. The default value is white.
				 */
				labelBgColor: {
					type: "string",
					group: "Misc",
					defaultValue: 'RGB(255;255;255)'
				},

				/**
				 * The visual objects label border color. The default is no border.
				 */
				labelBorderColor: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * The visual objects label arrow. For left/right/top/bottom aligned labels an additional arrow points to the label's object.
				 */
				labelArrow: {
					type: "boolean",
					group: "Misc",
					defaultValue: false
				},

				/**
				 * The visual objects label position. This property determines the positioning of the label relative to the VO it belongs to.
				 * Possible values are:
				 * <ul>
				 * <li>0: centered</li>
				 * <li>1: top</li>
				 * <li>2: top right</li>
				 * <li>3: right</li>
				 * <li>4: bottom right</li>
				 * <li>5: bottom</li>
				 * <li>6: bottom left</li>
				 * <li>7: left</li>
				 * <li>8: top left</li>
				 * </ul>
				 * The default alignment is VO specific. <br>
				 * For multiple position based VOs, like Route, or Area the label is dynamically positioned. If the current display of a VO consists
				 * of multiple disconnected parts, each part gets an own label.
				 */
				labelPos: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * Set to true if VO is changeable. Which properties are actually changeable can be controlled on the related VO aggregation.
				 */
				changeable: {
					type: "boolean",
					group: "Misc",
					defaultValue: false
				},

				/**
				 * Data to be dragged. This property allows you to provide an arbitrary data string, which is transfered to the target in a drag'n
				 * drop operation
				 */
				dragData: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * Set to true if the element is selected
				 */
				select: {
					type: "boolean",
					group: "Misc",
					defaultValue: false
				}
			},
			events: {
				// Events are implemented in VoAggregation.js!

				/**
				 * The event is raised when there is a click action on a visual object.
				 */
				click: {},

				/**
				 * The event is raised when there is a right click or a tap and hold action on a visual object.
				 */
				contextMenu: {
					parameters: {

						/**
						 * Menu to open
						 */
						menu: {
							type: "sap.ui.unified.Menu"
						}
					}
				},

				/**
				 * This event is raised when the design handle is moved.
				 */
				handleMoved: {
					parameters: {
						/**
						 * The number of the handle where the click occured. Handles are numbered zero based.
						 */
						handle: {
							type: "int"
						}
					}
				},

				/**
				 * This event is raised when the design handle is right clicked.
				 */
				handleContextMenu: {
					parameters: {
						/**
						 * The number of the handle where the click occured. Handles are numbered zero based.
						 */
						handle: {
							type: "int"
						},
						/**
						 * Menu to open
						 */
						menu: {
							type: "sap.ui.unified.Menu"
						}
					}
				},

				/**
				 * This event is raised when the design handle is clicked.
				 */
				handleClick: {
					parameters: {
						/**
						 * The number of the handle where the click occured. Handles are numbered zero based.
						 */
						handle: {
							type: "int"
						}
					}
				},

				/**
				 * The event is raised when something is dropped on the object.
				 */
				drop: {
					parameters: {
						/**
						 * Dragged instance
						 */
						dragSource: {
							type: "sap.ui.vbm.VoBase"
						}
					}
				}
			}
		}
	});

	/**
	 * Open a Detail Window for the visual object at click position. The method relies on the state saved before firing event <i>click</i>.
	 * 
	 * @param {string} sCaption Caption of detail window
	 * @param {string} sOffsetX Position offset in x-direction from the anchor point
	 * @param {string} sOffsetY Position offset in y-direction from the anchor point
	 * @returns {void}
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	VoBase.prototype.openDetailWindow = function(sCaption, sOffsetX, sOffsetY) {
		this.oParent.openDetailWindow(this, {
			caption: sCaption,
			offsetX: sOffsetX,
			offsetY: sOffsetY
		}, false); // the default implementation uses position binding for the detail window
	};

	/**
	 * Open the context menu. The method relies on the state saved before firing event <i>contextMenu</i>. Further the object oMenu is expected to be
	 * the one given as parameter <i>menu</i> of event <i>contextMenu</i>.
	 * 
	 * @param {object} oMenu The context menu to be opened. The object is expected the have an attribute
	 * @returns {void}
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	VoBase.prototype.openContextMenu = function(oMenu) {
		// function is just modelled here and needs to be implemented in the extension
		jQuery.sap.log.warning("Implementation missing");
	};

	// /**
	// * This file defines behavior for the control,
	// */
	// VoBase.prototype.init = function() {
	// // do something for initialization...
	// };

	VoBase.prototype.DefaultColorBad = (Parameters) ? Parameters.get("sapUiChartBad") : "rgb(211, 32, 48)";
	VoBase.prototype.DefaultColorCritical = (Parameters) ? Parameters.get("sapUiChartCritical") : "rgb(225, 123, 36)";
	VoBase.prototype.DefaultColorGood = (Parameters) ? Parameters.get("sapUiChartGood") : "rgb(97, 166, 86)";
	VoBase.prototype.DefaultColorNeutral = (Parameters) ? Parameters.get("sapUiChartNeutral") : "rgb(132, 143, 148)";

	// VO Interface implementation ..............................................//

	VoBase.prototype.getDataElement = function() {
		// get the control.....................................................//
		var oElement = {};

		var type = this.getLabelType();

		var oBindInfo = this.oParent.mBindInfo;

		// add the key.........................................................//
		// oElement.K = this.getId(); // Use the Id as key here, since the Event dispatching relies on the structure of the Id!
		oElement.K = this.getUniqueId(); // Use the Id as key here, since the Event dispatching relies on the structure of the Id!

		// changeable...........................................................//
		if (oBindInfo.M) {
			oElement['VB:c'] = this.getChangeable();
		}

		// add the control object description..................................//
		if (oBindInfo.HS) {
			oElement.HS = this.getHotScale();
		}
		if (oBindInfo.HDC) {
			oElement.HDC = this.getHotDeltaColor();
		}
		if (oBindInfo.SC) {
			oElement.SC = this.getSelectColor();
		}
		if (oBindInfo.FS) {
			oElement.FS = this.getFxsize();
		}
		if (oBindInfo.FD) {
			oElement.FD = this.getFxdir();
		}
		if (oBindInfo.ET) {
			oElement.ET = this.getEntity();
		}
		if (type != sap.ui.vbm.SemanticType.Hidden) {
			if (oBindInfo.LT) {
				oElement.LT = this.getLabelText();
			}
			if (oBindInfo.LBC) {
				oElement.LBC = this.getLabelBgColor();
			}
			if (oBindInfo.LP) {
				oElement.LP = this.getLabelPos();
			}
			if (oBindInfo.LBBC) {
				oElement.LBBC = this.getLabelBorderColor();
			}
			if (oBindInfo.AR) {
				oElement.AR = this.getLabelArrow();
			}
		}
		if (oBindInfo.DD) {
			oElement.DD = this.getDragData();
		}
		oElement['VB:s'] = this.getSelect(); // always bound

		var tt = this.getTooltip();

		if (tt instanceof sap.ui.core.TooltipBase) {
			oElement.TT = "rtt#" + oElement.K; // send rtt#id and use RttMap[id] in sapscene.js
			sap.ui.vbm.VBI.RttMap[oElement.K] = tt;
		} else {
			oElement.TT = (tt) ? tt : "";
		}

		var oElem = this.getLabelProps(type);
		if (oElem && oElement.LT) {
			if (oElem.LBC) {
				oElement.LBC = oElem.LBC;
			}
			if (oElem.LBBC) {
				oElement.LBBC = oElem.LBBC;
			}
			if (oElem.LIC) {
				oElement.LIC = oElem.LIC;
			}
			if (oElem.LICC) {
				oElement.LICC = oElem.LICC;
			}
			if (oElem.LICTC) {
				oElement.LICTC = oElem.LICTC;
			}
		}
		if (!oElement.LBC) {
			oElement.LBC = "rgba(255,255,255,1.0)";
		}
		if (oElement.LBBC == "") {
			oElement.LBBC = oElement.LBC;
		}

		// add custom properties
		var aCustomData;
		if ((aCustomData = this.getCustomData())) {
			var oCPMap, oParent = this.getParent();
			if (oParent.getCustomPropertiesMap && (oCPMap = oParent.getCustomPropertiesMap())) {
				for (var i = 0; i < aCustomData.length; ++i) {
					var sKey = aCustomData[i].getKey();
					if (oCPMap[sKey]) {
						oElement[sKey] = aCustomData[i].getValue();
					}
				}
			}
		}

		return oElement;
	};

	VoBase.prototype.handleChangedData = function(oElement) {
		// default impl is empty, but makes interface function available for all VOs
	};

	// VO Base helper functions ..................................................//

	VoBase.prototype.getDragDropDefs = function() {

		var oBindInfo = this.oParent.mBindInfo;
		var aDragDrop = []; // array consisting of Drag and Drop attributes

		if (oBindInfo.DS) {
			// DragSource of VO instance
			var aDragSource = this.getDragSource(), sDS = [];

			// iterate over each DragSource
			for (var nJ = 0, lenDS = aDragSource.length; nJ < lenDS; ++nJ) {
				sDS.push({
					"VB:ix": nJ, // index
					"A": aDragSource[nJ].getType()
				// type
				});
			}
			if (sDS.length) {
				aDragDrop.push({
					"name": "DS",
					"E": sDS
				});
			}
		}

		if (oBindInfo.DT) {
			// DropTarget of VO instance
			var aDropTarget = this.getDropTarget(), sDT = [];

			// iterate over each DropTarget
			for (var nK = 0, lenDT = aDropTarget.length; nK < lenDT; ++nK) {
				sDT.push({
					"VB:ix": nK, // index
					"A": aDropTarget[nK].getType()
				// type
				});
			}
			if (sDT.length) {
				aDragDrop.push({
					"name": "DT",
					"E": sDT
				});
			}
		}
		return aDragDrop;
	};

	VoBase.prototype.getLabelProps = function(type) {
		var oElement = {};

		if (type == sap.ui.vbm.SemanticType.None || type == sap.ui.vbm.SemanticType.Default || type == sap.ui.vbm.SemanticType.Hidden) {
			return null;
		}

		oElement.LBC = oElement.LICTC = "rgba(255,255,255,1.0)";
		switch (type) {
			case sap.ui.vbm.SemanticType.Warning:
				oElement.LBBC = oElement.LICC = this.DefaultColorCritical;
				oElement.LIC = "message-warning";
				break;
			case sap.ui.vbm.SemanticType.Error:
				oElement.LBBC = oElement.LICC = this.DefaultColorBad;
				oElement.LIC = "message-error";
				break;
			case sap.ui.vbm.SemanticType.Success:
				oElement.LBBC = oElement.LICC = this.DefaultColorGood;
				oElement.LIC = "accept";
				break;
			case sap.ui.vbm.SemanticType.Inactive:
				oElement.LBBC = oElement.LICC = this.DefaultColorNeutral;
				oElement.LIC = "hint";
				break;
			default:
				break;
		}
		
		return oElement;
	};

	VoBase.prototype.getKey = function() {
		var sKey = this.getProperty("key");
		if (!sKey) {
			// Key not given -> return Id instead
			sKey = this.getUniqueId();
		}
		return sKey;
	};

	VoBase.prototype.invalidate = function() {
		sap.ui.core.Control.prototype.invalidate.apply(this, arguments);
	};

	VoBase.prototype.getUniqueId = function() {
		if (this.UniqueId == undefined || this.UniqueId == 0) {
			var id = this.getId();
			var newstr = id;
			var matches = id.match(/\d+/g);
			if (matches && matches.length) {
				newstr = id.substring(0, id.lastIndexOf(matches[matches.length - 1]));
			}
			this.UniqueId = newstr + this.getParent().getUniqueIdx();
		}
		return this.UniqueId;
	};

	return VoBase;

});

}; // end of sap/ui/vbm/VoBase.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.lib.sapvbi') ) {
  jQuery.sap.declare('sap.ui.vbm.lib.sapvbi');
// ...........................................................................//
// VBI namespace.............................................................//

// Author: Ulrich Roegelein

/* global VBI */// declare unusual global vars for JSLint/SAPUI5 validation
(function() {
	"use strict";
	// .......................................................................//
	// check if there is already a VBI object................................//
	// .......................................................................//

	var bInitialized = (typeof VBI == "object") || window.VBI;

	// return immediately when vbi is already initialized....................//
	if (bInitialized) {
		return;
	}
	// ........................................................................//
	// create the vbi object..................................................//

	window.VBI = {
		// Mobile devices .....................................................//
		m_bIsMyChromeTest: (/chrome/gi).test(navigator.appVersion),

		m_bIsIDevice: (/iphone|ipad/gi).test(navigator.appVersion),
		m_bIsAndroid: (/android/gi).test(navigator.appVersion),
		m_bIsMobile: (/iphone|ipad|android|BB|blackberry|playbook/gi).test(navigator.appVersion),
		m_bIsPhone: jQuery.device.is.phone,
		m_bIsRtl: (document.dir == "rtl") ? true : false,
		// m_bIsPhone : true,

		// global key state....................................................//
		m_ctrlKey: false,
		m_shiftKey: false,
		m_dwRefKeyboardHook: 0,

		// .....................................................................//
		// get the location service............................................//

		GetGeoLocationService: function() {
			if (this.GeoLocationService) {
				return this.GeoLocationService;
			}
			this.GeoLocationService = new VBI.GeoLocation();
			return this.GeoLocationService;
		},

		// .....................................................................//
		// publish subscribe container.........................................//

		Events: function() {
			var oCon = {};

			var hOP = oCon.hasOwnProperty;
			return {
				subscribe: function(itm, cb) {
					// add the item to the event container.......................//
					if (!hOP.call(oCon, itm)) {
						oCon[itm] = [];
					}

					// add subscription
					var nJ = oCon[itm].push(cb) - 1;
					return {
						unsubscribe: function() {
							oCon[itm].splice(nJ, 1);
						}
					};
				},
				fire: function(itm, dat) {
					// when item is not there return immediately..................//
					if (!hOP.call(oCon, itm)) {
						return;
					}
					oCon[itm].forEach(function(itm) {
						itm(dat || {});
					});
				}
			};
		},

		// drag and drop event target
		m_DndTarget: null,
		// .....................................................................//
		// logging and tracing.................................................//

		m_Log: "",
		m_bTrace: (function() {
			// trace is active when VBITrace div is available................//
			var el = document.getElementById('VBITrace');
			return (el != null) ? true : false;
		})(),

		Trace: function(text) {
			// do a log on the console, a crlf is appended......................//
			if (typeof console != "undefined") {
				jQuery.sap.log.info(text + "\r\n");
			}
			// add the text to a trace element, the <br> linebreak tag is added.//
			var trace = document.getElementById('VBITrace');
			if (trace == null) {
				return;
			}
			VBI.m_Log = VBI.m_Log + text + "<br>";
			trace.innerHTML = VBI.m_Log;
		},

		// global register for key events.........................................//
		// for windows 8 surface like devices to get shift and ctrl key state at..//
		// any time...............................................................//

		RegisterKeyboardHook: function() {
			// add reference count.................................................//
			++window.VBI.m_dwRefKeyboardHook;

			// hook already registered.............................................//
			if (window.VBI.m_dwRefKeyboardHook > 1) {
				return;
			}

			window.VBI.onkeydown = function(e) {
				if (e.keyCode == 16) {
					VBI.m_shiftKey = true;
				} else if (e.keyCode == 17) {
					VBI.m_ctrlKey = true;
				}
			};
			window.VBI.onkeyup = function(e) {
				if (e.keyCode == 16) {
					VBI.m_shiftKey = false;
				} else if (e.keyCode == 17) {
					VBI.m_ctrlKey = false;
				}
			};

			document.addEventListener('keydown', window.VBI.onkeydown);
			document.addEventListener('keyup', window.VBI.onkeyup);

		},

		UnRegisterKeyboardHook: function() {
			--window.VBI.m_dwRefKeyboardHook;

			if (window.VBI.m_dwRefKeyboardHook > 0) {
				return;
			}

			// when to unregster the
			document.removeEventListener('keydown', window.VBI.onkeydown);
			document.removeEventListener('keyup', window.VBI.onkeyup);
			window.VBI.onkeydown = null;
			window.VBI.onkeyup = null;
		}

	};

	// .......................................................................//
	// this is the list of java script files needed for VBI..................//
	// use sap require to load additional scripts.............................//	
	 // utility functions
	 // control context
	 // data provider
	 // resources
	 // geo math functions
	
	
	 // map support
	
	 // visual objects base and vo implementation
	 // event subscription
	 // labels
	 // GetPosFrom... and co
	 // scene handling, scenes
	 // window handling, detail and so on
	 // actions handling, framework event subscription
	 
	 
	 // geo tools for VBI namespace
	
	 
	 // context menu
	 // map projection (mercator, linear)
	 // VO clustering
	 // expression evaluation
	
	
	

	jQuery.sap.require('sap.ui.core.IconPool'); // unlisted dependency retained

	jQuery.sap.require('sap.ui.core.theming.Parameters'); // unlisted dependency retained

	window.VBI.Utilities.GetTransparentImage();

})();

// based on sources from: https://github.com/MihaiValentin/setDragImage-IE polyfill
(function() {
	"use strict";
	if (!window.DataTransfer) { // return if drag not supported
		return;
	}
	if (typeof window.DataTransfer.prototype.setDragImage !== 'function') { // if the setDragImage is not available, implement it in VBI.Utilities to avoid touching global namespace
		VBI.Utilities.SetDragImage = function(image, offsetX, offsetY) {
			var randomDraggingClassName, dragStylesCSS, dragStylesEl, headEl, eventTarget;

			// generate a random class name that will be added to the element
			randomDraggingClassName = 'setdragimage-ie-dragging-' + Math.round(Math.random() * Math.pow(10, 5)) + '-' + Date.now();

			// prepare the rules for the random class
			dragStylesCSS = [
				'.' + randomDraggingClassName, '{', 'background: url("' + image.src + '") no-repeat #fff 0 0 !important;', 'width: ' + image.width + 'px !important;', 'height: ' + image.height + 'px !important;', 'text-indent: -9999px !important;', 'border: 0 !important;', 'outline: 0 !important;', '}', '.' + randomDraggingClassName + ' * {', 'display: none !important;', '}'
			];
			// create the element and add it to the head of the page
			dragStylesEl = document.createElement('style');
			dragStylesEl.innerText = dragStylesCSS.join('');
			headEl = document.getElementsByTagName('head')[0];
			headEl.appendChild(dragStylesEl);

			/*
			 * since we can't get the target element over which the drag start event occurred (because the `this` represents the window.DataTransfer
			 * object and not the element), we will walk through the parents of the current functions until we find one whose first argument is a drag
			 * event; since this doesn't work in strict mode we introduced a VBI.m_DnDTarget variable that is set in the dragstart event processing
			 */

			eventTarget = VBI.m_DndTarget;

			// and add the class we prepared to it
			eventTarget.classList.add(randomDraggingClassName);

			/*
			 * immediately after adding the class, we remove it. in this way the browser will have time to make a snapshot and use it just so it looks
			 * like the drag element
			 */
			setTimeout(function() {
				// remove the styles
				headEl.removeChild(dragStylesEl);
				// remove the class
				eventTarget.classList.remove(randomDraggingClassName);
			}, 0);
		};
	}
})();

}; // end of sap/ui/vbm/lib/sapvbi.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.AnalyticMapRenderer') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

jQuery.sap.declare('sap.ui.vbm.AnalyticMapRenderer'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/AnalyticMapRenderer",[
	'./GeoMapRenderer'
], function(GeoMapRenderer) {
	"use strict";

	/**
	 * @class MapRenderer renderer.
	 * @static
	 */
	var AnalyticMapRenderer = {};

	/**
	 * Renders the HTML for the given control, using the provided {@link sap.ui.core.RenderManager}.
	 * 
	 * @param {sap.ui.core.RenderManager} oRm the RenderManager that can be used for writing to the render output buffer
	 * @param {sap.ui.core.Control} oControl an object representation of the control that should be rendered
	 */
	AnalyticMapRenderer.render = function(oRm, oControl) {
		oControl.addStyleClass("sapUiVbmAnalyticMap");
		GeoMapRenderer.render(oRm, oControl);
	};

	return AnalyticMapRenderer;

}, /* bExport= */true);

}; // end of sap/ui/vbm/AnalyticMapRenderer.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Area') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.Area.
jQuery.sap.declare('sap.ui.vbm.Area'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/Area",[
	'./VoBase', './library'
], function(VoBase, library) {
	"use strict";

	/**
	 * Constructor for a new Area.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Specific Visual Object element for an <i>Area</i>. An Area is a filled polygon, which border is given as a list of geo-coordinates.
	 *        Areas can have multiple disjunct parts as well as each part can have an arbitrary number of exclusions/holes.<br>
	 *        The inner part and the edges of areas are interactive and fire events on click.<br>
	 *        Since the actual size of an area depends on the zoom level it might be only partly visible. Thus detail windows will open at the click
	 *        position.
	 * @extends sap.ui.vbm.VoBase
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.Area
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var Area = VoBase.extend("sap.ui.vbm.Area", /** @lends sap.ui.vbm.Area.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * The position array for the Area. For single part areas the format is "lon0;lat0;0.0;...;lonN,latN,0.0". For multi part areas you
				 * need to provide an array of arrays of the above position string: "[['lon0...'],['lon0...']]" (sequence of single and double quotes
				 * is important). <b>Single and Multi part areas must not be mixed within one Areas aggregation.</b><br>
				 * Finally each area part can have multiple exclusions/holes. In that case the position list of excluded areas has follow the list of
				 * the base shape: "['lon0...', 'exLon0...']".
				 */
				position: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * The fill color of the Area.
				 */
				color: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * The border color of the Area.
				 */
				colorBorder: {
					type: "string",
					group: "Misc"
				},

				/**
				 * Defines the dashing style of the area border using an array.
				 */
				borderDash: {
					type: "string",
					group: "Misc"
				}
			},
			events: {
				// Events are implemented in Areas.js!
				
				/**
				 * This event is raised when the edge of an Area is clicked.
				 */
				edgeClick: {
					/**
					 * The number of the edge where the click occured; edges are numbered zero based: e.g. edge from point 1 to point 2 has number 0
					 */
					edge: {
						type: "int"
					}
				},

				/**
				 * This event is raised when the edge of an Area is right clicked.
				 */
				edgeContextMenu: {
					/**
					 * The number of the edge where the click occured; edges are numbered zero based: e.g. edge from point 1 to point 2 has number 0
					 */
					edge: {
						type: "int"
					}

				}
			}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.Area.prototype.init = function(){
	// // do something for initialization...
	// };

	// Overwrite default impl from VoBase
	Area.prototype.openDetailWindow = function(sCaption, sOffsetX, sOffsetY) {
		this.oParent.openDetailWindow(this, {
			caption: sCaption,
			offsetX: sOffsetX,
			offsetY: sOffsetY
		}, true);

	};

	// Implement function defined in VoBase
	Area.prototype.openContextMenu = function(oMenu) {
		this.oParent.openContextMenu("Area", this, oMenu);
	};

	Area.prototype.getDataElement = function() {
		var oElement = VoBase.prototype.getDataElement.apply(this, arguments);
		var oBindInfo = this.oParent.mBindInfo;

		// add the VO specific properties..................................//
		if (oBindInfo.C) {
			oElement.C = this.getColor();
		}
		if (oBindInfo.CB) {
			var cb = this.getColorBorder();
			if (cb != undefined && cb != "") {
				oElement.CB = cb;
			}
		}
		if (oBindInfo.BD) {
			var bd = this.getBorderDash();
			if (bd != undefined && bd != "") {
				oElement.BD = bd;
			}
		}
		var pos = this.getPosition();
		if (pos.substring(0, 1) === "[") {
			pos = pos.replace(/\'/g, "\"");
			oElement.PM = JSON.parse(pos);
		} else {
			oElement.P = pos;
		}

		return oElement;
	};

	Area.prototype.handleChangedData = function(oElement) {
		if (oElement.P) {
			this.setPosition(oElement.P);
		}
		if (oElement.PM) {
			jQuery.sap.log.error("sap.ui.vbm.Area: Change of areas with multiple parts not supported");
		}
	};

	return Area;

});

}; // end of sap/ui/vbm/Area.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Areas') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.Areas.
jQuery.sap.declare('sap.ui.vbm.Areas'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/Areas",[
	'./VoAggregation', './library'
], function(VoAggregation, library) {
	"use strict";

	/**
	 * Constructor for a new Areas.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Type specific Visual Object aggregation for <i>Area</i> instances.
	 * @extends sap.ui.vbm.VoAggregation
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.Areas
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var Areas = VoAggregation.extend("sap.ui.vbm.Areas", /** @lends sap.ui.vbm.Areas.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * Set to true if position may be changed at runtime. The actual changeability is control on each aggregated element with property
				 * <i>changeable</i>.
				 */
				posChangeable: {
					type: "boolean",
					group: "Misc",
					defaultValue: true
				}
			},
			defaultAggregation: "items",
			aggregations: {

				/**
				 * Area object aggregation
				 */
				items: {
					type: "sap.ui.vbm.Area",
					multiple: true,
					singularName: "item"
				}
			},
			events: {

				/**
				 * This event is raised when the edge of an Area is clicked.
				 */
				edgeClick: {
					parameters: {

						/**
						 * Clicked instance
						 */
						instance: {
							type: "sap.ui.vbm.Area"
						},						
						/**
						 * The number of the edge where the click occured. Edges are numbered zero based: e.g. edge from point 1 to point 2 has number
						 * 0
						 */
						edge: {
							type: "int"
						}
					}

				},

				/**
				 * This event is raised when the edge of an Area is right clicked.
				 */
				edgeContextMenu: {
					parameters: {
						/**
						 * Clicked instance
						 */
						instance: {
							type: "sap.ui.vbm.Area"
						},
						/**
						 * The number of the edge where the click occured. Edges are numbered zero based: e.g. edge from point 1 to point 2 has number
						 * 0
						 */
						edge: {
							type: "int"
						}
					}
				}
			}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.Areas.prototype.init = function(){
	// // do something for initialization...
	// };

	// ...........................................................................//
	// model creators............................................................//

	Areas.prototype.getBindInfo = function() {
		var oBindInfo = VoAggregation.prototype.getBindInfo.apply(this, arguments);
		var oTemplateBindingInfo = this.getTemplateBindingInfo();

		// Note: Without Template no static properties -> all bound in the sense of VB JSON!
		oBindInfo.C = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("color") : true;
		oBindInfo.CB = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("colorBorder") : true;
		oBindInfo.BD = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("borderDash") : true;

		return oBindInfo;
	};

	Areas.prototype.getTemplateObject = function() {
		// get common template from base class (VoAggregation)
		var oTemp = VoAggregation.prototype.getTemplateObject.apply(this, arguments);

		var oBindInfo = this.mBindInfo = this.getBindInfo();
		var oVoTemplate = (oBindInfo.hasTemplate) ? this.getBindingInfo("items").template : null;

		oTemp["type"] = "{00100000-2012-0004-B001-F311DE491C77}";
		if (oBindInfo.C) {
			oTemp["color.bind"] = oTemp.id + ".C";
		} else {
			oTemp.color = oVoTemplate.getColor(); // C the color
		}
		if (oBindInfo.CB) {
			oTemp["colorBorder.bind"] = oTemp.id + ".CB";
		} else {
			oTemp.colorBorder = oVoTemplate.getColorBorder(); // BC the border color
		}
		if (oBindInfo.BD) {
			oTemp["borderDash.bind"] = oTemp.id + ".BD";
		} else {
			oTemp.borderDash = oVoTemplate.getBorderDash(); // BD is the line dashing array
		}
		// check first child if posarray or posarraymulti should be used
		var aVO = this.getItems();
		if (aVO.length) {
			if (aVO[0].getPosition().substring(0, 1) === "[") {
				oTemp["posarraymulti.bind"] = oTemp.id + ".PM"; // PM is the position array multi
			} else {
				oTemp["posarray.bind"] = oTemp.id + ".P"; // P is the position array
			}
		} else {
			jQuery.sap.log.warning("sap.ui.vbm.Areas: items aggregation must not be empty!");
		}

		return oTemp;
	};

	Areas.prototype.getTypeObject = function() {
		var oType = VoAggregation.prototype.getTypeObject.apply(this, arguments);
		var oBindInfo = this.mBindInfo;
		var pc = this.getPosChangeable().toString();

		// extend the object type.................................................//
		oType.A = oType.A.concat( [
			{
				"changeable": pc,
				"name": "P", // position array
				"alias": "P",
				"type": "vectorarray"
			}, {
				"changeable": pc,
				"name": "PM", // position array multi
				"alias": "PM",
				"type": "vectorarraymulti"
			}
		]);
		if (oBindInfo.C) {
			oType.A.push({
				"name": "C", // color
				"alias": "C",
				"type": "color"
			});
		}
		if (oBindInfo.CB) {
			oType.A.push({
				"name": "CB", // border color
				"alias": "CB",
				"type": "string"
			});
		}
		if (oBindInfo.BD) {
			oType.A.push({
				"name": "BD", // borderdash
				"alias": "BD",
				"type": "string"
			});
		}

		return oType;
	};

	Areas.prototype.getActionArray = function() {
		var aActions = VoAggregation.prototype.getActionArray.apply(this, arguments);

		var id = this.getId();

		// check if the different vo events are registered..............................//
		if (this.mEventRegistry["click"] || this.isEventRegistered("click")) {
			aActions.push({
				"id": id + "1",
				"name": "click",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "Click",
				"AddActionProperty": [
					{
						"name": "pos"
					}
				]
			});
		}
		if (this.mEventRegistry["contextMenu"] || this.isEventRegistered("contextMenu")) {
			aActions.push({
				"id": id + "2",
				"name": "contextMenu",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "ContextMenu"
			});
		}
		if (this.mEventRegistry["drop"] || this.isEventRegistered("drop")) {
			aActions.push({
				"id": id + "3",
				"name": "drop",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "Drop"
			});
		}
		if (this.mEventRegistry["edgeClick"] || this.isEventRegistered("edgeClick")) {
			aActions.push({
				"id": id + "7",
				"name": "edgeClick",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "EdgeClick"
			});
		}
		if (this.mEventRegistry["edgeContextMenu"] || this.isEventRegistered("edgeContextMenu")) {
			aActions.push({
				"id": id + "8",
				"name": "edgeContextMenu",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "EdgeContextMenu"
			});
		}

		return aActions;
	};

	// ..........................................................................//
	// helper functions.........................................................//

	Areas.prototype.handleEvent = function(event) {
		var s = event.Action.name;

		if (s == "edgeContextMenu" || s == "edgeClick") {

			var funcname = "fire" + s[0].toUpperCase() + s.slice(1);

			// first we try to get the event on a Areas instance......................//
			var Area;
			if ((Area = this.findInstance(event.Action.instance))) {
				var eventContext = {
				                  data: event,
				                  edge: parseInt(event.Action.Params.Param['2']['#'], 10)                
				};
				
				if (s == "edgeContextMenu") {
					Area.mClickPos = [
						event.Action.Params.Param[0]['#'], event.Action.Params.Param[1]['#']
					];
					// lazy load sap.ui.unified library for using the Menu
					sap.ui.getCore().loadLibrary("sap.ui.unified");

					if (this.oParent.mVBIContext.m_Menus) {
						this.oParent.mVBIContext.m_Menus.deleteMenu("DynContextMenu");
					}
					// create an empty menu
					var oMenuObject = new sap.ui.unified.Menu();
					oMenuObject.vbi_data = {};
					oMenuObject.vbi_data.menuRef = "CTM";
					oMenuObject.vbi_data.VBIName = "DynContextMenu";

				    eventContext.menu = oMenuObject;
				}
				if (Area.mEventRegistry[s]) {
					Area[funcname](eventContext);
				}
				if (this.mEventRegistry[s]) {
					eventContext.instance = Area;
					this[funcname](eventContext);
				}
			} else {
				jQuery.sap.log.error("Instance for event not found");
			}
		} else {
			VoAggregation.prototype.handleEvent.apply(this, arguments);
		}
	};

	return Areas;

});

}; // end of sap/ui/vbm/Areas.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Box') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.Box.
jQuery.sap.declare('sap.ui.vbm.Box'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/Box",[
	'./VoBase', './library'
], function(VoBase, library) {
	"use strict";

	/**
	 * Constructor for a new Box.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Specific Visual Object element for a <i>Box</i>. A Box is a rectangle, which is positioned with its centerpoint at the given <i>position</i>.
	 *        The ratio between width and height can be controlled with property <i>scale</i>. Depending on the property <i>fxsize</i> a box has an
	 *        absolute or relative size.<br>
	 *        Since the actual size of a box may depend on the zoom level it might be only partly visible. Thus detail windows will open at the click
	 *        position.
	 * @extends sap.ui.vbm.VoBase
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.Box
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var Box = VoBase.extend("sap.ui.vbm.Box", /** @lends sap.ui.vbm.Box.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * The position of the Box. The format is "lon;lat;0".
				 */
				position: {
					type: "string",
					group: "Misc",
					defaultValue: '0;0;0'
				},

				/**
				 * The scale of the box. The format is "x-Scale;y-Scale;z-Scale" whereas z-Scale is currently ignored.
				 */
				scale: {
					type: "string",
					group: "Misc",
					defaultValue: '1;1;1'
				},

				/**
				 * The color of the box.
				 */
				color: {
					type: "string",
					group: "Misc",
					defaultValue: 'RGB(255;0;0)'
				},

				/**
				 * The border color of the box.
				 */
				colorBorder: {
					type: "string",
					group: "Misc",
					defaultValue: 'RGB(255;0;0)'
				}
			},
			events: {}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.Box.prototype.init = function(){
	// // do something for initialization...
	// };

	// Overwrite default impl from VoBase
	Box.prototype.openDetailWindow = function(sCaption, sOffsetX, sOffsetY) {
		this.oParent.openDetailWindow(this, {
			caption: sCaption,
			offsetX: sOffsetX,
			offsetY: sOffsetY
		}, true);

	};

	// Implement function defined in VoBase
	Box.prototype.openContextMenu = function(oMenu) {
		this.oParent.openContextMenu("Box", this, oMenu);

	};

	Box.prototype.getDataElement = function() {
		var oElement = VoBase.prototype.getDataElement.apply(this, arguments);
		var oBindInfo = this.oParent.mBindInfo;

		// add the VO specific properties..................................//
		if (oBindInfo.P) {
			oElement.P = this.getPosition();
		}
		if (oBindInfo.S) {
			oElement.S = this.getScale();
		}
		if (oBindInfo.C) {
			oElement.C = this.getColor();
		}
		if (oBindInfo.CB) {
			oElement.CB = this.getColorBorder();
		}

		return oElement;
	};

	Box.prototype.handleChangedData = function(oElement) {
		if (oElement.P) {
			this.setPosition(oElement.P);
		}
		if (oElement.S) {
			this.setScale(oElement.S);
		}
	};

	return Box;

});

}; // end of sap/ui/vbm/Box.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Boxes') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.Boxes.
jQuery.sap.declare('sap.ui.vbm.Boxes'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/Boxes",[
	'./VoAggregation', './library'
], function(VoAggregation, library) {
	"use strict";

	/**
	 * Constructor for a new Boxes.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Type specific Visual Object aggregation for <i>Box</i> instances.
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.Boxes
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var Boxes = VoAggregation.extend("sap.ui.vbm.Boxes", /** @lends sap.ui.vbm.Boxes.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * Set to true if position may be changed at runtime. The actual changeability is control on each aggregated element with property
				 * <i>changeable</i>.
				 */
				posChangeable: {
					type: "boolean",
					group: "Misc",
					defaultValue: true
				},

				/**
				 * Set to true if scale may be changed at runtime. The actual changeability is control on each aggregated element with property
				 * <i>changeable</i>.
				 */
				scaleChangeable: {
					type: "boolean",
					group: "Misc",
					defaultValue: true
				}
			},
			defaultAggregation: "items",
			aggregations: {

				/**
				 * Box object aggregation
				 */
				items: {
					type: "sap.ui.vbm.Box",
					multiple: true,
					singularName: "item"
				}
			},
			events: {

			}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.Boxes.prototype.init = function(){
	// // do something for initialization...
	// };

	// ...........................................................................//
	// model creators...........................................................//

	Boxes.prototype.getBindInfo = function() {
		var oBindInfo = VoAggregation.prototype.getBindInfo.apply(this, arguments);
		var oTemplateBindingInfo = this.getTemplateBindingInfo();

		// Note: Without Template no static properties -> all bound in the sense of VB JSON!
		oBindInfo.C = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("color") : true;
		oBindInfo.CB = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("colorBorder") : true;
		oBindInfo.P = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("position") : true;
		oBindInfo.S = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("scale") : true;

		return oBindInfo;
	};

	Boxes.prototype.getTemplateObject = function() {
		// get common template from base class (VoAggregation)
		var oTemp = VoAggregation.prototype.getTemplateObject.apply(this, arguments);

		var oBindInfo = this.mBindInfo = this.getBindInfo();
		var oVoTemplate = (oBindInfo.hasTemplate) ? this.getBindingInfo("items").template : null;

		oTemp["type"] = "{00100000-2012-0004-B001-BFED458C3076}";
		if (oBindInfo.P) {
			oTemp["pos.bind"] = oTemp.id + ".P";
		} else {
			oTemp.pos = oVoTemplate.getPosition(); // P is the position
		}
		if (oBindInfo.S) {
			oTemp["scale.bind"] = oTemp.id + ".S";
		} else {
			oTemp.scale = oVoTemplate.getScale(); // S is the scaling
		}
		if (oBindInfo.C) {
			oTemp["color.bind"] = oTemp.id + ".C";
		} else {
			oTemp.color = oVoTemplate.getColor(); // C the color
		}
		if (oBindInfo.CB) {
			oTemp["colorBorder.bind"] = oTemp.id + ".CB";
		} else {
			oTemp.colorBorder = oVoTemplate.getColorBorder(); // BC the border color
		}

		return oTemp;
	};

	Boxes.prototype.getTypeObject = function() {
		var oType = VoAggregation.prototype.getTypeObject.apply(this, arguments);
		var oBindInfo = this.mBindInfo;

		// extend the object type.................................................//
		if (oBindInfo.P) {
			oType.A.push({
				"changeable": this.getPosChangeable().toString(),
				"name": "P", // position
				"alias": "P",
				"type": "vector"
			});
		}
		if (oBindInfo.S) {
			oType.A.push({
				"changeable": this.getScaleChangeable().toString(),
				"name": "S", // scale
				"alias": "S",
				"type": "vector"
			});
		}
		if (oBindInfo.C) {
			oType.A.push({
				"name": "C", // color
				"alias": "C",
				"type": "color"
			});
		}
		if (oBindInfo.CB) {
			oType.A.push({
				"name": "CB", // colorBorder
				"alias": "CB",
				"type": "color"
			});
		}
		return oType;
	};

	Boxes.prototype.getActionArray = function() {
		var aActions = VoAggregation.prototype.getActionArray.apply(this, arguments);

		var id = this.getId();

		// check if the different vo events are registered..............................//
		if (this.mEventRegistry["click"] || this.isEventRegistered("click")) {
			aActions.push({
				"id": id + "1",
				"name": "click",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "Click",
				"AddActionProperty": [
					{
						"name": "pos"
					}
				]
			});
		}
		if (this.mEventRegistry["contextMenu"] || this.isEventRegistered("contextMenu")) {
			aActions.push({
				"id": id + "2",
				"name": "contextMenu",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "ContextMenu"
			});
		}
		if (this.mEventRegistry["drop"] || this.isEventRegistered("drop")) {
			aActions.push({
				"id": id + "3",
				"name": "drop",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "Drop"
			});
		}

		return aActions;
	};

	// ..........................................................................//
	// helper functions.........................................................//	

	return Boxes;

});

}; // end of sap/ui/vbm/Boxes.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Circle') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.Circle.
jQuery.sap.declare('sap.ui.vbm.Circle'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/Circle",[
	'./VoBase', './library'
], function(VoBase, library) {
	"use strict";

	/**
	 * Constructor for a new Circle.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Specific Visual Object element for an <i>Circle</i>. A Circle is positioned with its centerpoint at the given <i>position</i>. The
	 *        detail window will open at the center of the circle.
	 * @extends sap.ui.vbm.VoBase
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.Circle
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var Circle = VoBase.extend("sap.ui.vbm.Circle", /** @lends sap.ui.vbm.Circle.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * The position of the circle.
				 */
				position: {
					type: "string",
					group: "Misc",
					defaultValue: '0;0;0'
				},

				/**
				 * The pixel radius of the circle.
				 */
				radius: {
					type: "string",
					group: "Misc",
					defaultValue: '20'
				},

				/**
				 * The color of the circle.
				 */
				color: {
					type: "string",
					group: "Misc",
					defaultValue: 'RGBA(0,0,128,128)'
				},

				/**
				 * The border color of the circle.
				 */
				colorBorder: {
					type: "string",
					group: "Misc",
					defaultValue: 'RGB(0,0,0)'
				},

				/**
				 * Number of circle slices. The property is required only when the PlugIn is used.
				 */
				slices: {
					type: "string",
					group: "Misc",
					defaultValue: null
				}
			},
			events: {}
		}
	});

	// Implement function defined in VoBase
	Circle.prototype.openContextMenu = function(oMenu) {
		this.oParent.openContextMenu("Circle", this, oMenu);
	};

	Circle.prototype.getDataElement = function() {
		var oElement = VoBase.prototype.getDataElement.apply(this, arguments);
		var oBindInfo = this.oParent.mBindInfo;

		// add the VO specific properties..................................//
		if (oBindInfo.P) {
			oElement.P = this.getPosition();
		}
		if (oBindInfo.R) {
			oElement.R = this.getRadius();
		}
		if (oBindInfo.C) {
			oElement.C = this.getColor();
		}
		if (oBindInfo.CB) {
			oElement.CB = this.getColorBorder();
		}
		if (oBindInfo.NS) {
			oElement.NS = this.getSlices();
		}

		return oElement;
	};

	Circle.prototype.handleChangedData = function(oElement) {
		if (oElement.P) {
			this.setPosition(oElement.P);
		}
		if (oElement.R) {
			this.setRadius(oElement.R);
		}
	};

	return Circle;

});

}; // end of sap/ui/vbm/Circle.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Circles') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.Circles.
jQuery.sap.declare('sap.ui.vbm.Circles'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/Circles",[
	'./VoAggregation', './library'
], function(VoAggregation, library) {
	"use strict";

	/**
	 * Constructor for a new Circles.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Type specific Visual Object aggregation for <i>Circle</i> elements.
	 * @extends sap.ui.vbm.VoAggregation
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.Circles
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var Circles = VoAggregation.extend("sap.ui.vbm.Circles", /** @lends sap.ui.vbm.Circles.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * Set to true if position may be changed at runtime. The actual changeability is control on each aggregated element with property
				 * <i>changeable</i>.
				 */
				posChangeable: {
					type: "boolean",
					group: "Misc",
					defaultValue: true
				},

				/**
				 * Set to true if radius may be changed at runtime. The actual changeability is control on each aggregated element with property
				 * <i>changeable</i>.
				 */
				radiusChangeable: {
					type: "boolean",
					group: "Misc",
					defaultValue: true
				}
			},
			defaultAggregation: "items",
			aggregations: {

				/**
				 * circle object aggregation
				 */
				items: {
					type: "sap.ui.vbm.Circle",
					multiple: true,
					singularName: "item"
				}
			},
			events: {

			}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.Circles.prototype.init = function(){
	// // do something for initialization...
	// };

	// ...........................................................................//
	// model creators...........................................................//

	Circles.prototype.getBindInfo = function() {
		var oBindInfo = VoAggregation.prototype.getBindInfo.apply(this, arguments);
		var oTemplateBindingInfo = this.getTemplateBindingInfo();

		// Note: Without Template no static properties -> all bound in the sense of VB JSON!
		oBindInfo.C = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("color") : true;
		oBindInfo.CB = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("colorBorder") : true;
		oBindInfo.P = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("position") : true;
		oBindInfo.NS = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("slices") : true;
		oBindInfo.R = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("radius") : true;

		return oBindInfo;
	};

	Circles.prototype.getTemplateObject = function() {
		// get common template from base class (VoAggregation)
		var oTemp = VoAggregation.prototype.getTemplateObject.apply(this, arguments);

		var oBindInfo = this.mBindInfo = this.getBindInfo();
		var oVoTemplate = (oBindInfo.hasTemplate) ? this.getBindingInfo("items").template : null;

		oTemp["type"] = "{00100000-2013-0004-B001-7EB3CCC039C4}";
		if (oBindInfo.P) {
			oTemp["pos.bind"] = oTemp.id + ".P";
		} else {
			oTemp.pos = oVoTemplate.getPosition(); // P is the position
		}
		if (oBindInfo.NS) {
			oTemp["slices.bind"] = oTemp.id + ".NS";
		} else {
			oTemp.slices = oVoTemplate.getSlices(); // NS is the number of slices
		}
		if (oBindInfo.C) {
			oTemp["color.bind"] = oTemp.id + ".C";
		} else {
			oTemp.color = oVoTemplate.getColor(); // C the color
		}
		if (oBindInfo.CB) {
			oTemp["colorBorder.bind"] = oTemp.id + ".CB";
		} else {
			oTemp.colorBorder = oVoTemplate.getColorBorder(); // BC the border color
		}
		if (oBindInfo.R) {
			oTemp["radius.bind"] = oTemp.id + ".R";
		} else {
			oTemp.radius = oVoTemplate.getRadius(); // R is the radius
		}

		return oTemp;
	};

	Circles.prototype.getTypeObject = function() {
		var oType = VoAggregation.prototype.getTypeObject.apply(this, arguments);
		var oBindInfo = this.mBindInfo;

		if (oBindInfo.P) {
			oType.A.push({
				"changeable": this.getPosChangeable().toString(),
				"name": "P", // position
				"alias": "P",
				"type": "vector"
			});
		}
		if (oBindInfo.R) {
			oType.A.push({
				"changeable": this.getRadiusChangeable().toString(),
				"name": "R", // radius
				"alias": "R",
				"type": "double"
			});
		}
		if (oBindInfo.C) {
			oType.A.push({
				"name": "C", // color
				"alias": "C",
				"type": "color"
			});
		}
		if (oBindInfo.CB) {
			oType.A.push({
				"name": "CB", // colorBorder
				"alias": "CB",
				"type": "color"
			});
		}
		if (oBindInfo.NS) {
			oType.A.push({
				"name": "NS", // slices
				"alias": "NS",
				"type": "long"
			});
		}
		return oType;
	};

	Circles.prototype.getActionArray = function() {
		var aActions = VoAggregation.prototype.getActionArray.apply(this, arguments);

		var id = this.getId();

		// check if the different vo events are registered..............................//
		if (this.mEventRegistry["click"] || this.isEventRegistered("click")) {
			aActions.push({
				"id": id + "1",
				"name": "click",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "Click",
				"AddActionProperty": [
					{
						"name": "pos"
					}
				]
			});
		}
		if (this.mEventRegistry["contextMenu"] || this.isEventRegistered("contextMenu")) {
			aActions.push({
				"id": id + "2",
				"name": "contextMenu",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "ContextMenu"
			});
		}
		if (this.mEventRegistry["drop"] || this.isEventRegistered("drop")) {
			aActions.push({
				"id": id + "3",
				"name": "drop",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "Drop"
			});
		}

		return aActions;
	};

	// ..........................................................................//
	// helper functions.........................................................//

	return Circles;

});

}; // end of sap/ui/vbm/Circles.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Container') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.Container.
jQuery.sap.declare('sap.ui.vbm.Container'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/Container",[
	'./VoBase', './library'
], function(VoBase, library) {
	"use strict";

	/**
	 * Constructor for a new Container.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Specific Visual Object element acting as a container for other controls. A Container is positioned at the given position on the map. It
	 *        can aggregate other controls, which will then move with the map.<br>
	 *        <b>Since a Container is not a real visual object most features borrowed from <i>VoBase</i> will not work. There is no label, no edit
	 *        mode, and no drop support. Events like click will only be fired if the aggregated control is not handling them.</b>
	 * @extends sap.ui.vbm.VoBase
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.Container
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var Container = VoBase.extend("sap.ui.vbm.Container", /** @lends sap.ui.vbm.Container.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * The position for the Container. The format is "lon;lat;0".
				 */
				position: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * Alignment of the container to its position:
				 * <ul>
				 * <li>0: center
				 * <li>1: top center
				 * <li>2: top right
				 * <li>3: center right
				 * <li>4: bottom right
				 * <li>5: bottom center
				 * <li>6: bottom left
				 * <li>7: center left
				 * <li>8: top left
				 * </ul>
				 */
				alignment: {
					type: "string",
					group: "Misc",
					defaultValue: '0'
				}
			},
			aggregations: {

				/**
				 * The control that should be placed in the container.
				 */
				item: {
					type: "sap.ui.core.Control",
					multiple: false
				}
			},
			events: {}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.Container.prototype.init = function(){
	// // do something for initialization...
	// };
	
	// Implement function defined in VoBase
	Container.prototype.openContextMenu = function(oMenu) {
		this.getParent().openContextMenu("Container", this, oMenu);
	};	

	Container.prototype.getDataElement = function() {
		var oElement = VoBase.prototype.getDataElement.apply(this, arguments);
		var oBindInfo = this.oParent.mBindInfo;

		// add the VO specific properties..................................//
		//oElement.IK = this.getId();
		oElement.IK = this.getUniqueId();
		if (oBindInfo.P) {
			oElement.P = this.getPosition();
		}
		if (oBindInfo.AL) {
			oElement.AL = this.getAlignment();
		}

		return oElement;
	};

	Container.prototype.handleChangedData = function(oElement) {
		if (oElement.P) {
			this.setPosition(oElement.P);
		}
	};

	return Container;

});

}; // end of sap/ui/vbm/Container.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Containers') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.Containers.
jQuery.sap.declare('sap.ui.vbm.Containers'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/Containers",[
	'./VoAggregation', './library'
], function(VoAggregation, library) {
	"use strict";

	/**
	 * Constructor for a new Containers.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Type specific Visual Object aggregation for <i>Container</i> instances.
	 * @extends sap.ui.vbm.VoAggregation
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.Containers
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var Containers = VoAggregation.extend("sap.ui.vbm.Containers", /** @lends sap.ui.vbm.Containers.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			defaultAggregation: "items",
			aggregations: {

				/**
				 * Container object aggregation
				 */
				items: {
					type: "sap.ui.vbm.Container",
					multiple: true,
					singularName: "item"
				}
			},
			events: {}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.Containers.prototype.init = function(){
	// // do something for initialization...
	// };

	// ...........................................................................//
	// model creators............................................................//

	Containers.prototype.getBindInfo = function() {
		var oBindInfo = VoAggregation.prototype.getBindInfo.apply(this, arguments);
		var oTemplateBindingInfo = this.getTemplateBindingInfo();

		// Note: Without Template no static properties -> all bound in the sense of VB JSON!
		oBindInfo.P = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("position") : true;
		oBindInfo.AL = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("alignment") : true;

		return oBindInfo;
	};

	Containers.prototype.getTemplateObject = function() {
		// get common template from base class (VoAggregation)
		var oTemp = VoAggregation.prototype.getTemplateObject.apply(this, arguments);

		var oBindInfo = this.mBindInfo = this.getBindInfo();
		var oVoTemplate = (oBindInfo.hasTemplate) ? this.getBindingInfo("items").template : null;

		oTemp["type"] = "{00100000-2012-0004-B001-2297943F0CE6}";
		oTemp["key.bind"] = oTemp.id + ".IK"; // IK is the key
		if (oBindInfo.P) {
			oTemp["pos.bind"] = oTemp.id + ".P";
		} else {
			oTemp.pos = oVoTemplate.getPosition(); // P is the position
		}
		if (oBindInfo.AL) {
			oTemp["alignment.bind"] = oTemp.id + ".AL";
		} else {
			oTemp.alignment = oVoTemplate.getAlignment(); // AL is the alignment
		}

		return oTemp;
	};

	Containers.prototype.getTypeObject = function() {
		var oType = VoAggregation.prototype.getTypeObject.apply(this, arguments);
		var oBindInfo = this.mBindInfo;

		// extend the object type.................................................//
		oType.A.push({
			"name": "IK", // key
			"alias": "IK",
			"type": "key"
		});
		if (oBindInfo.P) {
			oType.A.push({
				"changeable": "true",
				"name": "P", // position
				"alias": "P",
				"type": "vector"
			});
		}
		if (oBindInfo.AL) {
			oType.A.push({
				"name": "AL", // alignment
				"alias": "AL",
				"type": "string"
			});
		}
		return oType;
	};

	Containers.prototype.getActionArray = function() {
		var aActions = VoAggregation.prototype.getActionArray.apply(this, arguments);

		var id = this.getId();

		// check if the different vo events are registered..............................//
		if (this.mEventRegistry["click"] || this.isEventRegistered("click")) {
			aActions.push({
				"id": id + "1",
				"name": "click",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "Click",
				"AddActionProperty": [
					{
						"name": "pos"
					}
				]
			});
		}
		if (this.mEventRegistry["contextMenu"] || this.isEventRegistered("contextMenu")) {
			aActions.push({
				"id": id + "2",
				"name": "contextMenu",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "ContextMenu"
			});
		}

		return aActions;
	};

	// ...........................................................................//
	// helper functions..........................................................//

	Containers.prototype.handleContainerCreated = function(event) {
		// get the right container aggregation
		var cont = this.findInstance(event.mParameters.id);
		// get the child control
		var oItem = cont.getItem();
		if (oItem) {
			// attach to container div events
			var oDomRef = event.getParameter("contentarea");
			oDomRef.addEventListener("click", this, false);
			oDomRef.addEventListener("contextmenu", this, false);
			
			var oParent;
			if ((oParent = this.getParent())) {
				// determine the id of the div to place the item in
				var id = oDomRef.id;
				oParent.addRenderItem( oItem, id );
			} 
		}
	};

	Containers.prototype.handleContainerDestroyed = function(event) {
		// detach container div events
		var oDomRef = event.getParameter("contentarea");
		oDomRef.removeEventListener("click", this, false);
		oDomRef.removeEventListener("contextmenu", this, false);
	};

	Containers.prototype.findInstance = function(key) {
		var aVO = this.getItems();
		if (!aVO) {
			return false;
		}
		
		for (var nJ = 0, len = this.aUniqueIdx.length; nJ < len; ++nJ) {
			// get the control.....................................................//
			if (this.aUniqueIdx[nJ] === key) {
				return aVO[nJ];
			}
		}
		
		return null;
	};
	
	/**
	 * Generic event handler for DOM events from container divs
	 * Note: This is not a redefinition of handleEvent from base class VOAggregation!
	 * @param oEvent DOM event
	 */
	Containers.prototype.handleEvent = function(oEvent) {
		var sContainerId = oEvent.currentTarget.m_Key;
		var oContainer = this.findInstance(sContainerId);
		
		switch (oEvent.type) {
			case "click":
				oContainer.fireClick();
				this.fireClick( {instance: oContainer } );
				break;
			case "contextmenu":		
				var eventContext = {};
				var oMapDivRect = this.oParent.getDomRef().getBoundingClientRect();
				oContainer.mClickPos = [
					oEvent.clientX - oMapDivRect.left, oEvent.clientY - oMapDivRect.top
				];
				// lazy load sap.ui.unified library for using the Menu
				sap.ui.getCore().loadLibrary("sap.ui.unified");

				try {
					if (this.oParent.mVBIContext.m_Menus) {
						this.oParent.mVBIContext.m_Menus.deleteMenu("DynContextMenu");
					}
					// create an empty menu
					var oMenuObject = new sap.ui.unified.Menu();
					oMenuObject.vbi_data = {};
					oMenuObject.vbi_data.menuRef = "CTM";
					oMenuObject.vbi_data.VBIName = "DynContextMenu";

					eventContext.menu = oMenuObject;
					oEvent.preventDefault();
					
					oContainer.fireContextMenu(eventContext);
					
					eventContext.instance = oContainer;
					this.fireContextMenu(eventContext);
				} catch(e) {}				
				break;
		}
	};		

	return Containers;

});

}; // end of sap/ui/vbm/Containers.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.FeatureCollection') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.FeatureCollection.
jQuery.sap.declare('sap.ui.vbm.FeatureCollection'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.core.theming.Parameters'); // unlisted dependency retained
sap.ui.define("sap/ui/vbm/FeatureCollection",[
	'sap/ui/core/theming/Parameters', './GeoJsonLayer', './library'
], function(Parameters, GeoJsonLayer, library) {
	"use strict";

	/**
	 * Constructor for a new FeatureCollection.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class FeatureCollection aggregation container. A FeatureCollection can render the content of an assigned GeoJSON. The naming is associated to
	 *        the GeoJSON standard. All features found in the GeoJSON are rendered as separated objects. From the possible feature types only
	 *        <ul>
	 *        <li>Polygon and
	 *        <li>Multipolygon
	 *        </ul>
	 *        are supported so far. The feature type support will be extended in the upcoming releases.<br>
	 *        All features from the GeoJSON will be rendered with the given default colors and are inactive. They do not react on mouse over, except
	 *        with tooltip, or raise any events on click or right click.<br>
	 *        By adding <i>Feature elements</i> to the items aggregation you can make the match (by id) feature from the GeoJSON interactive and give
	 *        it alternative colors.
	 * @extends sap.ui.vbm.GeoJsonLayer
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.FeatureCollection
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var FeatureCollection = GeoJsonLayer.extend("sap.ui.vbm.FeatureCollection", /** @lends sap.ui.vbm.FeatureCollection.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {},
			defaultAggregation: "items",
			aggregations: {

				/**
				 * Feature object aggregation
				 */
				items: {
					type: "sap.ui.vbm.Feature",
					multiple: true,
					singularName: "item"
				}
			},
			events: {

				/**
				 * The event is raised when there is a click action on an aggregated Feature. Clicks on other Features from the GeoJSON are ignored.
				 */
				click: {
					parameters: {
						/**
						 * Id of clicked Feature
						 */
						featureId: {
							type: "string"
						}
					}
				},

				/**
				 * The event is raised when there is a right click or a tap and hold action on an aggregated Feature. Clicks on other Features from
				 * the GeoJSON are ignored.
				 */
				contextMenu: {
					parameters: {
						/**
						 * Id of clicked Feature
						 */
						featureId: {
							type: "string"
						}
					}
				}
			}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */

	// ...........................................................................//
	// model creators............................................................//

	FeatureCollection.prototype.getDataObjects = function() {
		if (this.mbGeoJSONDirty) {
			this._triggerFeatureCreation();
		}

		// apply the feature properties to the vbi datacontext.....................//
		// do a clone of the original data, to be able to handle complete....//
		// model changes..........................................................//

		var aElements = [], aPolys = [], aLines = [], aPoints = [];
		jQuery.extend(aElements, this.mFeatureColl); // shallow copy of array -> need to copy elements before change!

		var oOverlayMap = {};
		if (aElements.length) {
			// create lookup for overlayed features..................................//
			var aOverlayFeatures = this.getItems();
			for (var nJ = 0, len = aOverlayFeatures ? aOverlayFeatures.length : 0, item; nJ < len; ++nJ) {
				item = aOverlayFeatures[nJ];
				oOverlayMap[item.getFeatureId()] = item;
			}
		}

		// iterate over feature table.............................................//
		for (var nK = 0, oElement, oOverlay, tmp; nK < aElements.length; ++nK) {
			oElement = aElements[nK];

			if ((oOverlay = oOverlayMap[oElement.K])) {
				// Overlay found, apply properties.....................................//
				// do not change original element -> make copy first!
				var oCopy = {};
				jQuery.extend(oCopy, oElement);
				oElement = aElements[nK] = oCopy;
				// apply changes
				oElement.C = oOverlay.getColor();
				if ((tmp = oOverlay.getTooltip())) {
					oElement.TT = tmp;
				}
			}
			switch (oElement.type) {
				case "Polygon":
				case "MultiPolygon":
					aPolys.push(oElement);
					break;
				case "LineString":
				case "MultiLineString":
					aLines.push(oElement);
					break;
				case "Point":
				case "MultiPoint":
					aPoints.push(oElement);
					break;
				default:
					jQuery.sap.log.error("FeatureCollection: Unknown feature type: " + oElement.type);
			}
		}

		return [
			{
				"name": this.getId() + "_Polys",
				"type": "N",
				"E": aPolys
			}, {
				"name": this.getId() + "_Lines",
				"type": "N",
				"E": aLines
			}, {
				"name": this.getId() + "_Points",
				"type": "N",
				"E": aPoints
			}
		];
	};

	FeatureCollection.prototype.getDataRemoveObjects = function() {
		return [
			{
				"name": this.getId() + "_Polys",
				"type": "N"
			}, {
				"name": this.getId() + "_Lines",
				"type": "N"
			}, {
				"name": this.getId() + "_Points",
				"type": "N"
			}
		];
	};

	/**
	 * Returns Properties for Features like name, bounding box, and midpoint
	 * 
	 * @param {string[]} aFeatureIds Array of Feature Ids. The Feature Id must match the GeoJSON tag.
	 * @returns {array} Array of Feature Information Objects. Each object in the array has the properties BBox: Bounding Box for the Feature in format
	 *          "lonMin;latMin;lonMax;latMax", Midpoint: Centerpoint for Feature in format "lon;lat", Name: Name of the Feature, and Properties: Array
	 *          of name-value-pairs associated with the Feature
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	FeatureCollection.prototype.getFeaturesInfo = function(aFeatureIds) {
		var result = [];
		for (var nJ = 0, len = aFeatureIds.length, featureId; nJ < len; ++nJ) {
			featureId = aFeatureIds[nJ];
			result[featureId] = {};
			result[featureId].BBox = this.mFeatureBBox[featureId];
			result[featureId].Midpoint = [
				(this.mFeatureBBox[featureId][0] + this.mFeatureBBox[featureId][1]) / 2, (this.mFeatureBBox[featureId][2] + this.mFeatureBBox[featureId][3]) / 2
			];
			result[featureId].Name = this.mNames[featureId];
			result[featureId].Properties = this.mFeatureProps[featureId];
		}
		return result;
	};

	return FeatureCollection;

});

}; // end of sap/ui/vbm/FeatureCollection.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.GeoCircle') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.GeoCircle.
jQuery.sap.declare('sap.ui.vbm.GeoCircle'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/GeoCircle",[
	'./VoBase', './library'
], function(VoBase, library) {
	"use strict";

	/**
	 * Constructor for a new GeoCircle.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Specific Visual Object element for a <i>GeoCircle</i>. A GeoCircle is positioned with its centerpoint at the given <i>position</i>.
	 *        Since the actual size of a geocircle may depend on the zoom level it might be only partly visible. Thus detail windows will open at the
	 *        click position.
	 * @extends sap.ui.vbm.VoBase
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.GeoCircle
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var GeoCircle = VoBase.extend("sap.ui.vbm.GeoCircle", /** @lends sap.ui.vbm.GeoCircle.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * The position of the geocircle. The format is "lon;lat;0".
				 */
				position: {
					type: "string",
					group: "Misc",
					defaultValue: '0;0;0'
				},

				/**
				 * The border color of the geocirle.
				 */
				colorBorder: {
					type: "string",
					group: "Misc",
					defaultValue: 'RGB(0,0,0)'
				},

				/**
				 * The radius in meters of the geocirle.
				 */
				radius: {
					type: "string",
					group: "Misc",
					defaultValue: '10000'
				},

				/**
				 * The color of the geocirle.
				 */
				color: {
					type: "string",
					group: "Misc",
					defaultValue: 'RGB(0,0,0)'
				},

				/**
				 * The number of slices of the geocircle.
				 */
				slices: {
					type: "string",
					group: "Misc",
					defaultValue: '20'
				}
			},
			events: {}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.GeoCircle.prototype.init = function(){
	// // do something for initialization...
	// };

	// Overwrite default impl from VoBase
	GeoCircle.prototype.openDetailWindow = function(sCaption, sOffsetX, sOffsetY) {
		this.oParent.openDetailWindow(this, {
			caption: sCaption,
			offsetX: sOffsetX,
			offsetY: sOffsetY
		}, true);
	};

	// Implement function defined in VoBase
	GeoCircle.prototype.openContextMenu = function(oMenu) {
		this.oParent.openContextMenu("GeoCircle", this, oMenu);
	};

	GeoCircle.prototype.getDataElement = function() {
		var oElement = VoBase.prototype.getDataElement.apply(this, arguments);
		var oBindInfo = this.oParent.mBindInfo;

		// add the VO specific properties..................................//
		if (oBindInfo.P) {
			oElement.P = this.getPosition();
		}
		if (oBindInfo.R) {
			oElement.R = this.getRadius();
		}
		if (oBindInfo.C) {
			oElement.C = this.getColor();
		}
		if (oBindInfo.CB) {
			oElement.CB = this.getColorBorder();
		}
		if (oBindInfo.NS) {
			oElement.NS = this.getSlices();
		}

		return oElement;
	};

	GeoCircle.prototype.handleChangedData = function(oElement) {
		if (oElement.P) {
			this.setPosition(oElement.P);
		}
		if (oElement.R) {
			this.setRadius(oElement.R);
		}
	};

	return GeoCircle;

});

}; // end of sap/ui/vbm/GeoCircle.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.GeoCircles') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.GeoCircles.
jQuery.sap.declare('sap.ui.vbm.GeoCircles'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/GeoCircles",[
	'./VoAggregation', './library'
], function(VoAggregation, library) {
	"use strict";

	/**
	 * Constructor for a new GeoCircles.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Type specific Visual Object aggregation for <i>GeoCircle</i> elements.
	 * @extends sap.ui.vbm.VoAggregation
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.GeoCircles
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var GeoCircles = VoAggregation.extend("sap.ui.vbm.GeoCircles", /** @lends sap.ui.vbm.GeoCircles.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * Set to true if position may be changed at runtime. The actual changeability is control on each aggregated element with property
				 * <i>changeable</i>.
				 */
				posChangeable: {
					type: "boolean",
					group: "Misc",
					defaultValue: true
				},

				/**
				 * Set to true if radius may be changed at runtime. The actual changeability is control on each aggregated element with property
				 * <i>changeable</i>.
				 */
				radiusChangeable: {
					type: "boolean",
					group: "Misc",
					defaultValue: true
				}
			},
			defaultAggregation: "items",
			aggregations: {

				/**
				 * GeoCircle element aggregation
				 */
				items: {
					type: "sap.ui.vbm.GeoCircle",
					multiple: true,
					singularName: "item"
				}
			},
			events: {

			}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.GeoCircles.prototype.init = function(){
	// // do something for initialization...
	// };

	// ...........................................................................//
	// model creators...........................................................//

	GeoCircles.prototype.getBindInfo = function() {
		var oBindInfo = VoAggregation.prototype.getBindInfo.apply(this, arguments);
		var oTemplateBindingInfo = this.getTemplateBindingInfo();

		// Note: Without Template no static properties -> all bound in the sense of VB JSON!
		oBindInfo.C = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("color") : true;
		oBindInfo.CB = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("colorBorder") : true;
		oBindInfo.P = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("position") : true;
		oBindInfo.NS = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("slices") : true;
		oBindInfo.R = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("radius") : true;

		return oBindInfo;
	};

	GeoCircles.prototype.getTemplateObject = function() {
		// get common template from base class (VoAggregation)
		var oTemp = VoAggregation.prototype.getTemplateObject.apply(this, arguments);

		var oBindInfo = this.mBindInfo = this.getBindInfo();
		var oVoTemplate = (oBindInfo.hasTemplate) ? this.getBindingInfo("items").template : null;

		oTemp["type"] = "{00100000-2013-0004-B001-686F01B57873}";
		if (oBindInfo.P) {
			oTemp["midpoint.bind"] = oTemp.id + ".P";
		} else {
			oTemp.pos = oVoTemplate.getPosition(); // P is the position
		}
		if (oBindInfo.NS) {
			oTemp["slices.bind"] = oTemp.id + ".NS";
		} else {
			oTemp.slices = oVoTemplate.getSlices(); // NS is the number of slices
		}
		if (oBindInfo.C) {
			oTemp["color.bind"] = oTemp.id + ".C";
		} else {
			oTemp.color = oVoTemplate.getColor(); // C the color
		}
		if (oBindInfo.CB) {
			oTemp["colorBorder.bind"] = oTemp.id + ".CB";
		} else {
			oTemp.colorBorder = oVoTemplate.getColorBorder(); // BC the border color
		}
		if (oBindInfo.R) {
			oTemp["radius.bind"] = oTemp.id + ".R";
		} else {
			oTemp.radius = oVoTemplate.getRadius(); // R is the radius
		}

		return oTemp;
	};

	GeoCircles.prototype.getTypeObject = function() {
		var oType = VoAggregation.prototype.getTypeObject.apply(this, arguments);
		var oBindInfo = this.mBindInfo;

		if (oBindInfo.P) {
			oType.A.push({
				"changeable": this.getPosChangeable().toString(),
				"name": "P", // position
				"alias": "P",
				"type": "vector"
			});
		}
		if (oBindInfo.R) {
			oType.A.push({
				"changeable": this.getRadiusChangeable().toString(),
				"name": "R", // radius
				"alias": "R",
				"type": "double"
			});
		}
		if (oBindInfo.C) {
			oType.A.push({
				"name": "C", // color
				"alias": "C",
				"type": "color"
			});
		}
		if (oBindInfo.CB) {
			oType.A.push({
				"name": "CB", // colorBorder
				"alias": "CB",
				"type": "color"
			});
		}
		if (oBindInfo.NS) {
			oType.A.push({
				"name": "NS", // slices
				"alias": "NS",
				"type": "long"
			});
		}
		return oType;
	};

	GeoCircles.prototype.getActionArray = function() {
		var aActions = VoAggregation.prototype.getActionArray.apply(this, arguments);

		var id = this.getId();

		// check if the different vo events are registered..............................//
		if (this.mEventRegistry["click"] || this.isEventRegistered("click")) {
			aActions.push({
				"id": id + "1",
				"name": "click",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "Click",
				"AddActionProperty": [
					{
						"name": "pos"
					}
				]
			});
		}
		if (this.mEventRegistry["contextMenu"] || this.isEventRegistered("contextMenu")) {
			aActions.push({
				"id": id + "2",
				"name": "contextMenu",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "ContextMenu"
			});
		}
		if (this.mEventRegistry["drop"] || this.isEventRegistered("drop")) {
			aActions.push({
				"id": id + "3",
				"name": "drop",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "Drop"
			});
		}

		return aActions;
	};

	// ..........................................................................//
	// helper functions.........................................................//

	return GeoCircles;

});

}; // end of sap/ui/vbm/GeoCircles.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.HeatPoint') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */
// Provides control sap.ui.vbm.HeatPoint.
jQuery.sap.declare('sap.ui.vbm.HeatPoint'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/HeatPoint",[
	'./VoBase', './library'
], function(VoBase, library) {
	"use strict";

	/**
	 * Constructor for a new HeatPoint.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Specific Visual Object element for a <i>HeatPoint</i>.
	 * @extends sap.ui.vbm.VoBase
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.HeatPoint
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var HeatPoint = VoBase.extend("sap.ui.vbm.HeatPoint", /** @lends sap.ui.vbm.HeatPoint.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {
				/**
				 * The position of a sample element of the heatmap. Should be bound. The format is "lon;lat;0"
				 */
				position: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * Heat Value of the sample element of the heatmap. May be bound.
				 */
				value: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * Radius of the sample values. May be bound
				 */
				radius: {
					type: "string",
					group: "Misc",
					defaultValue: '5'
				}
			},
			events: {}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.HeatPoint.prototype.init = function(){
	// // do something for initialization...
	// };

	// Overwrite default impl from VoBase
	HeatPoint.prototype.openDetailWindow = function(sCaption, sOffsetX, sOffsetY) {
		this.oParent.openDetailWindow(this, {
			caption: sCaption,
			offsetX: sOffsetX,
			offsetY: sOffsetY
		}, true);

	};

	HeatPoint.prototype.getDataElement = function() {
		var oElement = VoBase.prototype.getDataElement.apply(this, arguments);
		var oBindInfo = this.oParent.mBindInfo;

		// add the VO specific properties..................................//
		if (oBindInfo.P) {
			oElement.P = this.getPosition();
		}
		if (oBindInfo.V) {
			oElement.V = this.getValue();
		}

		if (oBindInfo.R) {
			oElement.R = this.getRadius();
		}
		return oElement;
	};

	HeatPoint.prototype.handleChangedData = function(oElement) {
		if (oElement.P) {
			this.setPosition(oElement.P);
		}
		if (oElement.V) {
			this.setScale(oElement.V);
		}
		if (oElement.R) {
			this.setRadius(oElement.R);
		}
	};

	HeatPoint.prototype.getUniqueId = function() {
		return (this.getId());
	};

	return HeatPoint;

});

}; // end of sap/ui/vbm/HeatPoint.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Heatmap') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */
// Provides control sap.ui.vbm.HeatPoint.
jQuery.sap.declare('sap.ui.vbm.Heatmap'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/Heatmap",[
	'./VoAbstract', './library'
], function(VoAbstract, library) {
	"use strict";

	/**
	 * Constructor for a new Heatmap.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Type specific Visual Object aggregation for <i>HeatPoint</i> instances.
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.Heatmap
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var Heatmap = VoAbstract.extend("sap.ui.vbm.Heatmap", /** @lends sap.ui.vbm.Heatmap.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {
				/**
				 * Gradient Definition. Can be either provided as Ressource - then it is type string.<br>
				 * Or as Array [n0,c0,n1,c1,...,nk,ck] (ni > ni-1; ci respective colors) with an arbitrary number of color stops as in the following<br>
				 * Example: [0,'rgba(0,255,0,1)',220,'rgba(255,255,0,1)',255,'rgba(255,0,0,1)'] 
				 */
				gradient: {
					type: "array",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * Opacity of the heatmap. 
				 */
				opacity: {
					type: "string",
					group: "Misc",
					defaultValue: '0.5'
				},

				/**
				 * Behavior of the HeatPoint, 0 Density Map, 2: Heat Map, 1: Intermediate. 
				 */
				behavior: {
					type: "string",
					group: "Misc",
					defaultValue: '2'
				},

				/**
				 * Scaling factor for the sample values. 
				 */
				valueScale: {
					type: "string",
					group: "Misc",
					defaultValue: '1.0'
				},
				/**
				 * Scaling factor for the sample radiuses. 
				 */
				radiusScale: {
					type: "string",
					group: "Misc",
					defaultValue: '1.0'
				},
				/**
				 * Exponent for the alphaChannel<br>
				 * aE = 1 : alpha Channel remains linear<br>
				 * 0 < aE < 1 : (e.g. aE=0.5 "square root") sub linear alpha channeling (lower value colors remain longer visible; range appears wider)<br>
				 * aE > 1 (e.g. aE=2: "squared") above linear alpha channeling ( lower value colors remain shortly visible; range appears chopped)<br>
				 */
				alphaExponent: {
					type: "string",
					group: "Misc",
					defaultValue: '1.0'
				},
				/**
				 * Exponent for the color<br>
				 * aE = 1 : Linear Gradient<br>
				 * 0 < aE < 1 : Sublinear Gradient; i.E. with cE=0.5 point values are square rooted before usage [share of lower value cols will decrease]<br>
				 * aE > 1 : Higher Level Gradient; i.E. with cE=2 point values are squared before usage [share of lower value cols will increase]
				 */
				colorExponent: {
					type: "string",
					group: "Misc",
					defaultValue: '1.0'
				}

			},
			defaultAggregation: "items",
			aggregations: {

				/**
				 * HeatPoint object aggregation
				 */
				items: {
					type: "sap.ui.vbm.HeatPoint",
					multiple: true,
					singularName: "item"
				}
			},
			events: {

			}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.Heatmap.prototype.init = function(){
	// // do something for initialization...
	// };

	// ...........................................................................//
	// model creators...........................................................//

	Heatmap.prototype.getBindInfo = function() {
		var oBindInfo = VoAbstract.prototype.getBindInfo.apply(this, arguments);
		var oTemplateBindingInfo = this.getTemplateBindingInfo();

		// Note: Without Template no static properties -> all bound in the sense of VB JSON!
		oBindInfo.P = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("position") : true;
		oBindInfo.V = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("value") : true;
		oBindInfo.R = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("radius") : true;

		return oBindInfo;
	};

	Heatmap.prototype.getTemplateObject = function() {
		// get common template from base class (VoAbstract)
		var oTemp = VoAbstract.prototype.getTemplateObject.apply(this, arguments);

		var oBindInfo = this.mBindInfo = this.getBindInfo();
		var oVoTemplate = (oBindInfo.hasTemplate) ? this.getBindingInfo("items").template : null;

		oTemp["type"] = "{00100000-2012-0004-B001-E180770E8A12}";
		if (oBindInfo.P) {
			oTemp["pos.bind"] = oTemp.id + ".P";
		} else {
			oTemp.pos = oVoTemplate.getPosition(); // P is the position
		}		
		if (oBindInfo.R) {
			oTemp["radius.bind"] = oTemp.id + ".R";
		} else {
			oTemp.radius = oVoTemplate.getRadius(); // P is the position
		}		
		if (oBindInfo.V) {
			oTemp["value.bind"] = oTemp.id + ".V";
		} else {
			oTemp.value = oVoTemplate.getValue(); // V Value
		}		
		oTemp.gradient = this.getGradient(); 
		oTemp.opacity = this.getOpacity(); 
		oTemp.behavior = this.getBehavior(); 
		oTemp.radiusScale = this.getRadiusScale();
		oTemp.valueScale = this.getValueScale();
		oTemp.alphaExponent = this.getAlphaExponent();
		oTemp.colorExponent = this.getColorExponent();

		return oTemp;
	};

	Heatmap.prototype.getTypeObject = function() {
		var oType = VoAbstract.prototype.getTypeObject.apply(this, arguments);
		var oBindInfo = this.mBindInfo;

		// extend the object type.................................................//
		if (oBindInfo.P) {
			oType.A.push({
				"name": "P", // position
				"alias": "P",
				"type": "vector"
			});
		}
		if (oBindInfo.V) {
			oType.A.push({
				"name": "V", // radius
				"alias": "V",
				"type": "string"
			});
		}
		if (oBindInfo.R) {
			oType.A.push({
				"name": "R", // radius
				"alias": "R",
				"type": "string"
			});
		}
		return oType;
	};

	// ..........................................................................//
	// helper functions.........................................................//

	Heatmap.prototype.handleEvent = function(event) {
//		var s = event.Action.name;
//
//		var funcname = "fire" + s[0].toUpperCase() + s.slice(1);
//
//		// first we try to get the event on a Heatmap instance......................//
//		var HeatPoint;
//		if ((HeatPoint = this.findInstance(event.Action.instance))) {
//			if (HeatPoint.mEventRegistry[s]) {
//			}
//		}
//		this[funcname]({
//			data: event
//		});
	};

	Heatmap.prototype.getActionArray = function() {
		var aActions = VoAbstract.prototype.getActionArray.apply(this, arguments);

		// var id = this.getId();

		return aActions;
	};

	return Heatmap;

});



}; // end of sap/ui/vbm/Heatmap.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Pie') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.Pie.
jQuery.sap.declare('sap.ui.vbm.Pie'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/Pie",[
	'./VoBase', './library'
], function(VoBase, library) {
	"use strict";

	/**
	 * Constructor for a new Pie.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Specific Visual Object element for a <i>Pie Chart</i>. A Pie is a round chart, which is positioned with its centerpoint at the given
	 *        <i>position</i>. The size of the pie can be controlled with property <i>scale</i>. The slices of the pie chart are defined by the
	 *        aggregated <i>PieItem</i> elements. The detail window will open at the center of the pie.<br>
	 *        The property <i>hotDeltaColor</i> borrowed from VoBase is applied only to the hot PieItem and not the whole pie.</b>
	 * @extends sap.ui.vbm.VoBase
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.Pie
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var Pie = VoBase.extend("sap.ui.vbm.Pie", /** @lends sap.ui.vbm.Pie.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * The position of the Pie.
				 */
				position: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * The scaling of the Pie. The scale must be a vector "x-Scale;y-Scale;z-Scale", but currently only the x scaling is applied to the
				 * Pie.
				 */
				scale: {
					type: "string",
					group: "Misc",
					defaultValue: null
				}
			},
			defaultAggregation: "items",
			aggregations: {

				/**
				 * PieItem object aggregation. A PieItem holds the data for one slice in a Pie.
				 */
				items: {
					type: "sap.ui.vbm.PieItem",
					multiple: true,
					singularName: "item"
				}
			},
			events: {}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.Pie.prototype.init = function(){
	// // do something for initialization...
	// };

	// Implement function defined in VoBase
	Pie.prototype.openContextMenu = function(oMenu) {
		this.oParent.openContextMenu("Pie", this, oMenu);
	};

	Pie.prototype.getDataElement = function() {
		// determine the series elements.......................................//
		var aSeriesElements = [];

		var aPieItems = this.getItems();
		for (var nK = 0, lenItems = aPieItems.length; nK < lenItems; ++nK) {
			var oItem = aPieItems[nK];
			aSeriesElements.push({
				"T": oItem.getName(),
				"V": oItem.getValue()
			});
		}

		var oElement = VoBase.prototype.getDataElement.apply(this, arguments);
		var oBindInfo = this.oParent.mBindInfo;

		// add the VO specific properties..................................//
		if (oBindInfo.P) {
			oElement.P = this.getPosition();
		}
		if (oBindInfo.S) {
			oElement.S = this.getScale();
		}
		oElement.N = {
			"name": "Series",
			"E": aSeriesElements
		};

		return oElement;
	};

	Pie.prototype.handleChangedData = function(oElement) {
		if (oElement.P) {
			this.setPosition(oElement.P);
		}
		if (oElement.S) {
			this.setScale(oElement.S);
		}
	};

	return Pie;

});

}; // end of sap/ui/vbm/Pie.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Pies') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.Pies.
jQuery.sap.declare('sap.ui.vbm.Pies'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/Pies",[
	'./VoAggregation', './library'
], function(VoAggregation, library) {
	"use strict";

	/**
	 * Constructor for a new Pies.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Type specific Visual Object aggregation for <i>Pie</i> instances.
	 * @extends sap.ui.vbm.VoAggregation
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.Pies
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var Pies = VoAggregation.extend("sap.ui.vbm.Pies", /** @lends sap.ui.vbm.Pies.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * Set to true if position may be changed at runtime. The actual changeability is control on each aggregated element with property
				 * <i>changeable</i>.
				 */
				posChangeable: {
					type: "boolean",
					group: "Misc",
					defaultValue: true
				},

				/**
				 * Set to true if scale may be changed at runtime. The actual changeability is control on each aggregated element with property
				 * <i>changeable</i>.
				 */
				scaleChangeable: {
					type: "boolean",
					group: "Misc",
					defaultValue: true
				}
			},
			defaultAggregation: "items",
			aggregations: {

				/**
				 * Pie object aggregation
				 */
				items: {
					type: "sap.ui.vbm.Pie",
					multiple: true,
					singularName: "item"
				}
			},
			events: {

			}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.Pies.prototype.init = function(){
	// // do something for initialization...
	// };

	// ...........................................................................//
	// model creators...........................................................//
	Pies.prototype.getBindInfo = function() {
		var oBindInfo = VoAggregation.prototype.getBindInfo.apply(this, arguments);
		var oTemplateBindingInfo = this.getTemplateBindingInfo();

		// Note: Without Template no static properties -> all bound in the sense of VB JSON!
		oBindInfo.P = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("position") : true;
		oBindInfo.S = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("scale") : true;

		return oBindInfo;
	};

	Pies.prototype.getTemplateObject = function() {
		// get common template from base class (VoAggregation)
		var oTemp = VoAggregation.prototype.getTemplateObject.apply(this, arguments);

		var oBindInfo = this.mBindInfo = this.getBindInfo();
		var oVoTemplate = (oBindInfo.hasTemplate) ? this.getBindingInfo("items").template : null;

		oTemp["type"] = "{00100000-2012-0004-B001-383477EA1DEB}";
		if (oBindInfo.P) {
			oTemp["pos.bind"] = oTemp.id + ".P";
		} else {
			oTemp.pos = oVoTemplate.getPosition(); // P is the position
		}
		if (oBindInfo.S) {
			oTemp["scale.bind"] = oTemp.id + ".S";
		} else {
			oTemp.scale = oVoTemplate.getScale(); // S is the scaling
		}

		// the series values...................................................//
		oTemp["series.bind"] = oTemp.id + ".Series"; // bind to the series for all pie instances
		oTemp["text.bind"] = oTemp.id + ".Series.T"; // T is the text
		oTemp["value.bind"] = oTemp.id + ".Series.V"; // V is the value

		return oTemp;
	};

	Pies.prototype.getTypeObject = function() {
		var oType = VoAggregation.prototype.getTypeObject.apply(this, arguments);
		var oBindInfo = this.mBindInfo;

		// extend the object type.................................................//
		if (oBindInfo.P) {
			oType.A.push({
				"changeable": this.getPosChangeable().toString(),
				"name": "P", // position
				"alias": "P",
				"type": "vector"
			});
		}
		if (oBindInfo.S) {
			oType.A.push({
				"changeable": this.getScaleChangeable().toString(),
				"name": "S", // scale
				"alias": "S",
				"type": "vector"
			});
		}
		oType.N = {
			"name": "Series",
			"A": [
				{
					"name": "V", // value
					"alias": "V",
					"type": "float"
				}, {
					"name": "T", // text
					"alias": "T",
					"type": "string"
				}
			]
		};
		return oType;
	};

	Pies.prototype.getActionArray = function() {
		var aActions = VoAggregation.prototype.getActionArray.apply(this, arguments);

		var id = this.getId();

		// check if the different vo events are registered..............................//
		if (this.mEventRegistry["click"] || this.isEventRegistered("click")) {
			aActions.push({
				"id": id + "1",
				"name": "click",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "Click",
				"AddActionProperty": [
					{
						"name": "pos"
					}
				]
			});
		}
		if (this.mEventRegistry["contextMenu"] || this.isEventRegistered("contextMenu")) {
			aActions.push({
				"id": id + "2",
				"name": "contextMenu",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "ContextMenu"
			});
		}
		if (this.mEventRegistry["drop"] || this.isEventRegistered("drop")) {
			aActions.push({
				"id": id + "3",
				"name": "drop",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "Drop"
			});
		}

		return aActions;
	};

	// ..........................................................................//
	// helper functions.........................................................//

	return Pies;

});

}; // end of sap/ui/vbm/Pies.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Route') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.Route.
jQuery.sap.declare('sap.ui.vbm.Route'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/Route",[
	'./VoBase', './library'
], function(VoBase, library) {
	"use strict";

	/**
	 * Constructor for a new Route.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Specific Visual Object element for a <i>Route</i>. A Route is a polyline, which is given as a list of geo-coordinates. In order to
	 *        indicate direction an arrow head can be added at start and end. Further it is possible to have a dot at each point of the coordinate
	 *        list.<br>
	 *        Since the actual length of a route depends on the zoom level it might be only partly visible. Thus detail windows will be dynamically
	 *        positioned in the middle of the visible route part.<br>
	 *        A Route supports GeoMap internal drag'n drop with fine grained control on matching drag sources and drop targets. A drag'n drop
	 *        operation is possible if any type in the drag source aggregation of the dragged visual object matches a type in the drop target
	 *        aggregation of the target vo. Drag source and drop target types defined on element level apply only for a single element instance,
	 *        except the element is used as template.
	 * @extends sap.ui.vbm.VoBase
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.Route
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var Route = VoBase.extend("sap.ui.vbm.Route", /** @lends sap.ui.vbm.Route.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * The position array of the route. The format is "lon0;lat0;0;...lonN;latN;0".
				 */
				position: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * The color of the route.
				 */
				color: {
					type: "string",
					group: "Misc",
					defaultValue: 'RGB(0;0;0)'
				},

				/**
				 * The start point type of the route.
				 * <ul>
				 * <li>0: no startpoint
				 * <li>1: arrow head as startpoint
				 * </ul>
				 */
				start: {
					type: "string",
					group: "Misc",
					defaultValue: '0'
				},

				/**
				 * The end point type of the route.
				 * <ul>
				 * <li>0: no endpoint
				 * <li>1: arrow as endpoint
				 * </ul>
				 */
				end: {
					type: "string",
					group: "Misc",
					defaultValue: '0'
				},

				/**
				 * The width of the route line. With width 0 no line is drawn.
				 */
				linewidth: {
					type: "string",
					group: "Misc",
					defaultValue: '3'
				},

				/**
				 * The color for the line dots of a route.
				 */
				dotcolor: {
					type: "string",
					group: "Misc",
					defaultValue: 'RGB(0;0;0)'
				},

				/**
				 * The border color of the line dots of a route.
				 */
				dotbordercolor: {
					type: "string",
					group: "Misc",
					defaultValue: 'RGB(0;0;0)'
				},

				/**
				 * The border color of the route.
				 */
				colorBorder: {
					type: "string",
					group: "Misc"
				},

				/**
				 * Defines the dashing style of the route using an array. The first value gives the length of the stroke and the second the length of
				 * the gap. Thus "1;1", would result in a doted line. However, strokes are painted with rounded endings. Thus the actual stroke length
				 * depends also on the line width. As a sample a stroke of 1 pixel length and a line width of 6 will result in at least 6 pixels total
				 * length. In that case the line dashing should be set to "1;6" for an equal length of stroke and gap!<br>
				 * The line dashing array can be extended to achive more complex pattern, e.g. "1;1;5;2" and so on.
				 */
				lineDash: {
					type: "string",
					group: "Misc"
				},

				/**
				 * The diameter of a dot in a route.
				 */
				dotwidth: {
					type: "string",
					group: "Misc",
					defaultValue: '0'
				},
				/**
				 * Defines the type of the route, default is 'Straight'. Other types are 'Geodesic' which show the shortest path between two points,
				 * e.g. flightroutes
				 * 
				 * @experimental Since 1.32.0 this method is experimental and might be modified or removed in future versions.
				 */
				routetype: {
					type: "sap.ui.vbm.RouteType",
					group: "Misc",
					defaultValue: 'Straight'
				},

				/**
				 * Set to true if intermediate triangles along the route should show the direction only applicable if arrow head is defined ( start
				 * and/or end ) it is not recommended to use line dots in addition because the direction indicators generate additional line
				 * points at their head and base positions
				 */
				directionIndicator: {
					type: "boolean",
					group: "Misc",
					defaultValue: false
				}
			},
			aggregations: {

				/**
				 * DragSource aggregation
				 */
				dragSource: {
					type: "sap.ui.vbm.DragSource",
					multiple: true,
					singularName: "dragSource"
				},

				/**
				 * DropTarget aggregation
				 */
				dropTarget: {
					type: "sap.ui.vbm.DropTarget",
					multiple: true,
					singularName: "dropTarget"
				}
			},
			events: {}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.Route.prototype.init = function(){
	// // do something for initialization...
	// };

	// Implement function defined in VoBase
	Route.prototype.openContextMenu = function(oMenu) {
		this.oParent.openContextMenu("Route", this, oMenu);
	};

	Route.prototype.getDataElement = function() {
		var oElement = VoBase.prototype.getDataElement.apply(this, arguments);
		var oBindInfo = this.oParent.mBindInfo;

		// add the VO specific properties..................................//
		if (oBindInfo.P) {
			if (this.getRoutetype() == 'Geodesic') {
				var pos = this.getPosition().split(";");
				var length = pos.length;
				var geo_start = pos.slice(0, 3);
				var geo_end = pos.slice(length - 3, length);
				var route = this.calcGeodesicRoute(geo_start, geo_end);
				oElement.P = geo_start[0] + ';' + geo_start[1] + ';0.0;' + route + geo_end[0] + ';' + geo_end[1] + ';0.0';
			} else {
				oElement.P = this.getPosition();
			}
		}
		if (oBindInfo.C) {
			oElement.C = this.getColor();
		}
		if (oBindInfo.ST) {
			oElement.ST = this.getStart();
		}
		if (oBindInfo.ED) {
			oElement.ED = this.getEnd();
		}
		if (oBindInfo.LW) {
			oElement.LW = this.getLinewidth();
		}
		if (oBindInfo.DC) {
			oElement.DC = this.getDotcolor();
		}
		if (oBindInfo.DBC) {
			oElement.DBC = this.getDotbordercolor();
		}
		if (oBindInfo.CB) {
			var cb = this.getColorBorder();
			if (cb != undefined && cb != "") {
				oElement.CB = cb;
			}
		}
		if (oBindInfo.LD) {
			var ld = this.getLineDash();
			if (ld != undefined && ld != "") {
				oElement.LD = ld;
			}
		}
		if (oBindInfo.DW) {
			oElement.DW = this.getDotwidth();
		}
		if (oBindInfo.DS || oBindInfo.DT) {
			oElement.N = this.getDragDropDefs();
		}
		if (oBindInfo.DI) {
			oElement.DI = this.getDirectionIndicator();
		}

		return oElement;
	};

	Route.prototype.handleChangedData = function(oElement) {
		if (oElement.P) {
			this.setPosition(oElement.P);
		}
	};
	
	/*
	 * @private
	 */
	Route.prototype.dot = function(a, b) {
		var c = 0;
		c = a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
		return c;
	};
	
	/*
	 * @private
	 */
	Route.prototype.cross = function(a, b) {
		var c = new Array(4);
		c[1] = a[2] * b[3] - a[3] * b[2];
		c[2] = a[3] * b[1] - a[1] * b[3];
		c[3] = a[1] * b[2] - a[2] * b[1];
		return c;
	};
	
	/*
	 * @private
	 */
	Route.prototype.radians = function(degrees) {
		return degrees * Math.PI / 180;
	};
	
	/*
	 * @private
	 */
	Route.prototype.degrees = function(radians) {
		return radians * 180 / Math.PI;
	};
	
	/*
	 * @private
	 */
	Route.prototype.calcGeodesicRoute = function(geo_start, geo_end) {
		var x_start = new Array(4); // Vektoren
		var x_end = new Array(4);
		var u = new Array(4);
		var u_norm = new Array(4);
		var v = new Array(4);

		x_start[1] = Math.cos(this.radians(geo_start[1])) * Math.cos(this.radians(geo_start[0]));
		x_start[2] = Math.cos(this.radians(geo_start[1])) * Math.sin(this.radians(geo_start[0]));
		x_start[3] = Math.sin(this.radians(geo_start[1]));

		x_end[1] = Math.cos(this.radians(geo_end[1])) * Math.cos(this.radians(geo_end[0]));
		x_end[2] = Math.cos(this.radians(geo_end[1])) * Math.sin(this.radians(geo_end[0]));
		x_end[3] = Math.sin(this.radians(geo_end[1]));

		// var angle_rad = radians(geo_end[0] - geo_start[0]);
		// var angle_deg = degrees(angle_rad);

		u = this.cross(x_start, x_end);
		var length = Math.sqrt(this.dot(u, u));
		u_norm[1] = u[1] / length;
		u_norm[2] = u[2] / length;
		u_norm[3] = u[3] / length;

		v = this.cross(u_norm, x_start);

		var flight = new Array(101);
		var flight_geo = new Array(201);
		var i;
		for (i = 0; i <= 100; i++) {
			flight[i] = new Array(4);
			flight_geo[i] = new Array(4);
		}

		// var step_geo = (geo_end[1] - geo_start[1]) / 100;
		// var step_rad = radians(step_geo);
		var angle_r = Math.acos(this.dot(x_start, x_end));
		// var angle_de = degrees(angle_r);

		var route = "";

		for (i = 0; i <= 100; i++) {
			var t = i / 100 * angle_r;

			flight[i][0] = 0;
			flight[i][1] = Math.cos(t) * x_start[1] + Math.sin(t) * v[1]; // x - coordinate
			flight[i][2] = Math.cos(t) * x_start[2] + Math.sin(t) * v[2]; // y - coordinate
			flight[i][3] = Math.cos(t) * x_start[3] + Math.sin(t) * v[3]; // z - coordinate

			flight_geo[i][0] = 0;
			flight_geo[i][1] = this.degrees(Math.atan2(flight[i][2], flight[i][1])); // lon - coordinate
			flight_geo[i][2] = this.degrees(Math.asin(flight[i][3])); // lat - coordinate

			route += flight_geo[i][1] + ';' + flight_geo[i][2] + '; 0 ' + ';';
		}
		return route;
	};

	return Route;

});

}; // end of sap/ui/vbm/Route.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Routes') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.Routes.
jQuery.sap.declare('sap.ui.vbm.Routes'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/Routes",[
	'./VoAggregation', './library'
], function(VoAggregation, library) {
	"use strict";

	/**
	 * Constructor for a new Routes.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Type specific Visual Object aggregation for <i>Route</i> elements.<br>
	 *        Routes support GeoMap internal drag'n drop with fine grained control on matching drag sources and drop targets. A drag'n drop operation
	 *        is possible if any type in the drag source aggregation of the dragged visual object matches a type in the drop target aggregation of the
	 *        target vo. If drag source and drop target types are defined on aggregation level they apply for all aggregated elements.
	 * @extends sap.ui.vbm.VoAggregation
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.Routes
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var Routes = VoAggregation.extend("sap.ui.vbm.Routes", /** @lends sap.ui.vbm.Routes.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * Set to true if position may be changed at runtime. The actual changeability is control on each aggregated element with property
				 * <i>changeable</i>.
				 */
				posChangeable: {
					type: "boolean",
					group: "Misc",
					defaultValue: true
				}
			},
			defaultAggregation: "items",
			aggregations: {

				/**
				 * Route object aggregation
				 */
				items: {
					type: "sap.ui.vbm.Route",
					multiple: true,
					singularName: "item"
				},

				/**
				 * DragSource aggregation
				 */
				dragSource: {
					type: "sap.ui.vbm.DragSource",
					multiple: true,
					singularName: "dragSource"
				},

				/**
				 * DropTarget aggregation
				 */
				dropTarget: {
					type: "sap.ui.vbm.DropTarget",
					multiple: true,
					singularName: "dropTarget"
				}
			},
			events: {

				/**
				 * The event is raised when there is a click action on a Route.
				 */
				click: {},

				/**
				 * The event is raised when there is a right click or a tap and hold action on a Route.
				 */
				contextMenu: {},

				/**
				 * The event is raised when something is dropped on a Route.
				 */
				drop: {}
			}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.Routes.prototype.init = function(){
	// // do something for initialization...
	// };

	// ...........................................................................//
	// model creators...........................................................//

	Routes.prototype.getBindInfo = function() {
		var oBindInfo = VoAggregation.prototype.getBindInfo.apply(this, arguments);
		var oTemplateBindingInfo = this.getTemplateBindingInfo();

		// Note: Without Template no static properties -> all bound in the sense of VB JSON!
		oBindInfo.P = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("position") : true;
		oBindInfo.C = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("color") : true;
		oBindInfo.ST = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("start") : true;
		oBindInfo.ED = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("end") : true;
		oBindInfo.LW = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("linewidth") : true;
		oBindInfo.DC = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("dotcolor") : true;
		oBindInfo.DW = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("dotwidth") : true;
		oBindInfo.DBC = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("dotbordercolor") : true;
		oBindInfo.CB = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("colorBorder") : true;
		oBindInfo.LD = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("lineDash") : true;
		oBindInfo.DI = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("directionIndicator") : true;

		return oBindInfo;
	};

	Routes.prototype.getTemplateObject = function() {
		// get common template from base class (VoAggregation)
		var oTemp = VoAggregation.prototype.getTemplateObject.apply(this, arguments);

		var oBindInfo = this.mBindInfo = this.getBindInfo();
		var oVoTemplate = (oBindInfo.hasTemplate) ? this.getBindingInfo("items").template : null;

		oTemp["type"] = "{00100000-2012-0004-B001-C46BD7336A1A}";
		if (oBindInfo.P) {
			oTemp["posarray.bind"] = oTemp.id + ".P";
		} else {
			oTemp.posarray = oVoTemplate.getPosition(); // P is the position array
		}
		if (oBindInfo.C) {
			oTemp["color.bind"] = oTemp.id + ".C";
		} else {
			oTemp.color = oVoTemplate.getColor(); // C is the color
		}
		if (oBindInfo.ST) {
			oTemp["start.bind"] = oTemp.id + ".ST";
		} else {
			oTemp.start = oVoTemplate.getStart(); // ST is the start style
		}
		if (oBindInfo.ED) {
			oTemp["end.bind"] = oTemp.id + ".ED";
		} else {
			oTemp.end = oVoTemplate.getEnd(); // ED is the end style
		}
		if (oBindInfo.LW) {
			oTemp["linewidth.bind"] = oTemp.id + ".LW";
		} else {
			oTemp.linewidth = oVoTemplate.getLinewidth(); // LW is the linewidth
		}
		if (oBindInfo.DC) {
			oTemp["dotcolor.bind"] = oTemp.id + ".DC";
		} else {
			oTemp.dotcolor = oVoTemplate.getDotcolor(); // DC is the dotcolor
		}
		if (oBindInfo.DBC) {
			oTemp["dotbordercolor.bind"] = oTemp.id + ".DBC";
		} else {
			oTemp.dotbordercolor = oVoTemplate.getDotbordercolor(); // DBC is the dotborder color
		}
		if (oBindInfo.CB) {
			oTemp["colorBorder.bind"] = oTemp.id + ".CB";
		} else {
			oTemp.colorBorder = oVoTemplate.getColorBorder(); // CB is the border color
		}
		if (oBindInfo.LD) {
			oTemp["lineDash.bind"] = oTemp.id + ".LD";
		} else {
			oTemp.lineDash = oVoTemplate.getLineDash(); // LD is the line dashing array
		}
		if (oBindInfo.DW) {
			oTemp["dotwidth.bind"] = oTemp.id + ".DW";
		} else {
			oTemp.dotwidth = oVoTemplate.getDotwidth(); // DW is the dot width // DD is the dragData
		}
		if (oBindInfo.DI) {
			oTemp["directionIndicator.bind"] = oTemp.id + ".DI";
		} else {
			oTemp.directionIndicator = oVoTemplate.getDirectionIndicator(); 
		}
		oTemp["DragSource"] = {
			"DragItem": this.getDragItemTemplate(oTemp.id)
		};
		oTemp["DropTarget"] = {
			"DropItem": this.getDropItemTemplate(oTemp.id)
		};

		return oTemp;
	};

	Routes.prototype.getTypeObject = function() {
		var oType = VoAggregation.prototype.getTypeObject.apply(this, arguments);
		var oBindInfo = this.mBindInfo;

		// extend the object type.................................................//
		if (oBindInfo.P) {
			oType.A.push({
				"changeable": this.getPosChangeable().toString(),
				"name": "P", // position
				"alias": "P",
				"type": "vector"
			});
		}
		if (oBindInfo.C) {
			oType.A.push({
				"name": "C", // color
				"alias": "C",
				"type": "color"
			});
		}
		if (oBindInfo.ST) {
			oType.A.push({
				"name": "ST", // start type
				"alias": "ST",
				"type": "long"
			});
		}
		if (oBindInfo.ED) {
			oType.A.push({
				"name": "ED", // end type
				"alias": "ED",
				"type": "long"
			});
		}
		if (oBindInfo.LW) {
			oType.A.push({
				"name": "LW", // linewidth
				"alias": "LW",
				"type": "float"
			});
		}
		if (oBindInfo.DC) {
			oType.A.push({
				"name": "DC", // dotcolor
				"alias": "DC",
				"type": "color"
			});
		}
		if (oBindInfo.DBC) {
			oType.A.push({
				"name": "DBC", // dotbordercolor
				"alias": "DBC",
				"type": "color"
			});
		}
		if (oBindInfo.CB) {
			oType.A.push({
				"name": "CB", // bordercolor
				"alias": "CB",
				"type": "color"
			});
		}
		if (oBindInfo.LD) {
			oType.A.push({
				"name": "LD", // linedash
				"alias": "LD",
				"type": "string"
			});
		}
		if (oBindInfo.DW) {
			oType.A.push({
				"name": "DW", // dot diameter
				"alias": "DW",
				"type": "float"
			});
		}
		if (oBindInfo.DI) {
			oType.A.push({
				"name": "DI", // dot diameter
				"alias": "DI",
				"type": "boolean"
			});
		}
		return oType;
	};

	Routes.prototype.getActionArray = function() {
		var aActions = VoAggregation.prototype.getActionArray.apply(this, arguments);

		var id = this.getId();

		// check if the different vo events are registered..............................//
		if (this.mEventRegistry["click"] || this.isEventRegistered("click")) {
			aActions.push({
				"id": id + "1",
				"name": "click",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "Click",
				"AddActionProperty": [
					{
						"name": "pos"
					}
				]
			});
		}
		if (this.mEventRegistry["contextMenu"] || this.isEventRegistered("contextMenu")) {
			aActions.push({
				"id": id + "2",
				"name": "contextMenu",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "ContextMenu"
			});
		}
		if (this.mEventRegistry["drop"] || this.isEventRegistered("drop")) {
			aActions.push({
				"id": id + "3",
				"name": "drop",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "Drop"
			});
		}

		return aActions;
	};

	// ..........................................................................//
	// helper functions.........................................................//

	return Routes;

});

}; // end of sap/ui/vbm/Routes.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Spot') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.Spot.
jQuery.sap.declare('sap.ui.vbm.Spot'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.core.theming.Parameters'); // unlisted dependency retained
sap.ui.define("sap/ui/vbm/Spot",[
	'sap/ui/core/theming/Parameters', './VoBase', './library'
], function(Parameters, VoBase, library) {
	"use strict";

	/**
	 * Constructor for a new Spot.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Specific Visual Object element for a <i>Spot</i>. A Spot is actually an image drawn at the given <i>position</i>. There are two modes
	 *        for using spots:
	 *        <ul>
	 *        <li>A controlled mode by providing a spot type. In this mode many properties for the spot are automatically set by programmed defaults
	 *        according to the Fiori guidelines.</li>
	 *        <li>A freestyle mode, providing the full control on colors and layout.</li>
	 *        </ul>
	 *        Beside the visualization with an image a spot can have an <i>icon</i> or <i>text</i>, which can be controlled and positioned using the
	 *        content properties. <br>
	 *        A Spot supports GeoMap internal drag'n drop with fine grained control on matching drag sources and drop targets. A drag'n drop operation
	 *        is possible if any type in the drag source aggregation of the dragged visual object matches a type in the drop target aggregation of the
	 *        target vo. Drag source and drop target types defined on element level apply only for a single element instance, except the element is
	 *        used as template.
	 * @extends sap.ui.vbm.VoBase
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.Spot
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var Spot = VoBase.extend("sap.ui.vbm.Spot", /** @lends sap.ui.vbm.Spot.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * The position of the spot. The format is "lon;lat;0"
				 */
				position: {
					type: "string",
					group: "Misc",
					defaultValue: '0;0;0'
				},

				/**
				 * The text that is displayed on the spot. The text should not exceed a few characters. Note that either text or icon may be displayed (
				 * not both together ).
				 */
				text: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * The image for the spot. This must be a reference to a resource.
				 */
				image: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * Alignment of the spot to its position:
				 * <ul>
				 * <li>0: center
				 * <li>1: top center
				 * <li>2: top right
				 * <li>3: center right
				 * <li>4: bottom right
				 * <li>5: bottom center
				 * <li>6: bottom left
				 * <li>7: center left
				 * <li>8: top left
				 * </ul>
				 */
				alignment: {
					type: "string",
					group: "Misc",
					defaultValue: '5'
				},

				/**
				 * The scale of the spot. The format is "x-Scale;y-Scale;z-Scale". The z-Scale is curretly ignored.
				 */
				scale: {
					type: "string",
					group: "Misc",
					defaultValue: '1;1;1'
				},

				/**
				 * The image for the spot when selected. This must be a reference to a resource.
				 */
				imageSelected: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * The icon to be rendered on the spot. Note that either text or icon may be displayed ( not both together ). Use the CharCode-Id of
				 * SAPUI5-Icons (e.g.: "\ue146")
				 */
				icon: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * The color of the content ( icon or text ).
				 */
				contentColor: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * The offset from the center of the image where to place the content ( text or icon ) in x;y- direction
				 */
				contentOffset: {
					type: "string",
					group: "Misc",
					defaultValue: '0;0'
				},

				/**
				 * The font of the spot's text. If icon is used then the font is automatically set to"SAP-icons".
				 */
				contentFont: {
					type: "string",
					group: "Misc",
					defaultValue: 'arial'
				},

				/**
				 * The font size to be used for text or icon
				 */
				contentSize: {
					type: "string",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * Spot type for semantic spots. A given semantic type will overrule settings for image, scale, and content.
				 */
				type: {
					type: "sap.ui.vbm.SemanticType",
					group: "Behavior",
					defaultValue: null
				}
			},
			aggregations: {

				/**
				 * DragSource aggregation
				 */
				dragSource: {
					type: "sap.ui.vbm.DragSource",
					multiple: true,
					singularName: "dragSource"
				},

				/**
				 * DropTarget aggregation
				 */
				dropTarget: {
					type: "sap.ui.vbm.DropTarget",
					multiple: true,
					singularName: "dropTarget"
				}
			},
			events: {}
		}
	});

	Spot.prototype.init = function() {
		// set control specific property defaults
		// explicitly set properties will still be applied later!
		this.mProperties.contentColor = (Parameters) ? Parameters.get("sapUiButtonTextColor") : "#000";
		this.mProperties.contentSize = (Parameters) ? Parameters.get("sapMFontMediumSize") : null;
	};

	// Implement function defined in VoBase
	Spot.prototype.openContextMenu = function(oMenu) {
		this.getParent().openContextMenu("Spot", this, oMenu);
	};

	Spot.prototype.getImageProps = function(type, txtLen, bHasIcon) {
		var oElement = {};

		if (type !== sap.ui.vbm.SemanticType.None) {
			if (type === sap.ui.vbm.SemanticType.Hidden) {
				oElement.I = "Pin_Hidden.png";
			} else {
				if (type === sap.ui.vbm.SemanticType.Error) {
					oElement.I = "Pin_Red_";
				}
				if (type === sap.ui.vbm.SemanticType.Warning) {
					oElement.I = "Pin_Orange_";
				}
				if (type === sap.ui.vbm.SemanticType.Success) {
					oElement.I = "Pin_Green_";
				}
				if (type === sap.ui.vbm.SemanticType.Inactive) {
					oElement.I = "Pin_Grey_";
				}
				if (type === sap.ui.vbm.SemanticType.Default) {
					oElement.I = "Pin_Blue_";
				}
				if (txtLen) {
					if (txtLen > 3) {
						oElement.I += "5-digit_space.png";
						oElement.CO = "15;-3";
					} else if (txtLen > 1) {
						oElement.I += "3-digit_space.png";
						oElement.CO = "9;-3";
					} else {
						oElement.I += "1-digit.png";
						oElement.CO = "0;-3";
					}
				} else if (oElement.I) {
					oElement.I += (bHasIcon) ? "1_Icon.png" : "0_Icon.png";
					if (bHasIcon) {
						oElement.CO = "0;-5";
					}
				}
			}

			if (oElement.I) {
				this.getParent().getParent().addResourceIfNeeded(oElement.I);
			}
		}

		return oElement;
	};

	Spot.prototype.getDataElement = function() {

		var oElement = VoBase.prototype.getDataElement.apply(this, arguments);
		var oBindInfo = this.oParent.mBindInfo;

		// add the VO specific properties..................................//
		if (oBindInfo.P) {
			oElement.P = this.getPosition();
		}
		if (oBindInfo.S) {
			oElement.S = this.getScale();
		}
		if (oBindInfo.T) {
			oElement.T = this.getText();
		}
		if (oBindInfo.I) {
			oElement.I = this.getImage();
		}
		if (oBindInfo.IS) {
			oElement.IS = this.getImageSelected();
		}
		if (oBindInfo.AL) {
			oElement.AL = this.getAlignment();
		}
		if (oBindInfo.IC) {
			oElement.IC = this.getIcon();
		}
		if (oBindInfo.CC) {
			oElement.CC = this.getContentColor();
		}
		if (oBindInfo.CO) {
			oElement.CO = this.getContentOffset();
		}
		if (oBindInfo.CF) {
			oElement.CF = this.getContentFont();
		}
		if (oBindInfo.CS) {
			oElement.CS = this.getContentSize();
		}
		if (oBindInfo.DS || oBindInfo.DT) {
			oElement.N = this.getDragDropDefs();
		}

		// get the image properties for this instance
		var txt = this.getText(); // Note: Use getter since text may be static/not bound! 
		var txtLen = txt ? txt.length : 0;
		var icon = this.getIcon(); // Note: Use getter since icon may be static/not bound!
		var bHasIcon = (icon.length > 0 ) ? true : false;

		var oElem = this.getImageProps(this.getType(), txtLen, bHasIcon);
		if (oElem.I) {
			oElement.I = oElem.I;
		}
		if (oElem.CO) {
			oElement.CO = oElem.CO;
		}

		return oElement;
	};

	Spot.prototype.handleChangedData = function(oElement) {
		if (oElement.P) {
			this.setPosition(oElement.P);
		}
		if (oElement.S) {
			this.setScale(oElement.S);
		}
	};

	return Spot;

});

}; // end of sap/ui/vbm/Spot.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Spots') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.Spots.
jQuery.sap.declare('sap.ui.vbm.Spots'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/Spots",[
	'./VoAggregation', './library'
], function(VoAggregation, library) {
	"use strict";

	/**
	 * Constructor for a new Spots.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Type specific Visual Object aggregation for <i>Spot</i> elements.<br>
	 *        Spots support GeoMap internal drag'n drop with fine grained control on matching drag sources and drop targets. A drag'n drop operation
	 *        is possible if any type in the drag source aggregation of the dragged visual object matches a type in the drop target aggregation of the
	 *        target vo. If drag source and drop target types are defined on aggregation level they apply for all aggregated elements.
	 * @extends sap.ui.vbm.VoAggregation
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.Spots
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var Spots = VoAggregation.extend("sap.ui.vbm.Spots", /** @lends sap.ui.vbm.Spots.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * Set to true if position may be changed at runtime. The actual changeability is control on each aggregated element with property
				 * <i>changeable</i>.
				 */
				posChangeable: {
					type: "boolean",
					group: "Misc",
					defaultValue: true
				},

				/**
				 * Set to true if scale may be changed at runtime. The actual changeability is control on each aggregated element with property
				 * <i>changeable</i>.
				 */
				scaleChangeable: {
					type: "boolean",
					group: "Misc",
					defaultValue: true
				}
			},
			defaultAggregation: "items",
			aggregations: {

				/**
				 * spot object aggregation
				 */
				items: {
					type: "sap.ui.vbm.Spot",
					multiple: true,
					singularName: "item"
				},

				/**
				 * DragSource aggregation
				 */
				dragSource: {
					type: "sap.ui.vbm.DragSource",
					multiple: true,
					singularName: "dragSource"
				},

				/**
				 * DropTarget aggregation
				 */
				dropTarget: {
					type: "sap.ui.vbm.DropTarget",
					multiple: true,
					singularName: "dropTarget"
				}
			},
			events: {
				
			}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	// sap.ui.vbm.Spots.prototype.init = function(){
	// // do something for initialization...
	// };

	// ...........................................................................//
	// model creators...........................................................//

	Spots.prototype.getBindInfo = function() {
		var oBindInfo = VoAggregation.prototype.getBindInfo.apply(this, arguments);
		var oTemplateBindingInfo = this.getTemplateBindingInfo();

		// Note: Without Template no static properties -> all bound in the sense of VB JSON!
		oBindInfo.S = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("scale") : true;
		oBindInfo.I = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("image") : true;
		oBindInfo.IS = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("imageSelected") : true;
		oBindInfo.P = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("position") : true;
		oBindInfo.T = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("text") : true;
		oBindInfo.AL = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("alignment") : true;
		oBindInfo.IC = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("icon") : true;
		oBindInfo.CC = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("contentColor") : true;
		oBindInfo.CO = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("contentOffset") : true;
		oBindInfo.CF = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("contentFont") : true;
		oBindInfo.CS = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("contentSize") : true;
		oBindInfo.Type = (oTemplateBindingInfo) ? oTemplateBindingInfo.hasOwnProperty("type") : true;

		return oBindInfo;
	};

	Spots.prototype.getTemplateObject = function() {
		// get common template from base class (VoAggregation)
		var oTemp = VoAggregation.prototype.getTemplateObject.apply(this, arguments);

		var oBindInfo = this.mBindInfo = this.getBindInfo();
		var oVoTemplate = (oBindInfo.hasTemplate) ? this.getBindingInfo("items").template : null;

		if (oBindInfo.Type || oVoTemplate.mProperties["type"] !== sap.ui.vbm.SemanticType.None) {
			// type is given -> set all properties influenced by the type to bound
			// the actual influence of the type is determined in Spot.getDataElement()
			oBindInfo.T = oBindInfo.I = oBindInfo.CO = oBindInfo.CC = true;
		}

		oTemp["type"] = "{00100000-2012-0004-B001-64592B8DB964}";
		if (oBindInfo.P) {
			oTemp["pos.bind"] = oTemp.id + ".P";
		} else {
			oTemp.pos = oVoTemplate.getPosition(); // P is the position
		}
		if (oBindInfo.IC) {
			oTemp["icon.bind"] = oTemp.id + ".IC";
		} else {
			oTemp.icon = oVoTemplate.getIcon(); // IC is the icon
		}
		if (oBindInfo.S) {
			oTemp["scale.bind"] = oTemp.id + ".S";
		} else {
			oTemp.scale = oVoTemplate.getScale(); // S is the scaling
		}
		if (oBindInfo.IS) {
			oTemp["imageSelected.bind"] = oTemp.id + ".IS";
		} else {
			oTemp.imageSelected = oVoTemplate.getImageSelected(); // IS is the image when selected
		}
		if (oBindInfo.AL) {
			oTemp["alignment.bind"] = oTemp.id + ".AL";
		} else {
			oTemp.alignment = oVoTemplate.getAlignment(); // AL is the alignment
		}
		if (oBindInfo.CF) {
			oTemp["contentFont.bind"] = oTemp.id + ".CF";
		} else {
			oTemp.contentFont = oVoTemplate.getContentFont(); // CF is the the font for icon/text
		}
		if (oBindInfo.CS) {
			oTemp["contentSize.bind"] = oTemp.id + ".CS";
		} else {
			oTemp.contentSize = oVoTemplate.getContentSize(); // CS is the the font size for icon/text
		}
		if (oBindInfo.T) {
			oTemp["text.bind"] = oTemp.id + ".T";
		} else {
			oTemp.text = oVoTemplate.getText(); // T is the text
		}
		if (oBindInfo.I) {
			oTemp["image.bind"] = oTemp.id + ".I";
		} else {
			oTemp.image = oVoTemplate.getImage(); // I is the image
		}
		if (oBindInfo.CO) {
			oTemp["contentOffset.bind"] = oTemp.id + ".CO";
		} else {
			oTemp.contentOffset = oVoTemplate.getContentOffset(); // CO is the content offset
		}
		if (oBindInfo.CC) {
			oTemp["contentColor.bind"] = oTemp.id + ".CC";
		} else {
			oTemp.contentColor = oVoTemplate.getContentColor(); // CC is the the color of the icon or text
		}

		oTemp["DragSource"] = {
			"DragItem": this.getDragItemTemplate(oTemp.id)
		};
		oTemp["DropTarget"] = {
			"DropItem": this.getDropItemTemplate(oTemp.id)
		};

		return oTemp;
	};

	Spots.prototype.getTypeObject = function() {
		var oType = VoAggregation.prototype.getTypeObject.apply(this, arguments);
		var oBindInfo = this.mBindInfo;

		// extend the object type.................................................//
		if (oBindInfo.P) {
			oType.A.push({
				"changeable": this.getPosChangeable().toString(),
				"name": "P", // position
				"alias": "P",
				"type": "vector"
			});
		}
		if (oBindInfo.S) {
			oType.A.push({
				"changeable": this.getScaleChangeable().toString(),
				"name": "S", // scale
				"alias": "S",
				"type": "vector"
			});
		}
		if (oBindInfo.T) {
			oType.A.push({
				"name": "T", // text
				"alias": "T",
				"type": "string"
			});
		}
		if (oBindInfo.I) {
			oType.A.push({
				"name": "I", // image
				"alias": "I",
				"type": "string"
			});
		}
		if (oBindInfo.IS) {
			oType.A.push({
				"name": "IS", // image selected
				"alias": "IS",
				"type": "string"
			});
		}
		if (oBindInfo.AL) {
			oType.A.push({
				"name": "AL", // alignment
				"alias": "AL",
				"type": "string"
			});
		}
		if (oBindInfo.IC) {
			oType.A.push({
				"name": "IC", // icon
				"alias": "IC",
				"type": "string"
			});
		}
		if (oBindInfo.CC) {
			oType.A.push({
				"name": "CC", // contentColor
				"alias": "CC",
				"type": "string"
			});
		}
		if (oBindInfo.CO) {
			oType.A.push({
				"name": "CO", // contentOffset
				"alias": "CO",
				"type": "string"
			});
		}
		if (oBindInfo.CF) {
			oType.A.push({
				"name": "CF", // contentFont
				"alias": "CF",
				"type": "string"
			});
		}
		if (oBindInfo.CF) {
			oType.A.push({
				"name": "CS", // contentsize
				"alias": "CS",
				"type": "string"
			});
		}
		return oType;
	};

	Spots.prototype.getActionArray = function(bForce) {
		var aActions = VoAggregation.prototype.getActionArray.apply(this, arguments);

		var id = this.getId();

		// check if the different vo events are registered..............................//
		if (bForce || this.mEventRegistry["click"] || this.isEventRegistered("click")) {
			aActions.push({
				"id": id + "1",
				"name": "click",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "Click",
				"AddActionProperty": [
					{
						"name": "pos"
					}
				]
			});
		}
		if (bForce || this.mEventRegistry["contextMenu"] || this.isEventRegistered("contextMenu")) {
			aActions.push({
				"id": id + "2",
				"name": "contextMenu",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "ContextMenu"
			});
		}
		if (bForce || this.mEventRegistry["drop"] || this.isEventRegistered("drop")) {
			aActions.push({
				"id": id + "3",
				"name": "drop",
				"refScene": "MainScene",
				"refVO": id,
				"refEvent": "Drop"
			});
		}

		return aActions;
	};

	// ..........................................................................//
	// helper functions.........................................................//

	return Spots;

});

}; // end of sap/ui/vbm/Spots.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.VBI') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* global VBI */// declare unusual global vars for ESLint/SAPUI5 validation
// Provides control sap.ui.vbm.VBI.
jQuery.sap.declare('sap.ui.vbm.VBI'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('jquery.sap.global'); // unlisted dependency retained
jQuery.sap.require('sap.ui.core.Control'); // unlisted dependency retained
sap.ui.define("sap/ui/vbm/VBI",[
	'jquery.sap.global', './library', 'sap/ui/core/Control', './lib/sapvbi'
], function(jQuery, library, Control, sapvbi) {
	"use strict";

	/**
	 * Constructor for a new VBI.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class The VBI control. This is the Visual Business base control, which is mainly intended to communicate directly with the Visual Business
	 *        Backend API in a proprietary JSON format. This control should not be used directly in a client side application. For this the control
	 *        extension <a href="sap.ui.vbm.GeoMap.html">sap.ui.vbm.GeoMap</a> is recommended.<br>
	 *        The main or high level API of the VBI control is made of
	 *        <ul>
	 *        <li>method <i>load</i> for sending JSON to the control for processing, and</li>
	 *        <li>event <i>submit</i> returning a result JSON as parameter data containing actual event information and changed data.</li>
	 *        </ul>
	 *        Further the high level API provides the thumbnail support.<br>
	 *        Additionally the control offers a low level API made of several events, like render, zoom, move and so on, which allow to render
	 *        application specific content directly on the controls canvas.
	 * @extends sap.ui.core.Control
	 * @author SAP SE
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.VBI
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var VBI1 = Control.extend("sap.ui.vbm.VBI", /** @lends sap.ui.vbm.VBI.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {

				/**
				 * Set the width of the control.
				 */
				width: {
					type: "sap.ui.core.CSSSize",
					group: "Misc",
					defaultValue: '800px'
				},

				/**
				 * Set the height of the control.
				 */
				height: {
					type: "sap.ui.core.CSSSize",
					group: "Misc",
					defaultValue: '600px'
				},

				/**
				 * @deprecated This property should not longer be used. Its functionality is covered by method <code>load</code>.
				 */
				config: {
					type: "object",
					group: "Misc",
					defaultValue: null
				},

				/**
				 * When true, the ActiveX plugin version of Visual Business will be used for rendering. For that the plugin needs to be installed on
				 * the client. Default (false) the control renders on canvas.
				 */
				plugin: {
					type: "boolean",
					group: "Misc",
					defaultValue: false
				},

				/**
				 * Defines whether the rectangular selection mode is active or not
				 */
				rectangularSelection: {
					type: "boolean",
					group: "Misc",
					defaultValue: false
				},

				/**
				 * Defines whether the lasso selection mode is active or not
				 */
				lassoSelection: {
					type: "boolean",
					group: "Misc",
					defaultValue: false
				},

				/**
				 * Defines whether the rectangular zoom mode is active or not
				 */
				rectZoom: {
					type: "boolean",
					group: "Misc",
					defaultValue: false
				},
				/**
				 * Allow repeating of keyboard events when key is pressed and hold.
				 */
				allowKeyEventRepeat: {
					type: "boolean",
					group: "Behavior",
					defaultValue: true
				},
				/**
				 * Miminum delay between keyboard events. Used to reduce frequency of keyboard events.
				 */
				keyEventDelay: {
					type: "int",
					group: "Behavior",
					defaultValue: 250
				}
			},
			events: {

				/**
				 * High level API. Submit event is raised.
				 */
				submit: {
					parameters: {

						/**
						 * JSON (or possibly XML and case the plugin is used) string describing the delta state of Visual Business and the information
						 * about the event.
						 */
						data: {
							type: "string"
						}
					}
				},

				/**
				 * High level API. ThumbnailClick event is raised.
				 */
				thumbnailClick: {
					parameters: {

						/**
						 * Geo coordinates in format "lon;lat;0"
						 */
						pos: {
							type: "string"
						},

						/**
						 * Level of detail.
						 */
						zoomLevel: {
							type: "int"
						}
					}
				},

				/**
				 * Low level API. Rendering of the canvas content is reqested. This event can be used to do custom rendering into the Visual Business
				 * overlay canvas. This function is not supported in plugin mode.
				 */
				render: {
					parameters: {

						/**
						 * Canvas object to render into.
						 */
						canvas: {
							type: "object"
						}
					}
				},

				/**
				 * Low level API. Tracking mode is set or reset. This function is not supported in plugin mode.
				 */
				changeTrackingMode: {
					parameters: {

						/**
						 * tracking mode to set or reset
						 */
						mode: {
							type: "int"
						},

						/**
						 * set or reset the mode
						 */
						bSet: {
							type: "boolean"
						}

					}
				},

				/**
				 * Low level API. The canvas is zoomed. This function is not supported in plugin mode.
				 */
				zoom: {
					parameters: {

						/**
						 * Canvas object to render into
						 */
						canvas: {
							type: "object"
						}
					}
				},

				/**
				 * Low level API. The canvas was moved. This function is not supported in plugin mode.
				 */
				move: {
					parameters: {

						/**
						 * Canvas object to render into.
						 */
						canvas: {
							type: "object"
						}
					}
				},

				/**
				 * The event is raised before a Visual Business window is opened. It is intended to be used to place arbitrary content in e.g. a
				 * Detail Window. This event is not supported in plugin mode.
				 */
				openWindow: {
					parameters: {

						/**
						 * DomRef of placeholder Div to render into.
						 */
						contentarea: {
							type: "object"
						},

						/**
						 * ID of the window that is opened.
						 */
						id: {
							type: "string"
						}
					}
				},

				/**
				 * The event is raised before a Visual Business window is closed. This function is not supported in plugin mode.
				 */
				closeWindow: {
					parameters: {

						/**
						 * DomRef of placeholder Div for content.
						 */
						contentarea: {
							type: "object"
						},

						/**
						 * ID of the window that is closed.
						 */
						id: {
							type: "string"
						}
					}
				},

				/**
				 * The event is raised when a Visual Business container VO instance is created. It is intended to be used to place arbitrary content
				 * in e.g. other controls. This event is not supported in plugin mode.
				 */
				containerCreated: {
					parameters: {

						/**
						 * DomRef of placeholder Div to render into.
						 */
						contentarea: {
							type: "object"
						},

						/**
						 * ID of the container that was created.
						 */
						id: {
							type: "string"
						}
					}
				},

				/**
				 * The event is raised before a Visual Business container VO instance is destroyed. This function is not supported in plugin mode.
				 */
				containerDestroyed: {
					parameters: {

						/**
						 * DomRef of placeholder Div of content.
						 */
						contentarea: {
							type: "object"
						},

						/**
						 * ID of the container that is destroyed.
						 */
						id: {
							type: "string"
						}
					}
				}
			}
		}
	});

	// ...........................................................................//
	// This file defines behavior for the control,...............................//
	// ...........................................................................//
	// Map used for storing RichTooltips
	VBI1.RttMap = {};

	VBI1.prototype.exit = function() {
		// create the vbi control context.........................................//
		// alert( "destroy" );
//		this.detachChangeTrackingMode(this.onVBIChangeTrackingMode, this);

		// destroy the vbi control context........................................//
		// or plugin keept resources..............................................//

		if (this.getPlugin()) {
			var pi = this.getPlugInControl();
			if (pi) {
				pi.OnSubmit = null; // unsubscribe event............//
			}
		} else if (this.mVBIContext) {
			this.mVBIContext.clear(); // clear the resources...................//
		}

		if (this.resizeID != "") {
			sap.ui.core.ResizeHandler.deregister(this.resizeID);
			this.resizeID = "";
		}

	};

	VBI1.prototype.resize = function(event) {
		var cntrl = (this.oControl != undefined) ? this.oControl : this;

		var ctx = cntrl.mVBIContext;
		if (ctx) {
			var scene = ctx.GetMainScene();
			if (scene) {
				scene.resizeCanvas(event);
			}
			if (ctx.m_Windows) {
				ctx.m_Windows.NotifyResize();
			}
		}
	};

	VBI1.prototype.init = function() {
		this.m_aLoadQueue = null; // load queue...................//
//		this.attachChangeTrackingMode(this.onVBIChangeTrackingMode, this);
		// create the vbi control context.........................................//
		if (!this.getPlugin()) {
			// just create the context.............................................//
			this.mVBIContext = new VBI.VBIContext(this);
		}
		this.resizeID = "";

		this.m_renderList = [];
	};

	/**
	 * Load application JSON for plugin
	 * @param {string | object} dat Application JSON
	 * @private
	 */
	VBI1.prototype.loadNative = function(dat) {
		var l_vbiId = this.getId();
		var elem = document.getElementById('VBI' + l_vbiId);

		if (!elem) {
			return; // element not found.......................................//
		}
		var sf = function(strVal) {
			// to be compatible with the html version, we skip the root object.....//
			// definition..........................................................//
			try {
				var oD;
				if ((oD = JSON.parse(strVal))) {
					var vb = oD.SAPVB;
					var txt = JSON.stringify(vb, null, '  ');

					// fire the submit..................................................//
					this.fireSubmit({
						data: txt
					});
				}
			} catch (e) {
				if (VBI.m_bTrace) {
					VBI.Trace("Error submitting plugin event");
				}
			}
		};

		if (jQuery.type(dat) == 'object') {
			// input is a json object, convert to sting and load...................//
			var txt = JSON.stringify(dat, null, '  ');
			try {
				elem.Load(txt);
				elem.OnSubmit = sf.bind(this);
			} catch (e) {
			}
		} else if (jQuery.type(dat) == 'string') {
			try {
				elem.Load(dat);
				elem.OnSubmit = sf.bind(this);
			} catch (e) {
			}
		}
	};

	/**
	 * Load application JSON for HTML5 version
	 * @param {string | object} data Application JSON
	 * @private
	 */
	VBI1.prototype.loadHtml = function(data) {
		var l_vbiId = this.getId();

		var dat = null;

		// ensure that data is converted to a json object.........................//
		// when this is a string, due ABAP servers sometimes sets a BOM at the....//
		// beginning of the string we try to skip this............................//
		if (typeof data === 'string') {
			dat = JSON.parse(data.indexOf('{') ? data.substr(data.indexOf('{')) : data);
		} else if (typeof data === 'object') {
			dat = data; // this is already an object
		}
		// return immediately when data can not be interpreted....................//
		if (!dat) {
			return;
		}

		// check for data binding.................................................//
		if (!dat["SAPVB"]) {
			var md;
			if (this.mVBIContext && (md = (new VBI.Adaptor(this.mVBIContext)).CreateLoadData(dat))) {
				this.loadHtml(md);
				return;
			} else {
				return; // this is no valid data..............
			}
		}

		/*
		 * TO DO:
		 * do correct handling when change flags get set
		 */
		var bModifiedData = false;
		var bModifiedScenes = false;
		var bModifiedWindows = false;
		var bModifiedResources = false;
		var bModifiedClustering = false;
		var bModifiedMapConfig = false;

		// the data can be a json object..........................................//
		if (jQuery.type(dat) === 'object') {
			if (dat.SAPVB) {
				// process configuration ...........................................//
				if (dat.SAPVB.Config) {
					// load the configuraiont .......................................//
					this.mVBIContext.GetConfig().load(dat.SAPVB.Config, this.mVBIContext);
				}
				// process resources................................................//
				if (dat.SAPVB.Resources) {
					// load the resources............................................//
					this.mVBIContext.GetResources().load(dat.SAPVB.Resources, this.mVBIContext);
					bModifiedResources = true;
				}
				// process datatypes................................................//
				if (dat.SAPVB.DataTypes) {
					// load the datatype provider....................................//
					if (!this.mVBIContext.m_DataTypeProvider) {
						this.mVBIContext.m_DataTypeProvider = new VBI.DataTypeProvider();
					}

					this.mVBIContext.m_DataTypeProvider.load(dat.SAPVB.DataTypes, this.mVBIContext);
				}
				// process datacontext..............................................//
				if (dat.SAPVB.Data) {
					// load the datacontext..........................................//
					// when the datacontext is loaded, provide the datatype info.....//
					if (!this.mVBIContext.m_DataProvider) {
						this.mVBIContext.m_DataProvider = new VBI.DataProvider();
					}

					this.mVBIContext.m_DataProvider.load(dat.SAPVB.Data, this.mVBIContext);
					bModifiedData = true;
				}
				// process mapproviders.............................................//
				if (dat.SAPVB.MapProviders) {
					// load the mapproviders.........................................//
					if (!this.mVBIContext.m_MapProviders) {
						this.mVBIContext.m_MapProviders = new VBI.MapProviders();
					}
					this.mVBIContext.m_MapProviders.load(dat.SAPVB.MapProviders, this.mVBIContext);
					bModifiedMapConfig = true;
				}
				// process maplayerstacks...........................................//
				if (dat.SAPVB.MapLayerStacks) {
					// load the mapproviders.........................................//
					if (!this.mVBIContext.m_MapLayerStackManager) {
						this.mVBIContext.m_MapLayerStackManager = new VBI.MapLayerStackManager(this.mVBIContext);
					}
					this.mVBIContext.m_MapLayerStackManager.load(dat.SAPVB.MapLayerStacks, this.mVBIContext);
					bModifiedMapConfig = true;
				}
				// process windows..................................................//
				if (dat.SAPVB.Windows) {
					if (!this.mVBIContext.m_Windows) {
						this.mVBIContext.m_Windows = new VBI.Windows();
					}
					this.mVBIContext.m_Windows.load(dat.SAPVB.Windows, this.mVBIContext);
					bModifiedWindows = true;
				}
				// process actions..................................................//
				if (dat.SAPVB.Actions) {
					if (!this.mVBIContext.m_Actions) {
						this.mVBIContext.m_Actions = new VBI.Actions();
					}
					this.mVBIContext.m_Actions.load(dat.SAPVB.Actions, this.mVBIContext);
				}
				// process automations..............................................//
				if (dat.SAPVB.Automation) {
					if (!this.mVBIContext.m_Automations) {
						this.mVBIContext.m_Automations = new VBI.Automations();
					}
					this.mVBIContext.m_Automations.load(dat.SAPVB.Automation, this.mVBIContext);
				}
				// context menues ..................................................//
				if (dat.SAPVB.Menus) {
					if (!this.mVBIContext.m_Menus) {
						this.mVBIContext.m_Menus = new VBI.Menus();
					}
					this.mVBIContext.m_Menus.load(dat.SAPVB.Menus, this.mVBIContext);
				}
				// clustering definition............................................//

				if (dat.SAPVB.Clustering) {
					if (!this.mVBIContext.m_Clustering) {
						this.mVBIContext.m_Clustering = new VBI.Clustering();
					}
					this.mVBIContext.m_Clustering.load(dat.SAPVB.Clustering, this.mVBIContext);
					bModifiedClustering = true;
				}

				// process scenes...................................................//
				// Note: process scenes last! Since it triggers a re-rendering everything should be updated before
				if (dat.SAPVB.Scenes) {
					if (!this.mVBIContext.m_SceneManager) {
						this.mVBIContext.m_SceneManager = new VBI.SceneManager();
					}
					this.mVBIContext.m_SceneManager.load(dat.SAPVB.Scenes, this.mVBIContext);
					bModifiedScenes = true;
				} else if (bModifiedMapConfig) {
					// update GeoScenes only, to refresh internal variables
					var scenes = this.mVBIContext.m_SceneManager.m_SceneArray;
					for (var i = 0; i < scenes.length; ++i) {
						if (scenes[i].RefreshMapLayerStack) {
							scenes[i].RefreshMapLayerStack();
						}
					}
				}
			}

			// notify framework about data modifications...........................//
			if (bModifiedData) {
				if (this.mVBIContext.m_Windows) {
					this.mVBIContext.m_Windows.NotifyDataChange();
				}
			}

			// control context is loaded
			if (bModifiedScenes || bModifiedWindows) {
				if (this.mVBIContext.m_Windows) {
					this.mVBIContext.m_Windows.Awake(l_vbiId);
				}
			}

			if (bModifiedScenes || bModifiedData || bModifiedClustering || bModifiedResources) {
				if (this.mVBIContext.m_Windows) {
					this.mVBIContext.m_Windows.RenderAsync();
				}
			}
		}
	};

	// high level function interface implementation..............................//
	// interface function implementation.........................................//

	/**
	 * High level load function. The function accepts a json string or an already parsed json object. This can be a Visual Business application, any
	 * delta operations on the application or other hierachical data that can be mapped by the Visual Business data provider to the inner Visual
	 * Business data context.
	 * 
	 * @param {string} dat Application JSON to process
	 * @returns {void}
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	VBI1.prototype.load = function(dat) {
		// when the control is not yet rendered, queue the load calls.............//
		if (!this.isRendered()) {
			// create the queue and push load requests.............................//
			if (!this.m_aLoadQueue) {
				this.m_aLoadQueue = [];
			}
			this.m_aLoadQueue.push(dat);
			return;
		}

		// do processing when running as a plugin.................................//
		if (this.getPlugin()) {
			this.loadNative(dat);
		} else {
			this.loadHtml(dat);
		}

		if (this.resizeID == "" && this.mVBIContext.GetMainScene()) {
			this.resize();
			this.resizeID = sap.ui.core.ResizeHandler.register(this, this.resize);
		}
	};

	/**
	 * Returns a Screenshot of the Overlay. Please note that the map cannot be included due to browser restrictions. Function returns the visible part
	 * of the Canvas excluding map, copyright info, navigation control, scaler, legend, detail windows, container elements. Analytic Maps are returned
	 * as they are not treated as "maps" internally. Modes 2 & 3 are experimental, trying to load the map (this may work on inhouse servers with
	 * adapted settings, standard configurations should fail)
	 * 
	 * @param {int} [iMode] 0: Overlay only; 1 (default) and 3: include Labels; 2 and 3: try to include maps (will return "" if not possible)
	 * @returns {string} Base64 encoded picture (PNG format) on success, "" otherwise
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	VBI1.prototype.getPicOfOverlay = function(iMode) {

		var scene = this.mVBIContext.GetMainScene();
		if (!(scene && scene.GetOverlayPicture)) {
			return "";
		}
		return scene.GetOverlayPicture(iMode);
	};

	/**
	 * Minimize to Thumbnail.
	 * 
	 * @param {int} iNewWidth Width of the thumbnail
	 * @param {int} iNewHeight Height of the thumbnail
	 * @param {int} [iFullWidth] Width of the underlying VBI control. If ommitted or zero, current width is taken
	 * @param {int} [iFullHeight] Height of the underlying control. If ommitted or zero, current width is taken
	 * @param {string} [font] Font to be used for text added to the thumbnail
	 * @param {string} [fontCol] Color for the thumbnailtext
	 * @param {int} [fontPos] Position (0 - 8) of the text within the thumbnail
	 * @param {string} [text] text to be shown
	 * @returns {void}
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	VBI1.prototype.minimize = function(iNewWidth, iNewHeight, iFullWidth, iFullHeight, font, fontCol, fontPos, text) {
		var vbictx = this.mVBIContext;
		if (!vbictx.moThumbnail) {
			vbictx.moThumbnail = {
				bThumbnailed: false
			};
		}
		var thb = vbictx.moThumbnail;
		thb.nThumbWidth = iNewWidth;
		thb.nThumbHeight = iNewHeight;
		thb.strFont = font;
		thb.strCol = fontCol;
		thb.nFontPos = fontPos;
		thb.strText = text;
		if (iFullWidth) {
			thb.nFullWidth = iFullWidth;
		}
		if (iFullHeight) {
			thb.nFullHeight = iFullHeight;
		}
		var scene = vbictx.GetMainScene();
		if (scene) {
			vbictx.DoMinimize(scene);
		}
	};

	/**
	 * Maximize from Thumbnail.
	 * 
	 * @param {int} [iFullWidth] Width of the underlying VBI control. If ommitted current width is taken
	 * @param {int} [iFullHeight] Height of the underlying control. If ommitted current width is taken
	 * @returns {void}
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	VBI1.prototype.maximize = function(iFullWidth, iFullHeight) {

		var scene = this.mVBIContext.GetMainScene();
		if (scene && this.mVBIContext.moThumbnail) {
			var newWidth, newHeight;
			if (iFullWidth) {
				newWidth = String(iFullWidth) + "px";
			} else {
				newWidth = this.mVBIContext.moThumbnail.strOrgWidth ? this.mVBIContext.moThumbnail.strOrgWidth : this.getWidth();
			}
			if (iFullHeight) {
				newHeight = String(iFullHeight) + "px";
			} else {
				newHeight = this.mVBIContext.moThumbnail.strOrgHeight ? this.mVBIContext.moThumbnail.strOrgHeight : this.getHeight();
			}
			this.mVBIContext.m_bThumbnail = false;

			this.setWidth(newWidth);
			this.setHeight(newHeight);
			scene.m_Ctx.moThumbnail = undefined;

			// we trigger resizing always as we cannot rely on Resize Handler as the size might not change
			scene.resizeCanvas(0);
		}
	};

	/**
	 * Zoom to one or multiple geo positions. This function works only for the main geo scene in the Visual Business control.
	 * 
	 * @param {float} fLon Longitude in degrees. This can also be an array of longitude values.
	 * @param {float} fLat Latitude in degrees. This can also be an array of latitude values.
	 * @param {int} iLod Level of detail, usually between 0 and 20. This will be limited by the map provider capabilities.
	 * @returns {void}
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	VBI1.prototype.zoomToGeoPosition = function(fLon, fLat, iLod) {
		// the project must be loaded already
		var scene = null;
		if ((scene = this.mVBIContext.GetMainScene())) {
			if (jQuery.type(fLon) == 'array' && jQuery.type(fLat) == 'array') {
				if (fLon.length > 1 && fLat.length > 1) {
					scene.ZoomToMultiplePositions(fLon, fLat);
				} else {
					scene.ZoomToGeoPosition(VBI.MathLib.DegToRad([
						parseFloat(fLon[0]), parseFloat(fLat[0])
					]), parseFloat(iLod));
				}
			} else {
				scene.ZoomToGeoPosition(VBI.MathLib.DegToRad([
					parseFloat(fLon), parseFloat(fLat)
				]), parseFloat(iLod));
			}
		}
	};

	/**
	 * Zoom to one or multiple Areas. This function works only for the main geo scene in the Visual Business control.
	 * 
	 * @param {array} aAreaList List of Area Ids to zoom to.
	 * @param {float} corr . This correction factor deals with the space which is reserved to the div borders. The Correction factor can be expressed
	 *        either in a fracture (e.g. 0.9, this means 10% space to the borders) or array of pixel values (order left, top, right, bottom) for the
	 *        added margin of the calculated zoom area, e.g. [450,150,0,0] which keeps a left border of 450 pixels and a top border of 150 pixels.
	 * @returns {void}
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	VBI1.prototype.zoomToAreas = function(aAreaList, corr) {
		// the project must be loaded already
		var scene = null;
		if ((scene = this.mVBIContext.GetMainScene())) {
			scene.ZoomToAreas(aAreaList, corr);
		}
	};

	/**
	 * Retrieve information on a specific cluster object . Type : 0 : contained VOs 1 : child clusters (tree clustering only) 2 : parent Node (tree
	 * clustering only) 10 : Information on Node 11 : Edges of the Voronoi Area (tree clustering only, not merged with rectangle)
	 * 
	 * @param {string} sIdent Cluster Id
	 * @param {sap.ui.vbm.ClusterInfoType} iType Type of information which should be returned
	 * @returns {oClusterInfo} Cluster Info Object with requested info according to given Cluster Info Type
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	VBI1.prototype.getInfoForCluster = function(sIdent, iType) {
		var scene = null;
		if ((scene = this.mVBIContext.GetMainScene())) {
			return scene.getInfoForCluster(sIdent, iType);
		}
		return null;
	};


	/**
	 * Set Tracking Mode for Rectangular Selection on/off.
	 * 
	 * @param { boolean	} bSet to start or stop tracking mode
	 * @returns {sap.ui.vbm.VBI} This allows method chaining
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	VBI1.prototype.setRectangularSelection = function(bSet) {
		var scene = this.mVBIContext.GetMainScene();
		if (scene) {
			if (!(bSet && scene.m_nInputMode == window.VBI.InputModeRectSelect)) {
				scene.endTrackingMode();
				if (bSet) {
					this.setProperty("lassoSelection", false);
					this.setProperty("rectZoom", false);
					new scene.RectSelection();
					scene.m_Ctx.onChangeTrackingMode(VBI.InputModeRectSelect, true);
				}
			}
		}
		this.setProperty("rectangularSelection", bSet);
		return this;
	};

	/**
	 * Set Tracking Mode for Lasso Selection on/off.
	 * 
	 * @param {boolean} bSet to start or stop tracking mode
	 * @returns {sap.ui.vbm.VBI} This allows method chaining
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	VBI1.prototype.setLassoSelection = function(bSet) {
		var scene = this.mVBIContext.GetMainScene();
		if (scene) {
			if (!(bSet && scene.m_nInputMode == window.VBI.InputModeLassoSelect)) {
				scene.endTrackingMode();
				if (bSet) {
					this.setProperty("rectangularSelection", false);
					this.setProperty("rectZoom", false);
					new scene.LassoSelection();
					scene.m_Ctx.onChangeTrackingMode(VBI.InputModeLassoSelect, true);
				}
			}
		}
		this.setProperty("lassoSelection", bSet);
		return this;
	};

	/**
	 * Set Tracking Mode for Rectangular Zoom on/off.
	 * 
	 * @param {boolean} bSet to start or stop tracking mode
	 * @returns {sap.ui.vbm.VBI} This allows method chaining
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	VBI1.prototype.setRectZoom = function(bSet) {
		var scene = this.mVBIContext.GetMainScene();
		if (scene) {
			if (!(bSet && scene.m_nInputMode == window.VBI.InputModeRectZoom)) {
				scene.endTrackingMode();
				if (bSet) {
					this.setProperty("lassoSelection", false);
					this.setProperty("rectangularSelection", false);
					new scene.RectangularZoom();
					scene.m_Ctx.onChangeTrackingMode(VBI.InputModeRectZoom, true);
				}
			}
		}
		this.setProperty("rectZoom", bSet);
		return this;
	};
		
	// ...........................................................................//
	// once VBI control is rendered, we attach navigation bar and map it self....//

	VBI1.prototype.onAfterRendering = function() {

		// when there is preserved content restore it.............................//
		if (this.$oldContent.length > 0) {
			// insert preserved control DOM content
			this.$().append(this.$oldContent);
		}

		// process the load queue.................................................//
		if (this.m_aLoadQueue) {
			var nJ;
			for (nJ = 0; nJ < this.m_aLoadQueue.length; ++nJ) {
				this.load(this.m_aLoadQueue[nJ]);
			}
			this.m_aLoadQueue = null;
		}

		if (this.resizeID == "" && this.mVBIContext.GetMainScene()) {
			this.resize();
			this.resizeID = sap.ui.core.ResizeHandler.register(this, this.resize);
		}

		// do a new adjust of DOM placed elements.................................//
		// the function should do nothing if nothing needs to be done.............//
		var l_vbiId = this.getId();
		if (this.mVBIContext.m_Windows) {
			this.mVBIContext.m_Windows.Awake(l_vbiId);
		}

		// move elements from hidden area to there final location
		var aElems = jQuery(this.getDomRef()).children(".vbi-hidden").children();
		for (var i = 0, oEntry; i < aElems.length; ++i) {
			oEntry = aElems[i];
			// Note: We cannot use a jQuery selector, since it fails with the artifical ID for cluster objects
			// jQuery("#" + oEntry.attributes.getNamedItem("data").nodeValue).append(oEntry.firstChild);
			var oDomref = document.getElementById(oEntry.attributes.getNamedItem("data").nodeValue);
			if (oDomref) {
				oDomref.appendChild(oEntry.firstChild);
				oEntry.parentNode.removeChild(oEntry);
			}
			
		}
	};

	VBI1.prototype.onBeforeRendering = function() {
		// this is called before the renderer is called...........................//

		this.$oldContent = sap.ui.core.RenderManager.findPreservedContent(this.getId());
	};

	// ...........................................................................//
	// diagnostics...............................................................//

	VBI1.prototype.isRendered = function() {
		return this.getDomRef() ? true : false;
	};

	// ...........................................................................//
	// helpers...................................................................//

	VBI1.prototype.getPlugInControl = function() {
		var l_vbiId = this.getId();
		var elem = document.getElementById('VBI' + l_vbiId);
		return elem ? elem : null;
	};

	// ...........................................................................//
	// re implement property setters.............................................//

	VBI1.prototype.setConfig = function(config) {
		// just call the load function............................................//
		// this will execute once and discard the config..........................//
		return this.load(config);
	};

	VBI1.prototype.setWidth = function(val) {
		if (typeof val === 'number') {
			this.setProperty("width", parseInt(val, 10).toString() + "px");
		} else {
			this.setProperty("width", val);
		}
	};

	VBI1.prototype.setHeight = function(val) {
		if (typeof val === 'number') {
			this.setProperty("height", parseInt(val, 10).toString() + "px");
		} else {
			this.setProperty("height", val);
		}
	};

	/**
	 * Add dependant child control for rendering.
	 * 
	 * @param {object} oControl Child control to render
	 * @param {string} targetElemId ID of DOM element the child to append to
	 * @protected
	 */
	VBI1.prototype.addRenderItem = function(oControl, targetElemId) {
		this.m_renderList.push({
			control: oControl,
			data: targetElemId
		});
		this.invalidate();
	};

	return VBI1;

});

}; // end of sap/ui/vbm/VBI.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.ClusterContainer') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.ClusterContainer.
jQuery.sap.declare('sap.ui.vbm.ClusterContainer'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/ClusterContainer",[
	'./Container', './library'
], function(Container, library) {
	"use strict";

	/**
	 * Constructor for a new ClusterContainer.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Specific Visual Object element acting as a container for cluster visualization objects. A ClusterContainer is positioned at a calculated position on the map. It
	 *        aggregates a visualization controls, which will then move with the map.<br>
	 *        <b>Since a ClusterContainer is not a real visual object most features borrowed from <i>VoBase</i> and event <i>Container</i> will not work. There is no label, no edit
	 *        mode, and no drop support. Events like click may only be fired if the aggregated control is not handling them. The properties are not changeable as well as the aggregated 
	 *        item. Only read access is possible</b>
	 * @extends sap.ui.vbm.Container
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.ClusterContainer
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var ClusterContainer = Container.extend("sap.ui.vbm.ClusterContainer", /** @lends sap.ui.vbm.ClusterContainer.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {},
			aggregations: {},
			events: {}
		}
	});

	// /**
	// * This file defines behavior for the control,
	// */
	ClusterContainer.prototype.init = function(){
		this._oItem = null;
	};
	
	// Redefine UI5 interface functions
	
	ClusterContainer.prototype.getPosition = function() {
		var oMap = this.getParent().getParent();
		var nodeInfo = oMap.getInfoForCluster(this.getKey(), sap.ui.vbm.ClusterInfoType.NodeInfo);
		return nodeInfo.pos[0] + ";" + nodeInfo.pos[1] + ";0";
	};
	
	ClusterContainer.prototype.setPosition = function() {
		// not supported
	};
	
	ClusterContainer.prototype.getAlignment = function() {
		return 0; // center
	};
	
	ClusterContainer.prototype.setAlignment = function() {
		// not supported
	};
	
	ClusterContainer.prototype.getItem = function() {
		return this._oItem;
	};
	
	ClusterContainer.prototype.setItem = function(oControl) {
		this._oItem = oControl;
		return this;
	};	
	
	// Implement function defined in VoBase
	
	ClusterContainer.prototype.getDataElement = function() {
		// not supported
	};

	ClusterContainer.prototype.handleChangedData = function(oElement) {
		// not supported
	};

	return ClusterContainer;

});

}; // end of sap/ui/vbm/ClusterContainer.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.GeoMap') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.GeoMap.
jQuery.sap.declare('sap.ui.vbm.GeoMap'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/ui/vbm/GeoMap",[
	'./VBI', './library'
], function(VBI, library) {
	"use strict";

	/**
	 * Constructor for a new GeoMap.
	 *
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class Map control with the option to position multiple visual objects on top of a map. The GeoMap control shows an image based map loaded from
	 *        one or more configurable external providers. Per default a map from <a href="http://www.mapquest.com">MapQuest</a> is used. Other map
	 *        providers can be configured via property <i>mapConfiguration</i>. Multiple maps can be mashed up into one map layer stack. If multiple
	 *        map layer stacks are provided via configuration it is possible to switch between them during runtime. The control supports the display
	 *        of copyright information for the visible maps.<br>
	 *        On top of the map the GeoMap control provides a navigation control, a scale, and a legend. Each of them can be switched off separately.<br>
	 *        It is possible to set the initial position and zoom for the map display. Further the control allows to restrict the potentially visible
	 *        map area and zoom range.<br>
	 *        Different visual objects can be placed on the map. Visual objects are grouped in VO aggregations and an arbitrary number of VO
	 *        aggregations can be assigned to the <i>vos</i> aggregation.<br>
	 *        The second aggregation <i>featureCollections</i> allows the use of GeoJSON as source for visual objects.
	 * @extends sap.ui.vbm.VBI
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.GeoMap
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var GeoMap = VBI.extend("sap.ui.vbm.GeoMap", /** @lends sap.ui.vbm.GeoMap.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {
				/**
				 * This is the map configuration for the geo map. The map configuration defines the used maps, the layering of the maps and the
				 * servers that can be used to request the map tiles.
				 */
				mapConfiguration: {
					type: "object",
					group: "Misc",
					defaultValue: null
				},
				/**
				 * Toggles the visibility of the legend
				 */
				legendVisible: {
					type: "boolean",
					group: "Appearance",
					defaultValue: true
				},
				/**
				 * Defines the visibility of the scale. Only supported on initialization!
				 */
				scaleVisible: {
					type: "boolean",
					group: "Appearance",
					defaultValue: true
				},
				/**
				 * Defines the visibility of the navigation control. Only supported on initialization!
				 */
				navcontrolVisible: {
					type: "boolean",
					group: "Appearance",
					defaultValue: true
				},
				/**
				 * Initial position of the Map. Set is only supported on initialization! Format is "&lt;longitude&gt;;&lt;latitude&gt;;0".
				 */
				initialPosition: {
					type: "string",
					group: "Behavior",
					defaultValue: "0;0;0"
				},
				/**
				 * Initial zoom. Value needs to be positive whole number. Set is only supported on initialization!
				 */
				initialZoom: {
					type: "string",
					group: "Behavior",
					defaultValue: "2"
				},
				/**
				 * Center position of the Map. Format is "&lt;longitude&gt;;&lt;latitude&gt;".
				 */
				centerPosition: {
					type: "string",
					group: "Behavior",
					defaultValue: "0;0"
				},
				/**
				 * Zoomlevel for the Map. Value needs to be positive whole number.
				 */
				zoomlevel: {
					type: "int",
					group: "Behavior",
					defaultValue: 2
				},
				/**
				 * Name of the map layer stack (provided in mapConfiguration) which is used for map rendering. If not set the layer stack with the
				 * name 'Default' is chosen. Property can be changed at runtime to switch between map layer stack.
				 */
				refMapLayerStack: {
					type: "string",
					group: "Appearance",
					defaultValue: "Default"
				},
				/**
				 * Visual Frame object. Defining a frame {minX, maxX, minY, maxY, maxLOD, minLOD} to which the scene display is restricted.
				 */
				visualFrame: {
					type: "object",
					group: "Behavior",
					defaultValue: null
				},
				/**
				 * @deprecated This property should not longer be used. Its functionality has been replaced by the <code>clusters</code>
				 *             aggregation.
				 */
				clustering: {
					type: "object",
					group: "Behavior",
					defaultValue: null
				},
				/**
				 * Disable Map Zooming. This setting works only upon initialization and cannot be changed later on.
				 */
				disableZoom: {
					type: "boolean",
					group: "Behavior",
					defaultValue: false
				},
				/**
				 * Disable Map Paning. This setting works only upon initialization and cannot be changed later on.
				 */
				disablePan: {
					type: "boolean",
					group: "Behavior",
					defaultValue: false
				},
				/**
				 * Enable Animation of Map Zoom. Works in combination of setZoomlevel.
				 */
				enableAnimation: {
					type: "boolean",
					group: "Behavior",
					defaultValue: false
				}
			},
			defaultAggregation: "vos",
			aggregations: {
				/**
				 * Aggregation of visual object types. A VO aggregation can be considered to be a table of VOs of a common type.
				 */
				vos: {
					type: "sap.ui.vbm.VoAbstract",
					multiple: true,
					singularName: "vo"
				},
				/**
				 * Aggregation of GeoJSON layers. Object from a GeoJSON layer will be behind all other Visual Objects from the <code>vos</code>
				 * aggregation. In case of multiple GeoJSON layers the objects are orderer with the layers they belong to.
				 */
				geoJsonLayers: {
					type: "sap.ui.vbm.GeoJsonLayer",
					multiple: true,
					singularName: "geoJsonLayer"
				},
				/**
				 * @deprecated This aggregation should not longer be used. Its functionality has been replaced by the more generic<code>geoJsonLayers</code>
				 *             aggregation.
				 */
				featureCollections: {
					type: "sap.ui.vbm.FeatureCollection",
					multiple: true,
					singularName: "featureCollection"
				},
				/**
				 * Aggregation of resources. The images for e.g. Spots have to be provided as resources.
				 */
				resources: {
					type: "sap.ui.vbm.Resource",
					multiple: true,
					singularName: "resource"
				},
				/**
				 * Legend for the Map
				 */
				legend: {
					type: "sap.ui.vbm.Legend",
					multiple: false
				},
				/**
				 * Aggregation of clusters.
				 */
				clusters: {
					type: "sap.ui.vbm.ClusterBase",
					multiple: true,
					singularName: "cluster"
				}
			},
			events: {
				/**
				 * Raised when the map is clicked.
				 */
				click: {
					parameters: {

						/**
						 * Geo coordinates in format "&lt;longitude&gt;;&lt;latitude&gt;;0"
						 */
						pos: {
							type: "string"
						}
					}
				},
				/**
				 * Raised when the map is right clicked/longPressed(tap and hold).
				 */
				contextMenu: {
					parameters: {
						/**
						 * Client coordinate X
						 */
						clientX: {
							type: "int"
						},
						/**
						 * Client coordinate Y
						 */
						clientY: {
							type: "int"
						},
						/**
						 * Geo coordinates in format "&lt;longitude&gt;;&lt;latitude&gt;;0"
						 */
						pos: {
							type: "string"
						}
					}
				},
				/**
				 * Raised when something is dropped on the map.
				 */
				drop: {
					parameters: {

						/**
						 * Geo coordinates in format "&lt;longitude&gt;;&lt;latitude&gt;;0"
						 */
						pos: {
							type: "string"
						}
					}
				},
				/**
				 * This event is raised when a multi selection of visual objects has occurred
				 */
				select: {},
				/**
				 * this event is raised on zoom in or zoom out.
				 */
				zoomChanged: {
					parameters: {
						/**
						 * Center point of the map. Format : Lon;Lat;0.0.
						 */
						centerPoint: {
							type: "string"
						},
						/**
						 * Viewport bounding box's upperLeft and lowerRight coordinates. Format : Lon;Lat;0.0.
						 */
						viewportBB: {
							type: "object"
						},
						/**
						 * Level of detail.
						 */
						zoomLevel: {
							type: "int"
						}
					}
				},
				/**
				 * this event is raised on map move.
				 */
				centerChanged: {
					parameters: {
						/**
						 * Center point of the map. Format : Lon;Lat;0.0.
						 */
						centerPoint: {
							type: "string"
						},
						/**
						 * Viewport bounding box's upperLeft and lowerRight coordinates. Format : Lon;Lat;0.0.
						 */
						viewportBB: {
							type: "object"
						},
						/**
						 * Level of detail.
						 */
						zoomLevel: {
							type: "int"
						}
					}
				},
				/**
				 * this event is raised on map key down
				 */
				keyDown: {
					parameters: {
						/**
						 * Key value of the key
						 */
						key: {
							type: "string"
						},
						/**
						 * Code value of the key
						 */
						code: {
							type: "int"
						},
						/**
						 * Shift key modifier state
						 */
						shift: {
							type: "boolean"
						},
						/**
						 * Ctrl key modifier state
						 */
						ctrl: {
							type: "boolean"
						},
						/**
						 * Alt key modifier state
						 */
						alt: {
							type: "boolean"
						},
						/**
						 * Meta key modifier state
						 */
						meta: {
							type: "boolean"
						}
					}
				},
				/**
				 * this event is raised on map key press
				 */
				keyPress: {
					parameters: {
						/**
						 * Key value of the key
						 */
						key: {
							type: "string"
						},
						/**
						 * Code value of the key
						 */
						code: {
							type: "int"
						},
						/**
						 * Shift key modifier state
						 */
						shift: {
							type: "boolean"
						},
						/**
						 * Ctrl key modifier state
						 */
						ctrl: {
							type: "boolean"
						},
						/**
						 * Alt key modifier state
						 */
						alt: {
							type: "boolean"
						},
						/**
						 * Meta key modifier state
						 */
						meta: {
							type: "boolean"
						}
					}
				},
				/**
				 * this event is raised on map key up
				 */
				keyUp: {
					parameters: {
						/**
						 * Key value of the key
						 */
						key: {
							type: "string"
						},
						/**
						 * Code value of the key
						 */
						code: {
							type: "int"
						},
						/**
						 * Shift key modifier state
						 */
						shift: {
							type: "boolean"
						},
						/**
						 * Ctrl key modifier state
						 */
						ctrl: {
							type: "boolean"
						},
						/**
						 * Alt key modifier state
						 */
						alt: {
							type: "boolean"
						},
						/**
						 * Meta key modifier state
						 */
						meta: {
							type: "boolean"
						}
					}
				}
			}
		}
	});
	// /**
	// * This file defines behavior for the control,
	// */

	// Author: Ulrich Roegelein

	// ...........................................................................//
	// Define static class members................................................//
	// ...........................................................................//

	GeoMap.bEncodedSpotImagesAvailable = false;
	GeoMap.bEncodeSpotImageData = null;

	GeoMap.oBaseApp = {
		SAPVB: {
			version: "2.0",
			MapProviders: {
				Set: {
					MapProvider: {
						name: "404",
						type: "",
						description: "",
						tileX: "256",
						tileY: "256",
						maxLOD: "19",
						copyright: "Map Provider is not configured, please read this {LINK|SCN Article} to configure your own Map Provider.",
						copyrightLink: "//scn.sap.com/docs/DOC-74221",
						copyrightImage: "",
						Source: [
							{
								id: "s1",
								url: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAIAAAGkFw+nAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3ppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDoxMGJiNTIyYy1iMGY1LTRhOTgtOWEyZi1kYTY0MWU2ZTk0MGQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MURCMDcxRkE5NDBDMTFFNjlCODg5Njk4NURERjQ1RTUiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MURCMDcxRjk5NDBDMTFFNjlCODg5Njk4NURERjQ1RTUiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjExYzk5MTI5LWM0ZWYtNDZmYi05N2Q1LWUwNWExNGZmMDhlYSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxMGJiNTIyYy1iMGY1LTRhOTgtOWEyZi1kYTY0MWU2ZTk0MGQiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7y1q/+AAAmXElEQVR42uxWMRJFMBBNVFpHULsXF+AW9NRqo6RV6ikZlZJSGe9PZjKKb5IIXV6xs3aSfZvN2wzKGCNfwiEfwxJYAktgTjCOo2QFe4Su647jKMtSulKDIE1T2DAMtUoh0qTTNPHUIpLn+bZtOIEpwTAMwl/XFRZ5RUTxKFTruW7bFrau66IoFLeoEuz77nnehzL9mz3LsuvnPM9RFJnKtKoqYTniOH5BprhSyOYqJwwBIlwIqP1uo2qLcKuu68JJkgTpfs11HESCIIDv+/7zSW6ahheOYpdl0W0pkY6uIcjdfPV9z94Atf9FlsASkFMA9svYhmEQiKKehqEomYSOSZgDiRWQmIQ+edJJyEqwlZBLdy5O0Nz3x4f1n90DEzABE/iTQK2VughxvwAIuZqkRYR5iXgKAELIOPcFDjQB5IptzpJqCCVohgxV2QGndB+h1Ry8G1rmcOGtTQGxEmOcW77Q3OacdxzQheGZVCwvyJhK3967WjblcjnnQghf8NqHeCOL1ppOuoZnxhgsvPelFOr+z2g5GCmlh9JjucgETOA4ngKwa7UqFgJR+AUMZqNVH0SMZrMvIGafwOA7CDatBoOITeMmwWTQqkUR5O7HHpDLCnfdu/7c3Z0JwzAMer6Z8zPfOXO4Hfz6HWIAGAAGgAFgABiAPwagaRqwCyocep7308/djmkLVauqCv0wDGAD32XuJ3GCcRyTJFEUJU1TMEvMgLuZprle6ThOWZYYuK5LVaAd2tOs+3GCBSdwz8A/5Wp2PIF9VAh4QM8h9NtHW0uMBeixBqj2VaT9r9OWZfV9T4oEvRIE4bm67cVGvFcjPTQMI8/zA1Vo+zOGB4ky0q5708J4SRl1XQdXcRIAegiBf1O+kIReV3IxA/cKy4F5QPolRRQEwTzPF9gAopKu6+v5oigAQ5IkBK+2bTmOs20b89M0xXGsquoL2QBtPGWwaMvJaUZRtPFZyhleiAIWnAzG8DN1XdOAtiMMQ03TTruYfA2ASg4QFzqAXhRFhF7E0SzLZFnmef7i29yWY/J9/2X9LMsLMQAMAAPAAPxvAO8CsHP1KspDQbRZGwURSeOChaKihV1AEFGwsrDRSrAVfQF9APvvBeysLG2sRHwCBW1sLCwU/EUQURCx2IMDFzHZ3XwaY2BninBziTLnzsnMJJm5HAcYAANgAAyAATAABsAAGAADYAAMgAEwAOOFWkKflA/D1F0sFi6XC4NqtRqJRKxWqyRJD/eeGgpgNBptt1u/3w/VcXo4HFKpVL/fl2X5+T9/4WuVUqmUz+en0ynGwWAQR100vhfdvziIcvr5fK7aB6D8lP+MPHsT12q10+lUqVRET7PNZlutVhiA8fF4nCZBHuqRAekHg8GbLdDr9YrFouiHp76UHxabGv9hGfxKexPLCz8xEbmpska1KR6Ty+USFLLb7fv9Xs/iGl0soPrFF4uNBf53lR/2EtCl8/pWHnGjd8sJ9mcyGafTGQgExuMx2QRH4eMnkwkohEE4HIYPhVel9nazeCHVjS2KV4FZqOTsdaKzGy2Xy4JgGED7/91iw2g3KgSRFUcqdRJM83q92re+MEsg01fgssmq31nyDQBwz/wajEXlk/Ba3/UpGppOU5krbox6vY5gQrFZJHzEQyStNNNut3FBIpGg0/V6rR6yDCgzE8VmyiCAlRaxmUhCRzLRcDiczWbGeSEwlfhKe6dAKLQJKisDHxEDGGjHFYyPx2On03mbGxURQLnYYA4xm3RFKnV7XyqbSd8AQDXFwORtv+qtKVqt1vl8NkscuEsxkF80m02aDIVCWH6adzgchUKBxul02mKxmOuZGM8GpKvH49lsNnhsx9NjNBrd7XZ0gc/nM1cgQ85MlfYgNBWKCmY3Gg0DosqDAOA3SO/5VQTFu90u8k0jw6ImCoHN4EMsFoNXdrvdSIYlSYLexBAMRHqcTCYNfrn0oUX7bDaLAInVJX5DXVmWkeVTrejnVd72ekzL1gaiZcGE9Ze/u1GExsvlQuNcLme2d6NcL8QAGAADYAAMgAEwAAbAABjA3wXwJQB7VxMKXRiFLb4NCxZGfhoKi4lSKDsWfmdhZctaForVlI2wG1mxZENM7JSampHJAmHyEyUW/iXkr4Sm0Pc9fc/X2+36jDsM5s49z+LtneveKec57znve+6cc0x/HhANEggBQoBACBACBEKAECAQAoQAgRAgBAiEACFAIAQIAQIhQAgQCAFCgOBN/LLaP+zz+bKzs/mD7+vra5UcLAREE/v7+3l5eS0tLU6n0+/3V1RU7O3t5efnV1dX22y29fX1+vp6r9fLnPifhVl/FbG1tQVdZp4vBM2xra0NSo2/Qq+Zn52amprwNxXga0vVW2cFUNaYsIQAJI4r/f39LpcLao4rV1dX0PGEN5LiYxGxk3PBJEQmxTFllalxGG9ubrq7u9mAUuVY4p4wddv5VUx+DJO1KwW+/+k1tDgYDGJut9sh7sTERFgYFvbPzc19t+g8jT6bqbjd7tnZWYfDAXPk8Xjwze3t7RjhBqJZc8B0K4AptqOjo0oftVoJPTVe5QB3YkFgZGYsFwqLg3CJYA1F1I/2B/F9BFD07NaLicFKKkrKzG3EU7QqJA9rxcj3qOZJlibg3cxXdgSmZDFRek2Jay17eMLY6EOb9P4VjarijQBKFpKC7LSNpl53pWL1IlY2gPorR62sHP7EROaYdbym7LLR09NTVFR0eXlZUFCA3T22oThVBQIBbDrhqFtbW9n1zHQHmlgkIBQKdXZ23t3dYZuPjzjBjoyMnJ+fd3V16dohQfQnJydmlHusn4SxMU1OTu7r6zOdQM/OzhYXFyNo1vRb8CHQObH4DncQaksWke+xRDianUZvb29ZLdHlcvGikQfxFOcrKys47rHzF0Z4I1wpLy+HE4LKl5WVdXR0LC8vRxwFiTPFhPZh/8PThlYZVfHH8OcGRjug3bxfe05kSOO/j7+8vMzMzOCph4eHuN0F6QAtu7+/T09Pn5ubw8eGhga6YtWy06Aa+ny+yclJFk2E/nKuon7Ud20hy9PTU7BbWFhYXFwct06YdSMrKys9Hk9TU5Pdbu/t7XW73VjjGAcGBqCkTqfz4OAAW6MwjlpXbBj2ZHBwEM82NzcPDQ3hCrtdMmSUlZXFPpLKMMzPz19cXNTW1qakpFgiGvo6cKQ9ozEIYTCqynCT1hbRgOC89tpDQsrj4+PBYFAOYh8xRHCDUGEczYaHh7EaYDTYeBq2KCMjA/dom1AvLS0dHR3V1NTwRY28DzAaJoL6q3iOemfAEBujPbpqsjAsExMTCwsLEor4lHeFiGG1IfFAIJCTk5OUlLS6ukrHqLC2trazs1NVVUV9Nx2+9RygipYTY2NjcIxqDIVCuJiWloZxY2MD/nZqagqOMTMzEx9LSkoODw8dDodOY0pLSxsbG00q/W8yQWr7DI1mEVFWW1RxZl3Ic3NzE9uS4+NjK5yoo1nNm/F3jCxer96EqFdgurdUj4+P2Hf7/f7n52fLhjSiQAClrAqJcufHspwqsr+9vQ2l3t3dlSDS1zrhp6en6elpTOrq6j5fIdcKkHI1VtoFCYQAIUAgBAgBAiFACBAIAUKAQAgQAoQAgRAgBAiEACFA8CP4IwB75xZS1brF8VXWgxlFZXi8ZGSauTtdEMuKLMXUKBQE6UEJeumch8BAd0RP4WN0DJIgTj4FdheFTFpmmlQYpVnaRVRM8oaCBV1IjLL9Yw7Oxzwrc6u53XO5xniYzDXXXFMd//H9x39837ccuiCjI0ABUFMAFAA1BUABUFMAFAA1BUABUFMAFAA1BUABUFMAFAA1BUABUFMAFAA1BUABUFMAFAA1BUABUFMAFAA1BUABUFMAFAA1BUABUFMAFAA1BUABUFMAFAAvsdevX5eUlCgAf5vfT5486YSG8rMWANP8S3oSHD16tLCw0O12G78fO3bM39/foxeEAjBt1t/ff+/evYKCggsXLhD1XBkYGLD7fXh4uK2tzQl95+fOssAXhikqKtq5c+fChQvxdXl5+T8s+/z5s/H7unXrJtHu8a+0eV7qa2nAFhsbm5KS0tvbGxUV1dHRcfHixdzcXGBISEiAfNrb27kzKCjI3oDVcW3lvajXgWmk1NnZKc04pDGH6eYsjZ6lCbd0fNYuStOsYQh2uMVltRrMzMzkJDAw8OrVq7ANJLN///7KysqsrCzTedALzPlNxCTG7cFu4p0xYe9/Pn6veWf+gU5Jwo2NjegWaTFbVlYGj4tEqamp4RgZGQmtMwKkUSeWk5OD6xkHwcHBY44VnsbJPct4LAlDK+GxTbr7FhcXwy03btxAsEdHR+PcjIwMfJecnEy+bWpqGhwcrK+vN8KRm39Mp+Zd0m9FRQWghoWFdXd3kxIkISsAYxgufvnypZzjaGn9iNMJbVTN6dOnkY94lut2MfOjcQ+KCMwYFnv27GGshIaGVldX83wyB3rJmQDMkAyFBHAoR8QiwQvJLFiwQDoAczQVaUhICMcHDx5Igv3TQgnVHx4ezgOpucjDERER586dk4dgS5YsiYmJkZ8oqdt3k7Bp7cbx1q1b0tnanhgn1Yedm8nG0oVPtKnp7SnP8ejtqTLUJbEPpUj+JPw58ff3n1RZRLaAT0inJGS0ZmlpKS8fPny4d+9edCeJlxEwZnlsb+vsozlACF0oZf369dD6RIpScgMfIR/IS2hdWAu/19XVkRKam5s3bdokqn9M72PXrl3TOuD/6tiJMAx8ghCyN6QUYvndskmRlfTVdiwF+fH7zQzScXFx45S4VLCQCUc0KOrFz8/vxYsXyH9Sa0tLS2JiIretWLHi69evR44cGZ/r5s+ff/jwYXTn4sWL4Z/jx4+fPXs2NTVVZehPjdCGT9CgJ06coBSArFD9nz592rdvH9qfKDaqRqYwpV6zO10mJzgSTzASQoiP9/T0DAwMUFg4uduwI2ZDk5KSoHuRj7jMrj5Bwl7rMlZA68CBA5Jdnz9/3traGhAQAH4yAyq34X2cTqo/deqUw6eCnDIZRwE1EamO8Cfx5uXliaYCKgKfqIe+RFkNDQ2NX6/pCBjbxvc+ApSIZnAQ0ffv32dMSOqSkOcl3o+Pj3ey3PTKBRnoOygoiJBPT09ftmzZ27dvYao1a9a4rFbyxD7jJi0tDRhEnnqlOVCZ/ccy6T5vilupez0EpUc5rR21p8cIbci9sbGxu7u7q6uLjIo6cs1ScyIAZWVl+F2W1L3OoRI93g2AF5mINwoRRAHJiVT09OlTypdJyIHvPmnv3r37lY9LKsLpw8PDpCiZfJVcxZVJzcX6xNZEOM2UEbJUSQU3tXiXR1GCcE5mouom8Kk8eJmTk8NbXEEoe7cKmnYjNkVZTWpOELPvbSHq+/v7Oy3jxCw/NDQ0cOVflqHKvHVRfhpN9iIetUwqNcmKlBSQ9fLly7ko4+Bnc+ByUlBQsHTpUiMEZMk6IiKit7eXEzDgYkJCwurVq7n4X8skB1y6dMljtspXRgABSJgTiS8sg45NvHOREP5Z3cCdEu8UH6QH8wQzDuwVyY9Z5M2bN5BSS0vLFH5n1yygF0mGZuVAqEaWLeX6OLmUewCJE47yQQFSNh3JuXmIvQykOgGt2tra0dHRX/n9vXVvKPTy4cMHEX+8fPz4MRSRm5sLY0ALbrd7ImIc+k5PTw8LC4NDCGGyKNVfXFycLNhBVjwtNjbW7LPjyXV1dUNDQ1ANZcq0bO91eg6Q3c6yv0r8LqQsO7T6+vra29sJxqioKFkwWLRoUXNzc3x8/Pi1EvwOTfNZYKuurjYsX1lZybsAIGsPMtsKBUHr8MycOXMSExOzsrLw/myejJMo5mT79u1IurVr1xKk9fX1ZNfIyMiAgABJsyEhIaGhoR6Rbl8A8FiOlynVXbt2uawvEOBTud7U1MRPPHToEOdmzgN47t69y49mBPzTMh+aDeVvRllDI+gN8TKqIyMjo6OjA2fBOfYtcuNMBhQVFeFQXvIQwpZBAzwyknjIqlWr5Fsb5lGoo6qqKggnOTk5ODg4OzvbR+eCiD7xOF7AXzIR/adrBnYAMjMzUZMwzJkzZ2BtKFvC32VtxfCYuwbOnp6e1NTUv2U5wYkjAL8LLUzQ6TBSeXk5mQBiIZyJbryfn5/POeHMW48ePTp48KB9F0xbW9uTJ0+2bNkCp0F0Ohs6xYmw1tbWf1smdVBMTAzZgsDfuHHj+fPnCfkdO3YYvzOM7ty5s3Llyq1bt+qCzBQNSS7fFeAEGS6lln1TosdkwJcvX27evFlRUTEyMuLMv8gLAIBYKJHkixgodylQKZSkbuLIFY/ZTcqCy5cvDw4OOv+vcy4AlJ3EuAltMw0gJa7MENhLUzIBxdSrV6+8a0w7LglLiYt6kUljqTZlTo1jZ2enUY2Q+/v3769fvy5cv8oyXZKciugkYRLXsgFLxA9lEdFN0URRSukfHR1tcum3b98okT5+/JiWliZ7gbzaZnQqwsz0uv6389llbSakXLJvUZXii3KfIzI0KSkJAfPs2TNova+vz8/Pb/fu3Sj9WeD9mVNBsLbMDxsGJ3lK5rRTvMeuE+ojaL25uXkWLxb95SNA/m8GNI03ZVoRii8rKxsYGKDyZBDISp6MBuIdzuHdmpqa0dFRRH12dvaGDRtm8XLpdAJQUlJiFpvQJIWFhZzA15IwoXK5jUo1MDAwLy/P7XbD+DhdYr+0tBRsIBYSb3Jy8ty5vvGvdH6dW4xal1UnjqLczdoIL+Efs9xhjDQAw3R1dX33YftVGZqeni7fUCQrkjwJZ3yKnmlvbzebxeH6dZa5rO3mtbW1UVFRcXFxv1nm8m2bBhkK1eTn53NENRYXF6MOq6qquJ6bmytOHxkZuX379rx581JSUji61KZXBY35zVCK2Pr6+itXrqAgv6vN2Obcjo6OhoaGzZs3yxqh2kxQEBRfXV0dHh6+bds2dagPrQdoHaCmACgAagqAAqCmACgAagqAAqCmACgAagqAAqCmACgAagqAAqCmACgAagqAAqCmACgAagqAAqCmACgAagqAAqCmACgAagqAM+wPAdo7+5iqy/+NSwokFvgAJYkSiiVLSTLEShIzs+l001x/kMuyWXNuuUXMcmNKLSY53Wq1pq2t5sMfjsGmo4HmIDVR0RqiISoSZiCPipmET/1ev/Pe994ZoEPwgYfr+uPsPp/zeeKc63q/r/f9ue8bTdAQFIEEQQIQBAlAECQAQZAABEECEAQJQBAkAEGQAARBAhAECUAQJABBkAAEQQIQBAlAECQAQZAABEECEAQJQBAkAEGQAARBAhAECUAQJABBkAAEQQIQBAlAECQAQZAABEECEAQJQBAkAEGQAARBAhAECUAQJABBkAAEQQIQBAlAEDqOfvoKeg+OHTv25ZdfPvHEE5cuXaqsrFy1alVoaKgEIPQQnD9/Pi8vr7a2Nioq6sUXX2xN96amJnY7ceKE7b9ly5akpCRZIKF7IDk5edOmTS6Wnz59ev369e+9915mZiZbeE1LS5s5c+acOXMKCwvZ2dEd9hvdR40aReOxxx5DFTQiIiL0rSoDdBvMnj178+bNzz//fP/+/Qnt8fHxsL+qqorQHhAQEBwcfPHixYMHDxL7Y2Nj2dOOgu4PPfQQMoDugwYNQjP6Jr3h899//+lbuPf4999/eX3wwQftLeEcpvJ29+7dcHf58uW8TUlJecgD6PvGG2/A7NTU1KFDh8J7UsGePXu++OILDnFtzoMALl++jBieffZZfcntQV/ih76Fu0TxM2fOEHTdFsiNS4HN586da25u/v3339esWTNy5MhHHnmEiF5WVgZrw8PDf/31V/Qwbtw4aF1XV1dfX8+xFRUVxHUi/Y4dOzhk8uTJNTU1Dz/8MMdGR0eTHPp5wOGRkZGIR9+/aoD7DIJxeno6VHZbCOGBgYHW/vnnn7OysnhbWlrK26lTp8L7Q4cO0SbGm3GnwQ74dV5p43w4Ax7mqaeeIvCTB2joe5YF6kIgxpeUlISEhFCMwlHnWLx3MIdDFOetOfi5c+e++uqrtIuKiojxEydOdNZIkADuG44dO3azEIu9IUIbiZOTk3EdCxcuXLZsGU599OjRGzZsYPvKlSuN7u+//773eVCFdcuAZ555BjNzW4EcnWCr2lSIXc78D1fXL6gaoL3AqJhZh9lLly719fUNCwuDpj4+PvjsnJwczDq2BNNSUFCQkJCwb9++b775BuIaF/HlGBU/Pz/2eeWVVyhbcThBQUE4lsbGRrZjzd21OHz2/4Dpx8S3v4oAn3zySUNDA76fTyl8uaXi4mJey8vLX3vtNXwUV//444/1m6oGaC/Onz8Pm10XuwFaHz9+fN26dbQvX77cx9OhfvHiRVSRmZkJswm00I7tQ4YM4RWRzJo1C/Lh0YcNG8Yr+7B9wYIF1uhA/uHG4Lr1F1mX/9q1a2lTHKNYagxuyQoGUhAa4xBqCd7S0M+qDPD/EZRQff369RZBtAUoLgnbOz3AkEBl3hKYsfK5ublkg9DQUCIrMR6u19fXT5o0CbYRyK9du4bjJ9IvWrTIuuef9YCk0YG7tTzDtZAWRD916hS38e2335aVlY0aNWrjxo2UCm+++SYbsToXLlwg3l+9ehUZcGMkiqamphkzZrAnieUWWUXo4TUAjpw4bb3mZriJyklJSUTTtLQ02lCECIr59q5NHQV37drF4c61Q7W6urp58+bdKaOFSLjE/Pnzjx49Crm5DbajLquD7SanTZtm5QdbXBWB8GjYuAaiPke9/vrrtxa20BsFYIwhFhK8kUFAQAA8W7x4MTzGsdiTIxsk40TSwg7B0c53wliVjIGhGODtlClTyAxW/q5evRrimpmxoTgIj3tzXUP2YIt7todZvB0xYkTHfJTQG3uBXOejiYEtBE6oBufwx7R5bTMD3HEduv5N6+tEja5TyIJ9n//1+repxtvKe08//TT1hgh9u+iBY4EoBOEZYf5FD+zpEiG5kyMf4XFBQUFtbe2ECROIza7Pcdy4cWzExniTmEZeXt6BAwfi4uJsC5U0YsCs25NdkgCOv/N/LH8dyQ32kzSoQyyHCL26CKZC9S4EH/OgX7/bljoUz8jI8PPz43BcyrZt295++22qT3hvXZzW5/jOO++gB6J4fn7+9OnT3YWsM/TRRx/18fFJTExEJ2yMjo727hLtQNfQjh07jhw50rdvX/5AclpFRQWVMWmNcp970xAgZYCOV6jp6emBgYFE06KiIkphzHpYWBgbCd5sxKZTuRLFYeH27dsRgKUaK7s5A67du3iAiwiA8NwBb2Nj4ygYuDoNCt8lS5ZwA4hq4cKFth0Xh7q4VZIb18VKIchbPLwTeksG6BjwJI2NjdXV1R9++CHRmnAOvcaPHw/b9u/fP2/ePKI+URauW1+kpRoCP6TEzZNzWg9Bw5NERUVByr1799JAKjU1NSSBFmU3DKby5tPy8nIL4TY2jnzCLXH4559/HhISgirwVEgRn8P2kpISu9Xs7Gxi/1wP1AGqIrhTLt+NzMnMzMTZd75QtsQSHx8/ZswYMon3UGdXAZN2qAe8hwm53s/Bgwe7WzK1oAEr62X3JYCuKCFesSVG03fffbepqYm8wRYrea2HimzguoO8+2TXr19vT9zYk/yj3k8JoEsD63Lw4MHCwkLIOmvWLEyUdeHbZHM3T4Ww7aK4C+2lpaW5ubmchPAfGRkJ7+0Zhb5V1QBdl+7E8oyMDMoAKEvkJpxPmjRp/vz5ffv2/eyzzygScPAUDyiBHXDttDH3MTExfOTr6xvugfVQkQQwP/7+/pgcausZM2ZYN5GgXqCuCDMqixcvTkpKsmFqEJftZ86cgfRW/mLxCfyYmbq6Ot7SdhNw23QyWpGhK0CjQdsFo7sxG1v/0Ucf8Qq/g4ODc3JyiouLMTBWp8L1OzV2SDDgG4k4qgG6xC9BmA8ICFBtelfLKho2LY4vPC8vr7Ky0gazSABCj4ombu0WSiDS5qZNm4qKilasWAHjvUcrHjp0yEY03o3n3LJAvQhr1669j+sCnT59+j0PzM8Q2uE99wOzc3NzqawWLFiwZs2aQYMGlZaWBgYGul4BeE8GyM7OVgYQbgXIdOrUqeeee45oalGzxXyDe3MbFEUHDhwgitsgDjdMNTU1NS4uLisrKz4+3g1czczMLCgo+OCDD2yVUixQSkoKf8L48eNPnDjh3Cbbkc3dWMlUvUDd0iV7P3xwH0VFRcF16vI+nmVXiJr2JNvmG9jDY+95CJ25hx9++IFr2dsWY7lf9cBMDmHeuE4bMdTV1aGKPXv2lJWVrVy50h6V8OmqVau4vSlTplBiRUZG8if079/fW7HUA7C/uroahf/555+zZ88eMGCAMkBvKbvhDURZvnx5U1OT9cbiCtqc1mOUWr16NRy1Cc2dmW/A1bdv325D/ZxTt8Ed7oRciLtyOjzvgQ3TsJBvPPZeCS85OdnS1M2u29zc/Mcff5w8eZJLc2a0ER4e3oHxvMoA3YbltprQ1KlTvSO6m88Je6gOd+7cOWfOnD6tHj54n4pwO2LECOLr2LFj2znfoKqqCqpxTo7Ct+CaFi5caCsuuhEc7n7Ky8txU96HP+gBjmvw4MEobfjw4bYEr82Js47jPl6LQALvc9bW1hLUKyoqfHx8Hn/8ccL/kCFD/P39n/TgHnz5ygD3wcDANmg6ceJEe6RANKXN9s2bN3uHagvnBH78wIYNG+CTDR9yvbGdXEKL8//zzz80oKAjpRussXfvXu/t3h/ZBGWUkJCQQLzn3lqs/9UaV69eJaijkMbGRlvuDrr7+fnd919EQyE6BcLntWvXIOgtojsWHMZHRESw57JlywYOHBgTEwP1YTBRHycNMyZMmAAhjhw5gkJcZ190dPT06dNJDuwJ1X766Seivq2AYq+35QpsNPX+/fttMg1bSCmjR4/Geefm5gYFBdlMHUoLbhi+QmjK0+zs7GHDhkHZffv2YYeQ3Msvv2wDOnDhtsIXSvDuoGxoaCguLkY/R48excMgUfbkooR2eD9u3DhbX4MtXeEXVAa4DQKdPXsWOkJZCGEu1jpeCJMQ9+uvvz537hyxkNebrRVnGcCWEsLBm6vGzVPYwXLI0WKhB9u/A/He/lkGjsXm41sdTPBGeJyNJMOZuT1LKW7cHoSG6LS9V7OzVYbQXot7Q88Im6AO47Fq0BqR416618+qDNBepKWl3bhxg7hI8IOp3333na+vrwuff/31V35+vk2RgTo0rl+/3nqtOKIpeyIhgiLasG5K4rFF9NaZxC34nJGRgWzcfJcWc2sszxw+fJgzsA/tr776ilr5pZdegtO48zFjxnBXf//9NzuUlpaiVc5GnE5MTOQScJezXblyhfD/wgsvtFhZiDa0pkL45ZdfyFG21h1/0QMPPGDD/vg28OvBwcF3qU5VBugqpaqtzEOAJ7Nb8HZOnfD5448/IgbbgTywdOlSwu3WrVvZh+K1M33Y1uFj46VtFrzrFyIwE8jtZqwTHUZ6zzewjnZyFCf57bffyCSUH+QEm0jZ4kKIliyHaKlNkYr1nN7C4PUAqBeovbCFHlp0YoD58+dTShIg53nQooekY3PKKC127dplJ+ckGCT79xmuF9/1C3F+PsLq2OUQ3qVLl7hV/BIZiQOJzXZXT3ngXZUeP34c/0aDM+DTkCi+3MZs956fVRng9iIxQbTF46c7Aqsl3MJ1FtHZSDKxB0bV1dXw3romP/30UxMDodpNK7tZFYFtw3SdPHmSU3EU+YFL3KmnSBKA0N6uz8LCQlvtsI/n+T9mKT4+3rre3dxf6wN1HfDukRPHxsbGWveoJQfrRW3hYSwRISSuSCogqFNy4NT1E0gA9zNpeD+7xWxgqXHtbnAOgZzYDN29p1Bu2bLFem/aPCc/mT29IrRTj1pQ79iKvIIEcAeQnJxs/80uIiKCipOG+/8U3itN2AA1KteGhgYa9igXy/7WW2/dbDEfymjyAFaHRkhICFVpWFhYF+lBlwB6kYFxz25xHebXbYyNDWz0/k8wFvJh/PDhw7///nsjd3tm0pAHCOpnz57t16/fyJEjietBQUH6/iWA+8x+7Aosj4mJqa+vt64SLMrWrVvhqxWstpJPamoqsdzGjd16+lJzc3N5eTniYX+s/5NPPolUumMPugTQMw0Mode777L1s1tiOby31Xv6eMYOkATanLVUU1NDriB7+Pj4cHLObHOLBQngrgC7vHHjRkKyLcVjsRlqQsE+nlWjBw0a5J5nXfJgxYoVxcXFzsA4M4NBh+5xcXEJCQkIoKSkJCoqqnUno+HKlSs20osMgG+xkV6+vr6iV9dHj8q8tlInNp0qs49n+Io9OaIAxcBUVlZC38LCQmdR0ElZWZk94crJyUEAtG0Fc9qukLVl1q3NRwR16E7gCA8PxxQFBwf7+fk94YH4pAxwrwGJbUQxHIXuZkhgM8WosZwMYA/z2chrYmLiunXrzPO4B0mtT3v16lUb6XXhwgUb6UVQ73YjvYRukAGqqqqI2S2shZveOnPmzJSUlKFDh8bGxrK9zf9J4SZ6Y2mMzd6rhGPZDx8+TLSeO3euzVRqMZYBinMtUgGxgHoUp46KMDCjPBBFJIC7i23btsG/JUuW7Ny5083pdtNbm5qapk2blpWVZfTFqxCPbXAL8R49uGkllKe2gAwfLVq0yCnKGZjr16+bU6+rqxswYIAN30V7AwcOtP/uKDbIAt2fDEDBah3q1nYjAmx6KwYmPT0d3kNrK1gDAwPd/6Rok7h8ipaoiSlPw8LCcOrkEB8fH/3eQlesAdwoAJuK6tq7d+8OCAgYO3Ys++Tn5+NPMDbe6xrcuHHDhu/W1NSgE4hOluAQ/a5CdxKALbMxefLkW/x7H/y9jfRqbm4ODQ3FwFAMKKgLPa0XiPvByhPUsUP+/v420gv/o59K6MkCOHDgAHEdv67hu0KvzgCCcC+hcCtIAIIgAQiCBCAIEoAgSACCIAEIggQgCBKAIEgAgiABCIIEIAgSgCBIAIIgAQiCBCAIEoAgSACCIAEIggQgCBKAIEgAgiABCIIEIAgSgCBIAIIgAQiCBCAIEoAgSACCIAEIggQgCHcf/wdDxk1Jq1We/gAAAABJRU5ErkJggg=="
							}
						]
					}
				}
			},
			MapLayerStacks: {
				Set: {
					MapLayerStack: {
						name: "Default",
						MapLayer: {
							name: "layer1",
							refMapProvider: "404",
							opacity: "1.0",
							colBkgnd: "rgb(255,255,255)"
						}
					}
				}
			}
		}
	};

	// sap.ui.vbm.GeoMap.prototype.init = function(){
	// // do something for initialization...
	// };

	// ...........................................................................//
	// This section defines behavior for the control,............................//
	// ...........................................................................//

	GeoMap.prototype.exit = function() {
		VBI.prototype.exit.apply(this, arguments);

		// detach the event.......................................................//
		this.detachSubmit(this.onGeoMapSubmit, this);
		this.detachContainerCreated(this.onGeoMapContainerCreated, this);
		this.detachContainerDestroyed(this.onGeoMapContainerDestroyed, this);


	};

	//helper function
	function delayedUpdate() {

		if (this.m_updateTimerId) {
			clearTimeout(this.m_updateTimerId);
		}
		this.m_updateTimerId = setTimeout(function() {
			this.m_bActionsDirty = true; //force to rebuild VBI json for Actions
			this.m_bSceneDirty = true; //force to rebuild VBI json for Scene as Actions can be attached to VOs which are part of scene definition

			var data = this.update();
			if (data) {
				this.load(data);
			}
		}.bind(this), 0);
	}

	// track modifications on event listeners
	GeoMap.prototype.attachEvent = function() {
		VBI.prototype.attachEvent.apply(this, arguments);
		delayedUpdate.apply(this);
	};

	GeoMap.prototype.detachEvent = function() {
		VBI.prototype.detachEvent.apply(this, arguments);
		delayedUpdate.apply(this);
	};

	// track modifications on resources..........................................//
	GeoMap.prototype.destroyResources = function() {
		this.m_bResourcesDirty = true;
		return this.destroyAggregation("resources");
	};

	GeoMap.prototype.addResource = function(o) {
		this.m_bResourcesDirty = true;
		return this.addAggregation("resources", o);
	};

	GeoMap.prototype.insertResource = function(o, index) {
		this.m_bResourcesDirty = true;
		return this.insertAggregation("resources", o, index);
	};

	GeoMap.prototype.removeResource = function(o) {
		this.m_bResourcesDirty = true;
		return this.removeAggregation("resources", o);
	};

	GeoMap.prototype.removeAllResources = function(o) {
		this.m_bResourcesDirty = true;
		return this.removeAllAggregation("resources");
	};

	// track modifications on vos................................................//
	GeoMap.prototype.destroyVos = function() {
		this.m_bVosDirty = true;
		return this.destroyAggregation("vos");
	};

	GeoMap.prototype.addVo = function(o) {
		this.m_bVosDirty = true;
		this.addAggregation("vos", o);
		o.m_bAggRenew = true;
		return this;
	};

	GeoMap.prototype.insertVo = function(o, index) {
		this.m_bVosDirty = true;
		this.insertAggregation("vos", o, index);
		o.m_bAggRenew = true;
		return this;
	};

	GeoMap.prototype.removeVo = function(o) {
		this.m_bVosDirty = true;
		return this.removeAggregation("vos", o);
	};

	GeoMap.prototype.removeAllVos = function(o) {
		this.m_bVosDirty = true;
		return this.removeAllAggregation("vos");
	};

	// track modifications on geoJsonLayers.................................//
	GeoMap.prototype.destroyGeoJsonLayers = function() {
		this.m_bGJLsDirty = true;
		return this.destroyAggregation("geoJsonLayers");
	};

	GeoMap.prototype.addGeoJsonLayer = function(o) {
		this.m_bGJLsDirty = true;
		return this.addAggregation("geoJsonLayers", o);
	};

	GeoMap.prototype.insertGeoJsonLayer = function(o, index) {
		this.m_bGJLsDirty = true;
		return this.insertAggregation("geoJsonLayers", o, index);
	};

	GeoMap.prototype.removeGeoJsonLayer = function(o) {
		this.m_bGJLsDirty = true;
		return this.removeAggregation("geoJsonLayers", o);
	};

	GeoMap.prototype.removeAllGeoJsonLayers = function(o) {
		this.m_bGJLsDirty = true;
		return this.removeAllAggregation("geoJsonLayers");
	};

	// track modifications on featureCollections.................................//
	GeoMap.prototype.destroyFeatureCollections = function() {
		this.m_bFCsDirty = true;
		return this.destroyAggregation("featureCollections");
	};

	GeoMap.prototype.addFeatureCollection = function(o) {
		this.m_bFCsDirty = true;
		return this.addAggregation("featureCollections", o);
	};

	GeoMap.prototype.insertFeatureCollection = function(o, index) {
		this.m_bFCsDirty = true;
		return this.insertAggregation("featureCollections", o, index);
	};

	GeoMap.prototype.removeFeatureCollection = function(o) {
		this.m_bFCsDirty = true;
		return this.removeAggregation("featureCollections", o);
	};

	GeoMap.prototype.removeAllFeatureCollections = function(o) {
		this.m_bFCsDirty = true;
		return this.removeAllAggregation("featureCollections");
	};

	// track modifications on clusters............................................//
	GeoMap.prototype.destroyClusters = function() {
		this.m_bClustersDirty = true;
		return this.destroyAggregation("clusters");
	};

	GeoMap.prototype.addCluster = function(o) {
		this.m_bClustersDirty = true;
		return this.addAggregation("clusters", o);
	};

	GeoMap.prototype.insertCluster = function(o, index) {
		this.m_bClustersDirty = true;
		return this.insertAggregation("clusters", o, index);
	};

	GeoMap.prototype.removeCluster = function(o) {
		this.m_bClustersDirty = true;
		return this.removeAggregation("clusters", o);
	};

	GeoMap.prototype.removeAllClusters = function(o) {
		this.m_bClustersDirty = true;
		return this.removeAllAggregation("clusters");
	};

	// track modifications on mapConfiguration...................................//

	/**
	 * Set Map configuration data. Map Configurations contain a set of Map Providers and Map Layer Stacks refering to those providers. The GeoMap
	 * property refMapLayerStack defines, which Map Layer Stack becomes visible.
	 *
	 * @param {object} oMapConfiguration Map Configuration object
	 * @param {array} oMapConfiguration.MapProvider Array of Map Provider definitions.
	 * @param {string} oMapConfiguration.MapProvider.name Name for the provider. Needed in Map Layer Stack as reference.
	 * @param {string} oMapConfiguration.MapProvider.tileX X-pixel dimension of map tile. Typical 256.
	 * @param {string} oMapConfiguration.MapProvider.tileY Y-pixel dimension of map tile. Typical 256.
	 * @param {string} oMapConfiguration.MapProvider.minLOD Minimal supported Level Of Detail.
	 * @param {string} oMapConfiguration.MapProvider.maxLOD Maximal supported Level Of Detail.
	 * @param {string} oMapConfiguration.MapProvider.copyright Copyright Information to be shown with the map.
	 * @param {array} oMapConfiguration.MapProvider.Source Array of source definitions. At least on Source has to be given. Multiple sources can be
	 *        used for load distribution.
	 * @param {string} oMapConfiguration.MapProvider.Source.id Source id.
	 * @param {string} oMapConfiguration.MapProvider.Source.url Source URL for map tile service. URL includes place holders for variable informations
	 *        set at runtime, e.g. {LOD}.
	 * @param {array} oMapConfiguration.MapLayerStacks Array of Map Layer Stacks
	 * @param {string} oMapConfiguration.MapLayerStacks.name Name of Map Layer Stack. Use with the GeoMap refMapLayerStack property.
	 * @param {string} oMapConfiguration.MapLayerStacks.previewPosition.latitude Latitude position to use when creating image tile
	 * @param {string} oMapConfiguration.MapLayerStacks.previewPosition.longitude Longitude position to use when creating image tile
	 * @param {string} oMapConfiguration.MapLayerStacks.previewPosition.lod Lod position to use when creating image tile
	 * @param {array} oMapConfiguration.MapLayerStacks.MapLayer Array of Map Layers. Each Layer refers to a Map Proveride. Map Layers get overlayed in
	 *        the given sequence.
	 * @param {string} oMapConfiguration.MapLayerStacks.MapLayer.name Name of Map Layer.
	 * @param {string} oMapConfiguration.MapLayerStacks.MapLayer.refMapProvider Name of referenced Map Provider.
	 * @param {string} oMapConfiguration.MapLayerStacks.MapLayer.opacity Opacity of Map Layer. Value range 0 to 1.
	 * @param {sap.ui.core.CSSColor} oMapConfiguration.MapLayerStacks.colBkgnd Background color for Map Layer. Only meaningful if opacity is
	 *        below 1.
	 * @returns {sap.ui.vbm.GeoMap} This allows method chaining
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */

	GeoMap.prototype.setMapConfiguration = function(o) {
		this.m_bMapConfigurationDirty = true;

		if (o.MapLayerStacks && o.MapProvider) {
			this.m_bMapLayerStacksDirty = true;
			this.m_bMapProvidersDirty = true;

			this.setProperty("mapConfiguration", o);
		}
		return this;
	};

	/**
	 * Set clustering definitions.
	 *
	 * @param {object} oClustering Cluster Definition object
	 * @returns {sap.ui.vbm.GeoMap} This allows method chaining
	 * @public
	 * @deprecated This property should not longer be used. Its functionality has been replaced by the <code>clusters</code> aggregation.
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	GeoMap.prototype.setClustering = function(oClustering) {
		this.m_bClusteringDirty = true;
		this.setProperty("clustering", oClustering);
		return this;
	};

	GeoMap.prototype.setRefMapLayerStack = function(o) {
		if (o === this.getRefMapLayerStack()) {
			return this;
		}
		this.m_bRefMapLayerStackDirty = this.m_bSceneDirty = true;
		this.setProperty("refMapLayerStack", o);
		return this;
	};

	/**
	 * Set Visual Frame definition.
	 *
	 * @param {object} oVisFrame Visual Frame definition object
	 * @param {float} oVisFrame.minLon Minimal longitude of visual frame
	 * @param {float} oVisFrame.maxLon Maximal longitude of visual frame
	 * @param {float} oVisFrame.minLat Minimal latitude of visual frame
	 * @param {float} oVisFrame.maxLat Maximal latitude of visual frame
	 * @param {float} oVisFrame.minLOD Minimal Level of Detail for visual frame
	 * @param {float} oVisFrame.maxLOD Maximal Level of Detail for visual frame
	 * @param {float} oVisFrame.maxFraction Maximal fraction [0..1] of minLOD which is acceptable, otherwise minLOD is rounded upwards
	 * @returns {sap.ui.vbm.GeoMap} This allows method chaining
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	GeoMap.prototype.setVisualFrame = function(oVisFrame) {
		this.m_bVisualFrameDirty = true;
		this.setProperty("visualFrame", oVisFrame);
		return this;
	};

	/**
	 * Set Tracking Mode for Rectangular Selection on/off.
	 *
	 * @param {boolean} bSet to start or stop tracking mode
	 * @returns {sap.ui.vbm.GeoMap} This allows method chaining
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	GeoMap.prototype.setRectangularSelection = function(bSet) {
		VBI.prototype.setRectangularSelection.apply(this, arguments);
		return this;
	};

	/**
	 * Set Tracking Mode for Lasso Selection on/off.
	 *
	 * @param {boolean} bSet to start or stop tracking mode
	 * @returns {sap.ui.vbm.GeoMap} This allows method chaining
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	GeoMap.prototype.setLassoSelection = function(bSet) {
		VBI.prototype.setLassoSelection.apply(this, arguments);
		return this;
	};

	/**
	 * Set Tracking Mode for Rectangular Zoom on/off.
	 *
	 * @param {boolean} bSet to start or stop tracking mode
	 * @returns {sap.ui.vbm.GeoMap} This allows method chaining
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	GeoMap.prototype.setRectZoom = function(bSet) {
		VBI.prototype.setRectZoom.apply(this, arguments);
		return this;
	};

	/**
	 * Trigger the interactive creation mode to get a position or position array.
	 *
	 * @param {boolean} bPosArray Indicator if a single position or an array is requested
	 * @param {function} callback Callback function func( sPosArray ) to be called when done. Position(array) sPosArray is provided in format
	 *        "lon;lat;0;..."
	 * @returns {boolean} Indicator whether the creation mode could be triggered successfully or not.
	 * @public
	 * @experimental Since 1.30.0 This method is experimental and might be modified or removerd in future versions.
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	GeoMap.prototype.getPositionInteractive = function(bPosArray, callback) {
		var isCreationModeTriggered;
		if (!this.mIACreateCB && callback && typeof callback === "function") {
			this.mIACreateCB = callback;

			var sType = bPosArray ? "POSARRAY" : "POS";

			// trigger interactive creation mode by defining an automation call
			var oLoad = {
				"SAPVB": {
					"Automation": {
						"Call": {
							"handler": "OBJECTCREATIONHANDLER",
							"name": "CreateObject",
							"object": "MainScene",
							"scene": "MainScene",
							"instance": "",
							"Param": {
								"name": "data",
								"#": "{" + sType + "}"
							}
						}
					}
				}
			};
			this.load(oLoad);
			isCreationModeTriggered = true;
		} else {
			// callback function registered -> other create still pending!
			isCreationModeTriggered = false;
		}
		return isCreationModeTriggered;
	};

	/**
	 * Retrieves the center position of the current map.
	 * @returns {string} centerPosition A string representing the center position; it is retrieved in the form of "x;y".
	 * @public
	 */
	GeoMap.prototype.getCenterPosition = function() {
		var oScene = this.mVBIContext.GetMainScene(),
			centerPosition;
		//If the main scene exists, we calculate the center position of the scene.
		if (oScene) {
			//converting radians to degrees
			var aCoords = window.VBI.MathLib.RadToDeg(oScene.GetCenterPos());
			centerPosition = aCoords[0] + ";" + aCoords[1];
		} else {
			//If there is no main scene, we return the value of the centerPosition public property.
			centerPosition = this.getProperty("centerPosition");
		}
		return centerPosition;
	};

	GeoMap.prototype.isNumeric = function(n) {
		return !isNaN(parseFloat(n)) && isFinite(n);
	};

	GeoMap.prototype.setCenterPosition = function(sPosition) {
		var aCoords = sPosition ? sPosition.split(";") : undefined;
		if (!aCoords || aCoords.length <= 1 || !this.isNumeric(aCoords[0]) || !this.isNumeric(aCoords[1])) {
			jQuery.sap.log.error(sap.ui.vbm.getResourceBundle().getText("GEOMAP_INVALID_CENTER_POSITION") + ":'" + sPosition + "'", "setCenterPosition", "sap.ui.vbm.GeoMap");
		} else {
			var sPositionInternal = aCoords[0] + ";" + aCoords[1] + ";0";
			this.setProperty("centerPosition", sPositionInternal);
			if (this.isRendered()) {
				// Control already rendered -> need to call function zoom to geopos
				aCoords = sPositionInternal.split(";");
				this.zoomToGeoPosition(aCoords[0], aCoords[1], this.getZoomlevel());
			}
			// else: Control not yet rendered -> position will be taken for initial rendering
		}
		return this;
	};

	// this setter is required for legacy support!
	GeoMap.prototype.setInitialPosition = function(sPosition) {
		this.setCenterPosition(sPosition);
	};

	GeoMap.prototype.getZoomlevel = function() {
		var oScene = this.mVBIContext.GetMainScene();
		if (oScene) {
			return parseInt(oScene.GetCurrentZoomlevel(), 10);
		}
		return this.getProperty("zoomlevel");
	};

	GeoMap.prototype.setZoomlevel = function(iZoom) {
		if (!this.getDisableZoom()) {
			if (iZoom >= 0) {
				if (this.isRendered()) {
					var aCoords = this.getCenterPosition().split(";");
					if (this.getEnableAnimation()) {
						var oScene = this.mVBIContext.GetMainScene();
						oScene.AnimateZoomToGeo(oScene.GetCenterPos(), iZoom, 5);
					} else {
						this.zoomToGeoPosition(aCoords[0], aCoords[1], iZoom);
					}
				}
				this.setProperty("zoomlevel", iZoom);
			} else {
				jQuery.sap.log.error(sap.ui.vbm.getResourceBundle().getText("GEOMAP_INVALID_ZOOM_LEVEL") + ": " + iZoom.toString(), "setZoomlevel", "sap.ui.vbm.GeoMap");
			}
		}
	};

	// this setter is required for legacy support!
	GeoMap.prototype.setInitialZoom = function(sZoom) {
		this.setZoomlevel(parseInt(sZoom, 10));
	};

	/**
	 * Open Detail window
	 *
	 * @param {string} sPosition Postion for the Detail Window in format "lon;lat;0"
	 * @param {object} [oParams] Parameter Objects
	 * @param {string} [oParams.caption] Caption of the Detail Window
	 * @returns {void}
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	GeoMap.prototype.openDetailWindow = function(sPosition, oParams) {
		// set detail window context. The actual opening happens in getWindowsObject()

		this.mDTWindowCxt.key = "";
		this.mDTWindowCxt.open = true;
		this.mDTWindowCxt.bUseClickPos = true;
		this.mDTWindowCxt.params = oParams ? oParams : null;
		this.mDTWindowCxt.src = {
			mClickGeoPos: sPosition
		};
		this.invalidate(this);
		this.m_bWindowsDirty = true;
	};

	/**
	 * Go to Initial Start Position with Initial Zoom Level
	 *
	 * @returns {void}
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	GeoMap.prototype.goToStartPosition = function() {
		if (this.isRendered()) {
			this.mVBIContext.GetMainScene().GoToInitialStart();
		}
	};

	/**
	 * Close any open Detail window
	 *
	 * @returns {void}
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	GeoMap.prototype.closeAnyDetailWindow = function() {
		// set detail window open to false and invalide control -> actual closing is triggered in getWindowsObject()
		this.mDTWindowCxt.open = false;
		this.invalidate(this);
		this.m_bWindowsDirty = true;
	};

	/**
	 * Get an aggregated VO instance by its internal ID returned by e.g. function <code>getInfoForCluster</code>.
	 *
	 * @param {string} [voIdentifier] Internal VO Identifier
	 * @returns {sap.ui.vbm.VoBase} VO instance element or null if nothing found
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	GeoMap.prototype.getVoByInternalId = function(voIdentifier) {
		var voElement = null;
		var aSplitID = voIdentifier.split(/\./);
		var oAggregation = this.getAggregatorContainer(aSplitID[0]);
		if (oAggregation && oAggregation.findInstance) {
			voElement = oAggregation.findInstance(aSplitID[1]);
		}
		return voElement;
	};

	/**
	 * Retrieves all spot instances of a {sap.ui.vbm.ClusterContainer}
	 * @param {sap.ui.vbm.ClusterContainer} clusterContainer The cluster container whose spots we want to retrieve.
	 * @returns {sap.ui.vbm.Spot[]} spots An array of sap.ui.vbm.Spot instances.
	 * @public
	 */
	GeoMap.prototype.getClusteredSpots = function(clusterContainer) {
		//get the list of all internat spot ids belonging to the cluster container passed as argument
		var spotIds = this.getInfoForCluster(clusterContainer.getKey(), sap.ui.vbm.ClusterInfoType.ContainedVOs),
		//find and retrieved all spot instances based on their internat spot id
		spots = spotIds.map(function (spotId) {
			return this.getVoByInternalId(spotId);
		}.bind(this));
		return spots;
	};

	// ..............................................................................................//
	// write selection property back to model and fire select event on aggregation ..................//
	GeoMap.prototype.setSelectionPropFireSelect = function(dat) {
		var aN = dat.N;
		for (var nJ = 0; nJ < aN.length; ++nJ) {
			var oAgg = aN[nJ];
			var aEl = oAgg.E;
			var cont;
			if ((cont = this.getAggregatorContainer(oAgg.name)) && cont.handleSelectEvent) {
				cont.handleSelectEvent(aEl);
			}
		}
	};

	// ...........................................................................//
	// central event handler.....................................................//

	GeoMap.prototype.onGeoMapSubmit = function(e) {
		// analyze the event......................................................//
		var datEvent = JSON.parse(e.mParameters.data);

		// write changed data back to aggregated elements
		if (datEvent.Data && datEvent.Data.Merge) {
			this.handleChangedData(datEvent.Data.Merge.N);
		}

		// get the container......................................................//
		// and delegate the event to the container first..........................//
		var cont;
		if ((cont = this.getAggregatorContainer(datEvent.Action.object))) {
			cont.handleEvent(datEvent);
			if (datEvent.Action.name == "click" && datEvent.Data && datEvent.Data.Merge) {
				this.setSelectionPropFireSelect(datEvent.Data.Merge); // set selection property on model and call select and deselect on Aggregation
			}
		} else {
			/*
			 * TO DO:
			 * other events might be important later
			 */
			switch (datEvent.Action.name) {
				case "click":
					// fire the click..................................................//
					this.fireClick({
						pos: datEvent.Action.AddActionProperties.AddActionProperty[0]['#']
					});
					break;
				case "contextMenu":
					// fire the contextMenu..................................................//
					this.fireContextMenu({
						clientX: datEvent.Action.Params.Param[0]['#'],
						clientY: datEvent.Action.Params.Param[1]['#'],
						pos: datEvent.Action.AddActionProperties.AddActionProperty[0]['#']
					});
					break;
				case "drop":
					// fire the drop..................................................//
					this.fireDrop({
						pos: datEvent.Action.AddActionProperties.AddActionProperty[0]['#']
					});
					break;
				case "zoomChanged":
					// fire the zoomChanged..................................................//
					this.fireZoomChanged({
						zoomLevel: datEvent.Action.AddActionProperties.AddActionProperty[0]['#'],
						centerPoint: datEvent.Action.AddActionProperties.AddActionProperty[1]['#'],
						viewportBB: {
							upperLeft: datEvent.Action.Params.Param[3]['#'],
							lowerRight: datEvent.Action.Params.Param[4]['#']
						}
					});
					break;
				case "centerChanged":
					// fire the centerChanged..................................................//
					this.fireCenterChanged({
						zoomLevel: datEvent.Action.AddActionProperties.AddActionProperty[0]['#'],
						centerPoint: datEvent.Action.AddActionProperties.AddActionProperty[1]['#'],
						viewportBB: {
							upperLeft: datEvent.Action.Params.Param[3]['#'],
							lowerRight: datEvent.Action.Params.Param[4]['#']
						}
					});
					break;
				case "select":
					if (datEvent.Data && datEvent.Data.Merge.N) {
						var aSelected = this.getSelectedItems(datEvent.Data.Merge.N);
						// fire the select ...............................................//
						this.fireSelect({
							selected: aSelected
						});
						this.setSelectionPropFireSelect(datEvent.Data.Merge); // set selection property on model and call select and deselect on
						// Aggregation
					}
					break;
				case "GetPosComplete":
					// Interactive Position gathering finished
					if (this.mIACreateCB) {
						try {
							this.mIACreateCB(datEvent.Action.Params.Param[0]['#']);
							this.mIACreateCB = null;
						} catch (exc) {
							// clear callback function in any case
							this.mIACreateCB = null;
							throw exc;
						}
					}
					break;
				case "keydown":
					if (!this.fireEvent(
						"keyDown", {
							key: datEvent.Action.Params.Param[0]['#'],
							code: datEvent.Action.Params.Param[1]['#'],
							shift: datEvent.Action.Params.Param[2]['#'],
							ctrl: datEvent.Action.Params.Param[3]['#'],
							alt: datEvent.Action.Params.Param[4]['#'],
							meta: datEvent.Action.Params.Param[5]['#']},
							true)) {
						e.preventDefault();
					}
					break;
				case "keypress":
					if (!this.fireEvent(
						"keyPress", {
							key: datEvent.Action.Params.Param[0]['#'],
							code: datEvent.Action.Params.Param[1]['#'],
							shift: datEvent.Action.Params.Param[2]['#'],
							ctrl: datEvent.Action.Params.Param[3]['#'],
							alt: datEvent.Action.Params.Param[4]['#'],
							meta: datEvent.Action.Params.Param[5]['#']},
							true)) {
						e.preventDefault();
					}
					break;
				case "keyup":
					if (!this.fireEvent(
						"keyUp", {
							key: datEvent.Action.Params.Param[0]['#'],
							code: datEvent.Action.Params.Param[1]['#'],
							shift: datEvent.Action.Params.Param[2]['#'],
							ctrl: datEvent.Action.Params.Param[3]['#'],
							alt: datEvent.Action.Params.Param[4]['#'],
							meta: datEvent.Action.Params.Param[5]['#']},
							true)) {
						e.preventDefault();
					}
					break;
				default:
					this.fireEvent(
							datEvent.Action.name,
							datEvent);
					break;
			}
		}
	};

	GeoMap.prototype.onGeoMapContainerCreated = function(e) {
		// get the id of the div area where to place the control..................//
		var div = e.getParameter("contentarea");
		if (div.m_ID) {
			// get the container...................................................//
			// and delegate the event to the container first.......................//
			var cont;
			if ((cont = this.getAggregatorContainer(div.m_ID)) && cont.handleContainerCreated) {
				cont.handleContainerCreated(e);
			}
		}
	};

	GeoMap.prototype.onGeoMapContainerDestroyed = function(e) {
		// get the id of the div area where to place the control..................//
		var div = e.getParameter("contentarea");
		if (div.m_ID) {
			// get the container..................................................//
			// and delegate the event to the container first......................//
			var cont;
			if ((cont = this.getAggregatorContainer(div.m_ID)) && cont.handleContainerDestroyed) {
				cont.handleContainerDestroyed(e);
			}
		}
		if (this.mDTWindowCxt.open && e.getParameter("id") === "Detail") {
			// detail window gets closed
			this.mDTWindowCxt.open = false;
			this.mDTWindowCxt.src = null; // release VO
			this.m_bWindowsDirty = true;
		}
	};

	GeoMap.prototype.init = function() {
		// attach the events
		this.attachSubmit(this.onGeoMapSubmit, this);
		this.attachContainerCreated(this.onGeoMapContainerCreated, this);
		this.attachContainerDestroyed(this.onGeoMapContainerDestroyed, this);

		// initially set dirty state for all elements............................//
		this.m_bVosDirty = true;
		this.m_bFCsDirty = true;
		this.m_bGJLsDirty = true;
		this.m_bClustersDirty = true;
		this.m_bMapConfigurationDirty = true;
		this.m_bClusteringDirty = true;
		this.m_bVisualFrameDirty = true;
		this.m_bRefMapLayerStackDirty = true;
		this.m_bResourcesDirty = true;
		this.m_bMapProvidersDirty = true;
		this.m_bMapLayerStacksDirty = true;
		this.m_bWindowsDirty = true;
		this.m_bMapconfigDirty = true;
		this.m_bLegendDirty = true;
		this.m_bSceneDirty = true;
		this.m_bActionsDirty = true;

		this.mbForceDataUpdate = false;
		this.bDataDeltaUpdate = false;
		this.bHandleChangedDataActive = false;

		// Initialize Detail Window Context object
		this.mDTWindowCxt = {
			open: false,
			src: null,
			key: "",
			params: null
		};

		// call base class first
		VBI.prototype.init.apply(this, arguments);
	};

	// common helper functions...................................................//

	GeoMap.prototype.getSelectedItems = function(data) {
		var cont, aContSel, aSel = [];
		if (!data) {
			return null;
		}
		if (jQuery.type(data) === "object") {
			cont = this.getAggregatorContainer(data.name);
			aContSel = cont.findSelected(true, data.E);
			aSel = aSel.concat(aContSel);
		} else if (jQuery.type(data) === "array") {
			for (var nJ = 0; nJ < data.length; ++nJ) {
				cont = this.getAggregatorContainer(data[nJ].name);
				aContSel = cont.findSelected(true, data[nJ].E);
				if (aContSel && aContSel.length) {
					aSel = aSel.concat(aContSel);
				}
			}
		}

		return aSel;

	};

	GeoMap.prototype.getWindowsObject = function() {
		// determine the windows object..........................................//
		// Main window -> needs always to be defined
		var oWindows = {
			"Set": [
				{
					"name": "Main",
					"Window": {
						"id": "Main",
						"caption": "MainWindow",
						"type": "geo",
						"refParent": "",
						"refScene": "MainScene",
						"modal": "true"
					}
				}
			],
			"Remove": []
		};

		// Legend window ........................................................//
		var oLegend = this.getLegend();
		if (oLegend) {
			var legendDiv;
			if ((legendDiv = this.getDomRef(oLegend.getId()))) {
				this.m_curLegendPos = {
					right: parseInt(legendDiv.style.right, 10),
					top: parseInt(legendDiv.style.top, 10)
				};
			}

			var oLegendWindows = oLegend.getTemplateObject();

			// concat the sets
			if (oLegendWindows.Set) {
				oWindows.Set = oWindows.Set.concat(oLegendWindows.Set);
			}
			// concat the removes
			if (oLegendWindows.Remove) {

				oWindows.Remove = oWindows.Remove.concat(oLegendWindows.Remove);

			}
		}

		// Detail window..........................................................//
		if (this.mDTWindowCxt.src) {
			// Make sure any detail window opened before is closed
			var oRemove, oDTWindows;

			oRemove = [
				{
					"name": "Detail"
				}
			];

			// Check if given source element is still valid
			if (this.mDTWindowCxt.key) {
				var oCurrentSourceInst = this.getChildByKey(this.mDTWindowCxt.src, this.mDTWindowCxt.key);
				if (!oCurrentSourceInst) {
					// related source object does not longer exist -> reset context
					this.mDTWindowCxt.open = false;
					this.mDTWindowCxt.src = null;
					this.mDTWindowCxt.key = "";
					this.mDTWindowCxt.params = null;
				} else {
					// Note: Instances are not stable related to keys -> update source instance to match instance for given key
					this.mDTWindowCxt.src = oCurrentSourceInst;
				}
			}
			if (this.mDTWindowCxt.open) {
				oDTWindows = {
					"Set": [
						{
							"name": "Detail",
							"Window": {
								"id": "Detail",
								"type": "callout",
								"refParent": "Main",
								"refScene": "",
								"modal": "true",
								"caption": this.mDTWindowCxt.params.caption ? this.mDTWindowCxt.params.caption : "",
								"offsetX": this.mDTWindowCxt.params.offsetX ? this.mDTWindowCxt.params.offsetX : "0",
								"offsetY": this.mDTWindowCxt.params.offsetY ? this.mDTWindowCxt.params.offsetY : "0"
							}
						}
					]
				};

				// set window position
				if (this.mDTWindowCxt.bUseClickPos == true && this.mDTWindowCxt.src.mClickGeoPos) {
					oDTWindows.Set[0].Window.pos = this.mDTWindowCxt.src.mClickGeoPos;
				} else {
					oDTWindows.Set[0].Window['pos.bind'] = this.mDTWindowCxt.src.getParent().sId + "." + this.mDTWindowCxt.src.UniqueId + ".P";
				}

				// Add detail window to the list of windows
				oWindows.Set = oWindows.Set.concat(oDTWindows.Set);
			}

			oWindows.Remove = oWindows.Remove.concat(oRemove);
		}
		return oWindows;
	};

	GeoMap.prototype.getActionArray = function() {
		var aActions = [];
		// subscribe for map event
		// Note: We register Action only if event are subscribed
		if (this.mEventRegistry["click"]) {
			aActions.push({
				"id": "GMap1",
				"name": "click",
				"refScene": "MainScene",
				"refVO": "Map",
				"refEvent": "Click",
				"AddActionProperty": [
					{
						"name": "pos"
					}
				]
			});
		}
		if (this.mEventRegistry["contextMenu"]) {
			aActions.push({
				"id": "GMap2",
				"name": "contextMenu",
				"refScene": "MainScene",
				"refVO": "Map",
				"refEvent": "ContextMenu",
				"AddActionProperty": [
					{
						"name": "pos"
					}
				]
			});
		}
		if (this.mEventRegistry["drop"]) {
			aActions.push({
				"id": "GMap3",
				"name": "drop",
				"refScene": "MainScene",
				"refVO": "Map",
				"refEvent": "Drop",
				"AddActionProperty": [
					{
						"name": "pos"
					}
				]
			});
		}
		if (this.mEventRegistry["zoomChanged"]) {
			aActions.push({
				"id": "GMap4",
				"name": "zoomChanged",
				"refScene": "MainScene",
				"refVO": "Map",
				"refEvent": "ZoomChanged",
				"AddActionProperty": [
					{
						"name": "zoom"
					}, {
						"name": "centerpoint"
					}, {
						"name": "pos"
					}
				]
			});
		}
		if (this.mEventRegistry["centerChanged"]) {
			aActions.push({
				"id": "GMap5",
				"name": "centerChanged",
				"refScene": "MainScene",
				"refVO": "Map",
				"refEvent": "CenterChanged",
				"AddActionProperty": [
					{
						"name": "zoom"
					}, {
						"name": "centerpoint"
					}, {
						"name": "pos"
					}
				]
			});
		}
		if (this.mEventRegistry["select"]) {
			aActions.push({
				"id": "GMap6",
				"name": "select",
				"refScene": "MainScene",
				"refVO": "General",
				"refEvent": "Select"
			});
		}
		aActions.push({
			"id": "GMap7",
			"name": "GetPosComplete",
			"refScene": "MainScene",
			"refVO": "General",
			"refEvent": "CreateComplete"
		});
		if (this.mEventRegistry["keyDown"]) {
			aActions.push({
				"id": "GMap8",
				"name": "keydown",
				"refScene": "MainScene",
				"refVO": "",
				"refEvent": "KeyDown"
			});
		}
		if (this.mEventRegistry["keyPress"]) {
			aActions.push({
				"id": "GMap9",
				"name": "keypress",
				"refScene": "MainScene",
				"refVO": "",
				"refEvent": "KeyPress"
			});
		}
		if (this.mEventRegistry["keyUp"]) {
			aActions.push({
				"id": "GMap10",
				"name": "keyup",
				"refScene": "MainScene",
				"refVO": "",
				"refEvent": "KeyUp"
			});
		}
		return aActions;
	};

	GeoMap.prototype.getSceneVOdelta = function(oCurrent, oNew) {
		var aVO = [];
		var aRemove = [];
		// build map of current VOs
		var oVOMap = {};
		for (var nI = 0, len = oCurrent.length; nI < len; ++nI) {
			oVOMap[oCurrent[nI].id] = oCurrent[nI];
		}
		for (var nJ = 0; nJ < oNew.length; ++nJ) {
			if (oVOMap[oNew[nJ].id]) { // VO already exists ...
				if (JSON.stringify(oNew[nJ]) != JSON.stringify(oVOMap[oNew[nJ].id])) { // ... but is different
					aRemove.push({
						"id": oNew[nJ].id,
						"type": "VO"
					}); // remove old VO version from scene and
					aVO.push(oNew[nJ]); // add new VO version
					// window.VBI.m_bTrace && window.VBI.Trace( "Scene update VO " + oNew[nI].id );
				} // else {} // nothing to do

			} else { // new VO -> add it
				aVO.push(oNew[nJ]);
				// window.VBI.m_bTrace && window.VBI.Trace( "Scene add VO " + oNew[nI].id );
			}
			delete oVOMap[oNew[nJ].id]; // remove processed VOs from map
		}
		// remove VOs remaining on map
		for ( var id in oVOMap) {
			aRemove.push({
				"id": id,
				"type": "VO"
			});
			// window.VBI.m_bTrace && window.VBI.Trace( "Scene remove VO " + id );
		}
		var retVal = {
			"Merge": {
				"name": "MainScene",
				"type": "SceneGeo",
				"SceneGeo": {
					"id": "MainScene",
					"refMapLayerStack": this.getRefMapLayerStack()
				}
			}
		};
		if (aRemove.length) {
			retVal.Merge.SceneGeo.Remove = aRemove;
		}
		if (aVO.length) {
			retVal.Merge.SceneGeo.VO = aVO;
		}

		return retVal;
	};

	// diagnostics...............................................................//

	GeoMap.prototype.minimizeApp = function(oApp) {
		/*
		 * TO DO:
		 * calculate a hash instead of caching the json string
		 */

		// remove windows section when not necessary..............................//
		var t, s;
		s = null;
		if (!this.m_bWindowsDirty) {
			(t = oApp) && (t = t.SAPVB) && (t = t.Windows) && (s = JSON.stringify(t)) && (s == this.m_curWindows) && (delete oApp.SAPVB.Windows) || (this.m_curWindows = s ? s : this.m_curWindows);
		} else {
			this.m_bWindowsDirty = false;
		}

		// remove unmodified scenes...............................................//
		s = null;
		(t = oApp) && (t = t.SAPVB) && (t = t.Scenes) && (s = JSON.stringify(t)) && (s == this.m_curScenes) && (delete oApp.SAPVB.Scenes) || (this.m_curScenes = s ? s : this.m_curScenes);

		// remove unmodified actions..............................................//
		s = null;
		(t = oApp) && (t = t.SAPVB) && (t = t.Actions) && (s = JSON.stringify(t)) && (s == this.m_curActions) && (delete oApp.SAPVB.Actions) || (this.m_curActions = s ? s : this.m_curActions);

		// remove unmodified datatypes............................................//
		s = null;
		(t = oApp) && (t = t.SAPVB) && (t = t.DataTypes) && (s = JSON.stringify(t)) && (s == this.m_curDataTypes) && (delete oApp.SAPVB.DataTypes) || (this.m_curDataTypes = s ? s : this.m_curDataTypes);

		// remove unmodified data.................................................//
		if (!this.mbForceDataUpdate) {
			s = null;
			(t = oApp) && (t = t.SAPVB) && (t = t.Data) && (s = JSON.stringify(t)) && (s == this.m_curData) && (delete oApp.SAPVB.Data) || (this.m_curData = s ? s : this.m_curData);
		} else {
			this.mbForceDataUpdate = false; // reset
		}

		return oApp;
	};

	// helper functions..........................................................//

	GeoMap.prototype.getAggregatorContainer = function(id) {
		if (id !== "MainScene") { // don't search for preserved ids
			// find the right aggregation instance to delegate the event..............//
			var aCluster = this.getClusters();
			for (var nL = 0; nL < aCluster.length; ++nL) {
				if (aCluster[nL].sId === id) {
					return aCluster[nL];
				}
			}
			var aVO = this.getVos();
			for (var nJ = 0, len = aVO.length; nJ < len; ++nJ) {
				if (aVO[nJ].sId === id) {
					return aVO[nJ];
				}
			}
			var aGJL = this.getGeoJsonLayers();
			for (var nI = 0; nI < aGJL.length; ++nI) {
				if (id.indexOf(aGJL[nI].sId) === 0) { // id starts with sId
					return aGJL[nI];
				}
			}
			var aFC = this.getFeatureCollections();
			for (var nK = 0; nK < aFC.length; ++nK) {
				if (id.indexOf(aFC[nK].sId) === 0) { // id starts with sId
					return aFC[nK];
				}
			}
			var legend = this.getLegend();
			if (legend && legend.sId == id) {
				return legend;
			}
		}
		return null;
	};

	GeoMap.prototype.update = function() {
		// get the frame application..............................................//
		var oApp = jQuery.extend(true, {}, GeoMap.oBaseApp);

		// update the resource data...............................................//
		if (this.m_bResourcesDirty) {
			this.updateResourceData(oApp);
		}
		var oClusterRefVOs = {};
		if (this.m_bClusteringDirty || this.m_bClustersDirty) {
			this.updateClustering(oApp, oClusterRefVOs);
			this.mCurClusterRefVOs = jQuery.extend(true, {}, oClusterRefVOs); // deep copy!
		} else {
			oClusterRefVOs = jQuery.extend(true, {}, this.mCurClusterRefVOs); // deep copy!
		}
		// update the scene data.....................................................//
		if (this.m_bSceneDirty) {
			this.updateScene(oApp, oClusterRefVOs);
		}
		// new resources may have been added ( e.g. images for vo ) .................//
		if (this.m_bResourcesDirty) {
			this.updateResourceData(oApp);
		}
		if (this.m_bMapConfigurationDirty) {
			this.updateMapConfiguration(oApp);
		}

		this.updateMapProviders(oApp);
		this.updateMapLayerStacks(oApp);
		this.updateWindows(oApp);

		// add non VO related actions
		// legend events
		var legend;
		if ((legend = this.getLegend())) {
			if (oApp.SAPVB.Actions) {
				Array.prototype.push.apply(oApp.SAPVB.Actions.Set.Action, legend.getActionArray());
			}
		// } else {
		// var saAction = [];
		// Array.prototype.push.apply( saAction, legend.getActionArray() );
		// ((oApp.SAPVB.Actions = {}).Set = {}).Action = saAction;
		}

		if (this.m_bActionsDirty && !oApp.SAPVB.Actions) {
			this.m_bActionsDirty = false;
			((oApp.SAPVB.Actions = {}).Set = {}).Action = [];
		}

		if (oApp.SAPVB.Actions) {
			this.m_bActionsDirty = false;
			Array.prototype.push.apply(oApp.SAPVB.Actions.Set.Action, this.getActionArray());
		}
		// remove unnecessary sections and return application JSON...................//
		return this.minimizeApp(oApp);
	};

	GeoMap.prototype.updateMapProviders = function(oApp) {
		if (!this.m_bMapProvidersDirty) {
			delete oApp.SAPVB.MapProviders; // remove MapProviders from app
		}
		this.m_bMapProvidersDirty = false;
	};

	GeoMap.prototype.updateMapLayerStacks = function(oApp) {
		if (!this.m_bMapLayerStacksDirty) {
			delete oApp.SAPVB.MapLayerStacks; // remove MapLayerStacks from app
		}
		this.m_bMapLayerStacksDirty = false;
	};

	GeoMap.prototype.updateWindows = function(oApp) {
		oApp.SAPVB.Windows = this.getWindowsObject();
	};

	GeoMap.prototype.updateScene = function(oApp, oClusterRefVOs) {
		var saVO = []; // visual object array in the scene..................//
		var saData = (oClusterRefVOs.Data) ? oClusterRefVOs.Data : []; // data array in the data section....................//
		var saRemoveData = [];
		var saType = []; // type array in the type section ...................//
		var saAction = (oClusterRefVOs.Actions) ? oClusterRefVOs.Actions : []; // actions...........................................//

		// Insert GeoJSON layers and Feature Collection before VOs to get them rendered behind the VOs
		var bUseDelta = !this.m_bFCsDirty && !this.m_bGJLsDirty && !this.m_bVosDirty;
		this.updateGJLData(saVO, saData, saRemoveData, saType, saAction, bUseDelta);
		this.updateFCData(saVO, saData, saRemoveData, saType, saAction, bUseDelta);
		this.updateVOData(saVO, saData, saRemoveData, saType, saAction, bUseDelta);

		// Insert Cluster Viz VO definitions last to make sure they get painted on top
		if (oClusterRefVOs.VO) {
			saVO = saVO.concat(oClusterRefVOs.VO);
		}

		if (this.m_bLegendDirty) {
			// process legend.........................................................//
			var oLegend = this.getLegend();
			if (oLegend) {
				saRemoveData.push({
					name: oLegend.sId,
					type: "N"
				});

				saData.push(oLegend.getDataObject());
				saType.push(oLegend.getTypeObject());
			}
		}

		// check if an update of the scene is necessary...........................//
		// failsafe but data has to be created first..............................//
		var _saVO = JSON.stringify(saVO);
		var bMetaUpdate = true; // might be reset in else part
		if (!this.m_saVO) { // no prior VO data -> initial scene definition
			((((oApp.SAPVB.Scenes = {}).Set = {}).SceneGeo = {
				"id": "MainScene",
				"refMapLayerStack": this.getRefMapLayerStack(),
				"initialZoom": this.getProperty("zoomlevel"),
				"initialStartPosition": this.getProperty("centerPosition"),
				"scaleVisible": this.getScaleVisible().toString(),
				"navControlVisible": this.getNavcontrolVisible().toString(),
				"rectSelect": this.getRectangularSelection().toString(),
				"lassoSelect": this.getLassoSelection().toString(),
				"rectZoom": this.getRectZoom().toString(),
				"VisualFrame": this.getVisualFrame(),
				"NavigationDisablement": {
					"zoom": this.getDisableZoom().toString(),
					"move": this.getDisablePan().toString()
				}
			}).VO = saVO);
		} else if (this.m_bRefMapLayerStackDirty || !(this.m_saVO === _saVO)) {
			// prior VO data exists -> calculate delta and preserve scene
			(oApp.SAPVB.Scenes = this.getSceneVOdelta(JSON.parse(this.m_saVO), saVO));
			// bMetaUpdate = false;
		} else {
			bMetaUpdate = false;
		}
		this.m_saVO = _saVO;

		// now we should have data, data types and instance information...........//
		// merge it into the app..................................................//
		var nI;

		if (this.bDataDeltaUpdate) {
			oApp.SAPVB.Data = {};
			oApp.SAPVB.Data.Set = [];
			for (nI = 0; nI < saData.length; ++nI) {
				oApp.SAPVB.Data.Set.push({
					name: saData[nI].name,
					type: "N",
					N: saData[nI]
				});
			}
		} else {
			oApp.SAPVB.Data = {};
			if (saRemoveData.length) {
				oApp.SAPVB.Data.Remove = [];
				for (nI = 0; nI < saRemoveData.length; ++nI) {
					oApp.SAPVB.Data.Remove.push(saRemoveData[nI]);
				}
			}
			oApp.SAPVB.Data.Set = [];
			for (nI = 0; nI < saData.length; ++nI) {
				oApp.SAPVB.Data.Set.push({
					name: saData[nI].name,
					type: "N",
					N: saData[nI]
				});
			}

		}

		if (bMetaUpdate) {
			(((oApp.SAPVB.DataTypes = {}).Set = {}).N = saType);
		}
		// Update Actions always, since handler could be added or removed at any time!
		(((oApp.SAPVB.Actions = {}).Set = {}).Action = saAction);

		// reset dirty states
		this.resetDirtyStates();
	};

	GeoMap.prototype.resetDirtyStates = function() {
		this.m_bRefMapLayerStackDirty = this.m_bSceneDirty = this.m_bFCsDirty = this.m_bGJLsDirty = this.m_bVosDirty = false;
	};

	GeoMap.prototype.updateMapConfiguration = function(oApp) {
		if (!this.m_bMapConfigurationDirty) {
			return;
		}

		// reset dirty state......................................................//
		this.m_bMapConfigurationDirty = false;
		var aConfig = this.getMapConfiguration();

		// set the map providers
		if (aConfig) {
			oApp.SAPVB.MapProviders = {
				Set: {
					MapProvider: aConfig.MapProvider
				}
			};
			oApp.SAPVB.MapLayerStacks = {
				Set: {
					MapLayerStack: aConfig.MapLayerStacks
				}
			};
		}

		return;
	};

	GeoMap.prototype.updateClustering = function(oApp, oClusterRefVOs) {
		var aClusters = this.getClusters();
		var oClustering = null;

		if (aClusters.length) {
			oClustering = {
				Cluster: []
			};
			oClusterRefVOs.VO = [];
			oClusterRefVOs.Actions = [];
			oClusterRefVOs.Data = [];
			for (var nI = 0, oCluster; nI < aClusters.length; ++nI) {
				oCluster = aClusters[nI];
				// add ref VO for display
				oClusterRefVOs.VO.push(oCluster.getTemplateObject());
				// Note: Do not add a DataType or Data for the VizVO, it is not needed.
				// DataTypes array does not support delta logic and an update destroys the relation to the Data!
				oClusterRefVOs.Actions = oClusterRefVOs.Actions.concat(oCluster.getActionArray());
				oClustering.Cluster.push(oCluster.getClusterDefinition());
			}
		} else if (this.m_bClusteringDirty) {
			// cluster aggregation empty -> check for clustering prperty (to be removed later)
			oClustering = this.getClustering();
		}
		if (oClustering) {
			oApp.SAPVB.Clustering = {
				Set: oClustering
			};
		} else if (this.mCurClusterRefVOs && this.mCurClusterRefVOs.VO.length > 0) {
			// there was clustering before and now it is switched off
			oApp.SAPVB.Clustering = {
				Set: []
			};
		}
		this.m_bClusteringDirty = this.m_bClustersDirty = false;
	};

	GeoMap.prototype.updateResourceData = function(oApp) {
		if (!this.m_bResourcesDirty) {
			return;
		}

		// reset dirty state......................................................//
		this.m_bResourcesDirty = false;
		var aRes = this.getResources();

		((oApp.SAPVB.Resources = {}).Set = {}).Resource = [];

		// update function for delayed loaded resources...........................//
		function ResUpdate() {
			var oApp = this.update();
			this.load(oApp);
		}

		// image load callback..............................................//
		var funcLoaded = function(res) {
			if (!res.m_Img) {   // check if given resource is still alive and valid
				return;
			}
			if (!res.m_Img.complete) { //skip odd onload event from IE where image is not loaded yet
				return;
			}

			var canvas = document.createElement('canvas');
			canvas.width = res.m_Img.width;
			canvas.height = res.m_Img.height;
			var context = canvas.getContext('2d');
			context.drawImage(res.m_Img, 0, 0);
			res.mProperties.value = canvas.toDataURL();
			delete res.m_Img;
			// mark resources as dirty and apply them again..................//
			this.m_bResourcesDirty = true;
			window.setTimeout(ResUpdate.bind(this), 10);
		};

		// read the resources and update them.....................................//
		for (var nJ = 0, len = aRes.length; nJ < len; ++nJ) {
			// get the control.....................................................//
			var res = aRes[nJ];

			// load the data from an url, when done we replace the value...........//
			if (!res.mProperties.value && res.mProperties.src) {
				var img = document.createElement('img');
				img.crossOrigin = 'anonymous'; //enable CORS images rendered on canvas
				res.m_Img = img;
				img.onload = funcLoaded.bind(this, res);
				// we set the data url..............................................//
				img.src = res.mProperties.src;
			} else {
				// when a name is specified, use it. In all other cases use id.........//
				oApp.SAPVB.Resources.Set.Resource.push({
					"name": (res.mProperties.name ? res.mProperties.name : res.sId),
					"value": res.mProperties.value
				});
			}
		}

		return;
	};

	GeoMap.prototype.updateVOData = function(saVO, saData, saRemoveData, saType, saAction, bUseDelta) {
		var aVO = this.getVos();
		// process visual objects.................................................//
		// we collect the different arrays from the vo instances...................//

		for (var nJ = 0, len = aVO.length; nJ < len; ++nJ) {
			// get the control.....................................................//
			var oVO = aVO[nJ];
			var aDiff = oVO.aDiff;
			saVO.push(oVO.getTemplateObject());
			saType.push(oVO.getTypeObject());
			Array.prototype.push.apply(saAction, oVO.getActionArray());
			if (aDiff && aDiff.length && oVO.m_bAggChange && bUseDelta) {
				var oDelta = oVO.getDataDeltaObject(aDiff);
				if (oDelta.oData && oDelta.oData.E && oDelta.oData.E.length) {
					saData.push(oDelta.oData);
				}
				if (oDelta.aRemoveData) {
					for (var nK = 0; nK < oDelta.aRemoveData.length; ++nK) {
						saRemoveData.push(oDelta.aRemoveData[nK]);
					}
				}
			} else if (!bUseDelta || oVO.m_bAggRenew) {
				// renew all data
				saRemoveData.push(oVO.getDataRemoveObject());
				if (oVO instanceof sap.ui.vbm.VoAggregation) {
					oVO.resetIndices();
				}
				saData.push(oVO.getDataObject());
			}
			if (oVO instanceof sap.ui.vbm.VoAggregation) {
				oVO.aDiff = [];
				oVO.updateIdxArray();
				oVO.m_bAggRenew = oVO.m_bAggChange = false;
			}
		}

	};

	/*
	 * @private
	 */
	GeoMap.prototype.updateGJLData = function(saVO, saData, saRemoveData, saType, saAction, bUseDelta) {
		var aLayers = this.getGeoJsonLayers();

		// process feature collections.................................................//
		// we collect the different arrays from the fc instances...................//

		for (var nJ = 0, len = aLayers.length; nJ < len; ++nJ) {
			// get the control.....................................................//
			var oLayer = aLayers[nJ];

			// add the control objects description..................................//
			// Note: A feature collection may return multiple VOs!
			Array.prototype.push.apply(saVO, oLayer.getTemplateObjects());
			Array.prototype.push.apply(saType, oLayer.getTypeObjects());
			Array.prototype.push.apply(saAction, oLayer.getActionArray());
			// add the control data
			Array.prototype.push.apply(saRemoveData, oLayer.getDataRemoveObjects());
			Array.prototype.push.apply(saData, oLayer.getDataObjects());
		}
	};

	/*
	 * @private
	 */
	GeoMap.prototype.updateFCData = function(saVO, saData, saRemoveData, saType, saAction, bUseDelta) {
		var aFC = this.getFeatureCollections();

		// process feature collections.................................................//
		// we collect the different arrays from the fc instances...................//

		for (var nJ = 0, len = aFC.length; nJ < len; ++nJ) {
			// get the control.....................................................//
			var oFC = aFC[nJ];

			// add the control objects description..................................//
			// Note: A feature collection may return multiple VOs!
			Array.prototype.push.apply(saVO, oFC.getTemplateObjects());
			Array.prototype.push.apply(saType, oFC.getTypeObjects());
			Array.prototype.push.apply(saAction, oFC.getActionArray());
			// add the control data
			Array.prototype.push.apply(saRemoveData, oFC.getDataRemoveObjects());
			Array.prototype.push.apply(saData, oFC.getDataObjects());
		}
	};

	GeoMap.prototype.invalidate = function(oSource) {
		// invalidate scene in any case to trigger updateScene
		this.m_bSceneDirty = true;
		// set the vos dirty state when the aggregations have changed
		if (oSource instanceof sap.ui.vbm.VoAggregation) {
			this.m_bWindowsDirty = true;
			// if invalidate results from internal data change we allow delta update for data
			this.bDataDeltaUpdate = this.bHandleChangedDataActive;
		} else if (oSource instanceof sap.ui.vbm.Legend) {
			this.m_bLegendDirty = true;
		} else if (oSource instanceof sap.ui.vbm.GeoJsonLayer) {
			if (oSource instanceof sap.ui.vbm.FeatureCollection) {
				this.m_bFCsDirty = true;
			} else {
				this.m_bGJLsDirty = true;
			}
		} else if (oSource instanceof sap.ui.vbm.ClusterBase) {
			this.m_bClustersDirty = true;
		}

		sap.ui.core.Control.prototype.invalidate.apply(this, arguments);
	};

	GeoMap.prototype.openContextMenu = function(typ, inst, menu) {
		if (menu && menu.vbi_data && menu.vbi_data.VBIName == "DynContextMenu") {
			if (!this.mVBIContext.m_Menus) {
				this.mVBIContext.m_Menus = new window.VBI.Menus();
			}
			this.mVBIContext.m_Menus.m_menus.push(menu);
			var oAutomation = {

				"SAPVB": {
					"version": "2.0",
					"Automation": {
						"Call": {
							"earliest": "0",
							"handler": "CONTEXTMENUHANDLER",
							"instance": inst.sId,
							"name": "SHOW",
							"object": typ,
							"refID": "CTM",
							"Param": [
								{
									"name": "x",
									"#": inst.mClickPos[0]
								}, {
									"name": "y",
									"#": inst.mClickPos[1]
								}, {
									"name": "scene",
									"#": "MainScene"
								}
							]
						}
					}
				}
			};
			this.loadHtml(oAutomation);
		}
	};

	GeoMap.prototype.addResourceIfNeeded = function(resource) {
		var aRes = this.getResources();
		for (var nJ = 0, len = aRes.length; nJ < len; ++nJ) {
			if (aRes[nJ].getName() === resource) {
				// resource allready loaded
				return;
			}
		}
		if (GeoMap.bEncodedSpotImagesAvailable == false) {
			var aPathImgJSON = sap.ui.resource("sap.ui.vbm", "themes/base/img/Pin_images.json");
			var oResponse = jQuery.sap.syncGetJSON(aPathImgJSON);
			GeoMap.bEncodedSpotImageData = oResponse.data;
			GeoMap.bEncodedSpotImagesAvailable = true;
		}
		if (GeoMap.bEncodedSpotImageData) {
			for ( var key in GeoMap.bEncodedSpotImageData) {
				if (resource == key) {
					this.addResource(new sap.ui.vbm.Resource({
						name: key,
						value: GeoMap.bEncodedSpotImageData[key]
					}));
				}
			}
		} else {
			// resource not found
			this.addResource(new sap.ui.vbm.Resource({
				name: resource,
				src: sap.ui.resource("sap.ui.vbm", "themes/base/img/" + resource)
			}));
		}
		this.m_bResourcesDirty = true;
	};

	GeoMap.prototype.handleChangedData = function(aNodes) {
		try {
			this.bHandleChangedDataActive = true;
			if (aNodes && aNodes.length) {
				for (var nI = 0, oNode, oCont; nI < aNodes.length; ++nI) {
					oNode = aNodes[nI];
					oCont = this.getAggregatorContainer(oNode.name);
					if (oCont) {
						oCont.handleChangedData(oNode.E);
					}
				}
			}
			this.bHandleChangedDataActive = false;
		} catch (exc) {
			this.bHandleChangedDataActive = false;
			throw exc;
		}

	};

	GeoMap.prototype.getChildByKey = function(oChild, sKey) {
		var cont, oChildInst = null;
		if ((cont = oChild.getParent())) {
			if (cont instanceof sap.ui.vbm.VoAggregation) {
				if ((this.getAggregatorContainer(cont.getId()))) {
					oChildInst = cont.findInstanceByKey(sKey);
				}
			} else {
				oChildInst = cont.findInstance(sKey);
			}
		}
		return oChildInst;
	};

	/**
	 * Zoom to Areas by Id.
	 *
	 * @param {ui5AreaIds} ui5AreaIds is an Array of areas that we want to zoom to.
	 * @param {float} correlationFactor is the correction factor, if correlationFactor is set to 1.0 the bounding box points are exactly on the visible boder of the new area
	 * @returns {sap.ui.vbm.GeoMap} This allows method chaining
	 * @public
	 */
	GeoMap.prototype.zoomToAreasById = function(ui5AreaIds, correlationFactor) {
		//if the correlation is undefined use hardcoded value
		if (correlationFactor === undefined || correlationFactor === null) {
			correlationFactor = 0.9999;
		}

		ui5AreaIds = [].concat(ui5AreaIds);

		//Get all Vos and filter to create new array with elements that are instance of sap.ui.vbm.Areas
		var areaAggregations = this.getVos().filter(function(vo) {
			return vo instanceof sap.ui.vbm.Areas;
		});

		//Get Area items of Areas
		var areas = areaAggregations.reduce(function(previous, current) {
			return previous.concat(current.getItems());
		}, []);

		//get uniqueId of each area if it exists in ui5AreaIds
		var areaUniqueIds = areas.map(function(area) {
			if (ui5AreaIds.indexOf(area.getId()) !== -1) {
				return area.UniqueId;
			} else {
				return null;
			}
		});

		areaUniqueIds = areaUniqueIds.filter(function(areaUniqueId) {
			return areaUniqueId ? areaUniqueId : false;
		});

		//Call zoomTo from scene with array of areaUniqueIds
		var scene = this.mVBIContext.GetMainScene();
		scene.ZoomTo(areaUniqueIds, correlationFactor);

		return this;
	};


	return GeoMap;

}, /* bExport= */true);

}; // end of sap/ui/vbm/GeoMap.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.AnalyticMap') ) {
/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides control sap.ui.vbm.AnalyticMap.
jQuery.sap.declare('sap.ui.vbm.AnalyticMap'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.core.theming.Parameters'); // unlisted dependency retained
sap.ui.define("sap/ui/vbm/AnalyticMap",[
	'sap/ui/core/theming/Parameters', './GeoMap', './library', './VoBase'
], function(Parameters, GeoMap, library, VoBase) {
	"use strict";

	/**
	 * Constructor for a new AnalyticMap.
	 * 
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 * @class The AnalyticMap control. This control renders a Map based on a GeoJSON source. The GeoJSON file is searched in the following places in
	 *        the given sequence:
	 *        <ul>
	 *        <li> &lt;server&gt;:&lt;port&gt;/sap/bc/vbi/geojson/L0.json
	 *        <li> ./media/analyticmap/L0.json
	 *        </ul>
	 *        Further it is possible to specify a different URL by setting static attribute sap.ui.vbm.AnalyticMap.GeoJSONURL.<br>
	 *        The Features from the GeoJSON get rendered as neutral background in gray. They are not active, but may report a name via tooltip. Each
	 *        feature is expected to have a property id or id2, where as id2 should be an ISO country according to ISO 3166-2.<br>
	 *        By adding Region elements to the regions aggregation it is possible to make feature from the GeoJSON interactive. Region elements need
	 *        to match by ISO code.
	 * @extends sap.ui.vbm.GeoMap
	 * @author SAP SE
	 * @constructor
	 * @public
	 * @alias sap.ui.vbm.AnalyticMap
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var AnalyticMap = GeoMap.extend("sap.ui.vbm.AnalyticMap", /** @lends sap.ui.vbm.AnalyticMap.prototype */
	{
		metadata: {

			library: "sap.ui.vbm",
			properties: {},
			aggregations: {

				/**
				 * Regions that are different from the defaults. It is possible to specify the tooltip and color for regions. The region code must
				 * match the GeoJSON id2 identifier.
				 */
				regions: {
					type: "sap.ui.vbm.Region",
					multiple: true,
					singularName: "region"
				}
			},
			events: {

				/**
				 * The event is raised when there is a click or a tap on a region.
				 */
				regionClick: {
					parameters: {

						/**
						 * The regions code.
						 */
						code: {
							type: "string"
						}
					}
				},

				/**
				 * The event is raised when there is a right click or a tap and hold action on a region.
				 */
				regionContextMenu: {
					parameters: {

						/**
						 * The regions code.
						 */
						code: {
							type: "string"
						}
					}
				},

				/**
				 * Raised when regions get selected
				 */
				regionSelect: {},

				/**
				 * Event is raised when regions get deselected
				 */
				regionDeselect: {}
			}
		}
	});

	// ...........................................................................//
	// Author: Ulrich Roegelein
	// ...........................................................................//
	// Static Configuration......................................................//
	// ...........................................................................//
	// on abap systems the GeoJSON is requested from this handler................//
	AnalyticMap.DefaultABAPGeoJSONURL = "/sap/bc/vbi/geojson/L0.json";
	AnalyticMap.DefaultGeoJSONURL = "media/analyticmap/L0.json";
	AnalyticMap.DefaultRegionColor = (Parameters && Parameters.get("sapUiChoroplethRegionBG")) ? Parameters.get("sapUiChoroplethRegionBG") : "rgb(213,218,221)";
	AnalyticMap.DefaultRegionColorBorder = (Parameters && Parameters.get("sapUiChoroplethRegionBorder")) ? Parameters.get("sapUiChoroplethRegionBorder") : "rgb(255,255,255)";
	AnalyticMap.DefaultRegionSelectColor = "RHLSA(0;1;1;1)"; // no change!
	AnalyticMap.DefaultHotDeltaColor = "RHLSA(0;1;1;1.0)"; // default regions should not be hot
	AnalyticMap.AltBorderColor = (Parameters && Parameters.get("sapUiChartDataPointBorderHoverSelectedColor")) ? Parameters.get("sapUiChartDataPointBorderHoverSelectedColor") : "#676767";
	// reduce opacity to 60%
	var nonSelectOpacity = (Parameters && Parameters.get("sapUiChartDataPointNotSelectedBackgroundOpacity") ? Parameters.get("sapUiChartDataPointNotSelectedBackgroundOpacity") : "0.6");
	AnalyticMap.DefaultRegionNonSelectColor = "RHLSA(0;1;1;" + nonSelectOpacity + ")";

	// ...........................................................................//
	// This section defines behavior for the control,............................//
	// ...........................................................................//

	AnalyticMap.prototype.exit = function() {
		GeoMap.prototype.exit.apply(this, arguments);

		// detach the event.......................................................//
		this.detachEvent('submit', AnalyticMap.prototype.onAnalyticsSubmit, this);
	};

	AnalyticMap.prototype.onAfterRendering = function() {
		sap.ui.vbm.VBI.prototype.onAfterRendering.apply(this, arguments);
	};

	// changes in regions........................................................//

	AnalyticMap.prototype.destroyRegions = function() {
		this.mbRegionsDirty = true;
		this.destroyAggregation("regions");
	};

	AnalyticMap.prototype.addRegion = function(o) {
		this.mbRegionsDirty = true;
		this.addAggregation("regions", o);
	};

	AnalyticMap.prototype.removeRegion = function(o) {
		this.mbRegionsDirty = true;
		this.removeAggregation("regions", o);
	};

	AnalyticMap.prototype.insertRegion = function(o, index) {
		this.mbRegionsDirty = true;
		this.insertAggregation("regions", o, index);
	};

	AnalyticMap.prototype.removeAllRegions = function() {
		this.mbRegionsDirty = true;
		this.removeAllAggregation("regions");
	};

	// changes in legend..........................................................//

	AnalyticMap.prototype.destroyLegend = function() {
		this.mbLegendDirty = true;
		this.destroyAggregation("legend");
	};

	AnalyticMap.prototype.setLegend = function(o) {
		this.mbLegendDirty = true;
		this.setAggregation("legend", o);
	};

	AnalyticMap.prototype.onAnalyticsSubmit = function(e) {
		// analyze the event......................................................//
		var datEvent = JSON.parse(e.mParameters.data);

		// when clicking a region, the key is provided in the instance parameter..//
		var code, o, oParams;
		// fire the events........................................................//
		switch (datEvent.Action.name) {
			case "RGN_CONTEXTMENU":
				code = datEvent.Action.instance.split(".")[1];
				oParams = {
					code: code
				};
				if ((o = this.findRegionInAggregation(code))) {
					o.fireContextMenu(oParams);
				}

				this.fireRegionContextMenu(oParams);
				break;
			case "RGN_CLICK":
				code = datEvent.Action.instance.split(".")[1];
				oParams = {
					code: code
				};
				if ((o = this.findRegionInAggregation(code))) {
					o.fireClick(oParams);
				}
				this.fireRegionClick(oParams);
				if (datEvent.Data && datEvent.Data.Merge) {
					this.setSelectionPropFireSelect(datEvent.Data.Merge); // set selection property on model and call select and deselect on
				}
				// Aggregation
				break;
			default:
				break;
		}

	};

	AnalyticMap.prototype.init = function() {
		// set control specific property defaults
		// explicitely set properties will still be applied later!
		this.mProperties.scaleVisible = false;

		// call base class first.................................................//
		GeoMap.prototype.init.apply(this, arguments);

		// initially we set the dirty states.....................................//
		this.mbRegionsDirty = false;
		this.mbLegendDirty = false;

		// indicate that theming is not applied
		this.mbThemingDirty = true;

		// attach the event
		this.attachEvent('submit', AnalyticMap.prototype.onAnalyticsSubmit, this);

		this.createRegions();
	};

	AnalyticMap.prototype.createRegions = function() {
		// set some default colors
		var colC = this.mColC = AnalyticMap.DefaultRegionColor;
		var colCB = this.mColCB = AnalyticMap.DefaultRegionColorBorder;

		// region constructor.....................................................//
		function Region(id, array, type, color, colorBorder, tooltip, entity) {
			this.K = id;
			this.P = [];
			this.T = tooltip;
			this.C = color;
			this.CB = colorBorder;
			this.HDC = AnalyticMap.DefaultHotDeltaColor;
			this.ACB = this.CB; // no alternative border color per default
			this.G = entity;
			this.S = "false"; // per default nothing selected

			var str, area, areaParts;
			for (var nI = 0, alen = array.length; nI < alen; ++nI) {
				area = array[nI];
				areaParts = [];
				for (var nJ = 0, blen = area.length; nJ < blen; ++nJ) {
					str = "";
					for (var nK = 0, clen = area[nJ].length; nK < clen; ++nK) {
						if (nK) {
							(str += ";");
						}
						str += area[nJ][nK];
					}
					areaParts.push(str);
				}
				this.P.push(areaParts);
			}
		}

		// the constructor needs to be removed, when it is not removed the jquery.//
		// cloning will not work..................................................//
		delete Region.prototype.constructor;

		// ........................................................................//
		// load the geojson trying different location.............................//
		// first the explicit path, second abap third the default.................//

		var oData = null, aPathGeoJSON = [], oResponse, sPathGeoJSON = "";

		// build array of URLs to check for source JSON in the prioritized order
		aPathGeoJSON[0] = AnalyticMap.GeoJSONURL; // explicit specified
		var oUri = window.URI(AnalyticMap.DefaultABAPGeoJSONURL); // abap system
		oUri.addQuery("sap-language", sap.ui.getCore().getConfiguration().getLanguage()); // append the language parameter to the uri
		aPathGeoJSON[1] = oUri.toString();
		aPathGeoJSON[2] = sap.ui.resource("sap.ui.vbm", AnalyticMap.DefaultGeoJSONURL); // default path

		for (var mI = 0; mI < 3; ++mI) {
			sPathGeoJSON = aPathGeoJSON[mI];
			if (!oData && sPathGeoJSON) {
				oResponse = jQuery.sap.syncGetJSON(sPathGeoJSON);
				if (oResponse.statusCode === 200) {
					oData = oResponse.data;
					break;
				}
				// else: JSON not found under current URL -> try next
			}
		}

		// verify that the json at the specified location was loaded..............//
		if (!oData) {
			jQuery.sap.log.error("The GeoJSON file at location " + sPathGeoJSON + " is invalid or could not be parsed.\r\nPlease contact your Administrator.");
			return;
		}

		// load the data with the default settings................................//
		var E = [];
		this.mRegionApplicationTable = E;

		this.mRegionBox = []; // region box
		this.mNames = []; // array of names
		this.mRegionProps = []; // array of properties
		var minX, maxX, minY, maxY;

		var af = oData.features, tt = '', va;
		var xa; // array of bounding boxes for multi parts
		var mpa; // multi polygon array
		var ppa; // polygon parts array - with holes
		for (var nJ = 0, aflen = af.length; nJ < aflen; ++nJ) {
			va = [];
			mpa = [];
			ppa = [];
			xa = [];
			var f = af[nJ];

			// skip the Antarctica.................................................//
			if (f.id2 === "AQ") {
				continue;
			}

			// use id in case id2 is not given
			if (!f.id2) {
				f.id2 = f.id;
			}

			// get the name of the fragment........................................//
			tt = (f.properties && f.properties.name) ? f.properties.name : "";
			this.mNames[f.id2] = tt;
			this.mRegionProps[f.id2] = f.properties;

			var coord = f.geometry.coordinates;
			var acn, x, y, tmp, coordlen;
			var nI, nK;

			switch (f.geometry.type) {
				case "Polygon":
					minY = Number.MAX_VALUE;
					maxY = -Number.MAX_VALUE;
					minX = Number.MAX_VALUE;
					maxX = -Number.MAX_VALUE;

					coordlen = coord.length;
					for (nI = 0; nI < coordlen; ++nI) {
						acn = coord[nI];

						// create the vbi float array for regions
						va = [];
						for (nK = 0; nK < acn.length; ++nK) {
							tmp = acn[nK];
							if (!nI) {
								// do min max detection -> only on null'th, since holes will not contribute //
								if ((x = tmp[0]) < minX) {
									minX = x;
								}
								if (x > maxX) {
									maxX = x;
								}
								if ((y = tmp[1]) < minY) {
									minY = y;
								}
								if (y > maxY) {
									maxY = y;
								}
							}
							va.push(tmp[0], tmp[1], "0");
						}
						ppa.push(va);
					}
					mpa.push(ppa);
					xa.push([
						minX, maxX, minY, maxY
					]);
					break;
				case "MultiPolygon":
					for (var nL = 0, acmlen = coord.length; nL < acmlen; ++nL) {
						minY = Number.MAX_VALUE;
						maxY = -Number.MAX_VALUE;
						minX = Number.MAX_VALUE;
						maxX = -Number.MAX_VALUE;

						ppa = [];
						coordlen = coord[nL].length;
						for (nI = 0; nI < coordlen; ++nI) {
							acn = coord[nL][nI];

							// create the vbi float array for regions.....................//
							va = [];
							for (nK = 0; nK < acn.length; ++nK) {
								tmp = acn[nK];
								if (!nI) {
									// do min max detection -> only on null'th, since holes will not contribute //
									if ((x = tmp[0]) < minX) {
										minX = x;
									}
									if (x > maxX) {
										maxX = x;
									}
									if ((y = tmp[1]) < minY) {
										minY = y;
									}
									if (y > maxY) {
										maxY = y;
									}
								}
								va.push(tmp[0], tmp[1], "0");
							}
							ppa.push(va);
						}
						xa.push([
							minX, maxX, minY, maxY
						]);
						mpa.push(ppa);
					}
					break;
				default:
					// ignore all other feature types!
					continue;
			}
			E.push(new Region(f.id2, mpa, f.geometry.type, colC, colCB, tt, f.id2));

			// get surrounding box for all parts -> this needs to consider round world for optimized bounding box size!
			this.mRegionBox[f.id2] = window.VBI.MathLib.GetSurroundingBox(xa);
		}
	};

	// ...........................................................................//
	// helper functions for analytic content.....................................//

	AnalyticMap.prototype.getRegionsTemplateObject = function() {
		return {
			"id": "Region",
			"type": "{00100000-2012-0004-B001-F311DE491C77}",
			"entity.bind": "Regions.Entity",
			"datasource": "Regions",
			"posarraymulti.bind": "Regions.PosList",
			"color.bind": "Regions.Color",
			"selectColor": AnalyticMap.DefaultRegionSelectColor,
			"nonSelectColor": AnalyticMap.DefaultRegionNonSelectColor,
			"colorBorder.bind": "Regions.BorderColor",
			"tooltip.bind": "Regions.ToolTip",
			"hotDeltaColor.bind": "Regions.HotDeltaColor",
			"altBorderDeltaColor.bind": "Regions.AltBorderColor",
			"select.bind": "Regions.VB:s",
			"labelText.bind": "Regions.LT",
			"labelPos.bind": "Regions.LP",
			"labelBgColor.bind": "Regions.LBC",
			"labelBorderColor.bind": "Regions.LBBC",
			"labelArrow.bind": "Regions.AR",
			"labelType.bind": "Regions.LabelType"
		};
	};

	AnalyticMap.prototype.getRegionsTypeObject = function() {
		var arr = [
			{
				"name": "Key",
				"alias": "K",
				"type": "string"
			}, {
				"name": "PosList",
				"alias": "P",
				"type": "vectorarraymulti"
			}, {
				"name": "ToolTip",
				"alias": "T",
				"type": "string"
			}, {
				"name": "Color",
				"alias": "C",
				"type": "color"
			}, {
				"name": "BorderColor",
				"alias": "CB",
				"type": "color"
			}, {
				"name": "HotDeltaColor",
				"alias": "HDC",
				"type": "string"
			}, {
				"name": "AltBorderColor",
				"alias": "ACB",
				"type": "color"
			}, {
				"name": "Entity",
				"alias": "G",
				"type": "string"
			}, {
				"name": "VB:s", // selection flag
				"alias": "S",
				"type": "boolean"
			}, {
				"name": "LT", // label text
				"alias": "LT",
				"type": "string"
			}, {
				"name": "LP", // label position
				"alias": "LP",
				"type": "string"
			}, {
				"name": "LBC",
				"alias": "LBC", // label background color
				"type": "color"
			}, {
				"name": "LBBC",
				"alias": "LBBC", // label border color,
				"type": "color"
			}, {
				"name": "AR",
				"alias": "AR", // label arrow
				"type": "boolean"
			}, {
				"name": "LabelType",
				"alias": "LabelType", // label semantic type
				"type": "string"
			}
		];
		return {
			"name": "Regions",
			"minSel": "0",
			"maxSel": "-1",
			"key": "Key",
			"A": arr
		};
	};

	AnalyticMap.prototype.getRegionsDataObjects = function() {
		// apply the region properties to the vbi datacontext.....................//
		// do a real clone of the original data, to be able to handle complete....//
		// model changes..........................................................//
		var aElements = [];
		var aElementsRegions = [];
		var aElementsNonRegions = [];
		var aElementsAll = [];
		jQuery.extend(true, aElements, this.mRegionApplicationTable);

		if (!aElements.length) {
			return null; // return immediately when no regions are available.....//
		}

		// get lookup for modified properties..................................//
		var oRegionMap = this.getRegionMap();

		// iterate over region tables.............................................//
		for (var nJ = 0, len = aElements.length, oRegion, item, tmp; nJ < len; ++nJ) {
			item = aElements[nJ];

			if ((oRegion = oRegionMap[item.K])) {
				// item found, apply properties.....................................//
				item.HDC = "RHLSA(0;1.0;1.0;0.4)"; // lower opacity to 40%
				item.ACB = AnalyticMap.AltBorderColor;
				if ((tmp = oRegion.getColor())) {
					item.C = (this.getPlugin()) ? window.VBI.Utilities.String2VBColor(tmp) : tmp;
				}
				if ((tmp = oRegion.getTooltip())) {
					item.T = tmp;
				}
				item.LT = oRegion.getLabelText();

				item.S = oRegion.getSelect();

				// Label Position 0 means CENTERED
				item.LP = "0";

				item.LBC = oRegion.getLabelBgColor();

				item.LBBC = oRegion.getLabelBorderColor();

				item.AR = oRegion.getLabelArrow();

				var type = oRegion.getLabelType();

				// Applying changes according to the label type
				var oElem = VoBase.prototype.getLabelProps(type);
				if (oElem && item.LT) {
					if (oElem.LBC) {
						item.LBC = oElem.LBC;
					}
					if (oElem.LBBC) {
						item.LBBC = oElem.LBBC;
					}
					if (oElem.LIC) {
						item.LIC = oElem.LIC;
					}
					if (oElem.LICC) {
						item.LICC = oElem.LICC;
					}
					if (oElem.LICTC) {
						item.LICTC = oElem.LICTC;
					}
				}
				if (!item.LBC) {
					item.LBC = "rgba(255,255,255,1.0)";
				}
				if (item.LBBC == "") {
					item.LBBC = item.LBC;
				}

				aElementsRegions.push(item);
			} else {
				aElementsNonRegions.push(item);
			}
		}
		aElementsAll = aElementsNonRegions.concat(aElementsRegions);
		return {
			"name": "Regions",
			"type": "N",
			"E": aElementsAll
		};
	};

	AnalyticMap.prototype.addRegionsActions = function(aActions) {
		// check if the different vo events are registered........................//
		aActions.push({
			"id": "AMap1",
			"name": "RGN_CLICK",
			"refScene": "MainScene",
			"refVO": "Region",
			"refEvent": "Click"
		});
		aActions.push({
			"id": "AMap2",
			"name": "RGN_CONTEXTMENU",
			"refScene": "MainScene",
			"refVO": "Region",
			"refEvent": "ContextMenu"
		});
		// UR: Seems not to be used at all
		// aActions.push( { "id": "AMap3", "name": "regionSelect", "refScene": "MainScene", "refVO": "Region", "refEvent": "regionSelect" });
		// aActions.push( { "id": "AMap4", "name": "regionDeselect", "refScene": "MainScene", "refVO": "Region", "refEvent": "regionDeselect" });

		return aActions;
	};

	// ...........................................................................//
	// helper functions..........................................................//
	AnalyticMap.prototype.findSelected = function(select, data) {
		var aCP = this.getRegions();
		if (!aCP) {
			return null;
		}
		var aSel = [];
		if (jQuery.type(data) == 'object') {
			if (data.S == (select ? "true" : "false")) {
				for (var nI = 0; nI < aCP.length; ++nI) {
					if (aCP[nI].sId == data.K) {
						aSel.push(aCP[nI]);
					}
				}

			}
		} else if (jQuery.type(data) == 'array') {
			for (var nJ = 0; nJ < data.length; ++nJ) {
				if (data[nJ].S == (select ? "true" : "false")) {
					for (var nK = 0; nK < aCP.length; ++nK) {
						if (aCP[nK].mProperties.code === data[nJ].K) {
							aSel.push(aCP[nK]);
						}
					}
				}
			}
		}
		return aSel;
	};

	AnalyticMap.prototype.setSelectionPropFireSelect = function(dat) {
		var oGMDat = {};
		oGMDat.N = [];
		var aN = dat.N;
		for (var nJ = 0; nJ < aN.length; ++nJ) {
			var oAgg = aN[nJ];
			var aEl = oAgg.E;
			var aChangedSel, aChangedDesel;
			var bNonOverlaySelected = false;
			if (oAgg.name == "Regions") {
				aChangedSel = [];
				aChangedDesel = [];

				// get map region overlays..................................//
				var oRegionMap = this.getRegionMap();

				// collect overlay regions which selectin state changes
				for (var nK = 0; nK < aEl.length; ++nK) {
					var oEl = aEl[nK];
					var bEleSel = (oEl.S == "true" ? true : false);
					var oRegion = oRegionMap[oEl.K];
					if (oRegion) {
						var bModelSel = oRegion.getSelect();
						if (bEleSel != bModelSel) {
							oRegion.setSelect(bEleSel); // set selection property
							if (bEleSel && this.mEventRegistry["regionSelect"]) {
								// to be selected according to value
								aChangedSel.push(oRegion); // add element to array to fire the select on aggregation
							} else if (!bEleSel && this.mEventRegistry["regionDeselect"]) {
								// to be deselected
								aChangedDesel.push(oRegion); // add element to array to fire the deselect on aggregation
							}
						}
					} else {
						bNonOverlaySelected = true;
					}
				}

				// fire events
				if (aChangedDesel.length) {
					this.fireRegionDeselect({
						deselected: aChangedDesel
					});
				}
				if (aChangedSel.length) {
					this.fireRegionSelect({
						selected: aChangedSel
					});
				}

				if (bNonOverlaySelected) {
					// non-overlayed region selected -> invalidate to reset this selection
					// Selection state for overlayed regions already written to elements and will be read correctly on update
					this.invalidate();
					this.mbForceDataUpdate = true; // Make sure the data section passes the Minimizer!
				}
			} else {
				oGMDat.N.push(oAgg);
			}
		}
		// let geomap process all other VOs
		if (oGMDat.N.length) {
			GeoMap.prototype.setSelectionPropFireSelect.call(this, oGMDat);
		}
	};

	AnalyticMap.prototype.getSelectedItems = function(data) {
		var aSel = [];
		if (!data) {
			return null;
		}

		for (var nJ = 0; nJ < data.length; ++nJ) {
			if (data[nJ].name === "Regions") {
				var aRegSel = this.findSelected(true, data[nJ].E);
				if (aRegSel && aRegSel.length) {
					aSel = aSel.concat(aRegSel);
				}
			} else {
				var cont = this.getAggregatorContainer(data[nJ].name);
				var aContSel = cont.findSelected(true, data[nJ].E);
				if (aContSel && aContSel.length) {
					aSel = aSel.concat(aContSel);
				}
			}
		}

		return aSel;

	};

	AnalyticMap.prototype.findRegionInAggregation = function(code) {
		var aCP = this.getRegions();
		if (aCP) {
			for (var nJ = 0, len = aCP.length; nJ < len; ++nJ) {
				if (aCP[nJ].mProperties.code === code) {
					return aCP[nJ];
				}
			}
		}
		return null;
	};

	AnalyticMap.prototype.updateVOData = function(saVO, saData, saRemoveData, saType, saAction) {
		if (this.mbThemingDirty) {
			this.applyTheming(this.mRegionApplicationTable);
		}

		// get analytics specific data first.....................................//
		// Note: This ensures Analytic Map lays behind GeoMap objects
		saVO.push(this.getRegionsTemplateObject()); // template object
		saType.push(this.getRegionsTypeObject()); // template type
		// renew all data
		saRemoveData.push({
			name: "Regions",
			type: "N"
		});

		saData.push(this.getRegionsDataObjects()); // data objects containing colors

		// call base class and add GeoMap stuff..................................//
		GeoMap.prototype.updateVOData.apply(this, arguments);

		this.addRegionsActions(saAction);
		// set scale visibility
		// ( t = oGeoMapData ) && (t = t.SAPVB) && (t = t.Scenes) && (t = t.Set) && (t = t.SceneGeo ) && ( !( t.scaleVisible ) ) && (t.scaleVisible =
		// this.getScaleVisible().toString() );

	};

	AnalyticMap.prototype.resetDirtyStates = function() {
		GeoMap.prototype.resetDirtyStates.apply(this, arguments);
		this.mbRegionsDirty = false;
	};

	AnalyticMap.prototype.minimizeApp = function(oApp) {
		GeoMap.prototype.minimizeApp.apply(this, arguments);
		// when no map configuraton is set we remove it because the default......//
		// of the geomap should not be used......................................//
		var t, r;
		if (!this.getMapConfiguration()) {
			(t = oApp) && (t = t.SAPVB) && (t = t.Scenes) && ((r = t.Set) || (r = t.Merge)) && (t = r.SceneGeo) && (t.refMapLayerStack) && (t.refMapLayerStack = "");
		}
		return oApp;
	};

	AnalyticMap.prototype.invalidate = function(oSource) {
		// set the regions dirty state when a property has changed in the region..//
		if (oSource instanceof sap.ui.vbm.Region) {
			this.mbRegionsDirty = true;
		}

		// call base class........................................................//
		GeoMap.prototype.invalidate.apply(this, arguments);
	};

	AnalyticMap.prototype.getRegionMap = function() {
		var oRegionMap = {};
		var aCP = this.getRegions();
		for (var nJ = 0, len = aCP ? aCP.length : 0, item; nJ < len; ++nJ) {
			item = aCP[nJ];
			oRegionMap[item.getCode()] = item;
		}
		return oRegionMap;
	};

	/**
	 * Zoom to one ore more regions.
	 * 
	 * @param {string[]} aCodes Array of region codes. The region codes must match the geo json tags.
	 * @param {object} oCorr Correction for the calculated zoom factor. You can either a factor, the calculated zoom is multplied with or a array with
	 *        pixels to be added as border in the sequence [left, top,right, bottom].
	 * @returns {void}
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	AnalyticMap.prototype.zoomToRegions = function(aCodes, oCorr) {
		if (oCorr == undefined) {
			oCorr = 0.9999;
		}

		// get the bounding box around............................................//
		var areaList = [];

		// get the min max values from the region boxes...........................//
		for (var nJ = 0, len = aCodes.length; nJ < len; ++nJ) {
			var rb = this.mRegionBox[aCodes[nJ]];
			if (rb != undefined) {
				areaList.push(rb);
			}
		}

		// return immediately when no bounds found................................//
		if (!areaList.length) {
			return;
		}

		// the project must be loaded already.....................................//
		var scene = null;
		if ((scene = this.mVBIContext.GetMainScene())) {
			scene.ZoomToAreas(areaList, oCorr);
		}
	};

	/**
	 * Returns Infos for Regions like name, bounding box and midpoint
	 * 
	 * @param {string[]} aCodes Array of region codes. The region code must match the geo json tag.
	 * @returns {array} Array of Region Information Objects. Each object in the array has the properties BBox: Bounding Box for Region in format
	 *          "lonMin;latMin;lonMax;latMax", Midpoint: Centerpoint for Region in format "lon;lat", Name: Name of the region, and Properties: Array
	 *          of name-value-pair associated with the region
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	AnalyticMap.prototype.getRegionsInfo = function(aCodes) {
		var result = [];
		for (var nJ = 0, len = aCodes.length, code; nJ < len; ++nJ) {
			code = aCodes[nJ];
			result[code] = {};
			result[code].BBox = this.mRegionBox[code];
			result[code].Midpoint = [
				(this.mRegionBox[code][0] + this.mRegionBox[code][1]) / 2, (this.mRegionBox[code][2] + this.mRegionBox[code][3]) / 2
			];
			result[code].Name = this.mNames[code];
			result[code].Properties = this.mRegionProps[code];
		}
		return result;
	};

	AnalyticMap.prototype.onThemeChanged = function(oEvent) {
		// suppose colors have changed
		this.mbThemingDirty = true;
		this.invalidate();
	};

	AnalyticMap.prototype.applyTheming = function(aRegions) {
		if (sap.ui.core.theming && Parameters) { // only if theming parameters are available
			var sColC = AnalyticMap.DefaultRegionColor;
			if (Parameters.get("sapUiChoroplethRegionBG") != undefined) {
				sColC = AnalyticMap.DefaultRegionColor = Parameters.get("sapUiChoroplethRegionBG");
			}
			var sColCB = AnalyticMap.DefaultRegionColorBorder;
			if (Parameters.get("sapUiChoroplethRegionBorder") != undefined) {
				sColCB = AnalyticMap.DefaultRegionColorBorder = Parameters.get("sapUiChoroplethRegionBorder");
			}
			if (this.getPlugin()) { // plug-in mode -> make sure color format matches plugin requirements
				sColC = window.VBI.Utilities.String2VBColor(sColC);
				sColCB = window.VBI.Utilities.String2VBColor(sColCB);
			}
			if (sColC != this.mColC || sColCB != this.mColCB) {
				// apply new colors colors
				for (var i = 0; i < aRegions.length; ++i) {
					// Note: Only change default colors
					if (aRegions[i].C === this.mColC) {
						aRegions[i].C = sColC;
					}
					if (aRegions[i].CB === this.mColCB) {
						aRegions[i].CB = sColCB;
					}
				}
				// remember new default colors
				this.mColC = sColC;
				this.mColCB = sColCB;
			}
			this.mbThemingDirty = false;
		}
	};

	return AnalyticMap;

});

}; // end of sap/ui/vbm/AnalyticMap.js
