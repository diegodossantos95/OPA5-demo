// This file has been generated by the SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.richtexteditor.library-all');
if ( !jQuery.sap.isDeclared('sap.ui.richtexteditor.RichTextEditorRenderer') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */
// Provides default renderer for control sap.ui.richtexteditor.RichTextEditor
jQuery.sap.declare('sap.ui.richtexteditor.RichTextEditorRenderer'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('jquery.sap.global'); // unlisted dependency retained
jQuery.sap.require('sap.ui.core.Renderer'); // unlisted dependency retained
sap.ui.define("sap/ui/richtexteditor/RichTextEditorRenderer",['jquery.sap.global', 'sap/ui/core/Renderer'],
	function(jQuery, Renderer) {
	"use strict";


	/**
	 * RichTextEditorRenderer
	 * @class
	 * @static
	 * @author Malte Wedel, Andreas Kunz
	 */
	var RichTextEditorRenderer = {
	};

	/**
	 * Renders the HTML for the given control, using the provided {@link sap.ui.core.RenderManager}.
	 *
	 * @param {sap.ui.core.RenderManager} rm The RenderManager that can be used for writing to the Render-Output-Buffer.
	 * @param {sap.ui.richtexteditor.RichTextEditor}
	 *            oRichTextEditor The RichTextEditor control that should be rendered.
	 */
	RichTextEditorRenderer.render = function(rm, oRichTextEditor) {
		var oToolbarWrapper = oRichTextEditor.getAggregation("_toolbarWrapper");
		var bCustomToolbar = oToolbarWrapper && oRichTextEditor._bCustomToolbarRequirementsFullfiled;

		rm.write('<div');
		rm.writeControlData(oRichTextEditor);
		if (oRichTextEditor.getEditorType() == "TinyMCE4") {
			rm.writeAttribute("data-sap-ui-preserve", oRichTextEditor.getId());
		}
		rm.addClass("sapUiRTE");
		if (oRichTextEditor.getRequired()) {
			rm.addClass("sapUiRTEReq");
		}
		if (oRichTextEditor.getUseLegacyTheme()) {
			rm.addClass("sapUiRTELegacyTheme");
		}
		if (bCustomToolbar) {
			rm.addClass("sapUiRTEWithCustomToolbar");
		}

		rm.writeClasses();
		rm.addStyle("width", oRichTextEditor.getWidth());
		rm.addStyle("height", oRichTextEditor.getHeight());
		rm.writeStyles();
		if (oRichTextEditor.getTooltip_AsString()) { // ensure not to render null
			rm.writeAttributeEscaped("title", oRichTextEditor.getTooltip_AsString());
		}
		rm.write('>');

		if (bCustomToolbar) {
			oToolbarWrapper.addStyleClass("sapUiRTECustomToolbar");
			rm.renderControl(oToolbarWrapper);
		}

		// Call specialized renderer method if it exists
		var sRenderMethodName = "render" + oRichTextEditor.getEditorType() + "Editor";
		if (this[sRenderMethodName] && typeof this[sRenderMethodName] === "function") {
			this[sRenderMethodName].call(this, rm, oRichTextEditor);
		}

		rm.write('</div>');
	};

	return RichTextEditorRenderer;

}, /* bExport= */ true);

}; // end of sap/ui/richtexteditor/RichTextEditorRenderer.js
if ( !jQuery.sap.isDeclared('sap.ui.richtexteditor.ToolbarWrapperRenderer') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */
// Provides default renderer for control sap.ui.richtexteditor.ToolbarWrapper
jQuery.sap.declare('sap.ui.richtexteditor.ToolbarWrapperRenderer'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('jquery.sap.global'); // unlisted dependency retained
jQuery.sap.require('sap.ui.core.Renderer'); // unlisted dependency retained
sap.ui.define("sap/ui/richtexteditor/ToolbarWrapperRenderer",['jquery.sap.global', 'sap/ui/core/Renderer'],
	function (jQuery, Renderer) {
		"use strict";


		/**
		 * RichTextEditor's ToolbarRenderer
		 * @class
		 * @static
		 */
		var ToolbarRenderer = {};

		/**
		 * Renders the HTML for the given control, using the provided {@link sap.ui.core.RenderManager}.
		 *
		 * @param {sap.ui.core.RenderManager} oRM The RenderManager that can be used for writing to the Render-Output-Buffer.
		 * @param {sap.ui.richtexteditor.ToolbarWrapper} oToolbarWrapper The Toolbar control that should be rendered.
		 */
		ToolbarRenderer.render = function (oRM, oToolbarWrapper) {
			oToolbarWrapper.getAggregation("_toolbar").addStyleClass("sapUiRTECustomToolbar");
			oRM.renderControl(oToolbarWrapper.getAggregation("_toolbar"));
		};

		return ToolbarRenderer;

	}, /* bExport= */ true);

}; // end of sap/ui/richtexteditor/ToolbarWrapperRenderer.js
if ( !jQuery.sap.isDeclared('sap.ui.richtexteditor.library') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

/**
 * Initialization Code and shared classes of library sap.ui.richtexteditor.
 */
jQuery.sap.declare('sap.ui.richtexteditor.library'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('jquery.sap.global'); // unlisted dependency retained
jQuery.sap.require('sap.ui.core.Core'); // unlisted dependency retained
jQuery.sap.require('sap.ui.core.library'); // unlisted dependency retained
sap.ui.define("sap/ui/richtexteditor/library",['jquery.sap.global', 'sap/ui/core/Core', 'sap/ui/core/library'],
	function (jQuery, Core, library1) {
		"use strict";

		/**
		 * A rich text editor (RTE) control. Requires installation of an additional rich text editor library.
		 *
		 * @namespace
		 * @name sap.ui.richtexteditor
		 * @public
		 */


		// library dependencies

		// delegate further initialization of this library to the Core
		sap.ui.getCore().initLibrary({
			name : "sap.ui.richtexteditor",
			dependencies : ["sap.ui.core"],
			types: [
				"sap.ui.richtexteditor.EditorType"
			],
			interfaces: [
				"sap.ui.richtexteditor.IToolbar"
			],
			controls: [
				"sap.ui.richtexteditor.RichTextEditor",
				"sap.ui.richtexteditor.ToolbarWrapper"
			],
			elements: [],
			version: "1.50.6"
		});

		/**
		 *
		 * Interface for controls which are suitable as a Toolbar for RichTextEditor.
		 *
		 * @since 1.50
		 * @name sap.ui.richtexteditor.IToolbar
		 * @interface
		 * @public
		 * @ui5-metamodel This interface also will be described in the UI5 (legacy) designtime metamodel
		 */

		/**
		 * Determines which editor component should be used for editing the text.
		 *
		 * @enum {string}
		 * @public
		 * @ui5-metamodel This enumeration also will be described in the UI5 (legacy) designtime metamodel
		 */
		sap.ui.richtexteditor.EditorType = {

			/**
			 * Uses TinyMCE version 3 as editor (default)
			 * @public
			 */
			TinyMCE: "TinyMCE",

			/**
			 * Uses TinyMCE version 4 as editor
			 * @public
			 */
			TinyMCE4: "TinyMCE4"

		};

		/**
		 * Provides command for CustomToolbar in RichTextEditor control. Only
		 * relevant for TinyMCE4
		 *
		 * @enum {string}
		 * @private
		 */
		sap.ui.richtexteditor.EditorCommands = {
			Bold: {
				icon: "bold-text",
				command: "Bold",
				style: "bold",
				bundleKey: "BOLD_BUTTON_TOOLTIP"
			},
			Italic: {
				icon: "italic-text",
				command: "Italic",
				style: "italic",
				bundleKey: "ITALIC_BUTTON_TOOLTIP"
			},
			Underline: {
				icon: "underline-text",
				command: "Underline",
				style: "underline",
				bundleKey: "UNDERLINE_BUTTON_TOOLTIP"
			},
			Strikethrough: {
				icon: "edit", // just for testing
				command: "Strikethrough",
				style: "strikethrough",
				bundleKey: "STRIKETHROUGH_BUTTON_TOOLTIP"
			},
			Copy: {
				icon: "copy",
				command: "Copy",
				bundleKey: "COPY_BUTTON_TOOLTIP"
			},
			Cut: {
				icon: "scissors",
				command: "Cut",
				bundleKey: "CUT_BUTTON_TOOLTIP"
			},
			Paste: {
				icon: "paste",
				command: "Paste",
				bundleKey: "PASTE_BUTTON_TOOLTIP"
			},
			UnorderedList: {
				icon: "list",
				command: "InsertUnorderedList",
				bundleKey: "UNORDERED_LIST_BUTTON_TOOLTIP"
			},
			OrderedList: {
				icon: "numbered-text",
				command: "InsertOrderedList",
				bundleKey: "ORDERED_LIST_BUTTON_TOOLTIP"
			},
			Outdent: {
				icon: "outdent",
				command: "Outdent",
				bundleKey: "OUTDENT_BUTTON_TOOLTIP"
			},
			Indent: {
				icon: "indent",
				command: "Indent",
				bundleKey: "INDENT_BUTTON_TOOLTIP"
			},
			Undo: {
				icon: "undo",
				command: "Undo",
				bundleKey: "UNDO_BUTTON_TOOLTIP"
			},
			Redo: {
				icon: "redo",
				command: "Redo",
				bundleKey: "REDO_BUTTON_TOOLTIP"
			},
			TextAlign: {
				Left: {
					text: "Left",
					icon: "text-align-left",
					style: "alignleft"
				},
				Center: {
					text: "Center",
					icon: "text-align-center",
					style: "aligncenter"
				},
				Right: {
					text: "Right",
					icon: "text-align-right",
					style: "alignright"
				},
				Full: {
					text: "Full",
					icon: "text-align-justified",
					style: "alignjustify"
				},
				bundleKey: "TEXTALIGN_BUTTON_TOOLTIP"
			},
			FontFamily: {
				AndaleMono: {
					text: "Andale Mono",
					commandValue: '"andale mono",monospace'
				},
				Arial: {
					text: "Arial",
					commandValue: "arial, helvetica, sans-serif"
				},
				ArialBlack: {
					text: "Arial Black",
					commandValue: '"arial black", sans-serif'
				},
				BookAntiqua: {
					text: "Book Antiqua",
					commandValue: '"book antiqua", palatino, serif'
				},
				ComicSansMS: {
					text: "Comic Sans MS",
					commandValue: '"comic sans ms", sans-serif'
				},
				CourierNew: {
					text: "Courier New",
					commandValue: '"courier new", couriret, monospace'
				},
				Georgia: {
					text: "Georgia",
					commandValue: "georgia, palatino, serif"
				},
				Helvetica: {
					text: "Helvetica",
					commandValue: 'helvetica, arial, sans-serif'
				},
				Impact: {
					text: "Impact",
					commandValue: "impact, sans-serif"
				},
				Symbol: {
					text: "Symbol",
					commandValue: '"symbol"'
				},
				Tahoma: {
					text: "Tahoma",
					commandValue: "tahoma, arial, helvetica, sans-serif"
				},
				Terminal: {
					text: "Terminal",
					commandValue: "terminal, monaco, monospace"
				},
				TimesNewRoman: {
					text: "Times New Roman",
					commandValue: '"times new roman", times, sans-serif'
				},
				TrebuchetMS: {
					text: "Trebuchet MS",
					commandValue: '"trebuchet ms", geneva, sans-serif'
				},
				Verdana: {
					text: "Verdana",
					commandValue: "verdana, geneva, sans-serif"
				},
				Webdings: {
					text: "Webdings",
					commandValue: '"webdings"'
				},
				Wingings: {
					text: "Wingings",
					commandValue: 'wingings, "zapf dingbats"'
				}
			},
			FontSize: [8, 10, 12, 14, 18, 24, 36],
			TextColor: {
				title: "Text Color",
				icon: "text-color",
				command: "ForeColor",
				style: "color",
				defaultValue: "#000000",
				bundleKey: "TEXT_COLOR_BUTTON_TOOLTIP"
			},
			BackgroundColor: {
				title: "Background Color",
				icon: "color-fill",
				command: "HiliteColor",
				style: "background-color",
				defaultValue: "#ffffff",
				bundleKey: "BACKGROUND_COLOR_BUTTON_TOOLTIP"
			},
			InsertImage: {
				title: "Insert Image",
				icon: "picture",
				bundleKey: "IMAGE_BUTTON_TOOLTIP"
			},
			InsertLink: {
				title: "Insert Link",
				icon: "chain-link",
				bundleKey: "LINK_BUTTON_TOOLTIP"
			},
			Unlink: {
				icon: "broken-link",
				command: "unlink",
				bundleKey: "UNLINK_BUTTON_TOOLTIP"
			},
			InsertTable: {
				title: "Insert Table",
				icon: "table-view",
				bundleKey: "TABLE_BUTTON_TOOLTIP"
			}
		};

		/**
		 * Provides ButtonGroups for CustomToolbar in RichTextEditor control. Only
		 * relevant for TinyMCE4
		 *
		 * @enum {string}
		 * @private
		 */
		sap.ui.richtexteditor.ButtonGroups = {
			"font-style": ["Bold", "Italic", "Underline", "Strikethrough"],
			"text-align": ["TextAlign"],
			"font": ["FontFamily", "FontSize", "TextColor", "BackgroundColor"],
			"structure": ["UnorderedList", "OrderedList", "Outdent", "Indent"],
			"link": ["InsertLink", "Unlink"],
			"insert": ["InsertImage"],
			"undo": ["Undo", "Redo"],
			"clipboard": ["Cut", "Copy", "Paste"],
			"custom" : []
		};

		var setSapMDependencies = function () {
			sap.ui.require(["sap/m/MenuItem", "sap/m/Button", "sap/m/ToggleButton",
							"sap/m/MenuButton", "sap/m/Menu", "sap/m/Select",
							"sap/m/ToolbarSeparator", "sap/m/OverflowToolbar",
							"sap/m/OverflowToolbarLayoutData", "sap/m/Dialog",
							"sap/m/Label", "sap/m/CheckBox", "sap/m/Input",
							"sap/ui/unified/ColorPicker", "sap/m/HBox", "sap/m/VBox",
							"sap/m/Text", "sap/m/StepInput"],
				function (oMenuItem, oButton, oToggleButton, oMenuButton, oMenu,
							oSelect, oToolbarSeparator, oOverflowToolbar,
							oOverflowToolbarLayoutData, oDialog, oLabel,
							oCheckBox, oInput, oColorPicker, oHBox, oVBox,
							oText, oStepInput) {

					sap.ui.richtexteditor.RichTextEditorHelper.bSapMLoaded = true;
					_oCustomToolbarControls.Button = oButton;
					_oCustomToolbarControls.ToggleButton = oToggleButton;
					_oCustomToolbarControls.MenuButton = oMenuButton;
					_oCustomToolbarControls.Menu = oMenu;
					_oCustomToolbarControls.Select = oSelect;
					_oCustomToolbarControls.ToolbarSeparator = oToolbarSeparator;
					_oCustomToolbarControls.OverflowToolbar = oOverflowToolbar;
					_oCustomToolbarControls.OverflowToolbarLayoutData = oOverflowToolbarLayoutData;
					_oCustomToolbarControls.MenuItem = oMenuItem;
					_oCustomToolbarControls.Dialog = oDialog;
					_oCustomToolbarControls.Label = oLabel;
					_oCustomToolbarControls.CheckBox = oCheckBox;
					_oCustomToolbarControls.Input = oInput;
					_oCustomToolbarControls.ColorPicker = oColorPicker;
					_oCustomToolbarControls.HBox = oHBox;
					_oCustomToolbarControls.VBox = oHBox;
					_oCustomToolbarControls.Text = oText;
					_oCustomToolbarControls.StepInput = oStepInput;
				});
		};

		var _oCustomToolbarControls = {};
		var _fProxy = function (sControlName, oSettings) {
			if (_oCustomToolbarControls[sControlName]) {
				return new _oCustomToolbarControls[sControlName](oSettings);
			}
		};

		// Define the helper
		jQuery.sap.setObject("sap.ui.richtexteditor.RichTextEditorHelper", {
			bSapMLoaded: false,
			createOverflowToolbar: function (sId, oContent) {
				return _fProxy("OverflowToolbar", {id: sId, content: oContent});
			}, /* must return an OverflowToolbar control */
			createButton: function (mConfig) {
				mConfig.type = sap.m.ButtonType.Transparent;
				return _fProxy("Button", mConfig);
			}, /* must return a Button control */
			createMenuButton: function (sId, oItems, fItemSelected, sIcon, sTooltip) {
				return _fProxy("MenuButton", {
					layoutData: _fProxy("OverflowToolbarLayoutData", {
						priority: sap.m.OverflowToolbarPriority.NeverOverflow
					}),
					type: sap.m.ButtonType.Transparent,
					id: sId,
					menu: _fProxy("Menu", {
						itemSelected: fItemSelected,
						items: oItems
					}),
					icon: sIcon,
					tooltip: sTooltip
				});
			}, /* must return a MenuButton control */
			createMenuItem: function (sId, sText, sIcon) {
				return _fProxy("MenuItem", {
					id: sId,
					icon: sIcon,
					text: sText
				});
			}, /* must return a MenuItem control */
			createToggleButton: function (mConfig) {
				mConfig.layoutData = _fProxy("OverflowToolbarLayoutData", {
					priority: sap.m.OverflowToolbarPriority.NeverOverflow
				});
				mConfig.type = sap.m.ButtonType.Transparent;
				return _fProxy("ToggleButton", mConfig);
			}, /* must return a ToggleButton control */
			createToolbarSeparator: function () {
				return _fProxy("ToolbarSeparator");
			}, /* must return a ToolbarSeparator control */
			createSelect: function (mConfig) {
				return _fProxy("Select", mConfig);
			}, /* must return a Select control */
			createInput: function (mConfig) {
				return _fProxy("Input", mConfig);
			}, /* must return an Input control */
			createLabel: function (mConfig) {
				return _fProxy("Label", mConfig);
			}, /* must return a Label control */
			createCheckBox: function() {
				return _fProxy("CheckBox", {});
			},
			createColorPicker: function() {
				return _fProxy("ColorPicker", {});
			},
			createDialog: function(mConfig) {
				return _fProxy("Dialog", mConfig);
			} /* must return a Dialog control */,
			createText: function(mConfig) {
				return _fProxy("Text", mConfig);
			} /* must return a Text control */,
			createHBox: function(mConfig) {
				return _fProxy("HBox", mConfig);
			} /* must return a HBox control */,
			createVBox: function(mConfig) {
				return _fProxy("VBox", mConfig);
			} /* must return a HBox control */,
			createStepInput: function(mConfig) {
				return _fProxy("StepInput", mConfig);
			} /* must return a StepInput control */
		});

		// Check for sap.m library and set the RichTextEditorHelper
		if (sap.ui.getCore().getLoadedLibraries()["sap.m"]) {
			setSapMDependencies();
		} else {
			var libraryChangedListener = function (oEvent) {
				var oEventParams = oEvent.getParameters();

				if (oEventParams.stereotype === "library" && oEventParams.name === "sap.m") {
					jQuery.sap.delayedCall(0, null, setSapMDependencies);
					jQuery.sap.delayedCall(0, sap.ui.getCore(), 'detachLibraryChanged', [libraryChangedListener]);
				}
			};

			sap.ui.getCore().attachLibraryChanged(libraryChangedListener);
		}

		return sap.ui.richtexteditor;

	}, /* bExport= */ false);

}; // end of sap/ui/richtexteditor/library.js
if ( !jQuery.sap.isDeclared('sap.ui.richtexteditor.ToolbarWrapper') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

/*global Promise */

// Provides control sap.ui.richtexteditor.ToolbarWrapper.
jQuery.sap.declare('sap.ui.richtexteditor.ToolbarWrapper'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('jquery.sap.global'); // unlisted dependency retained
jQuery.sap.require('sap.ui.core.Control'); // unlisted dependency retained
jQuery.sap.require('sap.ui.core.IconPool'); // unlisted dependency retained
jQuery.sap.require('sap.ui.core.Item'); // unlisted dependency retained
sap.ui.define("sap/ui/richtexteditor/ToolbarWrapper",['jquery.sap.global', 'sap/ui/core/Control', './library', 'sap/ui/core/IconPool', 'sap/ui/core/Item'],
	function (jQuery, Control, library, IconPool, Item) {
		"use strict";


		/**
		 * Constructor for a new RichTextEditor's Custom Toolbar.
		 *
		 * @param {string} [sId] ID for the new control, generated automatically if no ID is given
		 * @param {object} [mSettings] Initial settings for the new control
		 *
		 * @class
		 * The toolbar control is used to replace the default TinyMCE toolbar, with a custom one, built with SAPUI5 controls.
		 * @extends sap.ui.core.Control
		 *
		 * @author SAP SE
		 *
		 * @constructor
		 * @private
		 * @alias sap.ui.richtexteditor.ToolbarWrapper
		 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
		 */
		var ToolbarWrapper = Control.extend("sap.ui.richtexteditor.ToolbarWrapper", /** @lends sap.ui.richtexteditor.ToolbarWrapper.prototype */ {
			metadata: {
				interfaces: [
					"sap.ui.richtexteditor.IToolbar"
				],
				library: "sap.ui.richtexteditor",
				aggregations: {
					/**
					 *  The Custom Toolbar control instance
					 */
					_toolbar: {type: "sap.m.OverflowToolbar", multiple: false, visibility: "hidden"},
					/**
					 * The custom insert image dialog for the Rich Text Editor
					 */
					_customInsertImageDialog: {type: "sap.ui.core.Control", multiple: false, visibility: "hidden"},
					/**
					 * The custom insert link dialog for the Rich Text Editor
					 */
					_customInsertLinkDialog: {type: "sap.ui.core.Control", multiple: false, visibility: "hidden"},
					/**
					 * The custom text color dialog for the Rich Text Editor
					 */
					_customTextColorDialog: {type: "sap.ui.core.Control", multiple: false, visibility: "hidden"},
					/**
					 * The custom background color dialog for the Rich Text Editor
					 */
					_customBackgroundColorDialog: {type: "sap.ui.core.Control", multiple: false, visibility: "hidden"},
					/**
					 * The custom insert table dialog for the Rich Text Editor
					 */
					_customInsertTableDialog: {type: "sap.ui.core.Control", multiple: false, visibility: "hidden"}
				},
				associations: {
					/**
					 * The RichTextEditor control to be linked to the Toolbar control.
					 */
					editor: {type: "sap.ui.richtexteditor.RichTextEditor", multiple: false}
				}
			}
		});

		ToolbarWrapper.prototype.init = function () {
			// This helper is defined within richtexteditor's library.js to provide loose coupling
			// with the controls in sap.m library
			this._helper = library.RichTextEditorHelper;
			this._oResourceBundle = sap.ui.getCore().getLibraryResourceBundle("sap.ui.richtexteditor");
		};

		ToolbarWrapper.prototype.onBeforeRendering = function () {
			if (!this.getAggregation("_toolbar")) {
				this.setAggregation("_toolbar", this._createCustomToolbar());
				this.setAggregation("_customInsertImageDialog",
					this._helper.createDialog(this._createInsertImageConfig("InsertImage")));
				this.setAggregation("_customInsertLinkDialog",
					this._helper.createDialog(this._createInsertLinkConfig("InsertLink")));
				this.setAggregation("_customTextColorDialog",
					this._helper.createDialog(this._createColorDialogConfig("TextColor")));
				this.setAggregation("_customBackgroundColorDialog",
					this._helper.createDialog(this._createColorDialogConfig("BackgroundColor")));
				this.setAggregation("_customInsertTableDialog",
					this._helper.createDialog(this._createInsertTableConfig("InsertTable")));
			}
		};

		ToolbarWrapper.prototype.exit = function () {
			this._customButtons = null;
		};

		/**
		 * As the toolbar is not direct aggregation of RTE
		 * we should construct a stable ID for the "ancestor" elements.
		 *
		 * @private
		 */
		ToolbarWrapper.prototype._getId = function (sExtension) {
			this._getId.counter = this._getId.counter ? this._getId.counter + 1 : 1;

			var sRTEId = this.getEditor() ? this.getEditor().getId() : "_rte" + this._getId.counter,
				sToolbarId = this.getId(),
				aBuilder = [sRTEId + sToolbarId];

			if (sExtension || sExtension === 0) {
				aBuilder.push(sExtension);
			}

			return aBuilder.join("-");
		};

		/**
		 * Gets the RichTextEditor instance
		 */
		ToolbarWrapper.prototype.getEditor = function () {
			var sId = this.getAssociation("editor"),
				oEditor = sap.ui.getCore().byId(sId);

			return oEditor || null;
		};

		/**
		 * Helper function for extending the configuration of the TinyMCE for the Custom Toolbar
		 * @public
		 *
		 * @param {object} [oConfig] Configuration object to be extended
		 */
		ToolbarWrapper.prototype.modifyRTEToolbarConfig = function (oConfig) {
			var oToolbar = this;

			// Remove the native toolbar. From now on the sap.ui.richtexteditor.ToolbarWrapper will be used
			oConfig.toolbar = false;

			oConfig.setup = function (editor) {
				editor.on('init', function () {
					var oEditorCommands = library.EditorCommands;

					// execute the default font styles to ensure right synchronizing of the custom toolbar
					editor.execCommand("FontName", false, oEditorCommands["FontFamily"]["Verdana"].commandValue);
					editor.execCommand("FontSize", false, "8");
					editor.execCommand("JustifyLeft", false);
				});

				// Sync sap.ui.richtexteditor.ToolbarWrapper buttons with the editor
				editor.on('NodeChange', function () {
					oToolbar._syncToolbarStates(this);
				});
			};

			return oConfig;
		};

		/**
		 * Helper function for synchronizing the button states or selected items with the styles applied on the editor
		 * @private
		 * @param {object} [oNativeEditor] Editor Object
		 */
		ToolbarWrapper.prototype._syncToolbarStates = function (oNativeEditor) {
			var oEditorCommand, oControl, sEditorCommand,
				oEditorCommands = library.EditorCommands,
				oFormatter = oNativeEditor.formatter,
				_syncTextAlign = function (oTextAlignCommand, oEditorFormatter, oControl) {
					var sAlignCommand;

					for (sAlignCommand in oTextAlignCommand) {
						if (oTextAlignCommand.hasOwnProperty(sAlignCommand) && oEditorFormatter.match(oTextAlignCommand[sAlignCommand].style)) {
							if (oControl.getIcon() !== IconPool.getIconURI(oEditorCommand[sAlignCommand].icon)) {
								oControl.setIcon(IconPool.getIconURI(oEditorCommand[sAlignCommand].icon));
							} else {
								// Text Align commands in TinyMCE have a toggle behavior
								// when you set a certain command twice the default
								// command (text-align-left) will be applied
								oControl.setIcon(IconPool.getIconURI(oEditorCommand["Left"].icon));
							}
							break;
						}
					}
				},
				_syncTextFontFamily = function (oEditor, oFontFamilyCommand, oControl) {
					var sFontName, sCommandValue, sText,
						sFontNameCommandValue = oEditor.getDoc().queryCommandValue("FontName");

					// Synchronize the selected item of the Font Family Select with the applied font family style
					for (sFontName in oFontFamilyCommand) {
						if (!oFontFamilyCommand.hasOwnProperty(sFontName)) {
							break;
						}

						sCommandValue = oFontFamilyCommand[sFontName].commandValue.match(/\w+/g).join("").toLowerCase();
						sFontNameCommandValue = sFontNameCommandValue && sFontNameCommandValue.match(/\w+/g).join("").toLowerCase();
						sText = oFontFamilyCommand[sFontName].text.match(/\w+/g).join("").toLowerCase();

						if (sCommandValue === sFontNameCommandValue || sFontNameCommandValue === sText) {
							oControl.setSelectedItemId(oControl.getId() + sFontName);
							break;
						}
					}
				};

			for (sEditorCommand in oEditorCommands) {
				if (!oEditorCommands.hasOwnProperty(sEditorCommand)) {
					continue;
				}

				oEditorCommand = oEditorCommands[sEditorCommand];
				// TODO: Probably there's a better way to handle this
				oControl = sap.ui.getCore().byId(this._getId(sEditorCommand));

				if (!oControl) {
					continue;
				}

				if (sEditorCommand === "TextAlign") {
					// Synchronize the icon of the Text Align MenuButton with the applied text align style
					_syncTextAlign(oEditorCommand, oFormatter, oControl);

				} else if (sEditorCommand === "FontFamily") {
					_syncTextFontFamily(oNativeEditor, oEditorCommand, oControl);

				} else if (sEditorCommand === "FontSize" && oNativeEditor.getDoc().queryCommandValue(sEditorCommand)) {

					// queryCommandValue("FontSize") always returns empty string in FireFox - to be fixed
					// Synchronize the selected item of the Font Name Select with the applied font size style
					oControl.setSelectedItemId(oControl.getId() + oNativeEditor.getDoc().queryCommandValue(sEditorCommand));

				} else if (oControl.getMetadata().getName() === "sap.m.ToggleButton") {
					// Synchronize the pressed state of the ToggleButtons
						oControl.setPressed(oFormatter.match(oEditorCommand.style));
					}
				}
			};

		/**
		 * Helper function for creating Button Control configuration
		 * @private
		 * @param {string} [sCommand] Editor Command
		 */
		ToolbarWrapper.prototype._createButtonConfig = function (sCommand) {
			var oEditorCommands = library.EditorCommands,
				oCommand = oEditorCommands[sCommand],
				oRTE = this.getEditor();


			return {
				id: this._getId(sCommand),
				icon: IconPool.getIconURI(oCommand.icon),
				tooltip: this._oResourceBundle.getText(oCommand.bundleKey),
				press: function () {
					if (oRTE) {
						oRTE.getNativeApi().execCommand(oCommand.command);
					} else {
						jQuery.sap.log.warning("Cannot execute native command: " + oCommand.command);
					}
				}
			};
		};

		/**
		 * Helper function for creating MenuButtonItem Controls
		 * @private
		 * @param {string} [sCommand] Editor Command
		 */
		ToolbarWrapper.prototype._createMenuButtonItems = function (sCommand) {
			var oEditorHelper = this._helper,
				oEditorCommands = library.EditorCommands,
				aItems = [],
				oCommand;

			for (var sEditorCommand in oEditorCommands[sCommand]) {
				if (sEditorCommand === 'bundleKey') {
					continue;
				}

				oCommand = oEditorCommands[sCommand][sEditorCommand];
				aItems.push(oEditorHelper.createMenuItem(this._getId(sCommand + sEditorCommand), oCommand.text, IconPool.getIconURI(oCommand.icon)));
			}

			return aItems;
		};

		/**
		 * Helper function for creating SelectItem Controls for FontStyle Select
		 * @private
		 */
		ToolbarWrapper.prototype._createFontStyleSelectItems = function () {
			var oEditorCommands = library.EditorCommands,
				oFontFamilies = oEditorCommands["FontFamily"],
				aItems = [],
				oItem;

			for (var sFontStyle in oFontFamilies) {
				oItem = {
					id: this._getId("FontFamily" + sFontStyle),
					text: oFontFamilies[sFontStyle].text
				};

				aItems.push(new Item(oItem));
			}

			return aItems;
		};

		/**
		 * Helper function for finding the command value of a given font style command
		 * @param {string} [sItemText] Font Family
		 * @private
		 */
		ToolbarWrapper.prototype._getFontStyleCommand = function (sItemText) {
			var oEditorCommands = library.EditorCommands,
				oFontFamilies = oEditorCommands["FontFamily"];

			for (var sFontStyle in oFontFamilies) {
				if (oFontFamilies.hasOwnProperty(sFontStyle) && oFontFamilies[sFontStyle].text === sItemText) {
					return oFontFamilies[sFontStyle].commandValue;
				}
			}
		};

		/**
		 * Helper function for creating SelectItem Controls for FontSize Select
		 * @private
		 */
		ToolbarWrapper.prototype._createFontSizeSelectItems = function () {
			var aItems = [],
				number = 1, //TinyMCE command values for font sizes have a value from 1 to 7
				oItem,
				oEditorCommands = library.EditorCommands;

			oEditorCommands["FontSize"].forEach(function (item) {
				oItem = {
					id: this._getId("FontSize" + number),
					text: item + "pt"
				};
				aItems.push(new Item(oItem));
				number++;
			}, this);
			return aItems;
		};

		/**
		 * Helper function for getting the color style applied to a current node or at a certain carret position
		 * @param {string} [sCommand] The Editor Command
		 * @private
		 */
		ToolbarWrapper.prototype._getColor = function (sCommand) {
			var oRTE = this.getEditor(),
				oCommandStyle = library.EditorCommands[sCommand].style,
				oNode = oRTE.getNativeApi().selection.getNode(),
				aNodes = oRTE.getNativeApi().dom.getParents(oNode),
				i, aCurrentNode, sColor;

			for (i = 0; i < aNodes.length; i++) {
				aCurrentNode = aNodes[i];
				sColor = aCurrentNode.style[oCommandStyle];

				if (sColor && sColor != "") {
					return sColor;
				}
			}

			// If there is no color style found, return the default color
			return library.EditorCommands[sCommand].defaultValue;
		};

		/**
		 * Helper function for creating Button Control configuration for opening dialogs
		 * @private
		 * @param {string} [sCommand] Editor Command
		 */
		ToolbarWrapper.prototype._createButtonForDialog = function (sCommand) {
			var oCommand = library.EditorCommands[sCommand],
				oToolbar = this;

			if (!oCommand) {
				return;
			}

			return {
				id: this._getId(sCommand),
				icon: sap.ui.core.IconPool.getIconURI(oCommand.icon),
				tooltip: this._oResourceBundle.getText(oCommand.bundleKey),
				press: function () {
					// If the command is for background color or font color,
					// get the applied color and set it to the color picker
					if (sCommand.indexOf("Color") !== -1) {
						oToolbar.getAggregation("_custom" + sCommand + "Dialog")
								.getContent()[0]
								.setColorString(oToolbar._getColor(sCommand));
					}

					oToolbar.getAggregation("_custom" + sCommand + "Dialog").open();
				}
			};
		};

		/**
		 * Helper function for creating Color Dialog configuration
		 * @private
		 * @param {string} [sType] Type of color command.
		 */
		ToolbarWrapper.prototype._createColorDialogConfig = function(sType) {
			var oCommand = library.EditorCommands[sType],
				oEditorHelper = this._helper,
				oColorPicker = oEditorHelper.createColorPicker(),
				oRTE = this.getEditor(),
				oToolbar = this,
				aButtons = [];

				if (!oCommand) {
					return;
				}

				aButtons.push(oEditorHelper.createButton({
					id: this._getId("OKButton" + sType),
					text: "OK",
					press: function () {
						// If the same color is set twice the editor sets the default color,
						// so when the user tries to set the same color again,
						// we should not execute the command
						if (oToolbar._getColor(sType).replace(/,\s/g, ',') !== oColorPicker.getColorString()) {
							oRTE.getNativeApi().execCommand(oCommand.command, false, oColorPicker.Color.hex);
						}
						oToolbar.getAggregation("_custom" + sType + "Dialog").close();
					}
				}));

				aButtons.push(oEditorHelper.createButton({
					id: this._getId("cancelButton" + sType),
					text: "Cancel",
					press: function () {
						oToolbar.getAggregation("_custom" + sType + "Dialog").close();
					}
				}));

			return {
				contentWidth: '320px',
				title: oCommand.title,
				content: [oColorPicker],
				buttons: aButtons
			};
		};


		/**
		 * Helper function for generating image HTML content
		 * @private
		 */
		ToolbarWrapper.prototype._generateImageHTML = function(sURL, sText, sHeight, sWidth, bRatio) {
			var sURLAttr = sURL ? ' src="' + sURL + '"' : '',
				sAltAttr = sText ? ' alt="' + sText + '"' : '',
				sHeightAttr = sHeight ? ' height="' + sHeight + 'px"' : '',
				sWidthAttr = sWidth ? ' width="' + sHeight + 'px"' : '',
				sDimensions = sHeightAttr + sWidthAttr;

			if (bRatio) {
				sDimensions = sHeightAttr ? sHeightAttr : sWidthAttr;
			}

			return '<img' + sURLAttr + sAltAttr + sDimensions + '/>';

		};

		/**
		 * Helper function for creating InsertImage Dialog configuration
		 * @private
		 */
		ToolbarWrapper.prototype._createInsertImageConfig = function() {
			var oURLInput = this._helper.createInput(),
				oURLLabel = this._helper.createLabel({
					text: "Source URL",
					labelFor: oURLInput
				}),
				oTextInput = this._helper.createInput(),
				oTextLabel = this._helper.createLabel({
					text: "Image Description",
					labelFor: oTextInput
				}),
				oDimensionHeightInput = this._helper.createInput({
					width: '8rem',
					fieldWidth:"6rem",
					description: 'px'
				}),
				oTextDimensions = this._helper.createText({
					textAlign: "Center",
					width: '2rem',
					text: 'x'
				}),
				oDimensionWidthInput = this._helper.createInput({
					fieldWidth: "6rem",
					width: '8rem',
					description: 'px'
				}),
				oDimensionsFlexBox = this._helper.createHBox({
					wrap: "Wrap",
					alignItems: "Center",
					justifyContent: "SpaceBetween",
					items: [oDimensionHeightInput,
							oTextDimensions,
							oDimensionWidthInput]
				}),
				oDimensionsLabel = this._helper.createLabel({
					text: "Dimensions"
				}),
				oRatioCheckBox = this._helper.createCheckBox(),
				oRatioLabel = this._helper.createLabel({
					text: "Maintain Aspect Ratio",
					labelFor: oRatioCheckBox
				}),
				oRTE = this.getEditor(),
				oToolbar = this,
				aButtons = [];

				aButtons.push(this._helper.createButton({
					id: this._getId("InsertImageButton"),
					text: "Insert",
					press: function () {
						oRTE.getNativeApi()
							.insertContent(oToolbar._generateImageHTML(oURLInput.getValue(),
																		oTextInput.getValue(),
																		oDimensionHeightInput.getValue(),
																		oDimensionWidthInput.getValue(),
																		oRatioCheckBox.getSelected()));
						oToolbar.getAggregation("_customInsertImageDialog").close();
					}
				}));

				aButtons.push(this._helper.createButton({
					id: this._getId("CancelInsertImageButton"),
					text: "Cancel",
					press: function () {
						oToolbar.getAggregation("_customInsertImageDialog").close();
					}
				}));

				return {
					contentWidth: '320px',
					title: sap.ui.richtexteditor.EditorCommands["InsertImage"].title,
					buttons: aButtons,
					content: [
						oURLLabel,
						oURLInput,
						oTextLabel,
						oTextInput,
						oDimensionsLabel,
						oDimensionsFlexBox,
						oRatioCheckBox,
						oRatioLabel
					]
				};
		};

		/**
		 * Helper function for generating link HTML content
		 * @private
		 */
		ToolbarWrapper.prototype._generateLinkHTML = function (sURL, sText, sTitle, bTarget) {
			var sURLAttr = sURL ? ' href="' + sURL + '"' : '',
				sTitleAttr = sTitle ? ' title="' + sTitle + '"' : '',
				sTargetAttr = bTarget ? ' target="_blank"' : '';

			sText = sText ? sText : '';

			return '<a' + sURLAttr + sTitleAttr + sTargetAttr + '>' + sText + '</a>';
		};

		/**
		 * Helper function for creating InsertLink Dialog configuration
		 * @private
		 */
		ToolbarWrapper.prototype._createInsertLinkConfig = function() {
			var oURLInput = this._helper.createInput(),
				oURLLabel = this._helper.createLabel({
					text: "URL",
					labelFor: oURLInput
				}),
				oTextInput = this._helper.createInput(),
				oTextLabel = this._helper.createLabel({
					text: "Display Text",
					labelFor: oTextInput
				}),
				oTitleInput = this._helper.createInput(),
				oTitleLabel = this._helper.createLabel({
					text: "Title",
					labelFor: oTitleInput
				}),
				oTargetSelect = this._helper.createSelect({
					id: this._getId("InsertLinkSelect"),
					items: [
						new Item({
							id: this._getId("InsertLinkSelectNone"),
							text: "None"
						}),
						new Item({
							id: this._getId("InsertLinkSelectNewWindow"),
							text: "New Window"
						})
					]
				}),
				oTargetLabel = this._helper.createLabel({
					text: "Target",
					labelFor: oTargetSelect
				}),
				oTargetFlexBox = this._helper.createVBox({
					direction: "Column",
					alignItems: "Start",
					items: [oTargetLabel,
							oTargetSelect]
				}),
				oRTE = this.getEditor(),
				oToolbar = this,
				aButtons = [];

				aButtons.push(this._helper.createButton({
					id: this._getId("InsertLinkButton"),
					text: "Insert",
					press: function (oEvent) {
						var bTarget = oTargetSelect.getSelectedItem().getText() === "New Window" ? true : false;
						oRTE.getNativeApi()
							.insertContent(oToolbar._generateLinkHTML(oURLInput.getValue(),
																	oTextInput.getValue(),
																	oTitleInput.getValue(),
																	bTarget));
						oToolbar.getAggregation("_customInsertLinkDialog").close();
					}
				}));

				aButtons.push(this._helper.createButton({
					id: this._getId("CancelInsertLinkButton"),
					text: "Cancel",
					press: function () {
						oToolbar.getAggregation("_customInsertLinkDialog").close();
					}
				}));

				return {
					contentWidth: '320px',
					title: library.EditorCommands["InsertLink"].title,
					buttons: aButtons,
					content: [
						oURLLabel,
						oURLInput,
						oTextLabel,
						oTextInput,
						oTitleLabel,
						oTitleInput,
						oTargetFlexBox
					]
				};
		};

		/**
		 * Helper function for creating Insert Table Dialog configuration
		 * @private
		 */
		ToolbarWrapper.prototype._createInsertTableConfig = function() {
			var oRowsInput = this._helper.createStepInput({
					value: 2,
					min: 0,
					width: "50%"
				}),
				oRowsLabel = this._helper.createLabel({
					text: "Number of Rows:",
					labelFor: oRowsInput
				}),
				oColsInput = this._helper.createStepInput({
					value: 2,
					min: 0,
					width: "50%"
				}),
				oColsLabel = this._helper.createLabel({
					text: "Number of Cols:",
					labelFor: oColsInput
				}),
				oDimensionHeightInput = this._helper.createInput({
					width: '8rem',
					fieldWidth:"6rem",
					description: 'px'
				}),
				oTextDimensions = this._helper.createText({
					textAlign: "Center",
					width: '2rem',
					text: 'x'
				}),
				oDimensionWidthInput = this._helper.createInput({
					fieldWidth: "6rem",
					width: '8rem',
					description: 'px'
				}),
				oDimensionsFlexBox = this._helper.createHBox({
					wrap: "Wrap",
					alignItems: "Center",
					justifyContent: "SpaceBetween",
					items: [oDimensionHeightInput,
							oTextDimensions,
							oDimensionWidthInput]
				}),
				oDimensionsLabel = this._helper.createLabel({
					text: "Dimensions"
				}),
				oRTE = this.getEditor(),
				oToolbar = this,
				aButtons = [];

				aButtons.push(this._helper.createButton({
					id: this._getId("InsertTableButton"),
					text: "Insert",
					press: function () {
						var tableElm = oRTE.getNativeApi().plugins.table
											.insertTable(oRowsInput.getValue(), oColsInput.getValue()),
							dom = oRTE.getNativeApi().dom;

						dom.setStyle(tableElm, 'width', oDimensionWidthInput.getValue() + "px");
						dom.setStyle(tableElm, 'height', oDimensionHeightInput.getValue() + "px");

						oToolbar.getAggregation("_customInsertTableDialog").close();
					}
				}));

				aButtons.push(this._helper.createButton({
					id: this._getId("CancelInsertTableButton"),
					text: "Cancel",
					press: function () {
						oToolbar.getAggregation("_customInsertTableDialog").close();
					}
				}));

				return {
					title: sap.ui.richtexteditor.EditorCommands["InsertTable"].title,
					buttons: aButtons,
					content: this._helper.createVBox({
						direction: "Column",
						alignItems: "Start",
						items: [oRowsLabel,
								oRowsInput,
								oColsLabel,
								oColsInput,
								oDimensionsLabel,
								oDimensionsFlexBox]
						})
				};
		};

		/**
		 * Helper function for creating a sap.m.OverflowToolbar
		 * @private
		 */
		ToolbarWrapper.prototype._createCustomToolbar = function () {
			var oEditorHelper = this._helper,
				aContent = [],
				oButtonGroups = library.ButtonGroups;

			Object.keys(oButtonGroups).forEach(function (sGroupName) {
				aContent = aContent.concat(this.addButtonGroup(sGroupName));
			}, this);

			return oEditorHelper.createOverflowToolbar(this._getId(), aContent);
		};


		/**
		 * Hides/Shows button group
		 * @param {string} [sGroupName] Group name
		 * @param {boolean} [bShow] Indicates if the group should be shown or hidden
		 * @public
		 */
		ToolbarWrapper.prototype.setShowGroup = function (sGroupName, bShow) {
			var aObjects = this._findGroupedControls(sGroupName),
				oToolbar = this.getAggregation("_toolbar");

			aObjects.forEach(function (oObject) {
				oObject.setVisible(bShow);
			});

			oToolbar && oToolbar.rerender();
		};

		/**
		 * Adds a Button Group to the Custom Toolbar
		 * @param {string} [sGroupName] Group name
		 * @returns {Array}
		 *
		 * @public
		 */
		ToolbarWrapper.prototype.addButtonGroup = function (sGroupName) {
			var oRTE = this.getEditor(),
				oEditorHelper = this._helper,
				aContent = [],
				oButtonGroups = library.ButtonGroups,
				oCommands = library.EditorCommands,
				bVisibleGroupClipboard,
				bVisibleGroupStructure,
				bVisibleGroupFont,
				bVisibleGroupFontStyle,
				bVisibleGroupUndo,
				bVisibleGroupTextAlign,
				bVisibleGroupLink,
				bVisibleGroupInsert;


			switch (sGroupName) {
				case "font-style":
					bVisibleGroupFontStyle = oRTE ? oRTE.getShowGroupFontStyle() : false;

					oButtonGroups["font-style"].forEach(function (oCommand) {
						aContent.push(oEditorHelper.createToggleButton(this._createButtonConfig(oCommand)).setVisible(bVisibleGroupFontStyle));
					}, this);
					break;
				case "font":
					bVisibleGroupFont = oRTE ? oRTE.getShowGroupFont() : false;

					aContent.push(
						oEditorHelper.createSelect({
							id: this._getId("FontFamily"),
							items: this._createFontStyleSelectItems(),
							change: function (oEvent) {
								var oItem;

								if (oRTE) {
									oItem = oEvent.getSource().getSelectedItem();
									oRTE.getNativeApi().execCommand('FontName', false, this._getFontStyleCommand(oItem.getText()));
								} else {
									jQuery.sap.log.warning("Cannot execute native command: " + 'FontName');
								}
							}.bind(this)
						}).setVisible(bVisibleGroupFont)
					);
					aContent.push(
						oEditorHelper.createSelect({
							id: this._getId("FontSize"),
							items: this._createFontSizeSelectItems(),
							change: function (oEvent) {
								var oItem;

								if (oRTE) {
									oItem = oEvent.getSource().getSelectedItem();
									oRTE.getNativeApi().execCommand('FontSize', false, oItem.getText());
								} else {
									jQuery.sap.log.warning("Cannot execute native command: " + 'FontSize');
								}
							}
						}).setVisible(bVisibleGroupFont)
					);
					aContent.push(oEditorHelper.createButton(this._createButtonForDialog("TextColor")).setVisible(bVisibleGroupFont));
					aContent.push(oEditorHelper.createButton(this._createButtonForDialog("BackgroundColor")).setVisible(bVisibleGroupFont));
					break;
				case "text-align":
					bVisibleGroupTextAlign = oRTE ? oRTE.getShowGroupTextAlign() : false;
					var aMenuItems = this._createMenuButtonItems("TextAlign");
					aContent.push(
						oEditorHelper.createMenuButton(
							this._getId("TextAlign"),
							aMenuItems,
							function (oEvent) {
								var oSelectedItem;

								if (oRTE) {
									oSelectedItem = oEvent.getParameter("item");
									oRTE.getNativeApi().execCommand('Justify' + oSelectedItem.getText());
									this.getParent().setIcon(oSelectedItem.getIcon()); //  TODO: Check what is this?
								} else {
									jQuery.sap.log.warning("Cannot execute native command: " + 'Justify');
								}
							},
							aMenuItems[0].getIcon(),
							this._oResourceBundle.getText(oCommands["TextAlign"].bundleKey)
						).setVisible(bVisibleGroupTextAlign)
					);
					break;
				case "structure":
					bVisibleGroupStructure = oRTE ? oRTE.getShowGroupStructure() : false;
					oButtonGroups["structure"].forEach(function (oCommand) {
						aContent.push(oEditorHelper.createButton(this._createButtonConfig(oCommand)).setVisible(bVisibleGroupStructure));
					}, this);
					break;
				case "clipboard":
					bVisibleGroupClipboard = oRTE ? oRTE.getShowGroupClipboard() : false;
					oButtonGroups["clipboard"].forEach(function (oCommand) {
						aContent.push(oEditorHelper.createButton(this._createButtonConfig(oCommand)).setVisible(bVisibleGroupClipboard));
					}, this);
					break;
				case "undo":
					bVisibleGroupUndo = oRTE ? oRTE.getShowGroupUndo() : false;
					oButtonGroups["undo"].forEach(function (oCommand) {
						aContent.push(oEditorHelper.createButton(this._createButtonConfig(oCommand)).setVisible(bVisibleGroupUndo));
					}, this);
					break;
				case "insert":
					bVisibleGroupInsert = oRTE ? oRTE.getShowGroupInsert() : false;
					aContent.push(oEditorHelper.createButton(this._createButtonForDialog("InsertImage")).setVisible(bVisibleGroupInsert));
					break;
				case "link":
					bVisibleGroupLink = oRTE ? oRTE.getShowGroupLink() : false;
					aContent.push(oEditorHelper.createButton(this._createButtonForDialog("InsertLink")).setVisible(bVisibleGroupLink));
					aContent.push(oEditorHelper.createButton(this._createButtonConfig("Unlink")).setVisible(bVisibleGroupLink));
					break;
				case "table":
					aContent.push(oEditorHelper.createButton(this._createButtonForDialog("InsertTable")));
					break;
			}

			return aContent;
		};

		/**
		 * Adds a Button Group to an existing Toolbar
		 * @param {map} [mGroup] Group object
		 * @param {Boolean} [bFullGroup] If false the group is generated from a group name
		 *
		 * @public
		 */
		ToolbarWrapper.prototype.addButtonGroupToContent = function (mGroup, bFullGroup) {
			var sGroupName;
			// if the group is generated add it to the button groups object
			// as a custom group (if it contains supported group buttons - ex."table")
			if (!bFullGroup && mGroup.buttons[0] === "table") {
				sGroupName = mGroup.buttons[0];
				sap.ui.richtexteditor.ButtonGroups.custom[mGroup.name] = {
					name: mGroup.buttons[0],
					controls: ["InsertTable"]
				};
			}

			// if the group is supported (ex. "table") add it to the button groups object
			if (bFullGroup && mGroup.name === "table") {
				sGroupName = mGroup.name;
				sap.ui.richtexteditor.ButtonGroups[mGroup.name] = ["InsertTable"];
			}

			// if not supported return and do not add content
			if (!sap.ui.richtexteditor.ButtonGroups[mGroup.name] && !sap.ui.richtexteditor.ButtonGroups.custom[mGroup.name]) {
				return this;
			}

			var oToolbar = this.getAggregation("_toolbar"),
				aContent = this.addButtonGroup(sGroupName),
				iContentSize = aContent.length,
				i;

			for (i = 0; i < iContentSize; i += 1) {
				oToolbar.addContent(aContent[i]);
			}

			return this;
		};

		/**
		 * Removes a button group from the Custom Toolbar
		 * @param {string} [sGroupName] Group name
		 * @public
		 */
		ToolbarWrapper.prototype.removeButtonGroup = function (sGroupName) {
			var aObjects = this._findGroupedControls(sGroupName);

			aObjects.forEach(function (oObject) {
				oObject.destroy();
			});
		};

		/**
		 * Helper function for finding controls from a group
		 * @param {string} [sGroupName] Group name
		 * @private
		 */
		ToolbarWrapper.prototype._findGroupedControls = function (sGroupName) {
			var oButtonGroups = library.ButtonGroups,
				oToolbar = this.getAggregation("_toolbar"),
				aControls;

			if (!oToolbar) {
				return [];
			}

			aControls = oButtonGroups[sGroupName] ?
						oButtonGroups[sGroupName] :
						oButtonGroups.custom[sGroupName].controls;

			var aIds = aControls.map(function (sName) {
				return this._getId(sName);
			}, this);

			return oToolbar.findAggregatedObjects(false, function (oAggregatedObject) {
				return aIds.indexOf(oAggregatedObject.getId()) > -1;
			}) || [];
		};

		/**
		 * Extend Toolbar's content.
		 *
		 * Allows users to add/insert/find/remove/destroy custom buttons from the Toolbar
		 * without modifying the existing content.
		 * All custom buttons are appended to the end of the Toolbar.
		 * Every action is applied *only* on the custom buttons.
		 * For example "insert" with values (new sap.m.Button(), 1) would insert that Object as a second custom button.
		 * but not as a second in the whole Toolbar.
		 *
		 * @public
		 * @param sModifier {string} Action. This is the same as aggregations' prefixes e.g. *add*Aggregation, *destroy*Aggregation, etc.
		 * @returns {*}
		 */
		ToolbarWrapper.prototype.modifyToolbarContent = function (sModifier) {
			var vResult,
				args = Array.prototype.slice.call(arguments);

			args.shift();

			switch (sModifier) {
				case "add":
					vResult = this._proxyToolbarAdd.apply(this, args);
					break;

				case "destroy":
					vResult = this._proxyToolbarDestroy.apply(this, args);
					break;

				case "get":
					vResult = this._proxyToolbarGet.apply(this, args);
					break;

				case "indexOf":
					vResult = this._proxyToolbarIndexOf.apply(this, args);
					break;

				case "insert":
					vResult = this._proxyToolbarInsert.apply(this, args);
					break;

				case "removeAll":
					vResult = this._proxyToolbarRemoveAll.apply(this, args);
					break;

				case "remove":
					vResult = this._proxyToolbarRemove.apply(this, args);
					break;
			}

			return vResult;
		};

		ToolbarWrapper.prototype._updateCustomToolbarRefIds = function (sId, iInsertionIndex) {
			var aCustomButtonGroup, iItemGroupIndex;

			aCustomButtonGroup = this._customButtons || [];
			iItemGroupIndex = aCustomButtonGroup.indexOf(sId);
			if (iItemGroupIndex > -1) {
				aCustomButtonGroup.splice(iItemGroupIndex, 1);
			}

			if (iInsertionIndex !== -1) {
				iInsertionIndex = iInsertionIndex >= 0 && iInsertionIndex <= aCustomButtonGroup.length ?
					iInsertionIndex : aCustomButtonGroup.length;

				aCustomButtonGroup.splice(iInsertionIndex, 0, sId);
			}

			this._customButtons = aCustomButtonGroup;
		};

		ToolbarWrapper.prototype._proxyToolbarAdd = function (oItem) {
			var oToolbar = this.getAggregation("_toolbar"),
				vResult = oToolbar.addContent(oItem);

			oToolbar.rerender();

			if (vResult) {
				this._updateCustomToolbarRefIds(oItem.getId());
			}

			return vResult;
		};

		ToolbarWrapper.prototype._proxyToolbarGet = function () {
			var oToolbar = this.getAggregation("_toolbar"),
				aCustomButtonGroup = this._customButtons || [];

			return oToolbar.findAggregatedObjects(false, function (oAggregatedObject) {
					return aCustomButtonGroup.indexOf(oAggregatedObject.getId()) > -1;
				}) || [];
		};

		ToolbarWrapper.prototype._proxyToolbarDestroy = function () {
			var aItems = this._proxyToolbarGet();

			aItems.forEach(function (oItem) {
				oItem.destroy();
			});

			this._customButtons = [];
		};

		ToolbarWrapper.prototype._proxyToolbarIndexOf = function (vId) {
			var aCustomButtons = this._customButtons || [],
				sId = typeof vId === "object" ? vId.getId() : vId;

			return aCustomButtons.indexOf(sId);
		};

		ToolbarWrapper.prototype._proxyToolbarInsert = function (oItem, iIndex) {
			var vResult,
				oToolbar = this.getAggregation("_toolbar"),
				aToolbarContent = oToolbar.getContent() || [],
				aCustomButtons = this._customButtons || [],
				iCalculatedIndex = aToolbarContent.length - aCustomButtons.length; // Start the index right after the last not custom item.

			// Align with ManagedObject@insertAggregation
			if (iIndex < 0) { // Out of bounds
				iIndex = 0;
			} else if (iIndex > aCustomButtons.length) { // Out of bounds
				iIndex = aCustomButtons.length;
			} else if (!iIndex && iIndex !== 0) { // iIndex is not defined
				iIndex = aCustomButtons.length;
			}

			iCalculatedIndex += iIndex;

			vResult = oToolbar.insertContent(oItem, iCalculatedIndex);
			oToolbar.rerender();

			if (vResult) {
				this._updateCustomToolbarRefIds(oItem.getId(), iIndex);
			}

			return vResult;
		};

		ToolbarWrapper.prototype._proxyToolbarRemoveAll = function () {
			var aItems = this._proxyToolbarGet();

			aItems.forEach(this._proxyToolbarRemove, this);

			return aItems;
		};

		ToolbarWrapper.prototype._proxyToolbarRemove = function (vItem) {
			var sId, vResult,
				oToolbar = this.getAggregation("_toolbar");

			switch (typeof vItem) {
				case "string":
					sId = vItem;
					break;
				case "object":
					sId = vItem.getId();
					break;
				case "number":
					sId = this._customButtons[vItem];
					break;
			}

			vResult = oToolbar.removeContent(sId);

			if (vResult && sId) {
				this._updateCustomToolbarRefIds(sId, -1);
			}

			return vResult;
		};

		return ToolbarWrapper;
	}, /* bExport= */ true);

}; // end of sap/ui/richtexteditor/ToolbarWrapper.js
if ( !jQuery.sap.isDeclared('sap.ui.richtexteditor.RichTextEditor') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

/*global Promise */

// Provides control sap.ui.richtexteditor.RichTextEditor.
jQuery.sap.declare('sap.ui.richtexteditor.RichTextEditor'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('jquery.sap.global'); // unlisted dependency retained
jQuery.sap.require('sap.ui.core.Control'); // unlisted dependency retained
jQuery.sap.require('sap.ui.core.ResizeHandler'); // unlisted dependency retained
sap.ui.define("sap/ui/richtexteditor/RichTextEditor",['jquery.sap.global', 'sap/ui/core/Control', 'sap/ui/core/ResizeHandler', './library', './ToolbarWrapper'],
	function(jQuery, Control, ResizeHandler, library, ToolbarWrapper) {
	"use strict";
	/**
	 * Describes the internal status of the editor component used inside the RichTextEditor control. Currently only
	 * relevant for TinyMCE4
	 *
	 * @enum {string}
	 * @private
	 */
	var EditorStatus = {
		/**
		 * Uses TinyMCE version 4 as editor
		 * @private
		 */
		Initial: "Initial",
		Loading: "Loading",
		Initializing: "Initializing",
		Loaded: "Loaded",
		Ready: "Ready",
		Destroyed: "Destroyed"
	};

	/**
	 * Constructor for a new RichTextEditor.
	 *
	 * The RichTextEditor uses a third party component, which might in some cases not be
	 * completely compatible with the way UI5's (re-)rendering mechanism works. If you keep hidden
	 * instances of the control (instances which are not visible in the DOM), you might run into
	 * problems with some browser versions. In this case please make sure you destroy the
	 * RichTextEditor instance instead of hiding it and create a new one when you show it again.
	 *
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 *
	 * @class
	 *
	 * The RichTextEditor-Control is used to enter formatted text.
	 *
	 * The <code>RichTextEditor</code> uses a third party component, which might in some cases not be
	 * completely compatible with the way UI5's (re-)rendering mechanism works. <strong>If you keep hidden
	 * instances of the control (instances which are not visible in the DOM), you might run into
	 * problems with some browser versions.</strong> In this case please make sure you destroy the
	 * <code>RichTextEditor</code> instance instead of hiding it and create a new one when you show it again.
	 *
	 * @extends sap.ui.core.Control
	 *
	 * @author SAP SE
	 *
	 * @constructor
	 * @public
	 * @disclaimer Since version 1.6.0.
	 * The RichTextEditor of SAPUI5 contains a third party component TinyMCE provided by Moxiecode Systems AB. The SAP license agreement covers the development of applications with RichTextEditor of SAPUI5 (as of May 2014).
	 * @alias sap.ui.richtexteditor.RichTextEditor
	 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
	 */
	var RichTextEditor = Control.extend("sap.ui.richtexteditor.RichTextEditor", /** @lends sap.ui.richtexteditor.RichTextEditor.prototype */ {
		metadata: {

			library: "sap.ui.richtexteditor",
			properties: {

				/**
				 * An HTML string representing the editor content. Because this is HTML, the value cannot be generically escaped to prevent cross-site scripting, so the application is responsible for doing so.
				 * Overwriting this property would also reset editor's Undo manager and buttons "Undo"/"Redo" would be set to their initial state.
				 */
				value: { type: "string", group: "Data", defaultValue: '' },

				/**
				 * The text direction
				 */
				textDirection: { type: "sap.ui.core.TextDirection", group: "Appearance", defaultValue: sap.ui.core.TextDirection.Inherit },

				/**
				 * Width of RichTextEditor control in CSS units.
				 */
				width: { type: "sap.ui.core.CSSSize", group: "Dimension", defaultValue: null },

				/**
				 * Height of RichTextEditor control in CSS units.
				 */
				height: { type: "sap.ui.core.CSSSize", group: "Dimension", defaultValue: null },

				/**
				 * The editor implementation to use.
				 * Valid values are the ones found under sap.ui.richtexteditor.EditorType and any other editor identifier that may be introduced by other groups (hence this is not an enumeration).
				 * Any attempts to set this property after the first rendering will not have any effect.
				 */
				editorType: { type: "string", group: "Misc", defaultValue: 'TinyMCE' },

				/**
				 * Relative or absolute URL where the editor is available. Must be on the same server.
				 * Any attempts to set this property after the first rendering will not have any effect.
				 * @deprecated Since version 1.25.0.
				 * The editorLocation is set implicitly when choosing the editorType.
				 */
				editorLocation: { type: "string", group: "Misc", defaultValue: 'js/tiny_mce/tiny_mce_src.js', deprecated: true },

				/**
				 * Determines whether the editor content can be modified by the user. When set to "false" there might not be any editor toolbar.
				 */
				editable: { type: "boolean", group: "Misc", defaultValue: true },

				/**
				 * Determines whether the toolbar button group containing commands like Bold, Italic, Underline and Strikethrough is available. Changing this after the initial rendering will result in some visible redrawing.
				 */
				showGroupFontStyle: { type: "boolean", group: "Misc", defaultValue: true },

				/**
				 * Determines whether the toolbar button group containing text alignment commands is available. Changing this after the initial rendering will result in some visible redrawing.
				 */
				showGroupTextAlign: { type: "boolean", group: "Misc", defaultValue: true },

				/**
				 * Determines whether the toolbar button group containing commands like Bullets and Indentation is available. Changing this after the initial rendering will result in some visible redrawing.
				 */
				showGroupStructure: { type: "boolean", group: "Misc", defaultValue: true },

				/**
				 * Determines whether the toolbar button group containing commands like Font, Font Size and Colors is available. Changing this after the initial rendering will result in some visible redrawing.
				 */
				showGroupFont: { type: "boolean", group: "Misc", defaultValue: false },

				/**
				 * Determines whether the toolbar button group containing commands like Cut, Copy and Paste is available. Changing this after the initial rendering will result in some visible redrawing.
				 */
				showGroupClipboard: { type: "boolean", group: "Misc", defaultValue: true },

				/**
				 * Determines whether the toolbar button group containing commands like Insert Image and Insert Smiley is available. Changing this after the initial rendering will result in some visible redrawing.
				 */
				showGroupInsert: { type: "boolean", group: "Misc", defaultValue: false },

				/**
				 * Determines whether the toolbar button group containing commands like Create Link and Remove Link is available. Changing this after the initial rendering will result in some visible redrawing.
				 */
				showGroupLink: { type: "boolean", group: "Misc", defaultValue: false },

				/**
				 * Determines whether the toolbar button group containing commands like Undo and Redo is available. Changing this after the initial rendering will result in some visible redrawing.
				 */
				showGroupUndo: { type: "boolean", group: "Misc", defaultValue: false },

				/**
				 * Determines whether the text in the editor is wrapped. This does not affect the editor's value, only the representation in the control.
				 */
				wrapping: { type: "boolean", group: "Appearance", defaultValue: true },

				/**
				 * Determines whether a value is required.
				 */
				required: { type: "boolean", group: "Misc", defaultValue: false },

				/**
				 * Determines whether to run the HTML sanitizer once the value (HTML markup) is applied or not. To configure allowed URLs please use the whitelist API via <code>jQuery.sap.addUrlWhitelist</code>
				 */
				sanitizeValue: { type: "boolean", group: "Misc", defaultValue: true },

				/**
				 * An array of plugin configuration objects with the obligatory property "name".
				 * Each object has to contain a property "name" which then contains the plugin name/ID.
				 */
				plugins: { type: "object[]", group: "Behavior", defaultValue: [] },

				/**
				 * Determines whether or not to use the legacy theme for the toolbar buttons. If this is set to false, the default theme for the editor will be used (which might change slightly with every update). The legacy theme has the disadvantage that not all functionality has its own icon, so using non default buttons might lead to invisible buttons with the legacy theme - use the default editor theme in this case.
				 */
				useLegacyTheme: { type: "boolean", group: "Appearance", defaultValue: true },

				/**
				 * An array of button configurations. These configurations contain the names of buttons as array in the property "buttons" and the name of the group in "name", they can also contain the "row" where the buttons should be placed, a "priority" and whether the buttons are "visible". See method addButtonGroup() for more details on the structure of the objects in this array.
				 */
				buttonGroups: { type: "object[]", group: "Behavior", defaultValue: [] },

				/**
				 * Determines whether a Fiori Toolbar is used instead of the TinyMCE default toolbar one. It is applied only when the EditorType is TinyMCE4 and sap.m library is loaded.
				 */
				customToolbar: { type: "boolean", group: "Misc", defaultValue: false }
			},
			events: {

				/**
				 * Event is fired when the text in the field has changed AND the focus leaves the editor or when the Enter key is pressed.
				 */
				change: {
					parameters: {

						/**
						 * The new control value.
						 */
						newValue: { type: "string" }
					}
				},

				/**
				 * Fired when the used editor is loaded and ready (its HTML is also created).
				 */
				ready: {},

				/**
				 * Analogous to the ready event, the event is fired when the used editor is loaded and ready. But the event is fired after every time the control is ready to use and not only once like the ready event.
				 */

				readyRecurring: {},

				/**
				 * This event is fired right before the TinyMCE instance is created and can be used to change the settings object that will be given to TinyMCE. The parameter "configuration" is the javascript oject that will be given to TinyMCE upon first instantiation. The configuration parameter contains a map that can be changed in the case of TinyMCE.
				 */
				beforeEditorInit: {}
			},
			aggregations: {
				/**
				 * Custom toolbar wrapper.
				 * The wrapper gets instantiated when customToolbar property is set to true.
				 *
				 * @since 1.48
				 */
				_toolbarWrapper: {type: "sap.ui.richtexteditor.IToolbar", multiple: false, visibility : "hidden", defaultValue: null},
				/**
				 * Custom buttons are meant to extend the RichTextEditor's custom toolbar.
				 * Though type is set to sap.ui.Control, only sap.m.Button is allowed.
				 * <b>Note:</b> customButtons are available only when the customToolbar is enabled and all the requirements are fulfilled.
				 *
				 * @since 1.48
				 */
				customButtons: {type: "sap.ui.core.Control", multiple: true, singularName: "customButton", defaultValue: null}
			}
		}
	});




	/*global tinymce */ // Tells JSLint/SAPUI5 validation we need access to this global variable
	/* eslint-disable strict (Will be adressed when moving to AMD syntax) */

	/*
		* The following code is editor-independent
		*/
	// Counter for creating internal ids
	RichTextEditor._lastId = 0;

	RichTextEditor._iCountInstances = 0;

	RichTextEditor.BUTTON_GROUPS = library.ButtonGroups;

	// Editor type entries for backwards compatibility
	RichTextEditor.EDITORTYPE_TINYMCE = library.EditorType.TinyMCE;
	RichTextEditor.EDITORTYPE_TINYMCE4 = library.EditorType.TinyMCE4;

	RichTextEditor.EDITORLOCATION_TINYMCE = "js/tiny_mce/tiny_mce.js";
	RichTextEditor.EDITORLOCATION_TINYMCE4 = "js/tiny_mce4/tinymce.min.js";

	if (sap.ui.getCore().getConfiguration().getDebug()) {
		RichTextEditor.EDITORLOCATION_TINYMCE = "js/tiny_mce/tiny_mce_src.js";
		RichTextEditor.EDITORLOCATION_TINYMCE4 = "js/tiny_mce4/tinymce.js";
	}

	RichTextEditor.MAPPED_LANGUAGES_TINYMCE4 = {
		"sh": "sr",
		"ji": "yi",
		"in": "id",
		"iw": "he",
		"no": "nb"
	};

	RichTextEditor.SUPPORTED_LANGUAGES_TINYMCE4 = {
		"en": true, // Default
		"ar": true,
		"ar_SA": true,
		"hy": true,
		"az": true,
		"eu": true,
		"be": true,
		"bn_BD": true,
		"bs": true,
		"bg_BG": true,
		"ca": true,
		"zh_CN": true,
		"zh_TW": true,
		"hr": true,
		"cs": true,
		"da": true,
		"dv": true,
		"nl": true,
		"en_CA": true,
		"en_GB": true,
		"et": true,
		"fo": true,
		"fi": true,
		"fr_FR": true,
		"gd": true,
		"gl": true,
		"ka_GE": true,
		"de": true,
		"de_AT": true,
		"el": true,
		"he_IL": true,
		"hi_IN": true,
		"hu_HU": true,
		"is_IS": true,
		"id": true,
		"it": true,
		"ja": true,
		"kk": true,
		"km_KH": true,
		"ko_KR": true,
		"ku": true,
		"ku_IQ": true,
		"lv": true,
		"lt": true,
		"lb": true,
		"ml": true,
		"ml_IN": true,
		"mn_MN": true,
		"nb_NO": true,
		"fa": true,
		"fa_IR": true,
		"pl": true,
		"pt_BR": true,
		"pt_PT": true,
		"ro": true,
		"ru": true,
		"ru@petr1708": true,
		"sr": true,
		"si_LK": true,
		"sk": true,
		"sl_SI": true,
		"es": true,
		"es_MX": true,
		"sv_SE": true,
		"tg": true,
		"ta": true,
		"ta_IN": true,
		"tt": true,
		"th_TH": true,
		"tr_TR": true,
		"ug": true,
		"uk": true,
		"uk_UA": true,
		"vi": true,
		"vi_VN": true,
		"cy": true
	};

	RichTextEditor.SUPPORTED_LANGUAGES_DEFAULT_REGIONS = {
		"zh": "CN",
		"fr": "FR",
		"bn": "BD",
		"bg": "BG",
		"ka": "GE",
		"he": "IL",
		"hi": "IN",
		"hu": "HU",
		"is": "IS",
		"km": "KH",
		"ko": "KR",
		"ku": "IQ",
		"mn": "MN",
		"nb": "NO",
		"pt": "PT",
		"si": "SI",
		"sv": "SE",
		"th": "TH",
		"tr": "TR"
	};

	RichTextEditor.pLoadTinyMCE = null;

	/**
	 * Creates and returns a promise to load the given location as script url. Only the first invocation needs the
	 * sLocation argument as all subsequent calls return the initially created promise. This corresponds to the
	 * fact that only one TinyMCE version can be loaded on the page. The promise can can still be used to determine
	 * when the TinyMCE API will be available.
	 *
	 * @param {string} sLocation - The URL of the TinyMCE script
	 * @returns {Promise} - The promise to load the URL given on first invocation
	 * @private
	 */
	RichTextEditor.loadTinyMCE = function(sLocation) {
		if (sLocation) {
			var sRealLocation = sap.ui.resource('sap.ui.richtexteditor', sLocation),
				oScriptElement = document.querySelector("#sapui5-tinyMCE"),
				sLoadedLocation = oScriptElement ? oScriptElement.getAttribute("src") : "";


			if (sRealLocation !== sLoadedLocation && RichTextEditor._iCountInstances === 1) {
				delete window.tinymce;
				delete window.TinyMCE;
				RichTextEditor.pLoadTinyMCE = null;
			}

			if (!RichTextEditor.pLoadTinyMCE) {
				RichTextEditor.pLoadTinyMCE = new Promise(function(fnResolve, fnReject) {
					jQuery.sap.includeScript(sRealLocation, "sapui5-tinyMCE", fnResolve, fnReject);
				});
			}
		}
		return RichTextEditor.pLoadTinyMCE;
	};

	/**
	 * Initialization
	 * @private
	 */
	RichTextEditor.prototype.init = function() {
		this._bEditorCreated = false;
		this._sTimerId = null;
		RichTextEditor._iCountInstances++;

		this.setButtonGroups([{
			name: "font-style",
			visible: true,
			row: 0,
			priority: 10,
			buttons: [
				"bold", "italic", "underline", "strikethrough"
			]
		}, {
			// Text Align group
			name: "text-align",
			visible: true,
			row: 0,
			priority: 20,
			buttons: [
				"justifyleft", "justifycenter", "justifyright", "justifyfull"
			]
		}, {
			name: "font",
			visible: false,
			row: 0,
			priority: 30,
			buttons: [
				"fontselect", "fontsizeselect", "forecolor", "backcolor"
			]
		}, {
			name: "clipboard",
			visible: true,
			row: 1,
			priority: 10,
			buttons: [
				"cut", "copy", "paste"
			]
		}, {
			name: "structure",
			visible: true,
			row: 1,
			priority: 20,
			buttons: [
				"bullist", "numlist", "outdent", "indent"
			]
		}, {
			name: "e-mail",
			visible: false,
			row: 1,
			priority: 30,
			buttons: []
		}, {
			name: "undo",
			visible: false,
			row: 1,
			priority: 40,
			buttons: [
				"undo", "redo"
			]
		}, {
			name: "insert",
			visible: false,
			row: 1,
			priority: 50,
			buttons: [
				"image", "emotions"
			]
		}, {
			name: "link",
			visible: false,
			row: 1,
			priority: 60,
			buttons: [
				"link", "unlink"
			]
		}]);

		this.setPlugins([{
			name: "lists"
		},{
			name: "emotions"
		}, {
			name: "directionality"
		}, {
			name: "inlinepopups"
		}, {
			name: "tabfocus"
		}, {
			name: "table"
		}]);

		this._textAreaId = this.getId() + "-textarea";
		this._iframeId = this._textAreaId + "_ifr";

		this._textAreaDom = document.createElement("textarea");
		this._textAreaDom.id = this._textAreaId;
		this._textAreaDom.style.height = "100%";
		this._textAreaDom.style.width = "100%";

		// This always calls initTinyMCE since init is called before the editorType can be set
		this._callEditorSpecific("init");
	};

	RichTextEditor.prototype.onBeforeRendering = function() {
		this._customToolbarEnablement();

		if (!this._bCustomToolbarRequirementsFullfiled && this.getCustomToolbar()) {
			jQuery.sap.log.warning("Cannot set custom toolbar - not all requirements are fulfilled.");
		}

		this._callEditorSpecific("onBeforeRendering");
	};

	RichTextEditor.prototype.onAfterRendering = function() {
		this._callEditorSpecific("onAfterRendering");
	};

	/**
	 * After configuration has changed, this method can be used to trigger a complete re-rendering
	 * that also re-initializes the editor instance from scratch. Caution: this is expensive, performance-wise!
	 * @private
	 */
	RichTextEditor.prototype.reinitialize = function() {
		// Make sure reinitialization does not happen because several settings are done
		clearTimeout(this._iReinitTimeout);
		this._iReinitTimeout = window.setTimeout(this._callEditorSpecific.bind(this, "reinitialize"), 0);
	};


	/**
	 * Returns the current editor's instance.
	 * CAUTION: using the native editor introduces a dependency to that editor and breaks the wrapping character of the RichTextEditor control, so it should only be done in justified cases.
	 *
	 * @returns {object} The native editor object (here: The TinyMCE editor instance)
	 * @public
	 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
	 */
	RichTextEditor.prototype.getNativeApi = function() {
		return this._callEditorSpecific("getNativeApi");
	};

	RichTextEditor.prototype.exit = function() {
		jQuery.sap.clearDelayedCall(this._reinitDelay);
		this._callEditorSpecific("exit");
		RichTextEditor._iCountInstances--;
	};

	RichTextEditor.prototype.setValue = function(sValue) {

		if (this.getSanitizeValue()) {
			jQuery.sap.log.trace("sanitizing HTML content for " + this);
			// images are using the URL whitelist support
			sValue = jQuery.sap._sanitizeHTML(sValue);
		}

		if (sValue === this.getValue()) {
			return this;
		}

		this.setProperty("value", sValue, true);
		sValue = this.getProperty("value");
		var methodName = "setValue" + this.getEditorType();
		if (this[methodName] && typeof this[methodName] === "function") {
			this[methodName].call(this, sValue);
		} else {
			this.reinitialize();
		}
		return this;
	};

	RichTextEditor.prototype._callEditorSpecific = function(sPrefix) {
		var methodName = sPrefix + this.getEditorType();
		if (this[methodName] && typeof this[methodName] === "function") {
			return this[methodName].call(this);
		} else {
			return undefined;
		}
	};

	// the following setters will work after initial rendering, but can cause a complete re-initialization

	RichTextEditor.prototype.setEditable = function(bEditable) {
		this.setProperty("editable", bEditable, true);
		this.reinitialize();
		return this;
	};

	RichTextEditor.prototype.setWrapping = function(bWrapping) {
		this.setProperty("wrapping", bWrapping, true);
		this.reinitialize();
		return this;
	};

	RichTextEditor.prototype.setRequired = function(bRequired) {
		this.setProperty("required", bRequired, true);
		this.reinitialize();
		return this;
	};

	/**
	 * Helper function for show/hide of each button group
	 * @private
	 * @param {boolean} [bShow] Boolean value, indicating if the group should be shown or hidden
 	 * @param {object} [mSettings] Settings object
	 */
	RichTextEditor.prototype._setShowGroup = function (bShow, mSettings) {
		var oCustomToolbar = this.getAggregation("_toolbarWrapper");

		this.setProperty(mSettings.property, bShow, true);
		this.setButtonGroupVisibility(mSettings.buttonGroup, bShow);

		if (!oCustomToolbar) {
			this.reinitialize();
			return this;
		}

		oCustomToolbar.setShowGroup(mSettings.buttonGroup, bShow);

		return this;
	};

	RichTextEditor.prototype.setShowGroupFontStyle = function(bShowGroupFontStyle) {
		return this._setShowGroup(bShowGroupFontStyle, {
			property: 'showGroupFontStyle',
			buttonGroup: 'font-style'
		});
	};


	RichTextEditor.prototype.setShowGroupTextAlign = function(bShowGroupTextAlign) {
		return this._setShowGroup(bShowGroupTextAlign, {
			property: 'showGroupTextAlign',
			buttonGroup: 'text-align'
		});
	};

	RichTextEditor.prototype.setShowGroupStructure = function(bShowGroupStructure) {
		return this._setShowGroup(bShowGroupStructure, {
			property: 'showGroupStructure',
			buttonGroup: 'structure'
		});
	};

	RichTextEditor.prototype.setShowGroupFont = function(bShowGroupFont) {
		return this._setShowGroup(bShowGroupFont, {
			property: 'showGroupFont',
			buttonGroup: 'font'
		});
	};

	RichTextEditor.prototype.setShowGroupClipboard = function(bShowGroupClipboard) {
		return this._setShowGroup(bShowGroupClipboard, {
			property: 'showGroupClipboard',
			buttonGroup: 'clipboard'
		});
	};

	RichTextEditor.prototype.setShowGroupInsert = function(bShowGroupInsert) {
		return this._setShowGroup(bShowGroupInsert, {
			property: 'showGroupInsert',
			buttonGroup: 'insert'
		});
	};

	RichTextEditor.prototype.setShowGroupLink = function(bShowGroupLink) {
		return this._setShowGroup(bShowGroupLink, {
			property: 'showGroupLink',
			buttonGroup: 'link'
		});
	};

	RichTextEditor.prototype.setShowGroupUndo = function(bShowGroupUndo) {
		return this._setShowGroup(bShowGroupUndo, {
			property: 'showGroupUndo',
			buttonGroup: 'undo'
		});
	};

	/**
	 * Allows to add plugins (that must already be installed on the server) to the
	 * RichtextEditor.
	 *
	 * @param {map|string} [mPlugin] A map with the property name containing the plugin IDs/name or an object with the property "name".
	 * @public
	 * @returns {object} Control instance (for method chaining)
	 */
	RichTextEditor.prototype.addPlugin = function(mPlugin) {
		if (typeof mPlugin === "string") {
			mPlugin = {
				name: mPlugin
			};
		}
		var aPlugins = this.getProperty("plugins");
		aPlugins.push(mPlugin);
		this.setProperty("plugins", aPlugins);
		this.reinitialize();
		return this;
	};

	/**
	 * Removes the plugin with the given name/ID from the list of plugins to load
	 *
	 * @param {string} [sPluginName] The name/id of the plugin to remove
	 * @returns {object} Control instance (for method chaining)
	 */
	RichTextEditor.prototype.removePlugin = function(sPluginName) {
		var aPlugins = this.getProperty("plugins").slice(0);
		for (var i = 0; i < aPlugins.length; ++i) {
			if (aPlugins[i].name === sPluginName) {
				aPlugins.splice(i, 1);
				--i;
			}
		}
		this.setProperty("plugins", aPlugins);

		this.reinitialize();
		return this;
	};


	/**
	 * Allows to opt out of the legacy theme that is applied to keep the old button look. In case
	 * butons are used that are not in the legacy theme, this can be disabled in order to show
	 * the button correctly.
	 *
	 * @param {boolean} [bUseLegacyTheme] Whether to use the legacy button theme
	 * @public
	 * @returns {object} Control instance (for method chaining)
	 */
	RichTextEditor.prototype.setUseLegacyTheme = function(bUseLegacyTheme) {
		var oDomRef = this.getDomRef();
		if (oDomRef) {
			jQuery(oDomRef).toggleClass("sapUiRTELegacyTheme", bUseLegacyTheme);
		}

		return this.setProperty("useLegacyTheme", bUseLegacyTheme, true);
	};


	/**
	 * Adds a button group to the editor.
	 *
	 * @param {map|string} [mGroup] Name/ID of a single button or map containing the group information
	 * @param {string[]}   [mGroup.buttons] Array of name/IDs of the buttons in the group
	 * @param {string}     [mGroup.name] Name/ID of the group.
	 * @param {boolean}    [mGroup.visible=true] (optional) The priority of the button group. Lower priorities are added first.
	 * @param {int}        [mGroup.row=0] (optional) Row number in which the button should be
	 * @param {int}        [mGroup.priority=10] (optional) The priority of the button group. Lower priorities are added first.
	 * @public
	 * @returns {object} Control instance (for method chaining)
	 */
	RichTextEditor.prototype.addButtonGroup = function (mGroup) {
		var aGroups = this.getProperty("buttonGroups").slice(),
			oCustomToolbar = this.getAggregation("_toolbarWrapper"),
			bFullGroup = true;

		// check if the group is already added
		for (var i = 0; i < aGroups.length; ++i) {
			if (mGroup === "string" && aGroups[i].name === mGroup || aGroups[i].name === mGroup.name) {
				return this;
			}
		}

		if (typeof mGroup === "string") {
			bFullGroup = false;
			mGroup = {
				name: this._createId("buttonGroup"),
				buttons: [mGroup]
			};
		}

		if (mGroup.visible === undefined) {
			mGroup.visible = true;
		}
		if (mGroup.priority === undefined) {
			mGroup.priority = 10;
		}
		if (mGroup.row === undefined) {
			mGroup.row = 0;
		}

		if (oCustomToolbar) {
			oCustomToolbar.addButtonGroupToContent(mGroup, bFullGroup);
		}

		var aButtonGroups = this.getButtonGroups();
		aButtonGroups.push(mGroup);
		this.setButtonGroups(aButtonGroups);

		return this;
	};

	RichTextEditor.prototype.removeButtonGroup = function(sGroupName) {
		var aGroups = this.getProperty("buttonGroups").slice(0),
			oCustomToolbar = this.getAggregation("_toolbarWrapper");

		for (var i = 0; i < aGroups.length; ++i) {
			if (aGroups[i].name === sGroupName) {
				aGroups.splice(i, 1);
				--i;

				oCustomToolbar && oCustomToolbar.removeButtonGroup(sGroupName);
			}
		}
		this.setProperty("buttonGroups", aGroups);

		this.reinitialize();
		return this;
	};

	/**
	 * Make the button group with the given name (in)visible (if used before initialization of the editor)
	 *
	 * @param {string} [sGroupName] Name of the group of buttons to be chenged
	 * @param {bool}   [bVisible=false] Whether or not this group should be visible
	 * @private
	 * @returns {object} Control instance (for method chaining)
	 */
	RichTextEditor.prototype.setButtonGroupVisibility = function(sGroupName, bVisible) {
		var aButtonGroups = this.getButtonGroups();
		for (var i = 0, iLen = aButtonGroups.length; i < iLen; ++i) {
			if (aButtonGroups[i].name === sGroupName) {
				aButtonGroups[i].visible = bVisible;
			}
		}

		return this;
	};

	/**
	 * Internal method to create unique (to the RTE) IDs
	 *
	 * @param {string} [sPrefix] The string prepended to the unique ID
	 * @returns {string} A unique ID for the editor
	 *
	 * @private
	 */
	RichTextEditor.prototype._createId = function(sPrefix) {
		if (sPrefix === undefined) {
			sPrefix = "_rte";
		}

		return sPrefix + (RichTextEditor._lastId++);
	};

	// the following functions shall not work after the first rendering
	/**
	 * Switches the editor type and sets the default settings for the editor.
	 * All plugins and button groups should be set after this has been invoked
	 *
	 * @param {string} [sEditorType] Which editor type to be used (currently only TinyMCE 3 and 4)
	 * @returns {object} Control instance (for method chaining)
	 * @public
	 */
	RichTextEditor.prototype.setEditorType = function(sEditorType) {
		if (!this._bEditorCreated) { // only supported before first rendering!
			this._callEditorSpecific("unload");

			this.setProperty("editorType", sEditorType);

			switch (sEditorType) {
				case library.EditorType.TinyMCE:
					this.setEditorLocation(RichTextEditor.EDITORLOCATION_TINYMCE);
					// The plugin "emotions" has been replaced by "emoticons" in v4 mind the "c"
					this.removePlugin("emoticons");
					this.addPlugin("emotions");
					this.removePlugin("lists");
					this.addPlugin("inlinepopups");
					this.removeButtonGroup("text-align");
					this.removePlugin("image");
					this.removePlugin("link");
					this.removePlugin("textcolor");
					this.removePlugin("colorpicker");
					this.removePlugin("textpattern");
					this.removePlugin("powerpaste");
					this.addButtonGroup({
						// Text Align group
						name: "text-align",
						visible: true,
						row: 0,
						priority: 20,
						buttons: [
							"justifyleft", "justifycenter", "justifyright", "justifyfull"
						]
					});
					this.removeButtonGroup("insert");
					this.addButtonGroup({
						name: "insert",
						visible: false,
						row: 1,
						priority: 50,
						buttons: [
							"image", "emotions"
						]
					});
					break;

				case library.EditorType.TinyMCE4:
					this.setEditorLocation(RichTextEditor.EDITORLOCATION_TINYMCE4);
					// The plugin "emotions" has been replaced by "emoticons" in v 4 mind the "c"
					this.removePlugin("emotions");
					this.addPlugin("emoticons");
					//TinyMCE has moved lists from core to a plugin
					this.addPlugin("lists");
					// All popups are now "inline"
					this.removePlugin("inlinepopups");
					this.removeButtonGroup("text-align");
					// TinyMCE4 handles images in plugin
					this.addPlugin("image");
					this.addPlugin("link");
					this.addPlugin("textcolor");
					this.addPlugin("colorpicker");
					this.addPlugin("textpattern");
					this.addPlugin("powerpaste");
					this.addButtonGroup({
						// Text Align group
						name: "text-align",
						visible: true,
						row: 0,
						priority: 20,
						buttons: [
							"alignleft", "aligncenter", "alignright", "alignjustify"
						]
					});
					this.removeButtonGroup("insert");
					this.addButtonGroup({
						name: "insert",
						visible: false,
						row: 1,
						priority: 50,
						buttons: [
							"image", "emoticons"
						]
					});
					break;

				default:
					jQuery.sap.log.error("editorType property set to an unknown editor type");
			}

			this._callEditorSpecific("init");
		} else {
			jQuery.sap.log.error(
				"editorType property cannot be set after the RichtextEditor has been rendered"
			);
		}

		return this;
	};

	RichTextEditor.prototype.setEditorLocation = function(sEditorLocation) {
		if (!this._bEditorCreated) { // only supported before first rendering!
			this.setProperty("editorLocation", sEditorLocation);
		} else {
			jQuery.sap.log.error(
				"editorLocation property cannot be set after the RichtextEditor has been rendered"
			);
		}
		return this;
	};


	/************************************************************************
	 * What now follows is Editor-dependent code
	 *
	 * For other editors create suitable versions of these methods
	 * and attach them to sap.ui.richtexteditor.RichTextEditor.prototype
	 ************************************************************************/

	/////////////////////////// Begin editor section "TinyMCE" (All versions) //////////////////////////

	/**
	 * Creates the ButtonRow strings for TinyMCE
	 *
	 * @param {string} [sButtonSeparator] Separator that is used to separate button entries
	 * @param {string} [sGroupSeparator]  Separator that is used to separate groups of button entries
	 * @returns {string[]} An array of strings with TinyMCE specific button format
	 * @private
	 */
	RichTextEditor.prototype._createButtonRowsTinyMCE = function(sButtonSeparator, sGroupSeparator) {
		sButtonSeparator = sButtonSeparator === undefined ? "," : sButtonSeparator;
		sGroupSeparator = sGroupSeparator === undefined ? "|" : sGroupSeparator;

		var aButtonGroups = this.getButtonGroups(),
			sGroupSep = sButtonSeparator + sGroupSeparator + sButtonSeparator,
			i, iLen, mGroup,
			aOrderedGroups = {},
			aButtonRows = [];

		// Order Groups by priority
		for (i = 0, iLen = aButtonGroups.length; i < iLen; ++i) {
			mGroup = aButtonGroups[i];
			if (!aOrderedGroups[mGroup.priority]) {
				aOrderedGroups[mGroup.priority] = [];
			}
			if (mGroup.priority === undefined) {
				mGroup.priority = Number.MAX_VALUE;
			}

			aOrderedGroups[mGroup.priority].push(mGroup);
		}

		// Add Groups in order to the four button rows
		for (var key in aOrderedGroups) {
			for (i = 0, iLen = aOrderedGroups[key].length; i < iLen; ++i) {
				mGroup = aOrderedGroups[key][i];
				var iRow = mGroup.row || 0;

				if (!mGroup.visible || !mGroup.buttons || mGroup.buttons.length === 0) {
					// Do not add empty or invisible groups
					continue;
				}

				if (!aButtonRows[iRow]) {
					aButtonRows[iRow] = "";
				}
				aButtonRows[iRow] += mGroup.buttons.join(sButtonSeparator) + sGroupSep;
			}
		}

		for (i = 0; i < aButtonRows.length; ++i) {
			if (aButtonRows[i] === null) {
				continue;
			} else if (!aButtonRows[i]) {
				aButtonRows.splice(i, 1);
				aButtonRows.push(null);
				continue;
			}

			// Remove trailing group separators
			if (aButtonRows[i].substr(-3) === sGroupSep) {
				aButtonRows[i] = aButtonRows[i].substr(0, aButtonRows[i].length - sGroupSep.length);
			}
			if (aButtonRows[i].substr(-1) === sButtonSeparator) {
				aButtonRows[i] = aButtonRows[i].substr(0, aButtonRows[i].length - sButtonSeparator.length);
			}
			// In case the row is empty, remove it
			if (aButtonRows[i].length === 0) {
				aButtonRows.splice(i, 1);
				aButtonRows.push(null);
			}
		}

		return aButtonRows;
	};

	/**
	 * Creates the ButtonRow strings for TinyMCE
	 *
	 * @private
	 * @returns {string} Plugin string specificly formatted for TinyMCE
	 */
	RichTextEditor.prototype._createPluginsListTinyMCE = function() {
		var aPlugins = this.getPlugins(),
			aPluginNames = [];

		for (var i = 0, iLen = aPlugins.length; i < iLen; ++i) {
			aPluginNames.push(aPlugins[i].name);
		}
		return aPluginNames.join(",");
	};



	/**
	 * Checks whether TinyMCE has rendered its HTML
	 *
	 * @private
	 * @returns {bool} Whether TinyMCE is rendered inside the page
	 */
	RichTextEditor.prototype.tinyMCEReady = function() {
		var iframe = jQuery.sap.domById(this._iframeId);
		return !!iframe;
	};


	/**
	 * TinyMCE-specific value setter that avoids re-rendering
	 *
	 * @param {string} [sValue] The content for the editor
	 * @returns {void}
	 */
	RichTextEditor.prototype.setValueTinyMCE = function(sValue) {
		if (this._bEditorCreated) {
			jQuery.sap.byId(this._textAreaId).text(sValue);
			this.setContentTinyMCE();
		} else {
			this.setProperty("value", sValue, true);
			if (this.getDomRef()) {
				jQuery.sap.byId(this._textAreaId).val(sValue);
			}
		}
	};

	/**
	 * Event handler being called when the text in the editor has changed
	 *
	 * @param {tinymce.Editor} [oCurrentInst] The current editor instance (tinymce native API)
	 * @returns {void}
	 * @private
	 */
	RichTextEditor.prototype.onTinyMCEChange = function(oCurrentInst) {
		var oldVal = this.getValue(),
			newVal = oCurrentInst.getContent();

		if ((oldVal !== newVal) && !this.bExiting) {
			this.setProperty("value", newVal, true); // suppress rerendering
			this.fireChange({ oldValue: oldVal, newValue: newVal });
		}
	};

	/**
	 * Called on every keydown
	 *
	 * @param {jQuery.Event} [oEvent] The keyboard event
	 * @returns {void}
	 * @private
	 */
	RichTextEditor.prototype._tinyMCEKeyboardHandler = function(oEvent) {
		var newIndex,
			key = oEvent['keyCode'];

		switch (key) {
			case jQuery.sap.KeyCodes.TAB: /* 9 */
				if (!this.$focusables.index(jQuery(oEvent.target)) === 0) { // if not on very first element
					var index = this.$focusables.size() - 1; // this element moves the focus into the iframe
					this.$focusables.get(index).focus();
				}
				break;

			case jQuery.sap.KeyCodes.ARROW_LEFT:
			case jQuery.sap.KeyCodes.ARROW_UP:
				newIndex = this.$focusables.index(jQuery(oEvent.target)) - 1;
				if (newIndex === 0) {
					newIndex = this.$focusables.size() - 2;
				}
				this.$focusables.get(newIndex).focus();
				break;

			case jQuery.sap.KeyCodes.ARROW_RIGHT:
			case jQuery.sap.KeyCodes.ARROW_DOWN:
				newIndex = this.$focusables.index(jQuery(oEvent.target)) + 1;
				if (newIndex === this.$focusables.size() - 1) {
					newIndex = 1;
				}
				this.$focusables.get(newIndex).focus();
				break;

			default:
				// Do not react to other keys
				break;
		}
	};


	/**
	 * Map languages that are incorrectly assigned or fallback if languages do not work
	 * TODO: Change this when more languages are supported by TinyMCE
	 *
	 * @returns {string} The language to be used for TinyMCE
	 */
	RichTextEditor.prototype._getLanguageTinyMCE = function() {
		var oLocale = new sap.ui.core.Locale(sap.ui.getCore().getConfiguration().getLanguage()),
			sLanguage = oLocale.getLanguage(),
			sRegion = oLocale.getRegion(),
			mLangFallback = {
				"zh": "zh-" + (sRegion ? sRegion.toLowerCase() : "cn"),
				"sh": "sr",
				"hi": "en" // Hindi is not supported by tinyMCE - fallback to en to show something at least
			};

		sLanguage = mLangFallback[sLanguage] ? mLangFallback[sLanguage] : sLanguage;

		return sLanguage;
	};
	//////////////////////////// End editor section "TinyMCE" (All versions) ///////////////////////////




	////////////////////////////////// Begin editor section "TinyMCE" //////////////////////////////////


	/**
	 * Static initialization for usage of TinyMCE
	 * @private
	 */
	RichTextEditor.initTinyMCEStatic = function() {
		RichTextEditor.TinyMCE = {};
		RichTextEditor.TinyMCEInitialized = true;
	};

	RichTextEditor.prototype.initTinyMCE = function() {
		sap.ui.getCore().getEventBus().subscribe("sap.ui", "__preserveContent", this._tinyMCEPreserveHandler, this);
		sap.ui.getCore().getEventBus().subscribe("sap.ui", "__beforePopupClose", this._tinyMCEPreserveHandler, this);
	};


	/**
	 * Saves the current control data and detaches the editor instance from the DOM element
	 * @private
	 */
	RichTextEditor.prototype.onBeforeRenderingTinyMCE = function() {
		RichTextEditor.loadTinyMCE(this.getEditorLocation()).then(function() {
			try {
				window.tinymce.execCommand('mceRemoveControl', false, this._textAreaId);
			} catch (ex) {
				// Ignore because editor might not even exist at this time
			}
		}.bind(this));
	};


	/**
	 * Restores the data and re-attaches the editor instance to the DOM element
	 * @private
	 */
	RichTextEditor.prototype.onAfterRenderingTinyMCE = function() {
		RichTextEditor.loadTinyMCE().then(function() {
			// Make sure the text-area is visible before the editor is (re-)created. This might not be the case if
			// the dom was removed externally
			this.getDomRef().appendChild(this._textAreaDom);
			this._textAreaDom.style.display = "";
			this._textAreaDom.style.visibility = "";
			this._textAreaDom.value = this.getValue();

			if (!this._bEditorCreated) {
				// first rendering: instantiate the editor
				this.initTinyMCEAfterFirstRendering();
			} else {
				// subsequent re-rendering:
				// the saved content is restored
				this.setContentTinyMCE();

				// re-connect the editor instance to the DOM element
				if (window.tinymce) {
					window.tinymce.execCommand('mceAddControl', false, this._textAreaId);
				}

				this.initWhenTinyMCEReady();
			}
		}.bind(this));
	};


	/**
	 * Initializes the TinyMCE instance
	 * @private
	 */
	RichTextEditor.prototype.initTinyMCEAfterFirstRendering = function() {
		var oCustomToolbar = this.getAggregation("_toolbarWrapper");

		// make sure static initialization has happened
		if (!RichTextEditor.TinyMCEInitialized) {
			RichTextEditor.initTinyMCEStatic();
		}

		// wait until the script is ready, don't start multiple timers for multiple calls
		if (this.sTimerId) {
			jQuery.sap.clearDelayedCall(this.sTimerId);
			this.sTimerId = null;
		}
		if (!window.tinymce) {
			this.sTimerId = jQuery.sap.delayedCall(10, this, this.initTinyMCEAfterFirstRendering); // "10" to avoid busy waiting
			return;
		}
		this._bEditorCreated = true; // do this as soon as we enter the init code with no chance of return

		var aButtonRows = this._createButtonRowsTinyMCE(),
			sPluginsList = this._createPluginsListTinyMCE(),
			oConfig = {
				mode: "exact",
				// The following line only covers the editor content, not the UI in general
				directionality: (sap.ui.getCore().getConfiguration().getRTL() ? "rtl" : "ltr"),
				elements: this._textAreaId,
				theme: "advanced",
				language: this._getLanguageTinyMCE(),
				browser_spellcheck: true,
				convert_urls: false,
				plugins: sPluginsList, /* autosave causes problems with missing selection, maybe after rerendering */
				// Theme options
				theme_advanced_buttons1: aButtonRows[0],
				theme_advanced_buttons2: aButtonRows[1],
				theme_advanced_buttons3: aButtonRows[2],
				theme_advanced_buttons4: aButtonRows[3],
				theme_advanced_toolbar_location: "top",
				theme_advanced_toolbar_align: "left",
				theme_advanced_statusbar_location: "none",
				readonly: (this.getEditable() ? 0 : 1),
				nowrap: !this.getWrapping(),
				onchange_callback: function(oCurrentInst) {
					var sId = oCurrentInst.editorId.substr(0, oCurrentInst.editorId.lastIndexOf("-")),
						oRTE = sap.ui.getCore().byId(sId);

					if (oRTE) {
						oRTE.onTinyMCEChange(oCurrentInst);
					} else {
						jQuery.sap.log.error("RichtTextEditor change called for unknown instance: " + sId);
					}
				}
			};

		// apply setup for RichTextEditor with Custom Toolbar
		if (this._bCustomToolbarRequirementsFullfiled && oCustomToolbar) {
			oConfig = oCustomToolbar.modifyRTEToolbarConfig(oConfig);
		}
		/*eslint-enable camelcase */

		this.fireBeforeEditorInit({ configuration: oConfig });

		tinymce.init(oConfig);
		this._bEditorCreated = true;

		this.setContentTinyMCE();
		this.initWhenTinyMCEReady();
	};

	RichTextEditor.prototype._tinyMCEPreserveHandler = function(sChannelId, sEventId, oData) {
		if ((this.getDomRef() && window.tinymce && jQuery(oData.domNode).find(jQuery.sap.byId(this._textAreaId)).length > 0) || (jQuery.sap.byId(this._textAreaId).length === 0)) {
			var oEditor = this.getNativeApi();
			if (oEditor && oEditor.getContainer()) {

				var that = this,
					fnRemoveControl = function() {
						try {
							/*eslint-disable camelcase */
							window.tinymce.execCommand('mceRemoveControl', false, that._textAreaId, { skip_focus: true });
							/*eslint-enable camelcase */
						} catch (ex) {
							// Ignored. If unloading fails this might lead to multiple instances of TinyMCE
							// being created, but there is nothing we can do as it depends on the third-
							// party tinymce code. This may happen in certain scenarios in IE < 11 or
							// Firefox when TinyMCE tries to access properties of the inner iframe's
							// document.
						}
					};

				try {
					this.setProperty("value", oEditor.getContent(), true); // required because rerendering newly creates the textarea, where tinymce stored the data
				} catch (ex) {
					// If the application manually hides or removes the editor DOM, FF might fail with
					// an exception when we try to access the editor content. If this happens the
					// changes since the last setValue invokaction might be lost.
					jQuery.sap.log.warning("TinyMCE was hidden before value could be read, changes might be lost.");
				}

				var oPopupControl = jQuery(oData.domNode).control(0);
				if (oPopupControl && oPopupControl.attachClosed) {
					// In case we can hook into the closed event, remove control only after the content
					// has been hidden
					oPopupControl.attachClosed(fnRemoveControl);
				} else {
					// Remove control directly
					fnRemoveControl();
				}
			}
		}
	};


	/**
	 * Contains initialization code that only can be run once the TinyMCE editor is fully created (=has rendered its HTML)
	 * @private
	 */
	RichTextEditor.prototype.initWhenTinyMCEReady = function() {
		// try later if editor not yet rendered, don't start multiple timers for multiple calls
		if (this.sTimerId) {
			jQuery.sap.clearDelayedCall(this.sTimerId);
			this.sTimerId = null;
		}
		if (!this.tinyMCEReady()) {
			this.sTimerId = jQuery.sap.delayedCall(10, this, "initWhenTinyMCEReady");
			return;
		}

		var inst = this.getNativeApiTinyMCE(),
			$IFrame = jQuery.sap.byId(this._iframeId),
			$Body = jQuery(inst.getBody()),
			bTriggered,
			sTooltip,
			sTitle;

		if (this.getTooltip() && this.getTooltip().length > 0) {
			sTooltip = jQuery.sap.encodeHTML(this.getTooltip_Text());
			inst.getBody().title = sTooltip;
			$IFrame.attr("title", sTooltip);
		} else {
			// TinyMCE3 creates wrong aria title (containing multiple ACC-help texts)
			sTitle = inst.getLang("aria.rich_text_area") + " - " + inst.getLang('advanced.help_shortcut');
			$IFrame.attr("title", sTitle);
		}

		// Make 100% height work in Firefox and IE
		if (sap.ui.Device.browser.firefox) {
			$IFrame.parent().height("100%");
		}
		if (sap.ui.Device.browser.internet_explorer) {
			$IFrame.height($IFrame.parent().height());
			var oDomRef = this.getDomRef();
			var fnResizeCallback = function() {
				$IFrame.height($IFrame.parent().height());
			};
			if (oDomRef.attachEvent) {
				oDomRef.attachEvent("resize", fnResizeCallback);
			} else if (oDomRef.addEventListener) {
				oDomRef.addEventListener("resize", fnResizeCallback);
			}
		}

		// Focus handling of RTE
		var tableId = this._textAreaId + "_tbl",
			$Editor = jQuery.sap.byId(tableId);

		this.$focusables = $Editor.find(":sapFocusable");
		$Editor.bind('keydown', jQuery.proxy(this, "_tinyMCEKeyboardHandler"));

		// set certain tooltips that are not configurable  TODO: must be made translatable
		jQuery.sap.byId(this.getId() + "-textarea_fontselect").attr("title", "Font");
		jQuery.sap.byId(this.getId() + "-textarea_fontsizeselect").attr("title", "Font Size");

		// Mae sure focus event is triggered, when body inside the iframe is focused
		$Body.bind('focus', function() {
			if (!bTriggered) {
				bTriggered = true;
				if (sap.ui.Device.browser.internet_explorer || sap.ui.Device.browser.edge) {
					$IFrame.trigger('activate');
				} else {
					$IFrame.trigger('focus');
				}
				$Body.focus();
				bTriggered = false;
			}
		});

		this._registerWithPopupTinyMCE();

		window.tinymce.execCommand('mceFocus', false, this._textAreaId);

		this.fireReady();
	};


	/**
	 * After configuration has changed, this method can be used to trigger a complete re-rendering
	 * that also re-initializes the editor instance from scratch. Caution: this is expensive, performance-wise!
	 * @private
	 */
	RichTextEditor.prototype.reinitializeTinyMCE = function() {
		if (this._bEditorCreated) {
			this._bEditorCreated = false; // need to re-initialize
			this.rerender();

			this.setContentTinyMCE();
		}
	};

	RichTextEditor.prototype.unloadTinyMCE = function() {
		if (window.tinymce) {
			try {
				window.tinymce.execCommand('mceRemoveControl', false, this._textAreaId); // also includes "remove" and "destroy"
			} catch (ex) {
				// Ignored. If unloading fails this might lead to a memory leak, but there is nothing
				// we can do as it depends on the third-party tinymce code. This may happen in certain
				// scenarios in IE < 11 or Firefox when TinyMCE tries to access properties of the inner
				// iframe's document.
			}
		}
		sap.ui.getCore().getEventBus().unsubscribe("sap.ui", "__preserveContent", this._tinyMCEPreserveHandler);
		sap.ui.getCore().getEventBus().unsubscribe("sap.ui", "__beforePopupClose", this._tinyMCEPreserveHandler);
	};

	RichTextEditor.prototype.exitTinyMCE = function() {
		this.bExiting = true;
		if (this._textAreaDom.parentNode) {
			this._textAreaDom.parentNode.removeChild(this._textAreaDom);
		}
		this._textAreaDom = null;

		this.unloadTinyMCE();
	};

	RichTextEditor.prototype.getNativeApiTinyMCE = function() {
		var oEditor = null;
		if (window.tinymce && window.tinymce.majorVersion == "3" && this._textAreaId) {
			oEditor = window.tinymce.getInstanceById(this._textAreaId);
		}
		return oEditor;
	};

	RichTextEditor.prototype.setContentTinyMCE = function() {
		var inst = this.getNativeApiTinyMCE(),
			value;

		if (inst && inst.getContainer()) {
			value = this.getValue();
			if (value != null) {
				inst.setContent(value);
				//Reset the undo manager
				inst.undoManager.clear();
				inst.undoManager.add();

				// if running in readonly mode, update link targets to _blank
				if (!this.getEditable()) {
					jQuery.each(inst.getDoc().getElementsByTagName("a"), function(i, oAnchor) {
						oAnchor.target = "_blank";
					});
				}
			}
		}
	};


	/**
	 * Publish addFocusableContent event to make the editor iframe and internal iframes of TinyMCE known
	 * to the popup (if contained in one) for focus handling. Needs to be done asynchronously, as the
	 * data-sap-ui-popup property is set in the onAfterRendering of the popup which occurs after the
	 * onAfterRendering of its content. For more info see sap.ui.core.Popup documentation
	 *
	 * @private
	 */
	RichTextEditor.prototype._registerWithPopupTinyMCE = function() {
		var oEditor = this.getNativeApi(),
			oBus = sap.ui.getCore().getEventBus(),
			$Pop = this.$().closest("[data-sap-ui-popup]");

		setTimeout(function() {
			if ($Pop.length === 1) {
				var sEventId = "sap.ui.core.Popup.addFocusableContent-" + $Pop.attr("data-sap-ui-popup"),
					oObject = { id: this._iframeId };

				oBus.publish("sap.ui", sEventId, oObject);

				oEditor.windowManager.onOpen.add(function(oTiny, oFrame, oPopup) {
					if (oPopup) {
						oObject = { id: oPopup.mce_window_id + "_ifr" };
						oBus.publish("sap.ui", sEventId, oObject);
					}
				});
			}
		}, 0);
	};

	/////////////////////////////////// End editor section "TinyMCE" ///////////////////////////////////


	////////////////////////////////// Begin editor section "TinyMCE4" /////////////////////////////////


	/**
	 * Called when the editor type is set to TinyMCE4
	 *
	 * @private
	 */
	RichTextEditor.prototype.initTinyMCE4 = function() {
		// TinyMCE 4 instance
		this._oEditor = null;

		// Status of the TinyMCE4 component
		this._tinyMCE4Status = EditorStatus.Initial;

		// Bound resize method, so it can be given to the Resizehandler with correct this-reference
		this._boundResizeEditorTinyMCE4 = this._resizeEditorTinyMCE4.bind(this);

		// If initialization is currently pending, but has not yet been requested from TinyMCE, we ca avoid calling
		// it again without any changes
		this._bInitializationPending = false;

		// make sure the first resize actually does something
		this._lastRestHeight = 0;

		sap.ui.getCore().getEventBus().subscribe("sap.ui", "__preserveContent", this._tinyMCE4PreserveHandler, this);
		sap.ui.getCore().getEventBus().subscribe("sap.ui", "__beforePopupClose", this._tinyMCE4PreserveHandler, this);
	};

	/**
	 * Called when the editor type is set from TinyMCE4 to something else or the control is destroyed
	 *
	 * @private
	 */
	RichTextEditor.prototype.exitTinyMCE4 = function() {
		this._bUnloading = true;

		sap.ui.getCore().getEventBus().unsubscribe("sap.ui", "__preserveContent", this._tinyMCE4PreserveHandler);
		sap.ui.getCore().getEventBus().unsubscribe("sap.ui", "__beforePopupClose", this._tinyMCE4PreserveHandler);

		ResizeHandler.deregister(this._resizeHandlerId);
		this._resizeHandlerId = null;

		this._removeEditorTinyMCE4();

	};

	/**
	 * @private
	 */
	RichTextEditor.prototype._removeEditorTinyMCE4 = function() {
		switch (this._tinyMCE4Status) {
			case EditorStatus.Initial:
			case EditorStatus.Loading:
			case EditorStatus.Loaded:
				// Ignored as the control is not rendered yet.
				break;

			case EditorStatus.Initializing:
				this._pTinyMCE4Initialized.then(this._removeEditorTinyMCE4.bind(this, this._oEditor));
				break;

			case EditorStatus.Ready:
				this._oEditor.remove();
				this._tinyMCE4Status = EditorStatus.Destroyed;
				this._boundResizeEditorTinyMCE4 = null;
				this._oEditor = null;
				break;

			case EditorStatus.Destroyed:
				// Ignored as the editor is already destroyed.
				break;
			default:
				jQuery.sap.log.error("Unknown TinyMCE4 status: " + this._tinyMCE4Status);
				break;
		}
	};


	/**
	 * @private
	 */
	RichTextEditor.prototype.onBeforeRenderingTinyMCE4 = function() {
		if (!window.tinymce || window.tinymce.majorVersion != "4") {
			// Load TinyMCE component
			this._tinyMCE4Status = EditorStatus.Loading;
			this._pTinyMCE4Loaded = RichTextEditor.loadTinyMCE(this.getEditorLocation()).then(function() {
				this._tinyMCE4Status = EditorStatus.Loaded;
			}.bind(this));
		} else {
			this._pTinyMCE4Loaded = Promise.resolve();
			this._tinyMCE4Status = EditorStatus.Loaded;
		}
	};



	/**
	 * @private
	 */
	RichTextEditor.prototype.onAfterRenderingTinyMCE4 = function() {
		var oDomRef = this.getDomRef();

		// If RTE is direct child of a container which would be preserved
		// there's no need to preserve the RTE. Such case is RTE inside XML View.
		if (oDomRef && oDomRef.parentNode && oDomRef.parentNode.getAttribute("data-sap-ui-preserve")) {
			oDomRef.removeAttribute("data-sap-ui-preserve");
		}

		if (!window.tinymce) {
			// TinyMCE not loaded yet. try again later...
			this._pTinyMCE4Loaded.then(this.onAfterRenderingTinyMCE4.bind(this));
		} else if (window.tinymce.majorVersion != "4") {
			// Re-rendered while wrong version is still active - wait for next rendering
			this._pTinyMCE4Loaded.then(this.onAfterRenderingTinyMCE4.bind(this));
		} else if (!oDomRef) {
			// We have been re-rendered while waiting for tinymce to load. onAfterRendering will be called again
			// when there is a DOM reference.
		} else {
			var $PreservedContent = sap.ui.core.RenderManager.findPreservedContent(this.getId());

			switch (this._tinyMCE4Status) {
				case EditorStatus.Initializing:
					// TinyMCE is still initializing, give it its DOM back.
					if ($PreservedContent.size() > 0) {
						this.$().replaceWith($PreservedContent);
					} else {
						oDomRef.appendChild(this._textAreaDom);
					}
					break;

				case EditorStatus.Loaded:
				case EditorStatus.Loading:
					// TinyMCE is still loading and has not been initialized yet.
					// It will be initialized when loaded.
					$PreservedContent.remove();
					this.getDomRef().appendChild(this._textAreaDom);
					this.reinitializeTinyMCE4();
					break;

				case EditorStatus.Ready:
					// TinyMCE has been loaded and initialized, we need to reinitialize it so changes will be shown.
					if ($PreservedContent.size() > 0) {
						this.$().replaceWith($PreservedContent);
					} else {
						oDomRef.appendChild(this._textAreaDom);
					}
					this.reinitializeTinyMCE4();
					break;

				default:
					jQuery.sap.log.error("Unknown TinyMCE4 status: " + this._tinyMCE4Status);
					break;

			}
		}
	};


	/**
	 * TinyMCE4 specific reinitialize method
	 * The TinyMCE instance is destroyed and recreated with new configuration values.
	 *
	 * @private
	 */
	RichTextEditor.prototype.reinitializeTinyMCE4 = function() {
		if (this._bInitializationPending || this._bUnloading) {
			// Do nothing if an initialization is currently waiting to happen or if the control has already been destroyed...
			return;
		}

		var fnReinitialize = function() {

			if (this._oEditor) {
				this._oEditor.remove();
			}

			this._initializeTinyMCE4();
		}.bind(this);

		switch (this._tinyMCE4Status) {
			case EditorStatus.Initial:
				// Ignored as the control is not rendered yet.
				break;

			case EditorStatus.Loading:
				this._bInitializationPending = true;
				this._pTinyMCE4Loaded.then(fnReinitialize);
				break;

			case EditorStatus.Initializing:
				// We are currently waiting for the initialization of TinyMCE4 to complete, we have to do it again to
				// make sure the latest changes will be reflected
				this._bInitializationPending = true;
				this._pTinyMCE4Initialized.then(fnReinitialize);
				break;

			case EditorStatus.Loaded:
			case EditorStatus.Ready:
				this._bInitializationPending = true;
				// Makes sure that all other started reinitializations are completed, before the next one starts. The RTE is crashing in IE11 and Edge browser without that extra timeout.
				setTimeout(function() {
					fnReinitialize();
				}, 0);
				break;

			default:
				jQuery.sap.log.error("Unknown TinyMCE4 status: " + this._tinyMCE4Status);
				break;
		}
	};

	/**
	 * TinyMCE4 specific getNativeApi method
	 * Returns the editor instance for this control instance if available
	 *
	 * @private
	 * @returns {object} The TinyMCE4 editor instance
	 */
	RichTextEditor.prototype.getNativeApiTinyMCE4 = function() {
		return this._oEditor;
	};


	/**
	 * TinyMCE4 specific setValue method
	 * Loads the content set in the controls property into the TinyMCE editor instance and does
	 * the necessary post processing
	 *
	 * @param {string} [sValue] Content, already sanitized if sanitizer is activated
	 * @private
	 */
	RichTextEditor.prototype.setValueTinyMCE4 = function(sValue) {
		switch (this._tinyMCE4Status) {
			case EditorStatus.Initial:
			case EditorStatus.Initializing:
			case EditorStatus.Loading:
				// Ignored - value will be set when TinyMCE is ready
				break;

			case EditorStatus.Ready:
				this._oEditor.setContent(sValue);
				//Reset the undo manager
				this._oEditor.undoManager.clear();
				this._oEditor.undoManager.add();

				// if running in readonly mode, update link targets to _blank
				if (!this.getEditable()) {
					jQuery.each(this._oEditor.getDoc().getElementsByTagName("a"), function(i, oAnchor) {
						oAnchor.target = "_blank";
					});
				}
				break;

			default:
				jQuery.sap.log.error("Unknown TinyMCE4 status: " + this._tinyMCE4Status);
				break;
		}
	};


	RichTextEditor.prototype._initializeTinyMCE4 = function() {
		this._pTinyMCE4Initialized = new Promise(function(fnResolve, fnReject) {
			this._bInitializationPending = false;
			this._tinyMCE4Status = EditorStatus.Initializing;
			this._textAreaDom.value = this._patchTinyMCE4Value(this.getValue());
			window.tinymce.init(this._createConfigTinyMCE4(function() {
				this._tinyMCE4Status = EditorStatus.Ready;
				// Wee need to add a timeout here, as the promise resolves before other asynchronous tasks like the
				// load-events, which leads to TinyMCE4 still trying to operate on its DOM after the promise is resolved.
				setTimeout(function() {
					if (!this._bInitializationPending) {
						this._onAfterReadyTinyMCE4();
					}
					fnResolve();
				}.bind(this), 0);
			}.bind(this)));
		}.bind(this));
	};

	/**
	 * Patches the value which would be inserted in TinyMCE4.
	 *
	 * If the value starts with an HTML comment, then tinyMCE
	 * throws an exception and its init hook is not executed.
	 *
	 * TODO: Check if this is fixed with higher version of TinyMCE and remove the patch
	 *
	 * @param value
	 * @returns {String}
	 * @private
	 */
	RichTextEditor.prototype._patchTinyMCE4Value = function (value) {
		if (value.indexOf("<!") === 0) {
			value = "&#8203;" + value; // Prepend the value with "ZERO WIDTH NO-BREAK SPACE" character
		}

		return value;
	};


	/**
	 * Sets up the TinyMCE instance after it has been loaded, initialized and shown on the
	 * page.
	 *
	 * @private
	 */
	RichTextEditor.prototype._onAfterReadyTinyMCE4 = function() {
		if (this._bUnloading) {
			// This only happens when the control instance is destroyed in the meantime...
			return;
		}

		this._oEditor.on("change", function(oEvent) {
			this.onTinyMCEChange(this._oEditor); // Works for TinyMCE 3 and 4
		}.bind(this));


		// Focus handling
		var $Editor = jQuery(this._oEditor.getContainer());
		$Editor.bind('keydown', jQuery.proxy(this, this._tinyMCEKeyboardHandler));

		// Make sure focus event is triggered, when body inside the iframe is focused
		var $EditorIFrame = jQuery.sap.byId(this._iframeId),
			$Body = jQuery(this._oEditor.getBody()),
			bTriggered = false;

		$Body.bind('focus', function() {
			if (!bTriggered) {
				bTriggered = true;
				if (sap.ui.Device.browser.internet_explorer || sap.ui.Device.browser.edge) {
					$EditorIFrame.trigger('activate');
				} else {
					$EditorIFrame.trigger('focus');
				}
				$Body.focus();
				bTriggered = false;
			}
		});

		if (this.getTooltip() && this.getTooltip().length > 0) {
			var sTooltip = this.getTooltip_Text();
			this._oEditor.getBody().setAttribute("title", sTooltip);
			$EditorIFrame.attr("title", sTooltip);
		}
		this._registerWithPopupTinyMCE4();

		// Handle resized correctly.
		if (!this._resizeHandlerId) {
			this._resizeHandlerId = ResizeHandler.register(this, this._boundResizeEditorTinyMCE4);
		}


		var fnResizeEditor = this._resizeEditorTinyMCE4.bind(this);
		// Resize when editor is loaded completely
		var oEditorDocument = this._oEditor.getDoc();
		if (oEditorDocument.readyState == "complete") {
			fnResizeEditor();
		} else {
			oEditorDocument.addEventListener("readystatechange", function() {
				if (oEditorDocument.readyState == "complete") {
					fnResizeEditor();
				}
			});
		}

		// TODO: make sure ready is fired if no reinitializations are pending
		this.fireReadyTinyMCE4();
	};


	/**
	 * Fires the ready event, but only once per instance. Subsequent calls to this method are ignored
	 *
	 * @private
	 */
	RichTextEditor.prototype.fireReadyTinyMCE4 = function() {
		switch (this._tinyMCE4Status) {
			case EditorStatus.Initial:
			case EditorStatus.Loading:
			case EditorStatus.Loaded:
			case EditorStatus.Initializing:
				// Ignored - will be called again after TinyMCE initialization
				break;

			case EditorStatus.Ready:
				if (!this._bInitializationPending) {
					if (!this._readyFired){
						this._readyFired = true;
						this.fireReady.apply(this, arguments);
					}
					this.fireReadyRecurring.apply(this, arguments);
				}
				break;

			default:
				jQuery.sap.log.error("Unknown TinyMCE4 status: " + this._tinyMCE4Status);
				break;
		}
	};


	/**
	 * Creates the configuration object which is used to initialize the tinymce editor instance
	 *
	 * @param {function} fnOnInit is a callback which is called on init
	 * @private
	 * @returns {bool} Whether the configuration changed since last time
	 */
	RichTextEditor.prototype._createConfigTinyMCE4 = function(fnOnInit) {
		var oCustomToolbar = this.getAggregation("_toolbarWrapper");

		// Create new instance of TinyMCE4
		var aButtonRows = this._createButtonRowsTinyMCE(" ", "|");
		if (aButtonRows.length === 0) {
			aButtonRows = false;
		}

		var sPluginsList = this._createPluginsListTinyMCE();

		/*eslint-disable camelcase */
		var oConfig = {
			// The following line only covers the editor content, not the UI in general
			directionality: (sap.ui.getCore().getConfiguration().getRTL() ? "rtl" : "ltr"),
			// Fixes the tooltip-problem by expanding the html inside the iframe to full height
			content_css: sap.ui.resource('sap.ui.richtexteditor', "themes/base/content/TinyMCE4Content.css"),
			selector: "#" + this._textAreaId,
			theme: "modern",
			menubar: false,
			language: this._getLanguageTinyMCE4(),
			browser_spellcheck: true,
			convert_urls: false,
			plugins: sPluginsList,
			toolbar_items_size: 'small',
			toolbar: aButtonRows,
			statusbar: false, // disables display of the status bar at the bottom of the editor
			image_advtab: true, // Adds an "Advanced" tab to the image dialog allowing you to add custom styles, spacing and borders to images
			readonly: (this.getEditable() ? 0 : 1),
			nowrap: !this.getWrapping(),
			init_instance_callback: function(oEditor) {
				this._oEditor = oEditor;
				fnOnInit();
			}.bind(this)
		};
		/*eslint-enable camelcase */

		// apply setup for RichTextEditor with Custom Toolbar}
		if (this._bCustomToolbarRequirementsFullfiled && oCustomToolbar) {
			oConfig = oCustomToolbar.modifyRTEToolbarConfig(oConfig);
		}

		// Hook to allow apps to modify the editor configuration directly before first creation
		this.fireBeforeEditorInit({ configuration: oConfig });

		return oConfig;
	};


	/**
	 * Map languages that are incorrectly assigned or fallback if languages do not work
	 * TODO: Change this when more languages are supported by TinyMCE
	 *
	 * @returns {string} The language to be used for TinyMCE
	 */
	RichTextEditor.prototype._getLanguageTinyMCE4 = function() {
		var oLocale = new sap.ui.core.Locale(sap.ui.getCore().getConfiguration().getLanguage()),
			sLanguage = oLocale.getLanguage(),
			sRegion = oLocale.getRegion(),
			sLangStr;

		// Language mapping for old/fallback languages
		sLanguage = RichTextEditor.MAPPED_LANGUAGES_TINYMCE4[sLanguage] || sLanguage;

		// Find default region, if region is not given
		if (!sRegion) {
			sRegion = RichTextEditor.SUPPORTED_LANGUAGES_DEFAULT_REGIONS[sLanguage];
		}

		sLangStr = sRegion ? sLanguage + "_" + sRegion.toUpperCase() : sLanguage;

		// If there is no language for that region defined, try without region
		if (!RichTextEditor.SUPPORTED_LANGUAGES_TINYMCE4[sLangStr]) {
			sLangStr = sLanguage;
		}
		// If there is still no language defined, fallback to english
		if (!RichTextEditor.SUPPORTED_LANGUAGES_TINYMCE4[sLangStr]) {
			sLangStr = "en";
		}

		return sLangStr;
	};

	/**
	 * Resizes the inner TinyMCE DOM to fit into the controls DOM element
	 *
	 * @returns {void}
	 * @private
	 */
	RichTextEditor.prototype._resizeEditorTinyMCE4 = function() {
		// Resize so the full editor takes the correct height

		if (this._tinyMCE4Status !== EditorStatus.Ready) {
			// This only happens when the control instance is destroyed in the meantime...
			return;
		}

		var oEditorContentDom = this._oEditor.getContentAreaContainer(),
			iFullHeight = this.getDomRef().offsetHeight,
			iContainerHeight = this._oEditor.getContainer().offsetHeight,
			iContentHeight = oEditorContentDom.offsetHeight,
			iCustomToolbarHeight,
			iRestHeight,
			iDifference;

		// if there is a custom toolbar substract the height from the editor height
		iCustomToolbarHeight = this.getAggregation("_toolbarWrapper") ? this.getAggregation("_toolbarWrapper")
																			.getAggregation("_toolbar")
																			.getDomRef().offsetHeight : "0";

		iRestHeight = iFullHeight - (iContainerHeight - iContentHeight) - iCustomToolbarHeight;

		// There is a border of 1 px around the editor, which screws up the size determination when used the combination
		// of a 100%-sized editor and an auto-sized dialog. In this case the border leads to end endless loop of resize
		// events that lead to an ever growing dialog.
		// So only trigger a resize if the size difference is actually noticable. In case the difference is 0, the resize
		// call is needed because TinyMCE does not always actually resize when the resizeTo method is called.
		// There should be a better solution to this problem...
		iDifference = Math.abs(this._lastRestHeight - iRestHeight);
		if (iDifference == 0 || iDifference > 5) {
			try {
				// the substraction of the result height is needed because of the
				// border bottom and border top (1px each) - otherwise they are being cut off
				this._oEditor.theme.resizeTo(undefined, iRestHeight - 2);
			} catch (ex) {
				// In some cases this leads to exceptions in IE11 after a current security fix. These cases can be safely ignored.
			}
		}

		this._lastRestHeight = iRestHeight;
	};



	/**
	 * Publish addFocusableContent event to make the editor iframe and internal iframes of TinyMCE known
	 * to the popup (if contained in one) for focus handling. Needs to be done asynchronously, as the
	 * data-sap-ui-popup property is set in the onAfterRendering of the popup which occurs after the
	 * onAfterRendering of its content. For more info see sap.ui.core.Popup documentation
	 *
	 * @private
	 */
	RichTextEditor.prototype._registerWithPopupTinyMCE4 = function() {
		var oBus = sap.ui.getCore().getEventBus(),
			$Pop = this.$().closest("[data-sap-ui-popup]");

		setTimeout(function() {
			if ($Pop.length === 1) {
				var sPopupId = $Pop.attr("data-sap-ui-popup"),
					oObject = { id: this._iframeId };

				oBus.publish("sap.ui", "sap.ui.core.Popup.addFocusableContent-" + sPopupId, oObject);

				if (this._oEditor) {
					this._oEditor.on('OpenWindow', function(oEvent) {
						var oObject = { id: oEvent.win._id };
						oBus.publish("sap.ui", "sap.ui.core.Popup.addFocusableContent-" + sPopupId, oObject);
					});
					this._oEditor.on('CloseWindow', function(oEvent) {
						var oObject = { id: oEvent.win._id };
						oBus.publish("sap.ui", "sap.ui.core.Popup.removeFocusableContent-" + sPopupId, oObject);
					});
				}
			}
		}.bind(this), 0);
	};

	RichTextEditor.prototype._tinyMCE4PreserveHandler = function(sChannelId, sEventId, oData) {
		if ((this.getDomRef() && window.tinymce && jQuery(oData.domNode).find(jQuery.sap.byId(this._textAreaId)).length > 0) || (jQuery.sap.byId(this._textAreaId).length === 0)) {
			if (this._oEditor) {

				try {
					this._oEditor.save();
					var sEditorValue = this._oEditor.getContent();
					this.setProperty("value", sEditorValue, true); // required because rerendering newly creates the textarea, where tinymce stored the data
				} catch (ex) {
					// If the application manually hides or removes the editor DOM, FF might fail with
					// an exception when we try to access the editor content. If this happens the
					// changes since the last setValue invocation might be lost.
					jQuery.sap.log.warning("TinyMCE was hidden before value could be read, changes might be lost.");
				}

				this._oEditor.hide();

				this._removeEditorTinyMCE4(this._oEditor);
			}
		}
	};
	////////////////////////////////// End editor section "TinyMCE4" /////////////////////////////////


	////////////////////////////////// Custom Toolbar Section  /////////////////////////////////

	/**
	 * Checks Custom Toolbar dependencies
	 *
	 * @returns {boolean}
	 * @private
	 */
	RichTextEditor.prototype._checkCustomToolbarRequirements = function() {
		var bRequirementsFullfiled = this.getCustomToolbar() &&
			this.getEditorType() === library.EditorType.TinyMCE4 &&
			library.RichTextEditorHelper.bSapMLoaded;

		this.$().toggleClass("sapUiRTEWithCustomToolbar", bRequirementsFullfiled);

		return bRequirementsFullfiled;
	};

	/**
	 * Manage Custom Toolbar lifecycle.
	 *
	 * As RichTextEditor's "customButtons" aggregation is just a proxy to the Toolbar's content,
	 * we need to take care of it manually.
	 * When the toolbar is created, the "customButtons" aggregation items are moved to the Toolbar,
	 * but if the Toolbar is destroyed, we need to move the items back to the RTE's aggregation.
	 * Therefore switching customToolbar on/off would produce the same output.
	 *
	 * @private
	 */
	RichTextEditor.prototype._customToolbarEnablement = function () {
		var aCustomButtons,
			oToolbarWrapper = this.getAggregation("_toolbarWrapper");
		this._bCustomToolbarRequirementsFullfiled = this._checkCustomToolbarRequirements();

		if (this._bCustomToolbarRequirementsFullfiled && !oToolbarWrapper) {
			aCustomButtons = this.getAggregation("customButtons"); // Take items from RichTextEditor's aggregation
			this.removeAllAggregation("customButtons"); // Detach custom buttons from the RTE before moving them to the Toolbar
			oToolbarWrapper = new ToolbarWrapper({editor: this});
			this.setAggregation("_toolbarWrapper", oToolbarWrapper);

			if (aCustomButtons && aCustomButtons.length) {
				// The delayedCall is needed as the ToolbarWrapper is not yet ready.
				jQuery.sap.delayedCall(0, this, function () {
					aCustomButtons.forEach(function (oButton) {
						oToolbarWrapper.modifyToolbarContent("add", oButton);
					});
				});
			}
		} else if (!this._bCustomToolbarRequirementsFullfiled && oToolbarWrapper) {
			aCustomButtons = oToolbarWrapper.modifyToolbarContent("removeAll"); // Take items through the proxy
			if (aCustomButtons && aCustomButtons.length) {
				// Store the items in RTE's aggregation
				aCustomButtons.forEach(function (oButton) {
					this.addAggregation("customButtons", oButton);
				}, this);
			}

			this.destroyAggregation("_toolbarWrapper");
		}
	};

	/**
	 * Overwrite customButton getters and setters and proxy that aggregation to the toolbar
	 */
	["add", "destroy", "get", "indexOf", "insert", "removeAll", "remove"].forEach(function (sMethodPrefix) {
		var sMethodName = sMethodPrefix + "CustomButton" +
			(["destroy", "get", "removeAll"].indexOf(sMethodPrefix) > -1 ? "s" : "");

		RichTextEditor.prototype[sMethodName] = function () {
			var vResult = null,
				oItem = arguments[0],
				oToolbarWrapper = this.getAggregation("_toolbarWrapper");

			// As we can't limit the aggregation type to sap.m.Button, the check should be performed manually
			if (typeof oItem === "object" && oItem.getMetadata().getName() !== "sap.m.Button") {
				jQuery.sap.log.error("Only sap.m.Button is allowed as aggregation.");
				return;
			}

			if (oToolbarWrapper && oToolbarWrapper.modifyToolbarContent) {
				vResult = oToolbarWrapper.modifyToolbarContent.bind(oToolbarWrapper, sMethodPrefix).apply(oToolbarWrapper, arguments);
			} else {
				vResult = this[sMethodPrefix + "Aggregation"].bind(this, "customButtons").apply(this, arguments);
			}

			return vResult;
		};
	});
	////////////////////////////////// END Custom Toolbar Section  /////////////////////////////////

	return RichTextEditor;

}, /* bExport= */ true);

}; // end of sap/ui/richtexteditor/RichTextEditor.js
